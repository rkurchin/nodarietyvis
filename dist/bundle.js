/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/cytoscape/dist/cytoscape.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.cjs.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/**
 * Copyright (c) 2016-2019, The Cytoscape Consortium.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var util = _interopDefault(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
var Heap = _interopDefault(__webpack_require__(/*! heap */ "./node_modules/heap/index.js"));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

var navigator = window$1 ? window$1.navigator : null;
var document$1 = window$1 ? window$1.document : null;

var typeofstr = _typeof('');

var typeofobj = _typeof({});

var typeoffn = _typeof(function () {});

var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);

var instanceStr = function instanceStr(obj) {
  return obj && obj.instanceString && fn(obj.instanceString) ? obj.instanceString() : null;
};

var string = function string(obj) {
  return obj != null && _typeof(obj) == typeofstr;
};
var fn = function fn(obj) {
  return obj != null && _typeof(obj) === typeoffn;
};
var array = function array(obj) {
  return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
};
var plainObject = function plainObject(obj) {
  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
};
var object = function object(obj) {
  return obj != null && _typeof(obj) === typeofobj;
};
var number = function number(obj) {
  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
};
var integer = function integer(obj) {
  return number(obj) && Math.floor(obj) === obj;
};
var htmlElement = function htmlElement(obj) {
  if ('undefined' === typeofhtmlele) {
    return undefined;
  } else {
    return null != obj && obj instanceof HTMLElement;
  }
};
var elementOrCollection = function elementOrCollection(obj) {
  return element(obj) || collection(obj);
};
var element = function element(obj) {
  return instanceStr(obj) === 'collection' && obj._private.single;
};
var collection = function collection(obj) {
  return instanceStr(obj) === 'collection' && !obj._private.single;
};
var core = function core(obj) {
  return instanceStr(obj) === 'core';
};
var stylesheet = function stylesheet(obj) {
  return instanceStr(obj) === 'stylesheet';
};
var event = function event(obj) {
  return instanceStr(obj) === 'event';
};
var emptyString = function emptyString(obj) {
  if (obj === undefined || obj === null) {
    // null is empty
    return true;
  } else if (obj === '' || obj.match(/^\s+$/)) {
    return true; // empty string is empty
  }

  return false; // otherwise, we don't know what we've got
};
var domElement = function domElement(obj) {
  if (typeof HTMLElement === 'undefined') {
    return false; // we're not in a browser so it doesn't matter
  } else {
    return obj instanceof HTMLElement;
  }
};
var boundingBox = function boundingBox(obj) {
  return plainObject(obj) && number(obj.x1) && number(obj.x2) && number(obj.y1) && number(obj.y2);
};
var promise = function promise(obj) {
  return object(obj) && fn(obj.then);
};
var ms = function ms() {
  return navigator && navigator.userAgent.match(/msie|trident|edge/i);
}; // probably a better way to detect this...

var memoize = function memoize(fn, keyFn) {
  if (!keyFn) {
    keyFn = function keyFn() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return 'undefined';
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      return args.join('$');
    };
  }

  var memoizedFn = function memoizedFn() {
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply(self, args);
    var cache = memoizedFn.cache;

    if (!(ret = cache[k])) {
      ret = cache[k] = fn.apply(self, args);
    }

    return ret;
  };

  memoizedFn.cache = {};
  return memoizedFn;
};

var camel2dash = memoize(function (str) {
  return str.replace(/([A-Z])/g, function (v) {
    return '-' + v.toLowerCase();
  });
});
var dash2camel = memoize(function (str) {
  return str.replace(/(-\w)/g, function (v) {
    return v[1].toUpperCase();
  });
});
var prependCamel = memoize(function (prefix, str) {
  return prefix + str[0].toUpperCase() + str.substring(1);
}, function (prefix, str) {
  return prefix + '$' + str;
});
var capitalize = function capitalize(str) {
  if (emptyString(str)) {
    return str;
  }

  return str.charAt(0).toUpperCase() + str.substring(1);
};

var number$1 = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';
var rgba = 'rgb[a]?\\((' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)(?:\\s*,\\s*(' + number$1 + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hsla = 'hsl[a]?\\((' + number$1 + ')\\s*,\\s*(' + number$1 + '[%])\\s*,\\s*(' + number$1 + '[%])(?:\\s*,\\s*(' + number$1 + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number$1 + ')\\s*,\\s*(?:' + number$1 + '[%])\\s*,\\s*(?:' + number$1 + '[%])(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

var ascending = function ascending(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
};
var descending = function descending(a, b) {
  return -1 * ascending(a, b);
};

var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  var args = arguments;

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if (obj == null) {
      continue;
    }

    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];
      tgt[k] = obj[k];
    }
  }

  return tgt;
};

var hex2tuple = function hex2tuple(hex) {
  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
    return;
  }

  var shortHex = hex.length === 4;
  var r, g, b;
  var base = 16;

  if (shortHex) {
    r = parseInt(hex[1] + hex[1], base);
    g = parseInt(hex[2] + hex[2], base);
    b = parseInt(hex[3] + hex[3], base);
  } else {
    r = parseInt(hex[1] + hex[2], base);
    g = parseInt(hex[3] + hex[4], base);
    b = parseInt(hex[5] + hex[6], base);
  }

  return [r, g, b];
}; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)

var hsl2tuple = function hsl2tuple(hsl) {
  var ret;
  var h, s, l, a, r, g, b;

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  var m = new RegExp('^' + hsla + '$').exec(hsl);

  if (m) {
    // get hue
    h = parseInt(m[1]);

    if (h < 0) {
      h = (360 - -1 * h % 360) % 360;
    } else if (h > 360) {
      h = h % 360;
    }

    h /= 360; // normalise on [0, 1]

    s = parseFloat(m[2]);

    if (s < 0 || s > 100) {
      return;
    } // saturation is [0, 100]


    s = s / 100; // normalise on [0, 1]

    l = parseFloat(m[3]);

    if (l < 0 || l > 100) {
      return;
    } // lightness is [0, 100]


    l = l / 100; // normalise on [0, 1]

    a = m[4];

    if (a !== undefined) {
      a = parseFloat(a);

      if (a < 0 || a > 1) {
        return;
      } // alpha is [0, 1]

    } // now, convert to rgb
    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript


    if (s === 0) {
      r = g = b = Math.round(l * 255); // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
      g = Math.round(255 * hue2rgb(p, q, h));
      b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
    }

    ret = [r, g, b, a];
  }

  return ret;
}; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)

var rgb2tuple = function rgb2tuple(rgb) {
  var ret;
  var m = new RegExp('^' + rgba + '$').exec(rgb);

  if (m) {
    ret = [];
    var isPct = [];

    for (var i = 1; i <= 3; i++) {
      var channel = m[i];

      if (channel[channel.length - 1] === '%') {
        isPct[i] = true;
      }

      channel = parseFloat(channel);

      if (isPct[i]) {
        channel = channel / 100 * 255; // normalise to [0, 255]
      }

      if (channel < 0 || channel > 255) {
        return;
      } // invalid channel value


      ret.push(Math.floor(channel));
    }

    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
    var allArePct = isPct[1] && isPct[2] && isPct[3];

    if (atLeastOneIsPct && !allArePct) {
      return;
    } // must all be percent values if one is


    var alpha = m[4];

    if (alpha !== undefined) {
      alpha = parseFloat(alpha);

      if (alpha < 0 || alpha > 1) {
        return;
      } // invalid alpha value


      ret.push(alpha);
    }
  }

  return ret;
};
var colorname2tuple = function colorname2tuple(color) {
  return colors[color.toLowerCase()];
};
var color2tuple = function color2tuple(color) {
  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
};
var colors = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

var setMap = function setMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to set map with object key');
    }

    if (i < keys.length - 1) {
      // extend the map if necessary
      if (obj[key] == null) {
        obj[key] = {};
      }

      obj = obj[key];
    } else {
      // set the value
      obj[key] = options.value;
    }
  }
}; // gets the value in a map even if it's not built in places

var getMap = function getMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to get map with object key');
    }

    obj = obj[key];

    if (obj == null) {
      return obj;
    }
  }

  return obj;
}; // deletes the entry in the map

var performance = window$1 ? window$1.performance : null;
var pnow = performance && performance.now ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

var raf = function () {
  if (window$1) {
    if (window$1.requestAnimationFrame) {
      return function (fn) {
        window$1.requestAnimationFrame(fn);
      };
    } else if (window$1.mozRequestAnimationFrame) {
      return function (fn) {
        window$1.mozRequestAnimationFrame(fn);
      };
    } else if (window$1.webkitRequestAnimationFrame) {
      return function (fn) {
        window$1.webkitRequestAnimationFrame(fn);
      };
    } else if (window$1.msRequestAnimationFrame) {
      return function (fn) {
        window$1.msRequestAnimationFrame(fn);
      };
    }
  }

  return function (fn) {
    if (fn) {
      setTimeout(function () {
        fn(pnow());
      }, 1000 / 60);
    }
  };
}();

var requestAnimationFrame = function requestAnimationFrame(fn) {
  return raf(fn);
};
var performanceNow = pnow;

var DEFAULT_SEED = 5381;
var hashIterableInts = function hashIterableInts(iterator) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  var hash = seed;
  var entry;

  for (;;) {
    entry = iterator.next();

    if (entry.done) {
      break;
    }

    hash = (hash << 5) + hash + entry.value | 0;
  }

  return hash;
};
var hashInt = function hashInt(num) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  return (seed << 5) + seed + num | 0;
};
var hashIntsArray = function hashIntsArray(ints, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = ints.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = ints[i++];
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashString = function hashString(str, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = str.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = str.charCodeAt(i++);
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashStrings = function hashStrings() {
  return hashStringsArray(arguments);
};
var hashStringsArray = function hashStringsArray(strs) {
  var hash;

  for (var i = 0; i < strs.length; i++) {
    var str = strs[i];

    if (i === 0) {
      hash = hashString(str);
    } else {
      hash = hashString(str, hash);
    }
  }

  return hash;
};

/*global console */
var warningsEnabled = true;
var warnSupported = console.warn != null; // eslint-disable-line no-console

var traceSupported = console.trace != null; // eslint-disable-line no-console

var MAX_INT = Number.MAX_SAFE_INTEGER || 9007199254740991;
var trueify = function trueify() {
  return true;
};
var falsify = function falsify() {
  return false;
};
var zeroify = function zeroify() {
  return 0;
};
var noop = function noop() {};
var error = function error(msg) {
  throw new Error(msg);
};
var warnings = function warnings(enabled) {
  if (enabled !== undefined) {
    warningsEnabled = !!enabled;
  } else {
    return warningsEnabled;
  }
};
var warn = function warn(msg) {
  /* eslint-disable no-console */
  if (!warnings()) {
    return;
  }

  if (warnSupported) {
    console.warn(msg);
  } else {
    console.log(msg);

    if (traceSupported) {
      console.trace();
    }
  }
};
/* eslint-enable */

var clone = function clone(obj) {
  return extend({}, obj);
}; // gets a shallow copy of the argument

var copy = function copy(obj) {
  if (obj == null) {
    return obj;
  }

  if (array(obj)) {
    return obj.slice();
  } else if (plainObject(obj)) {
    return clone(obj);
  } else {
    return obj;
  }
};
var copyArray = function copyArray(arr) {
  return arr.slice();
};
var uuid = function uuid(a, b
/* placeholders */
) {
  for ( // loop :)
  b = a = ''; // b - result , a - numeric letiable
  a++ < 36; //
  b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
  ? //  return a random number or 4
  (a ^ 15 // if "a" is not 15
  ? // genetate a random number from 0 to 15
  8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
  : 4 //  otherwise 4
  ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
  ) {
  }

  return b;
};
var _staticEmptyObject = {};
var staticEmptyObject = function staticEmptyObject() {
  return _staticEmptyObject;
};
var defaults = function defaults(_defaults) {
  var keys = Object.keys(_defaults);
  return function (opts) {
    var filledOpts = {};

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var optVal = opts == null ? undefined : opts[key];
      filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
    }

    return filledOpts;
  };
};
var removeFromArray = function removeFromArray(arr, ele, manyCopies) {
  for (var i = arr.length; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);

      if (!manyCopies) {
        break;
      }
    }
  }
};
var clearArray = function clearArray(arr) {
  arr.splice(0, arr.length);
};
var push = function push(arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];
    arr.push(el);
  }
};
var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[propName];
};
var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[propName] = value;
};

/* global Map */
var ObjectMap =
/*#__PURE__*/
function () {
  function ObjectMap() {
    _classCallCheck(this, ObjectMap);

    this._obj = {};
  }

  _createClass(ObjectMap, [{
    key: "set",
    value: function set(key, val) {
      this._obj[key] = val;
      return this;
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this._obj[key] = undefined;
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._obj[key] !== undefined;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._obj[key];
    }
  }]);

  return ObjectMap;
}();

var Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;

/* global Set */
var undef =  "undefined" ;

var ObjectSet =
/*#__PURE__*/
function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);
    this.size = 0;

    if (arrayOrObjectSet != null) {
      var arr;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: "instanceString",
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: "add",
    value: function add(val) {
      var o = this._obj;

      if (o[val] !== 1) {
        o[val] = 1;
        this.size++;
      }
    }
  }, {
    key: "delete",
    value: function _delete(val) {
      var o = this._obj;

      if (o[val] === 1) {
        o[val] = 0;
        this.size--;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: "has",
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: "forEach",
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }]);

  return ObjectSet;
}();

var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;

var Element = function Element(cy, params, restore) {
  restore = restore === undefined || restore ? true : false;

  if (cy === undefined || params === undefined || !core(cy)) {
    error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group; // try to automatically infer the group if unspecified

  if (group == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group = 'edges';
    } else {
      group = 'nodes';
    }
  } // validate group


  if (group !== 'nodes' && group !== 'edges') {
    error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  } // make the element array-like, just like a collection


  this.length = 1;
  this[0] = this; // NOTE: when something is added here, add also to ele.json()

  var _p = this._private = {
    cy: cy,
    single: true,
    // indicates this is an element
    data: params.data || {},
    // data object
    position: params.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: undefined,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: group,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: true,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false,
    // whether it's selected
    selectable: params.selectable === undefined ? true : params.selectable ? true : false,
    // whether it's selectable
    locked: params.locked ? true : false,
    // whether the element is locked (cannot be moved)
    grabbed: false,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
    // whether the element can be grabbed
    pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,
    // whether the element has passthrough panning enabled
    active: false,
    // whether the element is active from user interaction
    classes: new Set$1(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: params.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: false,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      'mid-source': null,
      'mid-target': null
    }
  };

  if (_p.position.x == null) {
    _p.position.x = 0;
  }

  if (_p.position.y == null) {
    _p.position.y = 0;
  } // renderedPosition overrides if specified


  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();
    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  var classes = [];

  if (array(params.classes)) {
    classes = params.classes;
  } else if (string(params.classes)) {
    classes = params.classes.split(/\s+/);
  }

  for (var i = 0, l = classes.length; i < l; i++) {
    var cls = classes[i];

    if (!cls || cls === '') {
      continue;
    }

    _p.classes.add(cls);
  }

  this.createEmitter();
  var bypass = params.style || params.css;

  if (bypass) {
    warn('Setting a `style` bypass at element creation is deprecated');
    this.style(bypass);
  }

  if (restore === undefined || restore) {
    this.restore();
  }
};

var defineSearch = function defineSearch(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  }; // from pseudocode on wikipedia

  return function searchFn(roots, fn$1, directed) {
    var options;

    if (plainObject(roots) && !elementOrCollection(roots)) {
      options = roots;
      roots = options.roots || options.root;
      fn$1 = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !fn(fn$1) ? fn$1 : directed;
    fn$1 = fn(fn$1) ? fn$1 : function () {};
    var cy = this._private.cy;
    var v = roots = string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges; // enqueue v


    for (var i = 0; i < v.length; i++) {
      var vi = v[i];
      var viId = vi.id();

      if (vi.isNode()) {
        Q.unshift(vi);

        if (params.bfs) {
          V[viId] = true;
          connectedNodes.push(vi);
        }

        id2depth[viId] = 0;
      }
    }

    var _loop2 = function _loop2() {
      var v = params.bfs ? Q.shift() : Q.pop();
      var vId = v.id();

      if (params.dfs) {
        if (V[vId]) {
          return "continue";
        }

        V[vId] = true;
        connectedNodes.push(v);
      }

      var depth = id2depth[vId];
      var prevEdge = connectedBy[vId];
      var src = prevEdge != null ? prevEdge.source() : null;
      var tgt = prevEdge != null ? prevEdge.target() : null;
      var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
      var ret = void 0;
      ret = fn$1(v, prevEdge, prevNode, j++, depth);

      if (ret === true) {
        found = v;
        return "break";
      }

      if (ret === false) {
        return "break";
      }

      var vwEdges = v.connectedEdges().filter(function (e) {
        return (!directed || e.source().same(v)) && edges.has(e);
      });

      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
        var e = vwEdges[_i2];
        var w = e.connectedNodes().filter(function (n) {
          return !n.same(v) && nodes.has(n);
        });
        var wId = w.id();

        if (w.length !== 0 && !V[wId]) {
          w = w[0];
          Q.push(w);

          if (params.bfs) {
            V[wId] = true;
            connectedNodes.push(w);
          }

          connectedBy[wId] = e;
          id2depth[wId] = id2depth[vId] + 1;
        }
      }
    };

    _loop: while (Q.length !== 0) {
      var _ret = _loop2();

      switch (_ret) {
        case "continue":
          continue;

        case "break":
          break _loop;
      }
    }

    var connectedEles = cy.collection();

    for (var _i = 0; _i < connectedNodes.length; _i++) {
      var node = connectedNodes[_i];
      var edge = connectedBy[node.id()];

      if (edge != null) {
        connectedEles.merge(edge);
      }

      connectedEles.merge(node);
    }

    return {
      path: cy.collection(connectedEles),
      found: cy.collection(found)
    };
  };
}; // search, spanning trees, etc


var elesfn = {
  breadthFirstSearch: defineSearch({
    bfs: true
  }),
  depthFirstSearch: defineSearch({
    dfs: true
  })
}; // nice, short mathemathical alias

elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

var dijkstraDefaults = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$1 = {
  dijkstra: function dijkstra(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        weight: args[1],
        directed: args[2]
      };
    }

    var _dijkstraDefaults = dijkstraDefaults(options),
        root = _dijkstraDefaults.root,
        weight = _dijkstraDefaults.weight,
        directed = _dijkstraDefaults.directed;

    var eles = this;
    var weightFn = weight;
    var source = string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (ele) {
      return ele.isLoop();
    });

    var getDist = function getDist(node) {
      return dist[node.id()];
    };

    var setDist = function setDist(node, d) {
      dist[node.id()] = d;
      Q.updateItem(node);
    };

    var Q = new Heap(function (a, b) {
      return getDist(a) - getDist(b);
    });

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      dist[node.id()] = node.same(source) ? 0 : Infinity;
      Q.push(node);
    }

    var distBetween = function distBetween(u, v) {
      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for (var _i = 0; _i < uvs.length; _i++) {
        var edge = uvs[_i];

        var _weight = weightFn(edge);

        if (_weight < smallestDistance || !smallestEdge) {
          smallestDistance = _weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();
      knownDist[uid] = smalletsDist;

      if (smalletsDist === Infinity) {
        continue;
      }

      var neighbors = u.neighborhood().intersect(nodes);

      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
        var v = neighbors[_i2];
        var vid = v.id();
        var vDist = distBetween(u, v);
        var alt = smalletsDist + vDist.dist;

        if (alt < getDist(v)) {
          setDist(v, alt);
          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for

    } // while


    return {
      distanceTo: function distanceTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        return knownDist[target.id()];
      },
      pathTo: function pathTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;
        var uid = u.id();

        if (target.length > 0) {
          S.unshift(target);

          while (prev[uid]) {
            var p = prev[uid];
            S.unshift(p.edge);
            S.unshift(p.node);
            u = p.node;
            uid = u.id();
          }
        }

        return eles.spawn(S);
      }
    };
  }
};

var elesfn$2 = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function kruskal(weightFn) {
    weightFn = weightFn || function (edge) {
      return 1;
    };

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var forest = new Array(numNodes);
    var A = nodes; // assumes byGroup() creates new collections that can be safely mutated

    var findSetIndex = function findSetIndex(ele) {
      for (var i = 0; i < forest.length; i++) {
        var eles = forest[i];

        if (eles.has(ele)) {
          return i;
        }
      }
    }; // start with one forest per node


    for (var i = 0; i < numNodes; i++) {
      forest[i] = this.spawn(nodes[i]);
    }

    var S = edges.sort(function (a, b) {
      return weightFn(a) - weightFn(b);
    });

    for (var _i = 0; _i < S.length; _i++) {
      var edge = S[_i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setUIndex = findSetIndex(u);
      var setVIndex = findSetIndex(v);
      var setU = forest[setUIndex];
      var setV = forest[setVIndex];

      if (setUIndex !== setVIndex) {
        A.merge(edge); // combine forests for u and v

        setU.merge(setV);
        forest.splice(setVIndex, 1);
      }
    }

    return A;
  }
};

var aStarDefaults = defaults({
  root: null,
  goal: null,
  weight: function weight(edge) {
    return 1;
  },
  heuristic: function heuristic(edge) {
    return 0;
  },
  directed: false
});
var elesfn$3 = {
  // Implemented from pseudocode from wikipedia
  aStar: function aStar(options) {
    var cy = this.cy();

    var _aStarDefaults = aStarDefaults(options),
        root = _aStarDefaults.root,
        goal = _aStarDefaults.goal,
        heuristic = _aStarDefaults.heuristic,
        directed = _aStarDefaults.directed,
        weight = _aStarDefaults.weight;

    root = cy.collection(root)[0];
    goal = cy.collection(goal)[0];
    var sid = root.id();
    var tid = goal.id();
    var gScore = {};
    var fScore = {};
    var closedSetIds = {};
    var openSet = new Heap(function (a, b) {
      return fScore[a.id()] - fScore[b.id()];
    });
    var openSetIds = new Set$1();
    var cameFrom = {};
    var cameFromEdge = {};

    var addToOpenSet = function addToOpenSet(ele, id) {
      openSet.push(ele);
      openSetIds.add(id);
    };

    var cMin, cMinId;

    var popFromOpenSet = function popFromOpenSet() {
      cMin = openSet.pop();
      cMinId = cMin.id();
      openSetIds["delete"](cMinId);
    };

    var isInOpenSet = function isInOpenSet(id) {
      return openSetIds.has(id);
    };

    addToOpenSet(root, sid);
    gScore[sid] = 0;
    fScore[sid] = heuristic(root); // Counter

    var steps = 0; // Main loop

    while (openSet.size() > 0) {
      popFromOpenSet();
      steps++; // If we've found our goal, then we are done

      if (cMinId === tid) {
        var path = [];
        var pathNode = goal;
        var pathNodeId = tid;
        var pathEdge = cameFromEdge[pathNodeId];

        for (;;) {
          path.unshift(pathNode);

          if (pathEdge != null) {
            path.unshift(pathEdge);
          }

          pathNode = cameFrom[pathNodeId];

          if (pathNode == null) {
            break;
          }

          pathNodeId = pathNode.id();
          pathEdge = cameFromEdge[pathNodeId];
        }

        return {
          found: true,
          distance: gScore[cMinId],
          path: this.spawn(path),
          steps: steps
        };
      } // Add cMin to processed nodes


      closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
      // Take into account if graph is directed or not

      var vwEdges = cMin._private.edges;

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i]; // edge must be in set of calling eles

        if (!this.hasElementWithId(e.id())) {
          continue;
        } // cMin must be the source of edge if directed


        if (directed && e.data('source') !== cMinId) {
          continue;
        }

        var wSrc = e.source();
        var wTgt = e.target();
        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id(); // node must be in set of calling eles

        if (!this.hasElementWithId(wid)) {
          continue;
        } // if node is in closedSet, ignore it


        if (closedSetIds[wid]) {
          continue;
        } // New tentative score for node w


        var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value
        // w not in openSet

        if (!isInOpenSet(wid)) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          addToOpenSet(w, wid);
          cameFrom[wid] = cMin;
          cameFromEdge[wid] = e;
          continue;
        } // w already in openSet, but with greater gScore


        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          cameFrom[wid] = cMin;
        }
      } // End of neighbors update

    } // End of main loop
    // If we've reached here, then we've not reached our goal


    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }
}; // elesfn

var floydWarshallDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$4 = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function floydWarshall(options) {
    var cy = this.cy();

    var _floydWarshallDefault = floydWarshallDefaults(options),
        weight = _floydWarshallDefault.weight,
        directed = _floydWarshallDefault.directed;

    var weightFn = weight;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var N = nodes.length;
    var Nsq = N * N;

    var indexOf = function indexOf(node) {
      return nodes.indexOf(node);
    };

    var atIndex = function atIndex(i) {
      return nodes[i];
    }; // Initialize distance matrix


    var dist = new Array(Nsq);

    for (var n = 0; n < Nsq; n++) {
      var j = n % N;
      var i = (n - j) / N;

      if (i === j) {
        dist[n] = 0;
      } else {
        dist[n] = Infinity;
      }
    } // Initialize matrix used for path reconstruction
    // Initialize distance matrix


    var next = new Array(Nsq);
    var edgeNext = new Array(Nsq); // Process edges

    for (var _i = 0; _i < edges.length; _i++) {
      var edge = edges[_i];
      var src = edge.source()[0];
      var tgt = edge.target()[0];

      if (src === tgt) {
        continue;
      } // exclude loops


      var s = indexOf(src);
      var t = indexOf(tgt);
      var st = s * N + t; // source to target index

      var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes


      if (dist[st] > _weight) {
        dist[st] = _weight;
        next[st] = t;
        edgeNext[st] = edge;
      } // If undirected graph, process 'reversed' edge


      if (!directed) {
        var ts = t * N + s; // target to source index

        if (!directed && dist[ts] > _weight) {
          dist[ts] = _weight;
          next[ts] = s;
          edgeNext[ts] = edge;
        }
      }
    } // Main loop


    for (var k = 0; k < N; k++) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        var ik = _i2 * N + k;

        for (var _j = 0; _j < N; _j++) {
          var ij = _i2 * N + _j;
          var kj = k * N + _j;

          if (dist[ik] + dist[kj] < dist[ij]) {
            dist[ij] = dist[ik] + dist[kj];
            next[ij] = next[ik];
          }
        }
      }
    }

    var getArgEle = function getArgEle(ele) {
      return (string(ele) ? cy.filter(ele) : ele)[0];
    };

    var indexOfArgEle = function indexOfArgEle(ele) {
      return indexOf(getArgEle(ele));
    };

    var res = {
      distance: function distance(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        return dist[i * N + j];
      },
      path: function path(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        var fromNode = atIndex(i);

        if (i === j) {
          return fromNode.collection();
        }

        if (next[i * N + j] == null) {
          return cy.collection();
        }

        var path = cy.collection();
        var prev = i;
        var edge;
        path.merge(fromNode);

        while (i !== j) {
          prev = i;
          i = next[i * N + j];
          edge = edgeNext[prev * N + i];
          path.merge(edge);
          path.merge(atIndex(i));
        }

        return path;
      }
    };
    return res;
  } // floydWarshall

}; // elesfn

var bellmanFordDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$5 = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function bellmanFord(options) {
    var _this = this;

    var _bellmanFordDefaults = bellmanFordDefaults(options),
        weight = _bellmanFordDefaults.weight,
        directed = _bellmanFordDefaults.directed,
        root = _bellmanFordDefaults.root;

    var weightFn = weight;
    var eles = this;
    var cy = this.cy();

    var _this$byGroup = this.byGroup(),
        edges = _this$byGroup.edges,
        nodes = _this$byGroup.nodes;

    var numNodes = nodes.length;
    var infoMap = new Map$1();
    var hasNegativeWeightCycle = false;
    var negativeWeightCycles = [];
    root = cy.collection(root)[0]; // in case selector passed

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numEdges = edges.length;

    var getInfo = function getInfo(node) {
      var obj = infoMap.get(node.id());

      if (!obj) {
        obj = {};
        infoMap.set(node.id(), obj);
      }

      return obj;
    };

    var getNodeFromTo = function getNodeFromTo(to) {
      return (string(to) ? cy.$(to) : to)[0];
    };

    var distanceTo = function distanceTo(to) {
      return getInfo(getNodeFromTo(to)).dist;
    };

    var pathTo = function pathTo(to) {
      var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
      var end = getNodeFromTo(to);
      var path = [];
      var node = end;

      for (;;) {
        if (node == null) {
          return _this.spawn();
        }

        var _getInfo = getInfo(node),
            edge = _getInfo.edge,
            pred = _getInfo.pred;

        path.unshift(node[0]);

        if (node.same(thisStart) && path.length > 0) {
          break;
        }

        if (edge != null) {
          path.unshift(edge);
        }

        node = pred;
      }

      return eles.spawn(path);
    }; // Initializations { dist, pred, edge }


    for (var i = 0; i < numNodes; i++) {
      var node = nodes[i];
      var info = getInfo(node);

      if (node.same(root)) {
        info.dist = 0;
      } else {
        info.dist = Infinity;
      }

      info.pred = null;
      info.edge = null;
    } // Edges relaxation


    var replacedEdge = false;

    var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
      var dist = info1.dist + weight;

      if (dist < info2.dist && !edge.same(info1.edge)) {
        info2.dist = dist;
        info2.pred = node1;
        info2.edge = edge;
        replacedEdge = true;
      }
    };

    for (var _i = 1; _i < numNodes; _i++) {
      replacedEdge = false;

      for (var e = 0; e < numEdges; e++) {
        var edge = edges[e];
        var src = edge.source();
        var tgt = edge.target();

        var _weight = weightFn(edge);

        var srcInfo = getInfo(src);
        var tgtInfo = getInfo(tgt);
        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge

        if (!directed) {
          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
        }
      }

      if (!replacedEdge) {
        break;
      }
    }

    if (replacedEdge) {
      // Check for negative weight cycles
      for (var _e = 0; _e < numEdges; _e++) {
        var _edge = edges[_e];

        var _src = _edge.source();

        var _tgt = _edge.target();

        var _weight2 = weightFn(_edge);

        var srcDist = getInfo(_src).dist;
        var tgtDist = getInfo(_tgt).dist;

        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
          warn('Graph contains a negative weight cycle for Bellman-Ford');
          hasNegativeWeightCycle = true;
          break;
        }
      }
    }

    return {
      distanceTo: distanceTo,
      pathTo: pathTo,
      hasNegativeWeightCycle: hasNegativeWeightCycle,
      negativeWeightCycles: negativeWeightCycles
    };
  } // bellmanFord

}; // elesfn

var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse

var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
  if (remainingEdges.length === 0) {
    error("Karger-Stein must be run on a connected (sub)graph");
  }

  var edgeInfo = remainingEdges[edgeIndex];
  var sourceIn = edgeInfo[1];
  var targetIn = edgeInfo[2];
  var partition1 = nodeMap[sourceIn];
  var partition2 = nodeMap[targetIn];
  var newEdges = remainingEdges; // re-use array
  // Delete all edges between partition1 and partition2

  for (var i = newEdges.length - 1; i >= 0; i--) {
    var edge = newEdges[i];
    var src = edge[1];
    var tgt = edge[2];

    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
      newEdges.splice(i, 1);
    }
  } // All edges pointing to partition2 should now point to partition1


  for (var _i = 0; _i < newEdges.length; _i++) {
    var _edge = newEdges[_i];

    if (_edge[1] === partition2) {
      // Check source
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][1] = partition1;
    } else if (_edge[2] === partition2) {
      // Check target
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][2] = partition1;
    }
  } // Move all nodes from partition2 to partition1


  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
    if (nodeMap[_i2] === partition2) {
      nodeMap[_i2] = partition1;
    }
  }

  return newEdges;
}; // Contracts a graph until we reach a certain number of meta nodes


var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
  while (size > sizeLimit) {
    // Choose an edge randomly
    var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge

    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
    size--;
  }

  return remainingEdges;
};

var elesfn$6 = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function kargerStein() {
    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / sqrt2);

    if (numNodes < 2) {
      error('At least 2 nodes are required for Karger-Stein algorithm');
      return undefined;
    } // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)


    var edgeIndexes = [];

    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);
    } // We will store the best cut found here


    var minCutSize = Infinity;
    var minCutEdgeIndexes = [];
    var minCutNodeMap = new Array(numNodes); // Initial meta node partition

    var metaNodeMap = new Array(numNodes);
    var metaNodeMap2 = new Array(numNodes);

    var copyNodesMap = function copyNodesMap(from, to) {
      for (var _i3 = 0; _i3 < numNodes; _i3++) {
        to[_i3] = from[_i3];
      }
    }; // Main loop


    for (var iter = 0; iter <= numIter; iter++) {
      // Reset meta node partition
      for (var _i4 = 0; _i4 < numNodes; _i4++) {
        metaNodeMap[_i4] = _i4;
      } // Contract until stop point (stopSize nodes)


      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
      var edgesState2 = edgesState.slice(); // copy
      // Create a copy of the colapsed nodes state

      copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state

      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?

      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCutEdgeIndexes = res1;
        copyNodesMap(metaNodeMap, minCutNodeMap);
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCutEdgeIndexes = res2;
        copyNodesMap(metaNodeMap2, minCutNodeMap);
      }
    } // end of main loop
    // Construct result


    var cut = this.spawn(minCutEdgeIndexes.map(function (e) {
      return edges[e[0]];
    }));
    var partition1 = this.spawn();
    var partition2 = this.spawn(); // traverse metaNodeMap for best cut

    var witnessNodePartition = minCutNodeMap[0];

    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
      var partitionId = minCutNodeMap[_i5];
      var node = nodes[_i5];

      if (partitionId === witnessNodePartition) {
        partition1.merge(node);
      } else {
        partition2.merge(node);
      }
    }

    var ret = {
      cut: cut,
      partition1: partition1,
      partition2: partition2
    };
    return ret;
  }
}; // elesfn

var copyPosition = function copyPosition(p) {
  return {
    x: p.x,
    y: p.y
  };
};
var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
  return {
    x: p.x * zoom + pan.x,
    y: p.y * zoom + pan.y
  };
};
var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
  return {
    x: (p.x - pan.x) / zoom,
    y: (p.y - pan.y) / zoom
  };
};
var array2point = function array2point(arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
};
var min = function min(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var min = Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      min = Math.min(val, min);
    }
  }

  return min;
};
var max = function max(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var max = -Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      max = Math.max(val, max);
    }
  }

  return max;
};
var mean = function mean(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var total = 0;
  var n = 0;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      total += val;
      n++;
    }
  }

  return total / n;
};
var median = function median(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

  if (copy) {
    arr = arr.slice(begin, end);
  } else {
    if (end < arr.length) {
      arr.splice(end, arr.length - end);
    }

    if (begin > 0) {
      arr.splice(0, begin);
    }
  } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start


  var off = 0; // offset from non-finite values

  for (var i = arr.length - 1; i >= 0; i--) {
    var v = arr[i];

    if (includeHoles) {
      if (!isFinite(v)) {
        arr[i] = -Infinity;
        off++;
      }
    } else {
      // just remove it if we don't want to consider holes
      arr.splice(i, 1);
    }
  }

  if (sort) {
    arr.sort(function (a, b) {
      return a - b;
    }); // requires copy = true if you don't want to change the orig
  }

  var len = arr.length;
  var mid = Math.floor(len / 2);

  if (len % 2 !== 0) {
    return arr[mid + 1 + off];
  } else {
    return (arr[mid - 1 + off] + arr[mid + off]) / 2;
  }
};
var deg2rad = function deg2rad(deg) {
  return Math.PI * deg / 180;
};
var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
};
var log2 = Math.log2 || function (n) {
  return Math.log(n) / Math.log(2);
};
var signum = function signum(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var dist = function dist(p1, p2) {
  return Math.sqrt(sqdist(p1, p2));
};
var sqdist = function sqdist(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return dx * dx + dy * dy;
};
var inPlaceSumNormalize = function inPlaceSumNormalize(v) {
  var length = v.length; // First, get sum of all elements

  var total = 0;

  for (var i = 0; i < length; i++) {
    total += v[i];
  } // Now, divide each by the sum of all elements


  for (var _i = 0; _i < length; _i++) {
    v[_i] = v[_i] / total;
  }

  return v;
};

var qbezierAt = function qbezierAt(p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};
var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
  return {
    x: qbezierAt(p0.x, p1.x, p2.x, t),
    y: qbezierAt(p0.y, p1.y, p2.y, t)
  };
};
var lineAt = function lineAt(p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var vecDist = dist(p0, p1);
  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };
  t = t == null ? 0 : t;
  d = d != null ? d : t * vecDist;
  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};
var bound = function bound(min, val, max) {
  return Math.max(min, Math.min(max, val));
}; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params

var makeBoundingBox = function makeBoundingBox(bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};
var copyBoundingBox = function copyBoundingBox(bb) {
  return {
    x1: bb.x1,
    x2: bb.x2,
    w: bb.w,
    y1: bb.y1,
    y2: bb.y2,
    h: bb.h
  };
};
var clearBoundingBox = function clearBoundingBox(bb) {
  bb.x1 = Infinity;
  bb.y1 = Infinity;
  bb.x2 = -Infinity;
  bb.y2 = -Infinity;
  bb.w = 0;
  bb.h = 0;
};
var updateBoundingBox = function updateBoundingBox(bb1, bb2) {
  // update bb1 with bb2 bounds
  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;
  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
};
var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
  bb.x1 = Math.min(bb.x1, x);
  bb.x2 = Math.max(bb.x2, x);
  bb.w = bb.x2 - bb.x1;
  bb.y1 = Math.min(bb.y1, y);
  bb.y2 = Math.max(bb.y2, y);
  bb.h = bb.y2 - bb.y1;
};
var expandBoundingBox = function expandBoundingBox(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};
var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
  var top, right, bottom, left;

  if (padding.length === 1) {
    top = right = bottom = left = padding[0];
  } else if (padding.length === 2) {
    top = bottom = padding[0];
    left = right = padding[1];
  } else if (padding.length === 4) {
    var _padding = _slicedToArray(padding, 4);

    top = _padding[0];
    right = _padding[1];
    bottom = _padding[2];
    left = _padding[3];
  }

  bb.x1 -= left;
  bb.x2 += right;
  bb.y1 -= top;
  bb.y2 += bottom;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};

var assignBoundingBox = function assignBoundingBox(bb1, bb2) {
  bb1.x1 = bb2.x1;
  bb1.y1 = bb2.y1;
  bb1.x2 = bb2.x2;
  bb1.y2 = bb2.y2;
  bb1.w = bb1.x2 - bb1.x1;
  bb1.h = bb1.y2 - bb1.y1;
};
var assignShiftToBoundingBox = function assignShiftToBoundingBox(bb, delta) {
  bb.x1 += delta.x;
  bb.x2 += delta.x;
  bb.y1 += delta.y;
  bb.y2 += delta.y;
};
var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
  // case: one bb to right of other
  if (bb1.x1 > bb2.x2) {
    return false;
  }

  if (bb2.x1 > bb1.x2) {
    return false;
  } // case: one bb to left of other


  if (bb1.x2 < bb2.x1) {
    return false;
  }

  if (bb2.x2 < bb1.x1) {
    return false;
  } // case: one bb above other


  if (bb1.y2 < bb2.y1) {
    return false;
  }

  if (bb2.y2 < bb1.y1) {
    return false;
  } // case: one bb below other


  if (bb1.y1 > bb2.y2) {
    return false;
  }

  if (bb2.y1 > bb1.y2) {
    return false;
  } // otherwise, must have some overlap


  return true;
};
var inBoundingBox = function inBoundingBox(bb, x, y) {
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};
var pointInBoundingBox = function pointInBoundingBox(bb, pt) {
  return inBoundingBox(bb, pt.x, pt.y);
};
var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
};
var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
  var cornerRadius = getRoundRectangleRadius(width, height);
  var halfWidth = width / 2;
  var halfHeight = height / 2; // Check intersections with straight line segments

  var straightLineIntersections; // Top segment, left to right

  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Right segment, top to bottom

  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Bottom segment, left to right

  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Left segment, top to bottom

  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Check intersections with arc segments

  var arcIntersections; // Top Left

  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Top Right

  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Right

  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Left

  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  return []; // if nothing
};
var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;
  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);
  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};
var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
  var bb = {
    x1: Math.min(x1, x3, x2) - tolerance,
    x2: Math.max(x1, x3, x2) + tolerance,
    y1: Math.min(y1, y3, y2) - tolerance,
    y2: Math.max(y1, y3, y2) + tolerance
  }; // if outside the rough bounding box for the bezier, then it can't be a hit

  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }
};
var solveQuadratic = function solveQuadratic(a, b, c, val) {
  c -= val;
  var r = b * b - 4 * a * c;

  if (r < 0) {
    return [];
  }

  var sqrtR = Math.sqrt(r);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;
  return [root1, root2];
};
var solveCubic = function solveCubic(a, b, c, d, result) {
  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component
  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
  var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value

  if (a === 0) {
    a = epsilon;
  }

  b /= a;
  c /= a;
  d /= a;
  var discriminant, q, r, dum1, s, t, term1, r13;
  q = (3.0 * c - b * b) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;
  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = b / 3.0;

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
    t = r - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
  return;
};
var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve
  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)
  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = []; // Use the cubic solving algorithm

  solveCubic(a, b, c, d, roots);
  var zeroThreshold = 0.0000001;
  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);
  var minDistanceSquared = -1;
  var curX, curY, distSquared;

  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));

    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }

  return minDistanceSquared;
};
var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];
  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};
var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
  var x1, y1, x2, y2;
  var y3; // Intersect with vertical line through (x, y)

  var up = 0; // let down = 0;

  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      } // if( y3 < y ){
      // down++;
      // }

    } else {
      continue;
    }
  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};
var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
  var transformedPoints = new Array(basePoints.length); // Gives negative angle

  var angle;

  if (direction[0] != null) {
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle); //    console.log("base: " + basePoints);

  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = expandPolygon(transformedPoints, -padding);
    points = joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return pointInsidePolygonPoints(x, y, points);
};
var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
  var cutPolygonPoints = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);
  var squaredCornerRadius = cornerRadius * cornerRadius;

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];
    cutPolygonPoints[i * 4] = cp0x;
    cutPolygonPoints[i * 4 + 1] = cp0y;
    cutPolygonPoints[i * 4 + 2] = cp1x;
    cutPolygonPoints[i * 4 + 3] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);

    if (squaredDistance <= squaredCornerRadius) {
      return true;
    }
  }

  return pointInsidePolygonPoints(x, y, cutPolygonPoints);
};
var joinLines = function joinLines(lineSet) {
  var vertices = new Array(lineSet.length / 2);
  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};
var expandPolygon = function expandPolygon(points, pad) {
  var expandedLineSet = new Array(points.length * 2);
  var currentPointX, currentPointY, nextPointX, nextPointY;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
    // Assume CCW polygon winding


    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX); // Normalize

    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;
    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};
var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
  var dispX = centerX - x;
  var dispY = centerY - y;
  dispX /= ellipseWradius;
  dispY /= ellipseHradius;
  var len = Math.sqrt(dispX * dispX + dispY * dispY);
  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;
  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};
var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
  x -= centerX;
  y -= centerY;
  x /= width / 2 + padding;
  y /= height / 2 + padding;
  return x * x + y * y <= 1;
}; // Returns intersections of increasing distance from line's start point

var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line

  var f = [x1 - centerX, y1 - centerY];
  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
  var discriminant = b * b - 4 * a * c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {
    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {
      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;
      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
};
var midOfThree = function midOfThree(a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
}; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)

var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;
  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;
  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;
    var flptThreshold = 0.001;

    var _min = 0 - flptThreshold;

    var _max = 1 + flptThreshold;

    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {
      // Parallel, coincident lines. Check if overlap
      // Check endpoint of second line
      if (midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      } // Check start point of second line


      if (midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      } // Endpoint of first line


      if (midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }

      return [];
    } else {
      // Parallel, non-coincident
      return [];
    }
  }
}; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)

var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var transformedPoints = new Array(basePoints.length);
  var doTransform = true;

  if (width == null) {
    doTransform = false;
  }

  var points;

  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }

    if (padding > 0) {
      var expandedLineSet = expandPolygon(transformedPoints, -padding);
      points = joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX, currentY, nextX, nextY;

  for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
    currentX = points[_i2 * 2];
    currentY = points[_i2 * 2 + 1];

    if (_i2 < points.length / 2 - 1) {
      nextX = points[(_i2 + 1) * 2];
      nextY = points[(_i2 + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};
var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var lines = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];

    if (i === 0) {
      lines[basePoints.length - 2] = cp0x;
      lines[basePoints.length - 1] = cp0y;
    } else {
      lines[i * 4 - 2] = cp0x;
      lines[i * 4 - 1] = cp0y;
    }

    lines[i * 4] = cp1x;
    lines[i * 4 + 1] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {
    intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  if (intersections.length > 2) {
    var lowestIntersection = [intersections[0], intersections[1]];
    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);

    for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
      var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);

      if (squaredDistance <= lowestSquaredDistance) {
        lowestIntersection[0] = intersections[_i4 * 2];
        lowestIntersection[1] = intersections[_i4 * 2 + 1];
        lowestSquaredDistance = squaredDistance;
      }
    }

    return lowestIntersection;
  }

  return intersections;
};
var shortenIntersection = function shortenIntersection(intersection, offset, amount) {
  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};
var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
  var points = generateUnitNgonPoints(sides, rotationRadians);
  points = fitPolygonToSquare(points);
  return points;
};
var fitPolygonToSquare = function fitPolygonToSquare(points) {
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  } // stretch factors


  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var _i5 = 0; _i5 < sides; _i5++) {
    x = points[2 * _i5] = points[2 * _i5] * sx;
    y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  if (minY < -1) {
    for (var _i6 = 0; _i6 < sides; _i6++) {
      y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
    }
  }

  return points;
};
var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  startAngle += rotationRadians;
  var points = new Array(sides * 2);
  var currentAngle;

  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;
    points[2 * i] = Math.cos(currentAngle); // x

    points[2 * i + 1] = Math.sin(-currentAngle); // y
  }

  return points;
}; // Set the default radius, unless half of width or height is smaller than default

var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
  return Math.min(width / 4, height / 4, 8);
}; // Set the default radius

var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
  return Math.min(width / 10, height / 10, 8);
};
var getCutRectangleCornerLength = function getCutRectangleCornerLength() {
  return 8;
};
var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
}; // get curve width, height, and control point position offsets as a percentage of node height / width

var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
  return {
    heightOffset: Math.min(15, 0.05 * height),
    widthOffset: Math.min(100, 0.25 * width),
    ctrlPtOffsetPct: 0.05
  };
};

var pageRankDefaults = defaults({
  dampingFactor: 0.8,
  precision: 0.000001,
  iterations: 200,
  weight: function weight(edge) {
    return 1;
  }
});
var elesfn$7 = {
  pageRank: function pageRank(options) {
    var _pageRankDefaults = pageRankDefaults(options),
        dampingFactor = _pageRankDefaults.dampingFactor,
        precision = _pageRankDefaults.precision,
        iterations = _pageRankDefaults.iterations,
        weight = _pageRankDefaults.weight;

    var cy = this._private.cy;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var numNodesSqd = numNodes * numNodes;
    var numEdges = edges.length; // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column

    var matrix = new Array(numNodesSqd);
    var columnSum = new Array(numNodes);
    var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix

    for (var i = 0; i < numNodes; i++) {
      for (var j = 0; j < numNodes; j++) {
        var n = i * numNodes + j;
        matrix[n] = 0;
      }

      columnSum[i] = 0;
    } // Now, process edges


    for (var _i = 0; _i < numEdges; _i++) {
      var edge = edges[_i];
      var srcId = edge.data('source');
      var tgtId = edge.data('target'); // Don't include loops in the matrix

      if (srcId === tgtId) {
        continue;
      }

      var s = nodes.indexOfId(srcId);
      var t = nodes.indexOfId(tgtId);
      var w = weight(edge);

      var _n = t * numNodes + s; // Update matrix


      matrix[_n] += w; // Update column sum

      columnSum[s] += w;
    } // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0


    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column

    for (var _j = 0; _j < numNodes; _j++) {
      if (columnSum[_j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var _i2 = 0; _i2 < numNodes; _i2++) {
          var _n2 = _i2 * numNodes + _j;

          matrix[_n2] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var _i3 = 0; _i3 < numNodes; _i3++) {
          var _n3 = _i3 * numNodes + _j;

          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
        }
      }
    } // Compute dominant eigenvector using power method


    var eigenvector = new Array(numNodes);
    var temp = new Array(numNodes);
    var previous; // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand

    for (var _i4 = 0; _i4 < numNodes; _i4++) {
      eigenvector[_i4] = 1;
    }

    for (var iter = 0; iter < iterations; iter++) {
      // Temp array with all 0's
      for (var _i5 = 0; _i5 < numNodes; _i5++) {
        temp[_i5] = 0;
      } // Multiply matrix with previous result


      for (var _i6 = 0; _i6 < numNodes; _i6++) {
        for (var _j2 = 0; _j2 < numNodes; _j2++) {
          var _n4 = _i6 * numNodes + _j2;

          temp[_i6] += matrix[_n4] * eigenvector[_j2];
        }
      }

      inPlaceSumNormalize(temp);
      previous = eigenvector;
      eigenvector = temp;
      temp = previous;
      var diff = 0; // Compute difference (squared module) of both vectors

      for (var _i7 = 0; _i7 < numNodes; _i7++) {
        var delta = previous[_i7] - eigenvector[_i7];
        diff += delta * delta;
      } // If difference is less than the desired threshold, stop iterating


      if (diff < precision) {
        break;
      }
    } // Construct result


    var res = {
      rank: function rank(node) {
        node = cy.collection(node)[0];
        return eigenvector[nodes.indexOf(node)];
      }
    };
    return res;
  } // pageRank

}; // elesfn

var defaults$1 = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  alpha: 0
});
var elesfn$8 = {
  degreeCentralityNormalized: function degreeCentralityNormalized(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!options.directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i]; // add current node to the current options object and call degreeCentrality

        options.root = node;
        var currDegree = this.degreeCentrality(options);

        if (maxDegree < currDegree.degree) {
          maxDegree = currDegree.degree;
        }

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function degree(node) {
          if (maxDegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return degrees[node.id()] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var _i = 0; _i < numNodes; _i++) {
        var _node = nodes[_i];

        var id = _node.id(); // add current node to the current options object and call degreeCentrality


        options.root = _node;

        var _currDegree = this.degreeCentrality(options);

        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
        indegrees[id] = _currDegree.indegree;
        outdegrees[id] = _currDegree.outdegree;
      }

      return {
        indegree: function indegree(node) {
          if (maxIndegree == 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return indegrees[node.id()] / maxIndegree;
        },
        outdegree: function outdegree(node) {
          if (maxOutdegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return outdegrees[node.id()] / maxOutdegree;
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function degreeCentrality(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var callingEles = this;
    var _options = options,
        root = _options.root,
        weight = _options.weight,
        directed = _options.directed,
        alpha = _options.alpha;
    root = cy.collection(root)[0];

    if (!directed) {
      var connEdges = root.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0; // Now, sum edge weights

      for (var i = 0; i < connEdges.length; i++) {
        s += weight(connEdges[i]);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var edges = root.connectedEdges();
      var incoming = edges.filter(function (edge) {
        return edge.target().same(root) && callingEles.has(edge);
      });
      var outgoing = edges.filter(function (edge) {
        return edge.source().same(root) && callingEles.has(edge);
      });
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0; // Now, sum incoming edge weights

      for (var _i2 = 0; _i2 < incoming.length; _i2++) {
        s_in += weight(incoming[_i2]);
      } // Now, sum outgoing edge weights


      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
        s_out += weight(outgoing[_i3]);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$8.dc = elesfn$8.degreeCentrality;
elesfn$8.dcn = elesfn$8.degreeCentralityNormalised = elesfn$8.degreeCentralityNormalized;

var defaults$2 = defaults({
  harmonic: true,
  weight: function weight() {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$9 = {
  closenessCentralityNormalized: function closenessCentralityNormalized(options) {
    var _defaults = defaults$2(options),
        harmonic = _defaults.harmonic,
        weight = _defaults.weight,
        directed = _defaults.directed;

    var cy = this.cy();
    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({
      weight: weight,
      directed: directed
    }); // Compute closeness for every node and find the maximum closeness

    for (var i = 0; i < nodes.length; i++) {
      var currCloseness = 0;
      var node_i = nodes[i];

      for (var j = 0; j < nodes.length; j++) {
        if (i !== j) {
          var d = fw.distance(node_i, nodes[j]);

          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }

      closenesses[node_i.id()] = currCloseness;
    }

    return {
      closeness: function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }

        if (string(node)) {
          // from is a selector string
          node = cy.filter(node)[0].id();
        } else {
          // from is a node
          node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function closenessCentrality(options) {
    var _defaults2 = defaults$2(options),
        root = _defaults2.root,
        weight = _defaults2.weight,
        directed = _defaults2.directed,
        harmonic = _defaults2.harmonic;

    root = this.filter(root)[0]; // we need distance from this node to every other node

    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];

      if (!n.same(root)) {
        var d = dijkstra.distanceTo(n);

        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$9.cc = elesfn$9.closenessCentrality;
elesfn$9.ccn = elesfn$9.closenessCentralityNormalised = elesfn$9.closenessCentralityNormalized;

var defaults$3 = defaults({
  weight: null,
  directed: false
});
var elesfn$a = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function betweennessCentrality(options) {
    var _defaults = defaults$3(options),
        directed = _defaults.directed,
        weight = _defaults.weight;

    var weighted = weight != null;
    var cy = this.cy(); // starting

    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function set(key, val) {
        _C[key] = val;

        if (val > max) {
          max = val;
        }
      },
      get: function get(key) {
        return _C[key];
      }
    }; // A contains the neighborhoods of every node

    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();

      if (directed) {
        A[vid] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set(vid, 0);
    }

    var _loop = function _loop(s) {
      var sid = V[s].id();
      var S = []; // stack

      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function (a, b) {
        return d[a] - d[b];
      }); // queue
      // init dictionaries

      for (var _i = 0; _i < V.length; _i++) {
        var _vid = V[_i].id();

        P[_vid] = [];
        g[_vid] = 0;
        d[_vid] = Infinity;
      }

      g[sid] = 1; // sigma

      d[sid] = 0; // distance to s

      Q.push(sid);

      while (!Q.empty()) {
        var _v = Q.pop();

        S.push(_v);

        if (weighted) {
          for (var j = 0; j < A[_v].length; j++) {
            var w = A[_v][j];
            var vEle = cy.getElementById(_v);
            var edge = void 0;

            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }

            var edgeWeight = weight(edge);
            w = w.id();

            if (d[w] > d[_v] + edgeWeight) {
              d[w] = d[_v] + edgeWeight;

              if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                Q.push(w);
              } else {
                // update position if w is in Q
                Q.updateItem(w);
              }

              g[w] = 0;
              P[w] = [];
            }

            if (d[w] == d[_v] + edgeWeight) {
              g[w] = g[w] + g[_v];
              P[w].push(_v);
            }
          }
        } else {
          for (var _j = 0; _j < A[_v].length; _j++) {
            var _w = A[_v][_j].id();

            if (d[_w] == Infinity) {
              Q.push(_w);
              d[_w] = d[_v] + 1;
            }

            if (d[_w] == d[_v] + 1) {
              g[_w] = g[_w] + g[_v];

              P[_w].push(_v);
            }
          }
        }
      }

      var e = {};

      for (var _i2 = 0; _i2 < V.length; _i2++) {
        e[V[_i2].id()] = 0;
      }

      while (S.length > 0) {
        var _w2 = S.pop();

        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
          var _v2 = P[_w2][_j2];
          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);

          if (_w2 != V[s].id()) {
            C.set(_w2, C.get(_w2) + e[_w2]);
          }
        }
      }
    };

    for (var s = 0; s < V.length; s++) {
      _loop(s);
    }

    var ret = {
      betweenness: function betweenness(node) {
        var id = cy.collection(node).id();
        return C.get(id);
      },
      betweennessNormalized: function betweennessNormalized(node) {
        if (max == 0) {
          return 0;
        }

        var id = cy.collection(node).id();
        return C.get(id) / max;
      }
    }; // alias

    ret.betweennessNormalised = ret.betweennessNormalized;
    return ret;
  } // betweennessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$a.bc = elesfn$a.betweennessCentrality;

// Implemented by Zoe Xi @zoexi for GSOC 2016
/* eslint-disable no-unused-vars */

var defaults$4 = defaults({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [// attributes/features used to group nodes, ie. similarity values between nodes
  function (edge) {
    return 1;
  }]
});
/* eslint-enable */

var setOptions = function setOptions(options) {
  return defaults$4(options);
};
/* eslint-enable */


var getSimilarity = function getSimilarity(edge, attributes) {
  var total = 0;

  for (var i = 0; i < attributes.length; i++) {
    total += attributes[i](edge);
  }

  return total;
};

var addLoops = function addLoops(M, n, val) {
  for (var i = 0; i < n; i++) {
    M[i * n + i] = val;
  }
};

var normalize = function normalize(M, n) {
  var sum;

  for (var col = 0; col < n; col++) {
    sum = 0;

    for (var row = 0; row < n; row++) {
      sum += M[row * n + col];
    }

    for (var _row = 0; _row < n; _row++) {
      M[_row * n + col] = M[_row * n + col] / sum;
    }
  }
}; // TODO: blocked matrix multiplication?


var mmult = function mmult(A, B, n) {
  var C = new Array(n * n);

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      C[i * n + j] = 0;
    }

    for (var k = 0; k < n; k++) {
      for (var _j = 0; _j < n; _j++) {
        C[i * n + _j] += A[i * n + k] * B[k * n + _j];
      }
    }
  }

  return C;
};

var expand = function expand(M, n, expandFactor
/** power **/
) {
  var _M = M.slice(0);

  for (var p = 1; p < expandFactor; p++) {
    M = mmult(M, _M, n);
  }

  return M;
};

var inflate = function inflate(M, n, inflateFactor
/** r **/
) {
  var _M = new Array(n * n); // M(i,j) ^ inflatePower


  for (var i = 0; i < n * n; i++) {
    _M[i] = Math.pow(M[i], inflateFactor);
  }

  normalize(_M, n);
  return _M;
};

var hasConverged = function hasConverged(M, _M, n2, roundFactor) {
  // Check that both matrices have the same elements (i,j)
  for (var i = 0; i < n2; i++) {
    var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places

    var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);

    if (v1 !== v2) {
      return false;
    }
  }

  return true;
};

var assign = function assign(M, n, nodes, cy) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var cluster = [];

    for (var j = 0; j < n; j++) {
      // Row-wise attractors and elements that they attract belong in same cluster
      if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {
        cluster.push(nodes[j]);
      }
    }

    if (cluster.length !== 0) {
      clusters.push(cy.collection(cluster));
    }
  }

  return clusters;
};

var isDuplicate = function isDuplicate(c1, c2) {
  for (var i = 0; i < c1.length; i++) {
    if (!c2[i] || c1[i].id() !== c2[i].id()) {
      return false;
    }
  }

  return true;
};

var removeDuplicates = function removeDuplicates(clusters) {
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j < clusters.length; j++) {
      if (i != j && isDuplicate(clusters[i], clusters[j])) {
        clusters.splice(j, 1);
      }
    }
  }

  return clusters;
};

var markovClustering = function markovClustering(options) {
  var nodes = this.nodes();
  var edges = this.edges();
  var cy = this.cy(); // Set parameters of algorithm:

  var opts = setOptions(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)


  var n = nodes.length,
      n2 = n * n;

  var M = new Array(n2),
      _M;

  for (var _i = 0; _i < n2; _i++) {
    M[_i] = 0;
  }

  for (var e = 0; e < edges.length; e++) {
    var edge = edges[e];
    var _i2 = id2position[edge.source().id()];
    var j = id2position[edge.target().id()];
    var sim = getSimilarity(edge, opts.attributes);
    M[_i2 * n + j] += sim; // G should be symmetric and undirected

    M[j * n + _i2] += sim;
  } // Begin Markov cluster algorithm
  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal


  addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );

  normalize(M, n);
  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 3:

    _M = expand(M, n, opts.expandFactor); // Step 4:

    M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached

    if (!hasConverged(M, _M, n2, 4)) {
      isStillMoving = true;
    }

    iterations++;
  } // Build clusters from matrix


  var clusters = assign(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix

  clusters = removeDuplicates(clusters);
  return clusters;
};

var markovClustering$1 = {
  markovClustering: markovClustering,
  mcl: markovClustering
};

// Common distance metrics for clustering algorithms

var identity = function identity(x) {
  return x;
};

var absDiff = function absDiff(p, q) {
  return Math.abs(q - p);
};

var addAbsDiff = function addAbsDiff(total, p, q) {
  return total + absDiff(p, q);
};

var addSquaredDiff = function addSquaredDiff(total, p, q) {
  return total + Math.pow(q - p, 2);
};

var sqrt = function sqrt(x) {
  return Math.sqrt(x);
};

var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
  return Math.max(currentMax, absDiff(p, q));
};

var getDistance = function getDistance(length, getP, getQ, init, visit) {
  var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
  var ret = init;
  var p, q;

  for (var dim = 0; dim < length; dim++) {
    p = getP(dim);
    q = getQ(dim);
    ret = visit(ret, p, q);
  }

  return post(ret);
};

var distances = {
  euclidean: function euclidean(length, getP, getQ) {
    if (length >= 2) {
      return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
    } else {
      // for single attr case, more efficient to avoid sqrt
      return getDistance(length, getP, getQ, 0, addAbsDiff);
    }
  },
  squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addSquaredDiff);
  },
  manhattan: function manhattan(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addAbsDiff);
  },
  max: function max(length, getP, getQ) {
    return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
  }
}; // in case the user accidentally doesn't use camel case

distances['squared-euclidean'] = distances['squaredEuclidean'];
distances['squaredeuclidean'] = distances['squaredEuclidean'];
function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {
  var impl;

  if (fn(method)) {
    impl = method;
  } else {
    impl = distances[method] || distances.euclidean;
  }

  if (length === 0 && fn(method)) {
    return impl(nodeP, nodeQ);
  } else {
    return impl(length, getP, getQ, nodeP, nodeQ);
  }
}

var defaults$5 = defaults({
  k: 2,
  m: 2,
  sensitivityThreshold: 0.0001,
  distance: 'euclidean',
  maxIterations: 10,
  attributes: [],
  testMode: false,
  testCentroids: null
});

var setOptions$1 = function setOptions(options) {
  return defaults$5(options);
};
/* eslint-enable */


var getDist = function getDist(type, node, centroid, attributes, mode) {
  var noNodeP = mode !== 'kMedoids';
  var getP = noNodeP ? function (i) {
    return centroid[i];
  } : function (i) {
    return attributes[i](centroid);
  };

  var getQ = function getQ(i) {
    return attributes[i](node);
  };

  var nodeP = centroid;
  var nodeQ = node;
  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
};

var randomCentroids = function randomCentroids(nodes, k, attributes) {
  var ndim = attributes.length;
  var min = new Array(ndim);
  var max = new Array(ndim);
  var centroids = new Array(k);
  var centroid = null; // Find min, max values for each attribute dimension

  for (var i = 0; i < ndim; i++) {
    min[i] = nodes.min(attributes[i]).value;
    max[i] = nodes.max(attributes[i]).value;
  } // Build k centroids, each represented as an n-dim feature vector


  for (var c = 0; c < k; c++) {
    centroid = [];

    for (var _i = 0; _i < ndim; _i++) {
      centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
    }

    centroids[c] = centroid;
  }

  return centroids;
};

var classify = function classify(node, centroids, distance, attributes, type) {
  var min = Infinity;
  var index = 0;

  for (var i = 0; i < centroids.length; i++) {
    var dist = getDist(distance, node, centroids[i], attributes, type);

    if (dist < min) {
      min = dist;
      index = i;
    }
  }

  return index;
};

var buildCluster = function buildCluster(centroid, nodes, assignment) {
  var cluster = [];
  var node = null;

  for (var n = 0; n < nodes.length; n++) {
    node = nodes[n];

    if (assignment[node.id()] === centroid) {
      //console.log("Node " + node.id() + " is associated with medoid #: " + m);
      cluster.push(node);
    }
  }

  return cluster;
};

var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
  return Math.abs(v2 - v1) <= sensitivityThreshold;
};

var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
  for (var i = 0; i < v1.length; i++) {
    for (var j = 0; j < v1[i].length; j++) {
      var diff = Math.abs(v1[i][j] - v2[i][j]);

      if (diff > sensitivityThreshold) {
        return false;
      }
    }
  }

  return true;
};

var seenBefore = function seenBefore(node, medoids, n) {
  for (var i = 0; i < n; i++) {
    if (node === medoids[i]) return true;
  }

  return false;
};

var randomMedoids = function randomMedoids(nodes, k) {
  var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
  // so we need to check to see if we've already seen or chose this node before.

  if (nodes.length < 50) {
    // Randomly select k medoids from the n nodes
    for (var i = 0; i < k; i++) {
      var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
      // Instead choose a different random node.

      while (seenBefore(node, medoids, i)) {
        node = nodes[Math.floor(Math.random() * nodes.length)];
      }

      medoids[i] = node;
    }
  } else {
    // Relatively large data set, so pretty safe to not check and just select random nodes
    for (var _i2 = 0; _i2 < k; _i2++) {
      medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
    }
  }

  return medoids;
};

var findCost = function findCost(potentialNewMedoid, cluster, attributes) {
  var cost = 0;

  for (var n = 0; n < cluster.length; n++) {
    cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');
  }

  return cost;
};

var kMeans = function kMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.

  var opts = setOptions$1(options); // Begin k-means algorithm

  var clusters = new Array(opts.k);
  var assignment = {};
  var centroids; // Step 1: Initialize centroid positions

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    } else if (_typeof(opts.testCentroids) === 'object') {
      centroids = opts.testCentroids;
    } else {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    }
  } else {
    centroids = randomCentroids(nodes, opts.k, opts.attributes);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest centroid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');
    } // Step 3: For each of the k clusters, update its centroid


    isStillMoving = false;

    for (var c = 0; c < opts.k; c++) {
      // Get all nodes that belong to this cluster
      var cluster = buildCluster(c, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      } // Update centroids by calculating avg of all nodes within the cluster.


      var ndim = opts.attributes.length;
      var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]

      var newCentroid = new Array(ndim);
      var sum = new Array(ndim);

      for (var d = 0; d < ndim; d++) {
        sum[d] = 0.0;

        for (var i = 0; i < cluster.length; i++) {
          node = cluster[i];
          sum[d] += opts.attributes[d](node);
        }

        newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change

        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
          isStillMoving = true;
        }
      }

      centroids[c] = newCentroid;
      clusters[c] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var kMedoids = function kMedoids(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null;
  var opts = setOptions$1(options); // Begin k-medoids algorithm

  var clusters = new Array(opts.k);
  var medoids;
  var assignment = {};
  var curCost;
  var minCosts = new Array(opts.k); // minimum cost configuration for each cluster
  // Step 1: Initialize k medoids

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {
      medoids = opts.testCentroids;
    } else {
      medoids = randomMedoids(nodes, opts.k);
    }
  } else {
    medoids = randomMedoids(nodes, opts.k);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest medoid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');
    }

    isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
    // select the node with the lowest configuration cost as new medoid.

    for (var m = 0; m < medoids.length; m++) {
      // Get all nodes that belong to this medoid
      var cluster = buildCluster(m, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      }

      minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost
      // Select different medoid if its configuration has the lowest cost

      for (var _n = 0; _n < cluster.length; _n++) {
        curCost = findCost(cluster[_n], cluster, opts.attributes);

        if (curCost < minCosts[m]) {
          minCosts[m] = curCost;
          medoids[m] = cluster[_n];
          isStillMoving = true;
        }
      }

      clusters[m] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
  var numerator, denominator;

  for (var n = 0; n < nodes.length; n++) {
    for (var c = 0; c < centroids.length; c++) {
      weight[n][c] = Math.pow(U[n][c], opts.m);
    }
  }

  for (var _c = 0; _c < centroids.length; _c++) {
    for (var dim = 0; dim < opts.attributes.length; dim++) {
      numerator = 0;
      denominator = 0;

      for (var _n2 = 0; _n2 < nodes.length; _n2++) {
        numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
        denominator += weight[_n2][_c];
      }

      centroids[_c][dim] = numerator / denominator;
    }
  }
};

var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
  // Save previous step
  for (var i = 0; i < U.length; i++) {
    _U[i] = U[i].slice();
  }

  var sum, numerator, denominator;
  var pow = 2 / (opts.m - 1);

  for (var c = 0; c < centroids.length; c++) {
    for (var n = 0; n < nodes.length; n++) {
      sum = 0;

      for (var k = 0; k < centroids.length; k++) {
        // against all other centroids
        numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');
        denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');
        sum += Math.pow(numerator / denominator, pow);
      }

      U[n][c] = 1 / sum;
    }
  }
};

var assign$1 = function assign(nodes, U, opts, cy) {
  var clusters = new Array(opts.k);

  for (var c = 0; c < clusters.length; c++) {
    clusters[c] = [];
  }

  var max;
  var index;

  for (var n = 0; n < U.length; n++) {
    // for each node (U is N x C matrix)
    max = -Infinity;
    index = -1; // Determine which cluster the node is most likely to belong in

    for (var _c2 = 0; _c2 < U[0].length; _c2++) {
      if (U[n][_c2] > max) {
        max = U[n][_c2];
        index = _c2;
      }
    }

    clusters[index].push(nodes[n]);
  } // Turn every array into a collection of nodes


  for (var _c3 = 0; _c3 < clusters.length; _c3++) {
    clusters[_c3] = cy.collection(clusters[_c3]);
  }

  return clusters;
};

var fuzzyCMeans = function fuzzyCMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$1(options); // Begin fuzzy c-means algorithm

  var clusters;
  var centroids;
  var U;

  var _U;

  var weight; // Step 1: Initialize letiables.

  _U = new Array(nodes.length);

  for (var i = 0; i < nodes.length; i++) {
    // N x C matrix
    _U[i] = new Array(opts.k);
  }

  U = new Array(nodes.length);

  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // N x C matrix
    U[_i3] = new Array(opts.k);
  }

  for (var _i4 = 0; _i4 < nodes.length; _i4++) {
    var total = 0;

    for (var j = 0; j < opts.k; j++) {
      U[_i4][j] = Math.random();
      total += U[_i4][j];
    }

    for (var _j = 0; _j < opts.k; _j++) {
      U[_i4][_j] = U[_i4][_j] / total;
    }
  }

  centroids = new Array(opts.k);

  for (var _i5 = 0; _i5 < opts.k; _i5++) {
    centroids[_i5] = new Array(opts.attributes.length);
  }

  weight = new Array(nodes.length);

  for (var _i6 = 0; _i6 < nodes.length; _i6++) {
    // N x C matrix
    weight[_i6] = new Array(opts.k);
  } // end init FCM


  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 2: Calculate the centroids for each step.

    updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.

    updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.

    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
      isStillMoving = true;
    }

    iterations++;
  } // Assign nodes to clusters with highest probability.


  clusters = assign$1(nodes, U, opts, cy);
  return {
    clusters: clusters,
    degreeOfMembership: U
  };
};

var kClustering = {
  kMeans: kMeans,
  kMedoids: kMedoids,
  fuzzyCMeans: fuzzyCMeans,
  fcm: fuzzyCMeans
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$6 = defaults({
  distance: 'euclidean',
  // distance metric to compare nodes
  linkage: 'min',
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: 'threshold',
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: Infinity,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: false,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: [] // array of attr functions

});
var linkageAliases = {
  'single': 'min',
  'complete': 'max'
};

var setOptions$2 = function setOptions(options) {
  var opts = defaults$6(options);
  var preferredAlias = linkageAliases[opts.linkage];

  if (preferredAlias != null) {
    opts.linkage = preferredAlias;
  }

  return opts;
};

var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
  // Find two closest clusters from cached mins
  var minKey = 0;
  var min = Infinity;
  var dist;
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  };

  for (var i = 0; i < clusters.length; i++) {
    var key = clusters[i].key;
    var _dist = dists[key][mins[key]];

    if (_dist < min) {
      minKey = key;
      min = _dist;
    }
  }

  if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {
    return false;
  }

  var c1 = index[minKey];
  var c2 = index[mins[minKey]];
  var merged; // Merge two closest clusters

  if (opts.mode === 'dendrogram') {
    merged = {
      left: c1,
      right: c2,
      key: c1.key
    };
  } else {
    merged = {
      value: c1.value.concat(c2.value),
      key: c1.key
    };
  }

  clusters[c1.index] = merged;
  clusters.splice(c2.index, 1);
  index[c1.key] = merged; // Update distances with new merged cluster

  for (var _i = 0; _i < clusters.length; _i++) {
    var cur = clusters[_i];

    if (c1.key === cur.key) {
      dist = Infinity;
    } else if (opts.linkage === 'min') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'max') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'mean') {
      dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
    } else {
      if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);
    }

    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
  } // Update cached mins


  for (var _i2 = 0; _i2 < clusters.length; _i2++) {
    var key1 = clusters[_i2].key;

    if (mins[key1] === c1.key || mins[key1] === c2.key) {
      var _min = key1;

      for (var j = 0; j < clusters.length; j++) {
        var key2 = clusters[j].key;

        if (dists[key1][key2] < dists[key1][_min]) {
          _min = key2;
        }
      }

      mins[key1] = _min;
    }

    clusters[_i2].index = _i2;
  } // Clean up meta data used for clustering


  c1.key = c2.key = c1.index = c2.index = null;
  return true;
};

var getAllChildren = function getAllChildren(root, arr, cy) {
  if (!root) return;

  if (root.value) {
    arr.push(root.value);
  } else {
    if (root.left) getAllChildren(root.left, arr);
    if (root.right) getAllChildren(root.right, arr);
  }
};

var buildDendrogram = function buildDendrogram(root, cy) {
  if (!root) return '';

  if (root.left && root.right) {
    var leftStr = buildDendrogram(root.left, cy);
    var rightStr = buildDendrogram(root.right, cy);
    var node = cy.add({
      group: 'nodes',
      data: {
        id: leftStr + ',' + rightStr
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: leftStr,
        target: node.id()
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: rightStr,
        target: node.id()
      }
    });
    return node.id();
  } else if (root.value) {
    return root.value.id();
  }
};

var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
  if (!root) return [];
  var left = [],
      right = [],
      leaves = [];

  if (k === 0) {
    // don't cut tree, simply return all nodes as 1 single cluster
    if (root.left) getAllChildren(root.left, left);
    if (root.right) getAllChildren(root.right, right);
    leaves = left.concat(right);
    return [cy.collection(leaves)];
  } else if (k === 1) {
    // cut at root
    if (root.value) {
      // leaf node
      return [cy.collection(root.value)];
    } else {
      if (root.left) getAllChildren(root.left, left);
      if (root.right) getAllChildren(root.right, right);
      return [cy.collection(left), cy.collection(right)];
    }
  } else {
    if (root.value) {
      return [cy.collection(root.value)];
    } else {
      if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
      if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
      return left.concat(right);
    }
  }
};
/* eslint-enable */


var hierarchicalClustering = function hierarchicalClustering(options) {
  var cy = this.cy();
  var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.

  var opts = setOptions$2(options);
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  }; // Begin hierarchical algorithm


  var clusters = [];
  var dists = []; // distances between each pair of clusters

  var mins = []; // closest cluster for each cluster

  var index = []; // hash of all clusters by key
  // In agglomerative (bottom-up) clustering, each node starts as its own cluster

  for (var n = 0; n < nodes.length; n++) {
    var cluster = {
      value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],
      key: n,
      index: n
    };
    clusters[n] = cluster;
    index[n] = cluster;
    dists[n] = [];
    mins[n] = 0;
  } // Calculate the distance between each pair of clusters


  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j <= i; j++) {
      var dist = void 0;

      if (opts.mode === 'dendrogram') {
        // modes store cluster values differently
        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
      } else {
        dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
      }

      dists[i][j] = dist;
      dists[j][i] = dist;

      if (dist < dists[i][mins[i]]) {
        mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
      }
    }
  } // Find the closest pair of clusters and merge them into a single cluster.
  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.


  var merged = mergeClosest(clusters, index, dists, mins, opts);

  while (merged) {
    merged = mergeClosest(clusters, index, dists, mins, opts);
  }

  var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
  // in addition to returning the clusters.

  if (opts.mode === 'dendrogram') {
    retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
    if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
  } else {
    // Regular mode simply returns the clusters
    retClusters = new Array(clusters.length);
    clusters.forEach(function (cluster, i) {
      // Clean up meta data used for clustering
      cluster.key = cluster.index = null;
      retClusters[i] = cy.collection(cluster.value);
    });
  }

  return retClusters;
};

var hierarchicalClustering$1 = {
  hierarchicalClustering: hierarchicalClustering,
  hca: hierarchicalClustering
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$7 = defaults({
  distance: 'euclidean',
  // distance metric to compare attributes between two nodes
  preference: 'median',
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1000,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [// functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
});

var setOptions$3 = function setOptions(options) {
  var dmp = options.damping;
  var pref = options.preference;

  if (!(0.5 <= dmp && dmp < 1)) {
    error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
  }

  var validPrefs = ['median', 'mean', 'min', 'max'];

  if (!(validPrefs.some(function (v) {
    return v === pref;
  }) || number(pref))) {
    error("Preference must be one of [".concat(validPrefs.map(function (p) {
      return "'".concat(p, "'");
    }).join(', '), "] or a number.  Got: ").concat(pref));
  }

  return defaults$7(options);
};
/* eslint-enable */


var getSimilarity$1 = function getSimilarity(type, n1, n2, attributes) {
  var attr = function attr(n, i) {
    return attributes[i](n);
  }; // nb negative because similarity should have an inverse relationship to distance


  return -clusteringDistance(type, attributes.length, function (i) {
    return attr(n1, i);
  }, function (i) {
    return attr(n2, i);
  }, n1, n2);
};

var getPreference = function getPreference(S, preference) {
  // larger preference = greater # of clusters
  var p = null;

  if (preference === 'median') {
    p = median(S);
  } else if (preference === 'mean') {
    p = mean(S);
  } else if (preference === 'min') {
    p = min(S);
  } else if (preference === 'max') {
    p = max(S);
  } else {
    // Custom preference number, as set by user
    p = preference;
  }

  return p;
};

var findExemplars = function findExemplars(n, R, A) {
  var indices = [];

  for (var i = 0; i < n; i++) {
    if (R[i * n + i] + A[i * n + i] > 0) {
      indices.push(i);
    }
  }

  return indices;
};

var assignClusters = function assignClusters(n, S, exemplars) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var index = -1;
    var max = -Infinity;

    for (var ei = 0; ei < exemplars.length; ei++) {
      var e = exemplars[ei];

      if (S[i * n + e] > max) {
        index = e;
        max = S[i * n + e];
      }
    }

    if (index > 0) {
      clusters.push(index);
    }
  }

  for (var _ei = 0; _ei < exemplars.length; _ei++) {
    clusters[exemplars[_ei]] = exemplars[_ei];
  }

  return clusters;
};

var assign$2 = function assign(n, S, exemplars) {
  var clusters = assignClusters(n, S, exemplars);

  for (var ei = 0; ei < exemplars.length; ei++) {
    var ii = [];

    for (var c = 0; c < clusters.length; c++) {
      if (clusters[c] === exemplars[ei]) {
        ii.push(c);
      }
    }

    var maxI = -1;
    var maxSum = -Infinity;

    for (var i = 0; i < ii.length; i++) {
      var sum = 0;

      for (var j = 0; j < ii.length; j++) {
        sum += S[ii[j] * n + ii[i]];
      }

      if (sum > maxSum) {
        maxI = i;
        maxSum = sum;
      }
    }

    exemplars[ei] = ii[maxI];
  }

  clusters = assignClusters(n, S, exemplars);
  return clusters;
};

var affinityPropagation = function affinityPropagation(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$3(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Begin affinity propagation algorithm


  var n; // number of data points

  var n2; // size of matrices

  var S; // similarity matrix (1D array)

  var p; // preference/suitability of a data point to serve as an exemplar

  var R; // responsibility matrix (1D array)

  var A; // availability matrix (1D array)

  n = nodes.length;
  n2 = n * n; // Initialize and build S similarity matrix

  S = new Array(n2);

  for (var _i = 0; _i < n2; _i++) {
    S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
  }

  for (var _i2 = 0; _i2 < n; _i2++) {
    for (var j = 0; j < n; j++) {
      if (_i2 !== j) {
        S[_i2 * n + j] = getSimilarity$1(opts.distance, nodes[_i2], nodes[j], opts.attributes);
      }
    }
  } // Place preferences on the diagonal of S


  p = getPreference(S, opts.preference);

  for (var _i3 = 0; _i3 < n; _i3++) {
    S[_i3 * n + _i3] = p;
  } // Initialize R responsibility matrix


  R = new Array(n2);

  for (var _i4 = 0; _i4 < n2; _i4++) {
    R[_i4] = 0.0;
  } // Initialize A availability matrix


  A = new Array(n2);

  for (var _i5 = 0; _i5 < n2; _i5++) {
    A[_i5] = 0.0;
  }

  var old = new Array(n);
  var Rp = new Array(n);
  var se = new Array(n);

  for (var _i6 = 0; _i6 < n; _i6++) {
    old[_i6] = 0.0;
    Rp[_i6] = 0.0;
    se[_i6] = 0;
  }

  var e = new Array(n * opts.minIterations);

  for (var _i7 = 0; _i7 < e.length; _i7++) {
    e[_i7] = 0;
  }

  var iter;

  for (iter = 0; iter < opts.maxIterations; iter++) {
    // main algorithmic loop
    // Update R responsibility matrix
    for (var _i8 = 0; _i8 < n; _i8++) {
      var max = -Infinity,
          max2 = -Infinity,
          maxI = -1,
          AS = 0.0;

      for (var _j = 0; _j < n; _j++) {
        old[_j] = R[_i8 * n + _j];
        AS = A[_i8 * n + _j] + S[_i8 * n + _j];

        if (AS >= max) {
          max2 = max;
          max = AS;
          maxI = _j;
        } else if (AS > max2) {
          max2 = AS;
        }
      }

      for (var _j2 = 0; _j2 < n; _j2++) {
        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
      }

      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
    } // Update A availability matrix


    for (var _i9 = 0; _i9 < n; _i9++) {
      var sum = 0;

      for (var _j3 = 0; _j3 < n; _j3++) {
        old[_j3] = A[_j3 * n + _i9];
        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
        sum += Rp[_j3];
      }

      sum -= Rp[_i9];
      Rp[_i9] = R[_i9 * n + _i9];
      sum += Rp[_i9];

      for (var _j4 = 0; _j4 < n; _j4++) {
        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
      }

      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
    } // Check for convergence


    var K = 0;

    for (var _i10 = 0; _i10 < n; _i10++) {
      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
      e[iter % opts.minIterations * n + _i10] = E;
      K += E;
    }

    if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
      var _sum = 0;

      for (var _i11 = 0; _i11 < n; _i11++) {
        se[_i11] = 0;

        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
          se[_i11] += e[_j5 * n + _i11];
        }

        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
          _sum++;
        }
      }

      if (_sum === n) {
        // then we have convergence
        break;
      }
    }
  } // Identify exemplars (cluster centers)


  var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters

  var clusterIndices = assign$2(n, S, exemplarsIndices);
  var clusters = {};

  for (var c = 0; c < exemplarsIndices.length; c++) {
    clusters[exemplarsIndices[c]] = [];
  }

  for (var _i12 = 0; _i12 < nodes.length; _i12++) {
    var pos = id2position[nodes[_i12].id()];

    var clusterIndex = clusterIndices[pos];

    if (clusterIndex != null) {
      // the node may have not been assigned a cluster if no valid attributes were specified
      clusters[clusterIndex].push(nodes[_i12]);
    }
  }

  var retClusters = new Array(exemplarsIndices.length);

  for (var _c = 0; _c < exemplarsIndices.length; _c++) {
    retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
  }

  return retClusters;
};

var affinityPropagation$1 = {
  affinityPropagation: affinityPropagation,
  ap: affinityPropagation
};

var hierholzerDefaults = defaults({
  root: undefined,
  directed: false
});
var elesfn$b = {
  hierholzer: function hierholzer(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        directed: args[1]
      };
    }

    var _hierholzerDefaults = hierholzerDefaults(options),
        root = _hierholzerDefaults.root,
        directed = _hierholzerDefaults.directed;

    var eles = this;
    var dflag = false;
    var oddIn;
    var oddOut;
    var startVertex;
    if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
    var nodes = {};
    var edges = {};

    if (directed) {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var ind = ele.indegree(true);
          var outd = ele.outdegree(true);
          var d1 = ind - outd;
          var d2 = outd - ind;

          if (d1 == 1) {
            if (oddIn) dflag = true;else oddIn = id;
          } else if (d2 == 1) {
            if (oddOut) dflag = true;else oddOut = id;
          } else if (d2 > 1 || d1 > 1) {
            dflag = true;
          }

          nodes[id] = [];
          ele.outgoers().forEach(function (e) {
            if (e.isEdge()) nodes[id].push(e.id());
          });
        } else {
          edges[id] = [undefined, ele.target().id()];
        }
      });
    } else {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var d = ele.degree(true);

          if (d % 2) {
            if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;
          }

          nodes[id] = [];
          ele.connectedEdges().forEach(function (e) {
            return nodes[id].push(e.id());
          });
        } else {
          edges[id] = [ele.source().id(), ele.target().id()];
        }
      });
    }

    var result = {
      found: false,
      trail: undefined
    };
    if (dflag) return result;else if (oddOut && oddIn) {
      if (directed) {
        if (startVertex && oddOut != startVertex) {
          return result;
        }

        startVertex = oddOut;
      } else {
        if (startVertex && oddOut != startVertex && oddIn != startVertex) {
          return result;
        } else if (!startVertex) {
          startVertex = oddOut;
        }
      }
    } else {
      if (!startVertex) startVertex = eles[0].id();
    }

    var walk = function walk(v) {
      var currentNode = v;
      var subtour = [v];
      var adj, adjTail, adjHead;

      while (nodes[currentNode].length) {
        adj = nodes[currentNode].shift();
        adjTail = edges[adj][0];
        adjHead = edges[adj][1];

        if (currentNode != adjHead) {
          nodes[adjHead] = nodes[adjHead].filter(function (e) {
            return e != adj;
          });
          currentNode = adjHead;
        } else if (!directed && currentNode != adjTail) {
          nodes[adjTail] = nodes[adjTail].filter(function (e) {
            return e != adj;
          });
          currentNode = adjTail;
        }

        subtour.unshift(adj);
        subtour.unshift(currentNode);
      }

      return subtour;
    };

    var trail = [];
    var subtour = [];
    subtour = walk(startVertex);

    while (subtour.length != 1) {
      if (nodes[subtour[0]].length == 0) {
        trail.unshift(eles.getElementById(subtour.shift()));
        trail.unshift(eles.getElementById(subtour.shift()));
      } else {
        subtour = walk(subtour.shift()).concat(subtour);
      }
    }

    trail.unshift(eles.getElementById(subtour.shift())); // final node

    for (var d in nodes) {
      if (nodes[d].length) {
        return result;
      }
    }

    result.found = true;
    result.trail = this.spawn(trail);
    return result;
  }
};

var elesfn$c = {};
[elesfn, elesfn$1, elesfn$2, elesfn$3, elesfn$4, elesfn$5, elesfn$6, elesfn$7, elesfn$8, elesfn$9, elesfn$a, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$b].forEach(function (props) {
  extend(elesfn$c, props);
});

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING = 0;
/*  [Promises/A+ 2.1.1]  */

var STATE_FULFILLED = 1;
/*  [Promises/A+ 2.1.2]  */

var STATE_REJECTED = 2;
/*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */

var api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api)) return new api(executor);
  /*  initialize object  */

  this.id = 'Thenable/1.0.7';
  this.state = STATE_PENDING;
  /*  initial state  */

  this.fulfillValue = undefined;
  /*  initial value  */

  /*  [Promises/A+ 1.3, 2.1.2.2]  */

  this.rejectReason = undefined;
  /*  initial reason */

  /*  [Promises/A+ 1.5, 2.1.3.2]  */

  this.onFulfilled = [];
  /*  initial handlers  */

  this.onRejected = [];
  /*  initial handlers  */

  /*  provide optional information-hiding proxy  */

  this.proxy = {
    then: this.then.bind(this)
  };
  /*  support optional executor function  */

  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
/*  promise API methods  */


api.prototype = {
  /*  promise resolving methods  */
  fulfill: function fulfill(value) {
    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
  },
  reject: function reject(value) {
    return deliver(this, STATE_REJECTED, 'rejectReason', value);
  },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function then(onFulfilled, onRejected) {
    var curr = this;
    var next = new api();
    /*  [Promises/A+ 2.2.7]  */

    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));
    /*  [Promises/A+ 2.2.2/2.2.6]  */

    curr.onRejected.push(resolver(onRejected, next, 'reject'));
    /*  [Promises/A+ 2.2.3/2.2.6]  */

    execute(curr);
    return next.proxy;
    /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};
/*  deliver an action  */

var deliver = function deliver(curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state;
    /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */

    curr[name] = value;
    /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */

    execute(curr);
  }

  return curr;
};
/*  execute all handlers  */


var execute = function execute(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
};
/*  execute particular set of handlers  */


var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */

  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0) return;
  /*  iterate over all handlers, exactly once  */

  var handlers = curr[name];
  curr[name] = [];
  /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */

  var func = function func() {
    for (var i = 0; i < handlers.length; i++) {
      handlers[i](value);
    }
    /*  [Promises/A+ 2.2.5]  */

  };
  /*  execute procedure asynchronously  */

  /*  [Promises/A+ 2.2.4, 3.1]  */


  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
};
/*  generate a resolver function  */


var resolver = function resolver(cb, next, method) {
  return function (value) {
    if (typeof cb !== 'function')
      /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value);
      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
        var result;

        try {
          result = cb(value);
        }
        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);
          /*  [Promises/A+ 2.2.7.2]  */

          return;
        }

        resolve(next, result);
        /*  [Promises/A+ 2.2.7.1]  */
      }
  };
};
/*  "Promise Resolution Procedure"  */

/*  [Promises/A+ 2.3]  */


var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */

  /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError('cannot resolve promise with itself'));
    return;
  }
  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */


  var then;

  if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {
    try {
      then = x.then;
    }
    /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e);
      /*  [Promises/A+ 2.3.3.2]  */

      return;
    }
  }
  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */


  if (typeof then === 'function') {
    var resolved = false;

    try {
      /*  call retrieved "then" method */

      /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
      /*  resolvePromise  */

      /*  [Promises/A+ 2.3.3.3.1]  */
      function (y) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        if (y === x)
          /*  [Promises/A+ 3.6]  */
          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
      },
      /*  rejectPromise  */

      /*  [Promises/A+ 2.3.3.3.2]  */
      function (r) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        promise.reject(r);
      });
    } catch (e) {
      if (!resolved)
        /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e);
      /*  [Promises/A+ 2.3.3.3.4]  */
    }

    return;
  }
  /*  handle other values  */


  promise.fulfill(x);
  /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
}; // so we always have Promise.all()


api.all = function (ps) {
  return new api(function (resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;

    var fulfill = function fulfill(i, val) {
      vals[i] = val;
      doneCount++;

      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    };

    for (var i = 0; i < ps.length; i++) {
      (function (i) {
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if (isPromise) {
          p.then(function (val) {
            fulfill(i, val);
          }, function (err) {
            rejectAll(err);
          });
        } else {
          var val = p;
          fulfill(i, val);
        }
      })(i);
    }
  });
};

api.resolve = function (val) {
  return new api(function (resolve, reject) {
    resolve(val);
  });
};

api.reject = function (val) {
  return new api(function (resolve, reject) {
    reject(val);
  });
};

var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

var Animation = function Animation(target, opts, opts2) {
  var isCore = core(target);
  var isEle = !isCore;

  var _p = this._private = extend({
    duration: 1000
  }, opts, opts2);

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if (_p.complete && fn(_p.complete)) {
    _p.completes.push(_p.complete);
  }

  if (isEle) {
    var pos = target.position();
    _p.startPosition = _p.startPosition || {
      x: pos.x,
      y: pos.y
    };
    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
  }

  if (isCore) {
    var pan = target.pan();
    _p.startPan = {
      x: pan.x,
      y: pan.y
    };
    _p.startZoom = target.zoom();
  } // for future timeline/animations impl


  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;
extend(anifn, {
  instanceString: function instanceString() {
    return 'animation';
  },
  hook: function hook() {
    var _p = this._private;

    if (!_p.hooked) {
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;

      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }

      q.push(this); // add to the animation loop pool

      if (elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }

      _p.hooked = true;
    }

    return this;
  },
  play: function play() {
    var _p = this._private; // autorewind

    if (_p.progress === 1) {
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will start the animation...

    return this;
  },
  playing: function playing() {
    return this._private.playing;
  },
  apply: function apply() {
    var _p = this._private;
    _p.applying = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will apply the animation at this progress

    return this;
  },
  applying: function applying() {
    return this._private.applying;
  },
  pause: function pause() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    return this;
  },
  stop: function stop() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },
  rewind: function rewind() {
    return this.progress(0);
  },
  fastforward: function fastforward() {
    return this.progress(1);
  },
  time: function time(t) {
    var _p = this._private;

    if (t === undefined) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  },
  progress: function progress(p) {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (p === undefined) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if (wasPlaying) {
        this.play();
      }
    }

    return this;
  },
  completed: function completed() {
    return this._private.progress === 1;
  },
  reverse: function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (wasPlaying) {
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function swap(a, b) {
      var _pa = _p[a];

      if (_pa == null) {
        return;
      }

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap('zoom', 'startZoom');
    swap('pan', 'startPan');
    swap('position', 'startPosition'); // swap styles

    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop = _p.style[i];
        var name = prop.name;
        var startStyleProp = _p.startStyle[name];
        _p.startStyle[name] = prop;
        _p.style[i] = startStyleProp;
      }
    }

    if (wasPlaying) {
      this.play();
    }

    return this;
  },
  promise: function promise(type) {
    var _p = this._private;
    var arr;

    switch (type) {
      case 'frame':
        arr = _p.frames;
        break;

      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise$1(function (resolve, reject) {
      arr.push(function () {
        resolve();
      });
    });
  }
});
anifn.complete = anifn.completed;
anifn.run = anifn.play;
anifn.running = anifn.playing;

var define = {
  animated: function animated() {
    return function animatedImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return false;
      }

      var ele = all[0];

      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    };
  },
  // animated
  clearQueue: function clearQueue() {
    return function clearQueueImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  },
  // clearQueue
  delay: function delay() {
    return function delayImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  delayAnimation: function delayAnimation() {
    return function delayAnimationImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  animation: function animation() {
    return function animationImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if (!cy.styleEnabled()) {
        return this;
      }

      var style = cy.style();
      properties = extend({}, properties, params);
      var propertiesEmpty = Object.keys(properties).length === 0;

      if (propertiesEmpty) {
        return new Animation(all[0], properties); // nothing to animate
      }

      if (properties.duration === undefined) {
        properties.duration = 400;
      }

      switch (properties.duration) {
        case 'slow':
          properties.duration = 600;
          break;

        case 'fast':
          properties.duration = 200;
          break;
      }

      if (isEles) {
        properties.style = style.getPropsList(properties.style || properties.css);
        properties.css = undefined;
      }

      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();
        properties.position = renderedToModelPosition(rpos, zoom, pan);
      } // override pan w/ panBy if set


      if (isCore && properties.panBy != null) {
        var panBy = properties.panBy;
        var cyPan = cy.pan();
        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      } // override pan w/ center if set


      var center = properties.center || properties.centre;

      if (isCore && center != null) {
        var centerPan = cy.getCenterPan(center.eles, properties.zoom);

        if (centerPan != null) {
          properties.pan = centerPan;
        }
      } // override pan & zoom w/ fit if set


      if (isCore && properties.fit != null) {
        var fit = properties.fit;
        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      } // override zoom (& potentially pan) w/ zoom obj if set


      if (isCore && plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);

        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }

          if (vp.panned) {
            properties.pan = vp.pan;
          }
        }
      }

      return new Animation(all[0], properties);
    };
  },
  // animate
  animate: function animate() {
    return function animateImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      if (params) {
        properties = extend({}, properties, params);
      } // manually hook and run the animation


      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);
        var ani = ele.animation(properties, queue ? {
          queue: true
        } : undefined);
        ani.play();
      }

      return this; // chaining
    };
  },
  // animate
  stop: function stop() {
    return function stopImpl(clearQueue, jumpToEnd) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;

          if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        } // clear the queue of future animations


        if (clearQueue) {
          _p.animation.queue = [];
        }

        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      } // we have to notify (the animation loop doesn't do it for us on `stop`)


      cy.notify('draw');
      return this;
    };
  } // stop

}; // define

var define$1 = {
  // access data field
  data: function data(params) {
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {},
      // key => true if immutable
      updateStyle: false,
      beforeGet: function beforeGet(self) {},
      beforeSet: function beforeSet(self, obj) {},
      onSet: function onSet(self) {},
      canSet: function canSet(self) {
        return true;
      }
    };
    params = extend({}, defaults, params);
    return function dataImpl(name, value) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)

      if (string(name)) {
        // set or get property
        // .data('foo')
        if (p.allowGetting && value === undefined) {
          // get
          var ret;

          if (single) {
            p.beforeGet(single);
            ret = single._private[p.field][name];
          }

          return ret; // .data('foo', 'bar')
        } else if (p.allowSetting && value !== undefined) {
          // set
          var valid = !p.immutableKeys[name];

          if (valid) {
            var change = _defineProperty({}, name, value);

            p.beforeSet(self, change);

            for (var i = 0, l = all.length; i < l; i++) {
              var ele = all[i];

              if (p.canSet(ele)) {
                ele._private[p.field][name] = value;
              }
            } // update mappers if asked


            if (p.updateStyle) {
              self.updateStyle();
            } // call onSet callback


            p.onSet(self);

            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            }
          }
        } // .data({ 'foo': 'bar' })

      } else if (p.allowSetting && plainObject(name)) {
        // extend
        var obj = name;
        var k, v;
        var keys = Object.keys(obj);
        p.beforeSet(self, obj);

        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];

          var _valid = !p.immutableKeys[k];

          if (_valid) {
            for (var j = 0; j < all.length; j++) {
              var _ele = all[j];

              if (p.canSet(_ele)) {
                _ele._private[p.field][k] = v;
              }
            }
          }
        } // update mappers if asked


        if (p.updateStyle) {
          self.updateStyle();
        } // call onSet callback


        p.onSet(self);

        if (p.settingTriggersEvent) {
          self[p.triggerFnName](p.settingEvent);
        } // .data(function(){ ... })

      } else if (p.allowBinding && fn(name)) {
        // bind to event
        var fn$1 = name;
        self.on(p.bindingEvent, fn$1); // .data()
      } else if (p.allowGetting && name === undefined) {
        // get whole object
        var _ret;

        if (single) {
          p.beforeGet(single);
          _ret = single._private[p.field];
        }

        return _ret;
      }

      return self; // maintain chainability
    }; // function
  },
  // data
  // remove data field
  removeData: function removeData(params) {
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable

    };
    params = extend({}, defaults, params);
    return function removeDataImpl(names) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      // .removeData('foo bar')

      if (string(names)) {
        // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for (var i = 0; i < l; i++) {
          // delete each non-empty key
          var key = keys[i];

          if (emptyString(key)) {
            continue;
          }

          var valid = !p.immutableKeys[key]; // not valid if immutable

          if (valid) {
            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
              all[i_a]._private[p.field][key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        } // .removeData()

      } else if (names === undefined) {
        // then delete all keys
        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all[_i_a]._private[p.field];

          var _keys = Object.keys(_privateFields);

          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p.immutableKeys[_key];

            if (validKeyToDelete) {
              _privateFields[_key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }
      }

      return self; // maintain chaining
    }; // function
  } // removeData

}; // define

var define$2 = {
  eventAliasesOn: function eventAliasesOn(proto) {
    var p = proto;
    p.addListener = p.listen = p.bind = p.on;
    p.unlisten = p.unbind = p.off = p.removeListener;
    p.trigger = p.emit; // this is just a wrapper alias of .on()

    p.pon = p.promiseOn = function (events, selector) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      return new Promise$1(function (resolve, reject) {
        var callback = function callback(e) {
          self.off.apply(self, offArgs);
          resolve(e);
        };

        var onArgs = args.concat([callback]);
        var offArgs = onArgs.concat([]);
        self.on.apply(self, onArgs);
      });
    };
  }
}; // define

// use this module to cherry pick functions into your prototype
var define$3 = {};
[define, define$1, define$2].forEach(function (m) {
  extend(define$3, m);
});

var elesfn$d = {
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop()
};

var elesfn$e = {
  classes: function classes(_classes) {
    var self = this;

    if (_classes === undefined) {
      var ret = [];

      self[0]._private.classes.forEach(function (cls) {
        return ret.push(cls);
      });

      return ret;
    } else if (!array(_classes)) {
      // extract classes from string
      _classes = (_classes || '').match(/\S+/g) || [];
    }

    var changed = [];
    var classesSet = new Set$1(_classes); // check and update each ele

    for (var j = 0; j < self.length; j++) {
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false; // check if ele has all of the passed classes

      for (var i = 0; i < _classes.length; i++) {
        var cls = _classes[i];
        var eleHasClass = eleClasses.has(cls);

        if (!eleHasClass) {
          changedEle = true;
          break;
        }
      } // check if ele has classes outside of those passed


      if (!changedEle) {
        changedEle = eleClasses.size !== _classes.length;
      }

      if (changedEle) {
        _p.classes = classesSet;
        changed.push(ele);
      }
    } // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  addClass: function addClass(classes) {
    return this.toggleClass(classes, true);
  },
  hasClass: function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  },
  toggleClass: function toggleClass(classes, toggle) {
    if (!array(classes)) {
      // extract classes from string
      classes = classes.match(/\S+/g) || [];
    }

    var self = this;
    var toggleUndefd = toggle === undefined;
    var changed = []; // eles who had classes changed

    for (var i = 0, il = self.length; i < il; i++) {
      var ele = self[i];
      var eleClasses = ele._private.classes;
      var changedEle = false;

      for (var j = 0; j < classes.length; j++) {
        var cls = classes[j];
        var hasClass = eleClasses.has(cls);
        var changedNow = false;

        if (toggle || toggleUndefd && !hasClass) {
          eleClasses.add(cls);
          changedNow = true;
        } else if (!toggle || toggleUndefd && hasClass) {
          eleClasses["delete"](cls);
          changedNow = true;
        }

        if (!changedEle && changedNow) {
          changed.push(ele);
          changedEle = true;
        }
      } // for j classes

    } // for i eles
    // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  removeClass: function removeClass(classes) {
    return this.toggleClass(classes, false);
  },
  flashClass: function flashClass(classes, duration) {
    var self = this;

    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self; // nothing to do really
    }

    self.addClass(classes);
    setTimeout(function () {
      self.removeClass(classes);
    }, duration);
    return self;
  }
};
elesfn$e.className = elesfn$e.classNames = elesfn$e.classes;

var tokens = {
  metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]',
  // chars we need to escape in let names, etc
  comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=',
  // binary comparison op (used in data selectors)
  boolOp: '\\?|\\!|\\^',
  // boolean (unary) operators (used in data selectors)
  string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'",
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: number$1,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: 'degree|indegree|outdegree',
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: '\\s*,\\s*',
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: '\\s+',
  child: '\\s+>\\s+',
  subject: '\\$',
  group: 'node|edge|\\*',
  directedEdge: '\\s+->\\s+',
  undirectedEdge: '\\s+<->\\s+'
};
tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name

tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number

tokens.className = tokens.variable; // a class name (follows variable conventions)

tokens.id = tokens.variable; // an element id (follows variable conventions)

(function () {
  var ops, op, i; // add @ variants to comparatorOp

  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += '|@' + op;
  } // add ! variants to comparatorOp


  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];

    if (op.indexOf('!') >= 0) {
      continue;
    } // skip ops that explicitly contain !


    if (op === '=') {
      continue;
    } // skip = b/c != is explicitly defined


    tokens.comparatorOp += '|\\!' + op;
  }
})();

/**
 * Make a new query object
 *
 * @prop type {Type} The type enum (int) of the query
 * @prop checks List of checks to make against an ele to test for a match
 */
var newQuery = function newQuery() {
  return {
    checks: []
  };
};

/**
 * A check type enum-like object.  Uses integer values for fast match() lookup.
 * The ordering does not matter as long as the ints are unique.
 */
var Type = {
  /** E.g. node */
  GROUP: 0,

  /** A collection of elements */
  COLLECTION: 1,

  /** A filter(ele) function */
  FILTER: 2,

  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,

  /** E.g. [foo] */
  DATA_EXIST: 4,

  /** E.g. [?foo] */
  DATA_BOOL: 5,

  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,

  /** E.g. :selected */
  STATE: 7,

  /** E.g. #foo */
  ID: 8,

  /** E.g. .foo */
  CLASS: 9,

  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,

  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,

  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,

  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,

  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,

  /** E.g. #foo > #bar */
  CHILD: 15,

  /** E.g. #foo #bar */
  DESCENDANT: 16,

  /** E.g. $#foo > #bar */
  PARENT: 17,

  /** E.g. $#foo #bar */
  ANCESTOR: 18,

  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,

  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
};

var stateSelectors = [{
  selector: ':selected',
  matches: function matches(ele) {
    return ele.selected();
  }
}, {
  selector: ':unselected',
  matches: function matches(ele) {
    return !ele.selected();
  }
}, {
  selector: ':selectable',
  matches: function matches(ele) {
    return ele.selectable();
  }
}, {
  selector: ':unselectable',
  matches: function matches(ele) {
    return !ele.selectable();
  }
}, {
  selector: ':locked',
  matches: function matches(ele) {
    return ele.locked();
  }
}, {
  selector: ':unlocked',
  matches: function matches(ele) {
    return !ele.locked();
  }
}, {
  selector: ':visible',
  matches: function matches(ele) {
    return ele.visible();
  }
}, {
  selector: ':hidden',
  matches: function matches(ele) {
    return !ele.visible();
  }
}, {
  selector: ':transparent',
  matches: function matches(ele) {
    return ele.transparent();
  }
}, {
  selector: ':grabbed',
  matches: function matches(ele) {
    return ele.grabbed();
  }
}, {
  selector: ':free',
  matches: function matches(ele) {
    return !ele.grabbed();
  }
}, {
  selector: ':removed',
  matches: function matches(ele) {
    return ele.removed();
  }
}, {
  selector: ':inside',
  matches: function matches(ele) {
    return !ele.removed();
  }
}, {
  selector: ':grabbable',
  matches: function matches(ele) {
    return ele.grabbable();
  }
}, {
  selector: ':ungrabbable',
  matches: function matches(ele) {
    return !ele.grabbable();
  }
}, {
  selector: ':animated',
  matches: function matches(ele) {
    return ele.animated();
  }
}, {
  selector: ':unanimated',
  matches: function matches(ele) {
    return !ele.animated();
  }
}, {
  selector: ':parent',
  matches: function matches(ele) {
    return ele.isParent();
  }
}, {
  selector: ':childless',
  matches: function matches(ele) {
    return ele.isChildless();
  }
}, {
  selector: ':child',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':orphan',
  matches: function matches(ele) {
    return ele.isOrphan();
  }
}, {
  selector: ':nonorphan',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':compound',
  matches: function matches(ele) {
    if (ele.isNode()) {
      return ele.isParent();
    } else {
      return ele.source().isParent() || ele.target().isParent();
    }
  }
}, {
  selector: ':loop',
  matches: function matches(ele) {
    return ele.isLoop();
  }
}, {
  selector: ':simple',
  matches: function matches(ele) {
    return ele.isSimple();
  }
}, {
  selector: ':active',
  matches: function matches(ele) {
    return ele.active();
  }
}, {
  selector: ':inactive',
  matches: function matches(ele) {
    return !ele.active();
  }
}, {
  selector: ':backgrounding',
  matches: function matches(ele) {
    return ele.backgrounding();
  }
}, {
  selector: ':nonbackgrounding',
  matches: function matches(ele) {
    return !ele.backgrounding();
  }
}].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
  return descending(a.selector, b.selector);
});

var lookup = function () {
  var selToFn = {};
  var s;

  for (var i = 0; i < stateSelectors.length; i++) {
    s = stateSelectors[i];
    selToFn[s.selector] = s.matches;
  }

  return selToFn;
}();

var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
  return lookup[sel](ele);
};
var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
  return s.selector;
}).join('|') + ')';

// so that values get compared properly in Selector.filter()

var cleanMetaChars = function cleanMetaChars(str) {
  return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
    return $1;
  });
};

var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
  selector[selector.length - 1] = replacementQuery;
}; // NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i]
// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward


var exprs = [{
  name: 'group',
  // just used for identifying when debugging
  query: true,
  regex: '(' + tokens.group + ')',
  populate: function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        group = _ref2[0];

    query.checks.push({
      type: Type.GROUP,
      value: group === '*' ? group : group + 's'
    });
  }
}, {
  name: 'state',
  query: true,
  regex: stateSelectorRegex,
  populate: function populate(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        state = _ref4[0];

    query.checks.push({
      type: Type.STATE,
      value: state
    });
  }
}, {
  name: 'id',
  query: true,
  regex: '\\#(' + tokens.id + ')',
  populate: function populate(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        id = _ref6[0];

    query.checks.push({
      type: Type.ID,
      value: cleanMetaChars(id)
    });
  }
}, {
  name: 'className',
  query: true,
  regex: '\\.(' + tokens.className + ')',
  populate: function populate(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        className = _ref8[0];

    query.checks.push({
      type: Type.CLASS,
      value: cleanMetaChars(className)
    });
  }
}, {
  name: 'dataExists',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        variable = _ref10[0];

    query.checks.push({
      type: Type.DATA_EXIST,
      field: cleanMetaChars(variable)
    });
  }
}, {
  name: 'dataCompare',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
  populate: function populate(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3),
        variable = _ref12[0],
        comparatorOp = _ref12[1],
        value = _ref12[2];

    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

    if (valueIsString) {
      value = value.substring(1, value.length - 1);
    } else {
      value = parseFloat(value);
    }

    query.checks.push({
      type: Type.DATA_COMPARE,
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value
    });
  }
}, {
  name: 'dataBool',
  query: true,
  regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        boolOp = _ref14[0],
        variable = _ref14[1];

    query.checks.push({
      type: Type.DATA_BOOL,
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }
}, {
  name: 'metaCompare',
  query: true,
  regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
  populate: function populate(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3),
        meta = _ref16[0],
        comparatorOp = _ref16[1],
        number = _ref16[2];

    query.checks.push({
      type: Type.META_COMPARE,
      field: cleanMetaChars(meta),
      operator: comparatorOp,
      value: parseFloat(number)
    });
  }
}, {
  name: 'nextQuery',
  separator: true,
  regex: tokens.separator,
  populate: function populate(selector, query) {
    var currentSubject = selector.currentSubject;
    var edgeCount = selector.edgeCount;
    var compoundCount = selector.compoundCount;
    var lastQ = selector[selector.length - 1];

    if (currentSubject != null) {
      lastQ.subject = currentSubject;
      selector.currentSubject = null;
    }

    lastQ.edgeCount = edgeCount;
    lastQ.compoundCount = compoundCount;
    selector.edgeCount = 0;
    selector.compoundCount = 0; // go on to next query

    var nextQuery = selector[selector.length++] = newQuery();
    return nextQuery; // this is the new query to be filled by the following exprs
  }
}, {
  name: 'directedEdge',
  separator: true,
  regex: tokens.directedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.DIRECTED_EDGE,
        source: source,
        target: target
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // source/target
      var srcTgtQ = newQuery();
      var _source = query;

      var _target = newQuery();

      srcTgtQ.checks.push({
        type: Type.NODE_SOURCE,
        source: _source,
        target: _target
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, srcTgtQ);
      selector.edgeCount++;
      return _target; // now populating the target with the following expressions
    }
  }
}, {
  name: 'undirectedEdge',
  separator: true,
  regex: tokens.undirectedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.UNDIRECTED_EDGE,
        nodes: [source, target]
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // neighbourhood
      var nhoodQ = newQuery();
      var node = query;
      var neighbor = newQuery();
      nhoodQ.checks.push({
        type: Type.NODE_NEIGHBOR,
        node: node,
        neighbor: neighbor
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, nhoodQ);
      return neighbor; // now populating the neighbor with following expressions
    }
  }
}, {
  name: 'child',
  separator: true,
  regex: tokens.child,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: child query
      var parentChildQuery = newQuery();
      var child = newQuery();
      var parent = selector[selector.length - 1];
      parentChildQuery.checks.push({
        type: Type.CHILD,
        parent: parent,
        child: child
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, parentChildQuery);
      selector.compoundCount++; // we're now populating the child query with expressions that follow

      return child;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _child = newQuery();

      var _parent = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _parent.checks.push({
        type: Type.TRUE
      }); // parent implicitly refs the subject


      right.checks.push({
        type: Type.PARENT,
        // type is swapped on right side queries
        parent: _parent,
        child: _child // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _child; // now populating the right side's child
    } else {
      // parent query
      // info for parent query
      var _parent2 = newQuery();

      var _child2 = newQuery();

      var pcQChecks = [{
        type: Type.PARENT,
        parent: _parent2,
        child: _child2
      }]; // the parent-child query takes the place of the query previously being populated

      _parent2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = pcQChecks; // pc query takes over

      selector.compoundCount++;
      return _child2; // we're now populating the child
    }
  }
}, {
  name: 'descendant',
  separator: true,
  regex: tokens.descendant,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: descendant query
      var ancChQuery = newQuery();
      var descendant = newQuery();
      var ancestor = selector[selector.length - 1];
      ancChQuery.checks.push({
        type: Type.DESCENDANT,
        ancestor: ancestor,
        descendant: descendant
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, ancChQuery);
      selector.compoundCount++; // we're now populating the descendant query with expressions that follow

      return descendant;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _descendant = newQuery();

      var _ancestor = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _ancestor.checks.push({
        type: Type.TRUE
      }); // ancestor implicitly refs the subject


      right.checks.push({
        type: Type.ANCESTOR,
        // type is swapped on right side queries
        ancestor: _ancestor,
        descendant: _descendant // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _descendant; // now populating the right side's descendant
    } else {
      // ancestor query
      // info for parent query
      var _ancestor2 = newQuery();

      var _descendant2 = newQuery();

      var adQChecks = [{
        type: Type.ANCESTOR,
        ancestor: _ancestor2,
        descendant: _descendant2
      }]; // the parent-child query takes the place of the query previously being populated

      _ancestor2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = adQChecks; // pc query takes over

      selector.compoundCount++;
      return _descendant2; // we're now populating the child
    }
  }
}, {
  name: 'subject',
  modifier: true,
  regex: tokens.subject,
  populate: function populate(selector, query) {
    if (selector.currentSubject != null && selector.currentSubject !== query) {
      warn('Redefinition of subject in selector `' + selector.toString() + '`');
      return false;
    }

    selector.currentSubject = query;
    var topQ = selector[selector.length - 1];
    var topChk = topQ.checks[0];
    var topType = topChk == null ? null : topChk.type;

    if (topType === Type.DIRECTED_EDGE) {
      // directed edge with subject on the target
      // change to target node check
      topChk.type = Type.NODE_TARGET;
    } else if (topType === Type.UNDIRECTED_EDGE) {
      // undirected edge with subject on the second node
      // change to neighbor check
      topChk.type = Type.NODE_NEIGHBOR;
      topChk.node = topChk.nodes[1]; // second node is subject

      topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type

      topChk.nodes = null;
    }
  }
}];
exprs.forEach(function (e) {
  return e.regexObj = new RegExp('^' + e.regex);
});

/**
 * Of all the expressions, find the first match in the remaining text.
 * @param {string} remaining The remaining text to parse
 * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
 */

var consumeExpr = function consumeExpr(remaining) {
  var expr;
  var match;
  var name;

  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;
    var m = remaining.match(e.regexObj);

    if (m != null) {
      match = m;
      expr = e;
      name = n;
      var consumed = m[0];
      remaining = remaining.substring(consumed.length);
      break; // we've consumed one expr, so we can return now
    }
  }

  return {
    expr: expr,
    match: match,
    name: name,
    remaining: remaining
  };
};
/**
 * Consume all the leading whitespace
 * @param {string} remaining The text to consume
 * @returns The text with the leading whitespace removed
 */


var consumeWhitespace = function consumeWhitespace(remaining) {
  var match = remaining.match(/^\s+/);

  if (match) {
    var consumed = match[0];
    remaining = remaining.substring(consumed.length);
  }

  return remaining;
};
/**
 * Parse the string and store the parsed representation in the Selector.
 * @param {string} selector The selector string
 * @returns `true` if the selector was successfully parsed, `false` otherwise
 */


var parse = function parse(selector) {
  var self = this;
  var remaining = self.inputText = selector;
  var currentQuery = self[0] = newQuery();
  self.length = 1;
  remaining = consumeWhitespace(remaining); // get rid of leading whitespace

  for (;;) {
    var exprInfo = consumeExpr(remaining);

    if (exprInfo.expr == null) {
      warn('The selector `' + selector + '`is invalid');
      return false;
    } else {
      var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery

      var ret = exprInfo.expr.populate(self, currentQuery, args);

      if (ret === false) {
        return false; // exit if population failed
      } else if (ret != null) {
        currentQuery = ret; // change the current query to be filled if the expr specifies
      }
    }

    remaining = exprInfo.remaining; // we're done when there's nothing left to parse

    if (remaining.match(/^\s*$/)) {
      break;
    }
  }

  var lastQ = self[self.length - 1];

  if (self.currentSubject != null) {
    lastQ.subject = self.currentSubject;
  }

  lastQ.edgeCount = self.edgeCount;
  lastQ.compoundCount = self.compoundCount;

  for (var i = 0; i < self.length; i++) {
    var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations

    if (q.compoundCount > 0 && q.edgeCount > 0) {
      warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');
      return false;
    }

    if (q.edgeCount > 1) {
      warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');
      return false;
    } else if (q.edgeCount === 1) {
      warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');
    }
  }

  return true; // success
};
/**
 * Get the selector represented as a string.  This value uses default formatting,
 * so things like spacing may differ from the input text passed to the constructor.
 * @returns {string} The selector string
 */


var toString = function toString() {
  if (this.toStringCache != null) {
    return this.toStringCache;
  }

  var clean = function clean(obj) {
    if (obj == null) {
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function cleanVal(val) {
    if (string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  };

  var space = function space(val) {
    return ' ' + val + ' ';
  };

  var checkToString = function checkToString(check, subject) {
    var type = check.type,
        value = check.value;

    switch (type) {
      case Type.GROUP:
        {
          var group = clean(value);
          return group.substring(0, group.length - 1);
        }

      case Type.DATA_COMPARE:
        {
          var field = check.field,
              operator = check.operator;
          return '[' + field + space(clean(operator)) + cleanVal(value) + ']';
        }

      case Type.DATA_BOOL:
        {
          var _operator = check.operator,
              _field = check.field;
          return '[' + clean(_operator) + _field + ']';
        }

      case Type.DATA_EXIST:
        {
          var _field2 = check.field;
          return '[' + _field2 + ']';
        }

      case Type.META_COMPARE:
        {
          var _operator2 = check.operator,
              _field3 = check.field;
          return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';
        }

      case Type.STATE:
        {
          return value;
        }

      case Type.ID:
        {
          return '#' + value;
        }

      case Type.CLASS:
        {
          return '.' + value;
        }

      case Type.PARENT:
      case Type.CHILD:
        {
          return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);
        }

      case Type.ANCESTOR:
      case Type.DESCENDANT:
        {
          return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);
        }

      case Type.COMPOUND_SPLIT:
        {
          var lhs = queryToString(check.left, subject);
          var sub = queryToString(check.subject, subject);
          var rhs = queryToString(check.right, subject);
          return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;
        }

      case Type.TRUE:
        {
          return '';
        }
    }
  };

  var queryToString = function queryToString(query, subject) {
    return query.checks.reduce(function (str, chk, i) {
      return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);
    }, '');
  };

  var str = '';

  for (var i = 0; i < this.length; i++) {
    var query = this[i];
    str += queryToString(query, query.subject);

    if (this.length > 1 && i < this.length - 1) {
      str += ', ';
    }
  }

  this.toStringCache = str;
  return str;
};
var parse$1 = {
  parse: parse,
  toString: toString
};

var valCmp = function valCmp(fieldVal, operator, value) {
  var matches;
  var isFieldStr = string(fieldVal);
  var isFieldNum = number(fieldVal);
  var isValStr = string(value);
  var fieldStr, valStr;
  var caseInsensitive = false;
  var notExpr = false;
  var isIneqCmp = false;

  if (operator.indexOf('!') >= 0) {
    operator = operator.replace('!', '');
    notExpr = true;
  }

  if (operator.indexOf('@') >= 0) {
    operator = operator.replace('@', '');
    caseInsensitive = true;
  }

  if (isFieldStr || isValStr || caseInsensitive) {
    fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;
    valStr = '' + value;
  } // if we're doing a case insensitive comparison, then we're using a STRING comparison
  // even if we're comparing numbers


  if (caseInsensitive) {
    fieldVal = fieldStr = fieldStr.toLowerCase();
    value = valStr = valStr.toLowerCase();
  }

  switch (operator) {
    case '*=':
      matches = fieldStr.indexOf(valStr) >= 0;
      break;

    case '$=':
      matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
      break;

    case '^=':
      matches = fieldStr.indexOf(valStr) === 0;
      break;

    case '=':
      matches = fieldVal === value;
      break;

    case '>':
      isIneqCmp = true;
      matches = fieldVal > value;
      break;

    case '>=':
      isIneqCmp = true;
      matches = fieldVal >= value;
      break;

    case '<':
      isIneqCmp = true;
      matches = fieldVal < value;
      break;

    case '<=':
      isIneqCmp = true;
      matches = fieldVal <= value;
      break;

    default:
      matches = false;
      break;
  } // apply the not op, but null vals for inequalities should always stay non-matching


  if (notExpr && (fieldVal != null || !isIneqCmp)) {
    matches = !matches;
  }

  return matches;
};
var boolCmp = function boolCmp(fieldVal, operator) {
  switch (operator) {
    case '?':
      return fieldVal ? true : false;

    case '!':
      return fieldVal ? false : true;

    case '^':
      return fieldVal === undefined;
  }
};
var existCmp = function existCmp(fieldVal) {
  return fieldVal !== undefined;
};
var data = function data(ele, field) {
  return ele.data(field);
};
var meta = function meta(ele, field) {
  return ele[field]();
};

/** A lookup of `match(check, ele)` functions by `Type` int */

var match = [];
/**
 * Returns whether the query matches for the element
 * @param query The `{ type, value, ... }` query object
 * @param ele The element to compare against
*/

var matches = function matches(query, ele) {
  return query.checks.every(function (chk) {
    return match[chk.type](chk, ele);
  });
};

match[Type.GROUP] = function (check, ele) {
  var group = check.value;
  return group === '*' || group === ele.group();
};

match[Type.STATE] = function (check, ele) {
  var stateSelector = check.value;
  return stateSelectorMatches(stateSelector, ele);
};

match[Type.ID] = function (check, ele) {
  var id = check.value;
  return ele.id() === id;
};

match[Type.CLASS] = function (check, ele) {
  var cls = check.value;
  return ele.hasClass(cls);
};

match[Type.META_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(meta(ele, field), operator, value);
};

match[Type.DATA_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(data(ele, field), operator, value);
};

match[Type.DATA_BOOL] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return boolCmp(data(ele, field), operator);
};

match[Type.DATA_EXIST] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return existCmp(data(ele, field));
};

match[Type.UNDIRECTED_EDGE] = function (check, ele) {
  var qA = check.nodes[0];
  var qB = check.nodes[1];
  var src = ele.source();
  var tgt = ele.target();
  return matches(qA, src) && matches(qB, tgt) || matches(qB, src) && matches(qA, tgt);
};

match[Type.NODE_NEIGHBOR] = function (check, ele) {
  return matches(check.node, ele) && ele.neighborhood().some(function (n) {
    return n.isNode() && matches(check.neighbor, n);
  });
};

match[Type.DIRECTED_EDGE] = function (check, ele) {
  return matches(check.source, ele.source()) && matches(check.target, ele.target());
};

match[Type.NODE_SOURCE] = function (check, ele) {
  return matches(check.source, ele) && ele.outgoers().some(function (n) {
    return n.isNode() && matches(check.target, n);
  });
};

match[Type.NODE_TARGET] = function (check, ele) {
  return matches(check.target, ele) && ele.incomers().some(function (n) {
    return n.isNode() && matches(check.source, n);
  });
};

match[Type.CHILD] = function (check, ele) {
  return matches(check.child, ele) && matches(check.parent, ele.parent());
};

match[Type.PARENT] = function (check, ele) {
  return matches(check.parent, ele) && ele.children().some(function (c) {
    return matches(check.child, c);
  });
};

match[Type.DESCENDANT] = function (check, ele) {
  return matches(check.descendant, ele) && ele.ancestors().some(function (a) {
    return matches(check.ancestor, a);
  });
};

match[Type.ANCESTOR] = function (check, ele) {
  return matches(check.ancestor, ele) && ele.descendants().some(function (d) {
    return matches(check.descendant, d);
  });
};

match[Type.COMPOUND_SPLIT] = function (check, ele) {
  return matches(check.subject, ele) && matches(check.left, ele) && matches(check.right, ele);
};

match[Type.TRUE] = function () {
  return true;
};

match[Type.COLLECTION] = function (check, ele) {
  var collection = check.value;
  return collection.has(ele);
};

match[Type.FILTER] = function (check, ele) {
  var filter = check.value;
  return filter(ele);
};

var filter = function filter(collection) {
  var self = this; // for 1 id #foo queries, just get the element

  if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {
    return collection.getElementById(self[0].checks[0].value).collection();
  }

  var selectorFunction = function selectorFunction(element) {
    for (var j = 0; j < self.length; j++) {
      var query = self[j];

      if (matches(query, element)) {
        return true;
      }
    }

    return false;
  };

  if (self.text() == null) {
    selectorFunction = function selectorFunction() {
      return true;
    };
  }

  return collection.filter(selectorFunction);
}; // filter
// does selector match a single element?


var matches$1 = function matches$1(ele) {
  var self = this;

  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (matches(query, ele)) {
      return true;
    }
  }

  return false;
}; // matches


var matching = {
  matches: matches$1,
  filter: filter
};

var Selector = function Selector(selector) {
  this.inputText = selector;
  this.currentSubject = null;
  this.compoundCount = 0;
  this.edgeCount = 0;
  this.length = 0;

  if (selector == null || string(selector) && selector.match(/^\s*$/)) ; else if (elementOrCollection(selector)) {
    this.addQuery({
      checks: [{
        type: Type.COLLECTION,
        value: selector.collection()
      }]
    });
  } else if (fn(selector)) {
    this.addQuery({
      checks: [{
        type: Type.FILTER,
        value: selector
      }]
    });
  } else if (string(selector)) {
    if (!this.parse(selector)) {
      this.invalid = true;
    }
  } else {
    error('A selector must be created from a string; found ');
  }
};

var selfn = Selector.prototype;
[parse$1, matching].forEach(function (p) {
  return extend(selfn, p);
});

selfn.text = function () {
  return this.inputText;
};

selfn.size = function () {
  return this.length;
};

selfn.eq = function (i) {
  return this[i];
};

selfn.sameText = function (otherSel) {
  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
};

selfn.addQuery = function (q) {
  this[this.length++] = q;
};

selfn.selector = selfn.toString;

var elesfn$f = {
  allAre: function allAre(selector) {
    var selObj = new Selector(selector);
    return this.every(function (ele) {
      return selObj.matches(ele);
    });
  },
  is: function is(selector) {
    var selObj = new Selector(selector);
    return this.some(function (ele) {
      return selObj.matches(ele);
    });
  },
  some: function some(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (ret) {
        return true;
      }
    }

    return false;
  },
  every: function every(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (!ret) {
        return false;
      }
    }

    return true;
  },
  same: function same(collection) {
    // cheap collection ref check
    if (this === collection) {
      return true;
    }

    collection = this.cy().collection(collection);
    var thisLength = this.length;
    var collectionLength = collection.length; // cheap length check

    if (thisLength !== collectionLength) {
      return false;
    } // cheap element ref check


    if (thisLength === 1) {
      return this[0] === collection[0];
    }

    return this.every(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  anySame: function anySame(collection) {
    collection = this.cy().collection(collection);
    return this.some(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  allAreNeighbors: function allAreNeighbors(collection) {
    collection = this.cy().collection(collection);
    var nhood = this.neighborhood();
    return collection.every(function (ele) {
      return nhood.hasElementWithId(ele.id());
    });
  },
  contains: function contains(collection) {
    collection = this.cy().collection(collection);
    var self = this;
    return collection.every(function (ele) {
      return self.hasElementWithId(ele.id());
    });
  }
};
elesfn$f.allAreNeighbours = elesfn$f.allAreNeighbors;
elesfn$f.has = elesfn$f.contains;
elesfn$f.equal = elesfn$f.equals = elesfn$f.same;

var cache = function cache(fn, name) {
  return function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if (selectorOrEles == null) {
      key = '';
    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key = selectorOrEles.id();
    }

    if (eles.length === 1 && key) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || [];
      var hash = hashString(key);
      var cacheHit = ch[hash];

      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn.call(eles, arg1, arg2, arg3, arg4);
    }
  };
};

var elesfn$g = {
  parent: function parent(selector) {
    var parents = []; // optimisation for single ele call

    if (this.length === 1) {
      var parent = this[0]._private.parent;

      if (parent) {
        return parent;
      }
    }

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;

      if (_parent) {
        parents.push(_parent);
      }
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  parents: function parents(selector) {
    var parents = [];
    var eles = this.parent();

    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents.push(ele);
      }

      eles = eles.parent();
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  commonAncestors: function commonAncestors(selector) {
    var ancestors;

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents = ele.parents();
      ancestors = ancestors || parents;
      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
    }

    return ancestors.filter(selector);
  },
  orphans: function orphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isOrphan();
    }).filter(selector);
  },
  nonorphans: function nonorphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isChild();
    }).filter(selector);
  },
  children: cache(function (selector) {
    var children = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var eleChildren = ele._private.children;

      for (var j = 0; j < eleChildren.length; j++) {
        children.push(eleChildren[j]);
      }
    }

    return this.spawn(children, {
      unique: true
    }).filter(selector);
  }, 'children'),
  siblings: function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  },
  isParent: function isParent() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },
  isChildless: function isChildless() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  },
  isChild: function isChild() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  },
  isOrphan: function isOrphan() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  },
  descendants: function descendants(selector) {
    var elements = [];

    function add(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        elements.push(ele);

        if (ele.children().nonempty()) {
          add(ele.children());
        }
      }
    }

    add(this.children());
    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }
};

function forEachCompound(eles, fn, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set$1();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }

  while (q.length > 0) {
    var _ele = q.shift();

    fn(_ele);
    did.add(_ele.id());

    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }

  return eles;
}

function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (!did.has(child.id())) {
        q.push(child);
      }
    }
  }
} // very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use


elesfn$g.forEachDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addChildren);
};

function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent = ele._private.parent;

    if (!did.has(parent.id())) {
      q.push(parent);
    }
  }
}

elesfn$g.forEachUp = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParent);
};

function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}

elesfn$g.forEachUpAndDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParentAndChildren);
}; // aliases


elesfn$g.ancestors = elesfn$g.parents;

var fn$1, elesfn$h;
fn$1 = elesfn$h = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),
  rscratch: define$3.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),
  removeRscratch: define$3.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),
  id: function id() {
    var ele = this[0];

    if (ele) {
      return ele._private.data.id;
    }
  }
}; // aliases

fn$1.attr = fn$1.data;
fn$1.removeAttr = fn$1.removeData;
var data$1 = elesfn$h;

var elesfn$i = {};

function defineDegreeFunction(callback) {
  return function (includeLoops) {
    var self = this;

    if (includeLoops === undefined) {
      includeLoops = true;
    }

    if (self.length === 0) {
      return;
    }

    if (self.isNode() && !self.removed()) {
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];

        if (!includeLoops && edge.isLoop()) {
          continue;
        }

        degree += callback(node, edge);
      }

      return degree;
    } else {
      return;
    }
  };
}

extend(elesfn$i, {
  degree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),
  indegree: defineDegreeFunction(function (node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),
  outdegree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback) {
  return function (includeLoops) {
    var ret;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var ele = nodes[i];
      var degree = ele[degreeFn](includeLoops);

      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
        ret = degree;
      }
    }

    return ret;
  };
}

extend(elesfn$i, {
  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
    return degree < min;
  }),
  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
    return degree > max;
  }),
  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
    return degree < min;
  }),
  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
    return degree > max;
  }),
  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
    return degree < min;
  }),
  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
    return degree > max;
  })
});
extend(elesfn$i, {
  totalDegree: function totalDegree(includeLoops) {
    var total = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      total += nodes[i].degree(includeLoops);
    }

    return total;
  }
});

var fn$2, elesfn$j;

var beforePositionSet = function beforePositionSet(eles, newPos, silent) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x != null ? newPos.x - oldPos.x : 0,
        y: newPos.y != null ? newPos.y - oldPos.y : 0
      };

      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
        ele.children().shift(delta, silent);
      }

      ele.shiftCachedBoundingBox(delta);
    }
  }
};

var positionDef = {
  field: 'position',
  bindingEvent: 'position',
  allowBinding: true,
  allowSetting: true,
  settingEvent: 'position',
  settingTriggersEvent: true,
  triggerFnName: 'emitAndNotify',
  allowGetting: true,
  validKeys: ['x', 'y'],
  beforeGet: function beforeGet(ele) {
    ele.updateCompoundBounds();
  },
  beforeSet: function beforeSet(eles, newPos) {
    beforePositionSet(eles, newPos, false);
  },
  onSet: function onSet(eles) {
    eles.dirtyCompoundBoundsCache();
  },
  canSet: function canSet(ele) {
    return !ele.locked();
  }
};
fn$2 = elesfn$j = {
  position: define$3.data(positionDef),
  // position but no notification to renderer
  silentPosition: define$3.data(extend({}, positionDef, {
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: false,
    beforeSet: function beforeSet(eles, newPos) {
      beforePositionSet(eles, newPos, true);
    }
  })),
  positions: function positions(pos, silent) {
    if (plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (fn(pos)) {
      var _fn = pos;
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];

        var _pos = void 0;

        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }

      cy.endBatch();
    }

    return this; // chaining
  },
  silentPositions: function silentPositions(pos) {
    return this.positions(pos, true);
  },
  shift: function shift(dim, val, silent) {
    var delta;

    if (plainObject(dim)) {
      delta = {
        x: number(dim.x) ? dim.x : 0,
        y: number(dim.y) ? dim.y : 0
      };
      silent = val;
    } else if (string(dim) && number(val)) {
      delta = {
        x: 0,
        y: 0
      };
      delta[dim] = val;
    }

    if (delta != null) {
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var pos = ele.position();
        var newPos = {
          x: pos.x + delta.x,
          y: pos.y + delta.y
        };

        if (silent) {
          ele.silentPosition(newPos);
        } else {
          ele.position(newPos);
        }
      }

      cy.endBatch();
    }

    return this;
  },
  silentShift: function silentShift(dim, val) {
    if (plainObject(dim)) {
      this.shift(dim, true);
    } else if (string(dim) && number(val)) {
      this.shift(dim, val, true);
    }

    return this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = plainObject(dim) ? dim : undefined;
    var setting = rpos !== undefined || val !== undefined && string(dim);

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];

          if (val !== undefined) {
            // set one dimension
            _ele.position(dim, (val - pan[dim]) / zoom);
          } else if (rpos !== undefined) {
            // set whole position
            _ele.position(renderedToModelPosition(rpos, zoom, pan));
          }
        }
      } else {
        // getting
        var pos = ele.position();
        rpos = modelToRenderedPosition(pos, zoom, pan);

        if (dim === undefined) {
          // then return the whole rendered position
          return rpos;
        } else {
          // then return the specified dimension
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  },
  // get/set the position relative to the parent
  relativePosition: function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = plainObject(dim) ? dim : undefined;
    var setting = ppos !== undefined || val !== undefined && string(dim);
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent = hasCompoundNodes ? _ele2.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if (hasParent) {
            parent = parent[0];
          }

          var origin = relativeToParent ? parent.position() : {
            x: 0,
            y: 0
          };

          if (val !== undefined) {
            // set one dimension
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== undefined) {
            // set whole position
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        // getting
        var pos = ele.position();

        var _parent = hasCompoundNodes ? ele.parent() : null;

        var _hasParent = _parent && _parent.length > 0;

        var _relativeToParent = _hasParent;

        if (_hasParent) {
          _parent = _parent[0];
        }

        var _origin = _relativeToParent ? _parent.position() : {
          x: 0,
          y: 0
        };

        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };

        if (dim === undefined) {
          // then return the whole rendered position
          return ppos;
        } else {
          // then return the specified dimension
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  }
}; // aliases

fn$2.modelPosition = fn$2.point = fn$2.position;
fn$2.modelPositions = fn$2.points = fn$2.positions;
fn$2.renderedPoint = fn$2.renderedPosition;
fn$2.relativePoint = fn$2.relativePosition;
var position = elesfn$j;

var fn$3, elesfn$k;
fn$3 = elesfn$k = {};

elesfn$k.renderedBoundingBox = function (options) {
  var bb = this.boundingBox(options);
  var cy = this.cy();
  var zoom = cy.zoom();
  var pan = cy.pan();
  var x1 = bb.x1 * zoom + pan.x;
  var x2 = bb.x2 * zoom + pan.x;
  var y1 = bb.y1 * zoom + pan.y;
  var y2 = bb.y2 * zoom + pan.y;
  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    w: x2 - x1,
    h: y2 - y1
  };
};

elesfn$k.dirtyCompoundBoundsCache = function () {
  var cy = this.cy();

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  this.forEachUp(function (ele) {
    if (ele.isParent()) {
      var _p = ele._private;
      _p.compoundBoundsClean = false;
      _p.bbCache = null;
      ele.emitAndNotify('bounds');
    }
  });
  return this;
};

elesfn$k.updateCompoundBounds = function () {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  } // save cycles when batching -- but bounds will be stale (or not exist yet)


  if (!force && cy.batching()) {
    return this;
  }

  function update(parent) {
    if (!parent.isParent()) {
      return;
    }

    var _p = parent._private;
    var children = parent.children();
    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';
    var min = {
      width: {
        val: parent.pstyle('min-width').pfValue,
        left: parent.pstyle('min-width-bias-left'),
        right: parent.pstyle('min-width-bias-right')
      },
      height: {
        val: parent.pstyle('min-height').pfValue,
        top: parent.pstyle('min-height-bias-top'),
        bottom: parent.pstyle('min-height-bias-bottom')
      }
    };
    var bb = children.boundingBox({
      includeLabels: includeLabels,
      includeOverlays: false,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h

    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent.pstyle('width').pfValue,
        h: parent.pstyle('height').pfValue
      };
      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }

    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;

      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }

      return {
        biasDiff: biasDiff,
        biasComplementDiff: biasComplementDiff
      };
    }

    function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
      if (paddingObject.units === '%') {
        switch (relativeTo) {
          case 'width':
            return width > 0 ? paddingObject.pfValue * width : 0;

          case 'height':
            return height > 0 ? paddingObject.pfValue * height : 0;

          case 'average':
            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;

          case 'min':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;

          case 'max':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;

          default:
            return 0;
        }
      } else if (paddingObject.units === 'px') {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }

    var leftVal = min.width.left.value;

    if (min.width.left.units === 'px' && min.width.val > 0) {
      leftVal = leftVal * 100 / min.width.val;
    }

    var rightVal = min.width.right.value;

    if (min.width.right.units === 'px' && min.width.val > 0) {
      rightVal = rightVal * 100 / min.width.val;
    }

    var topVal = min.height.top.value;

    if (min.height.top.units === 'px' && min.height.val > 0) {
      topVal = topVal * 100 / min.height.val;
    }

    var bottomVal = min.height.bottom.value;

    if (min.height.bottom.units === 'px' && min.height.val > 0) {
      bottomVal = bottomVal * 100 / min.height.val;
    }

    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;
    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;
    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);
    _p.autoWidth = Math.max(bb.w, min.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
    _p.autoHeight = Math.max(bb.h, min.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
  }

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;

    if (!_p.compoundBoundsClean) {
      update(ele);

      if (!cy.batching()) {
        _p.compoundBoundsClean = true;
      }
    }
  }

  return this;
};

var noninf = function noninf(x) {
  if (x === Infinity || x === -Infinity) {
    return 0;
  }

  return x;
};

var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  } // don't update with null dim


  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
  b.w = b.x2 - b.x1;
  b.h = b.y2 - b.y1;
};

var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
  if (b2 == null) {
    return b;
  }

  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};

var prefixedProperty = function prefixedProperty(obj, field, prefix) {
  return getPrefixedProperty(obj, field, prefix);
};

var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
  var x;
  var y;

  if (arrowType !== 'none') {
    if (prefix === 'source') {
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if (prefix === 'target') {
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    } // always store the individual arrow bounds


    var bbs = _p.arrowBounds = _p.arrowBounds || {};
    var bb = bbs[prefix] = bbs[prefix] || {};
    bb.x1 = x - halfArW;
    bb.y1 = y - halfArW;
    bb.x2 = x + halfArW;
    bb.y2 = y + halfArW;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    expandBoundingBox(bb, 1);
    updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
  }
};

var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var prefixDash;

  if (prefix) {
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle(prefixDash + 'label').strValue;

  if (label) {
    var halign = ele.pstyle('text-halign');
    var valign = ele.pstyle('text-valign');
    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
    var labelX = prefixedProperty(rstyle, 'labelX', prefix);
    var labelY = prefixedProperty(rstyle, 'labelY', prefix);
    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + 'text-rotation');
    var outlineWidth = ele.pstyle('text-outline-width').pfValue;
    var borderWidth = ele.pstyle('text-border-width').pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle('text-background-padding').pfValue;
    var lh = labelHeight;
    var lw = labelWidth;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if (isEdge) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch (valign.value) {
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    } // shift by margin and expand by outline and border


    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding;
    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding;
    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding;
    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding; // always store the unrotated label bounds separately

    var bbPrefix = prefix || 'main';
    var bbs = _p.labelBounds;
    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
    bb.x1 = lx1;
    bb.y1 = ly1;
    bb.x2 = lx2;
    bb.y2 = ly2;
    bb.w = lx2 - lx1;
    bb.h = ly2 - ly1;
    expandBoundingBox(bb, 1); // expand to work around browser dimension inaccuracies

    var isAutorotate = isEdge && rotation.strValue === 'autorotate';
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
      var cos = Math.cos(theta);
      var sin = Math.sin(theta); // rotation point (default value for center-center)

      var xo = (lx1 + lx2) / 2;
      var yo = (ly1 + ly2) / 2;

      if (!isEdge) {
        switch (halign.value) {
          case 'left':
            xo = lx2;
            break;

          case 'right':
            xo = lx1;
            break;
        }

        switch (valign.value) {
          case 'top':
            yo = ly2;
            break;

          case 'bottom':
            yo = ly1;
            break;
        }
      }

      var rotate = function rotate(x, y) {
        x = x - xo;
        y = y - yo;
        return {
          x: x * cos - y * sin + xo,
          y: x * sin + y * cos + yo
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }

    var bbPrefixRot = bbPrefix + 'Rot';
    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
    bbRot.x1 = lx1;
    bbRot.y1 = ly1;
    bbRot.x2 = lx2;
    bbRot.y2 = ly2;
    bbRot.w = lx2 - lx1;
    bbRot.h = ly2 - ly1;
    updateBounds(bounds, lx1, ly1, lx2, ly2);
    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
  }

  return bounds;
}; // get the bounding box of the elements (in raw model position)


var boundingBoxImpl = function boundingBoxImpl(ele, options) {
  var cy = ele._private.cy;
  var styleEnabled = cy.styleEnabled();
  var headless = cy.headless();
  var bounds = makeBoundingBox();
  var _p = ele._private;
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2; // extrema of body / lines

  var x, y; // node pos

  var rstyle = _p.rstyle;
  var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion
  // (other factors like width values will be considered later in this function anyway)

  var isDisplayed = function isDisplayed(ele) {
    return ele.pstyle('display').value !== 'none';
  };

  var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));

  if (displayed) {
    // displayed suffices, since we will find zero area eles anyway
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if (styleEnabled && options.includeOverlays) {
      overlayOpacity = ele.pstyle('overlay-opacity').value;

      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle('overlay-padding').value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if (styleEnabled) {
      w = ele.pstyle('width').pfValue;
      wHalf = w / 2;
    }

    if (isNode && options.includeNodes) {
      var pos = ele.position();
      x = pos.x;
      y = pos.y;

      var _w = ele.outerWidth();

      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2; // handle node dimensions
      /////////////////////////

      ex1 = x - halfW;
      ex2 = x + halfW;
      ey1 = y - halfH;
      ey2 = y + halfH;
      updateBounds(bounds, ex1, ey1, ex2, ey2);
    } else if (isEdge && options.includeEdges) {
      if (styleEnabled && !headless) {
        var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width

        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
        ////////////////

        if (curveStyle === 'haystack') {
          var hpts = rstyle.haystackPts;

          if (hpts && hpts.length === 2) {
            ex1 = hpts[0].x;
            ey1 = hpts[0].y;
            ex2 = hpts[1].x;
            ey2 = hpts[1].y;

            if (ex1 > ex2) {
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if (ey1 > ey2) {
              var _temp = ey1;
              ey1 = ey2;
              ey2 = _temp;
            }

            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
          }
        } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {
          var pts;

          switch (curveStyle) {
            case 'bezier':
            case 'unbundled-bezier':
              pts = rstyle.bezierPts;
              break;

            case 'segments':
            case 'taxi':
              pts = rstyle.linePts;
              break;
          }

          if (pts != null) {
            for (var j = 0; j < pts.length; j++) {
              var pt = pts[j];
              ex1 = pt.x - wHalf;
              ex2 = pt.x + wHalf;
              ey1 = pt.y - wHalf;
              ey2 = pt.y + wHalf;
              updateBounds(bounds, ex1, ey1, ex2, ey2);
            }
          }
        } // bezier-like or segment-like edge

      } else {
        // headless or style disabled
        // fallback on source and target positions
        //////////////////////////////////////////
        var n1 = ele.source();
        var n1pos = n1.position();
        var n2 = ele.target();
        var n2pos = n2.position();
        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;

        if (ex1 > ex2) {
          var _temp2 = ex1;
          ex1 = ex2;
          ex2 = _temp2;
        }

        if (ey1 > ey2) {
          var _temp3 = ey1;
          ey1 = ey2;
          ey2 = _temp3;
        } // take into account edge width


        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2);
      } // headless or style disabled

    } // edges
    // handle edge arrow size
    /////////////////////////


    if (styleEnabled && options.includeEdges && isEdge) {
      updateBoundsFromArrow(bounds, ele, 'mid-source');
      updateBoundsFromArrow(bounds, ele, 'mid-target');
      updateBoundsFromArrow(bounds, ele, 'source');
      updateBoundsFromArrow(bounds, ele, 'target');
    } // ghost
    ////////


    if (styleEnabled) {
      var ghost = ele.pstyle('ghost').value === 'yes';

      if (ghost) {
        var gx = ele.pstyle('ghost-offset-x').pfValue;
        var gy = ele.pstyle('ghost-offset-y').pfValue;
        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
      }
    } // always store the body bounds separately from the labels


    var bbBody = _p.bodyBounds = _p.bodyBounds || {};
    assignBoundingBox(bbBody, bounds);
    expandBoundingBoxSides(bbBody, manualExpansion);
    expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
    // overlay
    //////////

    if (styleEnabled) {
      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;
      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
    } // always store the body bounds separately from the labels


    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
    assignBoundingBox(bbOverlay, bounds);
    expandBoundingBoxSides(bbOverlay, manualExpansion);
    expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
    // handle label dimensions
    //////////////////////////

    var bbLabels = _p.labelBounds = _p.labelBounds || {};

    if (bbLabels.all != null) {
      clearBoundingBox(bbLabels.all);
    } else {
      bbLabels.all = makeBoundingBox();
    }

    if (styleEnabled && options.includeLabels) {
      if (options.includeMainLabels) {
        updateBoundsFromLabel(bounds, ele, null);
      }

      if (isEdge) {
        if (options.includeSourceLabels) {
          updateBoundsFromLabel(bounds, ele, 'source');
        }

        if (options.includeTargetLabels) {
          updateBoundsFromLabel(bounds, ele, 'target');
        }
      }
    } // style enabled for labels

  } // if displayed


  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  if (bounds.w > 0 && bounds.h > 0 && displayed) {
    expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides

    expandBoundingBox(bounds, 1);
  }

  return bounds;
};

var getKey = function getKey(opts) {
  var i = 0;

  var tf = function tf(val) {
    return (val ? 1 : 0) << i++;
  };

  var key = 0;
  key += tf(opts.incudeNodes);
  key += tf(opts.includeEdges);
  key += tf(opts.includeLabels);
  key += tf(opts.includeMainLabels);
  key += tf(opts.includeSourceLabels);
  key += tf(opts.includeTargetLabels);
  key += tf(opts.includeOverlays);
  return key;
};

var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
  if (ele.isEdge()) {
    var p1 = ele.source().position();
    var p2 = ele.target().position();

    var r = function r(x) {
      return Math.round(x);
    };

    return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);
  } else {
    return 0;
  }
};

var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
  var _p = ele._private;
  var bb;
  var isEdge = ele.isEdge();
  var key = opts == null ? defBbOptsKey : getKey(opts);
  var usingDefOpts = key === defBbOptsKey;
  var currPosKey = getBoundingBoxPosKey(ele);
  var isPosKeySame = _p.bbCachePosKey === currPosKey;
  var useCache = opts.useCache && isPosKeySame;

  var isDirty = function isDirty(ele) {
    return ele._private.bbCache == null;
  };

  var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());

  if (needRecalc) {
    if (!isPosKeySame) {
      ele.recalculateRenderedStyle();
    }

    bb = boundingBoxImpl(ele, defBbOpts);
    _p.bbCache = bb;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = currPosKey;
  } else {
    bb = _p.bbCache;
  }

  if (!needRecalc && (_p.bbCacheShift.x !== 0 || _p.bbCacheShift.y !== 0)) {
    var shift = assignShiftToBoundingBox;
    var delta = _p.bbCacheShift;

    var safeShift = function safeShift(bb, delta) {
      if (bb != null) {
        shift(bb, delta);
      }
    };

    shift(bb, delta);
    var bodyBounds = _p.bodyBounds,
        overlayBounds = _p.overlayBounds,
        labelBounds = _p.labelBounds,
        arrowBounds = _p.arrowBounds;
    safeShift(bodyBounds, delta);
    safeShift(overlayBounds, delta);

    if (arrowBounds != null) {
      safeShift(arrowBounds.source, delta);
      safeShift(arrowBounds.target, delta);
      safeShift(arrowBounds['mid-source'], delta);
      safeShift(arrowBounds['mid-target'], delta);
    }

    if (labelBounds != null) {
      safeShift(labelBounds.main, delta);
      safeShift(labelBounds.all, delta);
      safeShift(labelBounds.source, delta);
      safeShift(labelBounds.target, delta);
    }
  } // always reset the shift, because we either applied the shift or cleared it by doing a fresh recalc


  _p.bbCacheShift.x = _p.bbCacheShift.y = 0; // not using def opts => need to build up bb from combination of sub bbs

  if (!usingDefOpts) {
    var isNode = ele.isNode();
    bb = makeBoundingBox();

    if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
      if (opts.includeOverlays) {
        updateBoundsFromBox(bb, _p.overlayBounds);
      } else {
        updateBoundsFromBox(bb, _p.bodyBounds);
      }
    }

    if (opts.includeLabels) {
      if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {
        updateBoundsFromBox(bb, _p.labelBounds.all);
      } else {
        if (opts.includeMainLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.mainRot);
        }

        if (opts.includeSourceLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
        }

        if (opts.includeTargetLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.targetRot);
        }
      }
    }

    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeMainLabels: true,
  includeSourceLabels: true,
  includeTargetLabels: true,
  includeOverlays: true,
  useCache: true
};
var defBbOptsKey = getKey(defBbOpts);
var filledBbOpts = defaults(defBbOpts);

elesfn$k.boundingBox = function (options) {
  var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function

  if (this.length === 1 && this[0]._private.bbCache != null && (options === undefined || options.useCache === undefined || options.useCache === true)) {
    if (options === undefined) {
      options = defBbOpts;
    } else {
      options = filledBbOpts(options);
    }

    bounds = cachedBoundingBoxImpl(this[0], options);
  } else {
    bounds = makeBoundingBox();
    options = options || defBbOpts;
    var opts = filledBbOpts(options);
    var eles = this;
    var cy = eles.cy();
    var styleEnabled = cy.styleEnabled();

    if (styleEnabled) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var currPosKey = getBoundingBoxPosKey(ele);
        var isPosKeySame = _p.bbCachePosKey === currPosKey;
        var useCache = opts.useCache && isPosKeySame;
        ele.recalculateRenderedStyle(useCache);
      }
    }

    this.updateCompoundBounds();

    for (var _i = 0; _i < eles.length; _i++) {
      var _ele = eles[_i];
      updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
    }
  }

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);
  return bounds;
};

elesfn$k.dirtyBoundingBoxCache = function () {
  for (var i = 0; i < this.length; i++) {
    var _p = this[i]._private;
    _p.bbCache = null;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = null;
    _p.bodyBounds = null;
    _p.overlayBounds = null;
    _p.labelBounds.all = null;
    _p.labelBounds.source = null;
    _p.labelBounds.target = null;
    _p.labelBounds.main = null;
    _p.labelBounds.sourceRot = null;
    _p.labelBounds.targetRot = null;
    _p.labelBounds.mainRot = null;
    _p.arrowBounds.source = null;
    _p.arrowBounds.target = null;
    _p.arrowBounds['mid-source'] = null;
    _p.arrowBounds['mid-target'] = null;
  }

  this.emitAndNotify('bounds');
  return this;
};

elesfn$k.shiftCachedBoundingBox = function (delta) {
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;
    var bb = _p.bbCache;

    if (bb != null) {
      _p.bbCacheShift.x += delta.x;
      _p.bbCacheShift.y += delta.y;
    }
  }

  this.emitAndNotify('bounds');
  return this;
}; // private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway


elesfn$k.boundingBoxAt = function (fn) {
  var nodes = this.nodes();
  var cy = this.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  if (hasCompoundNodes) {
    nodes = nodes.filter(function (node) {
      return !node.isParent();
    });
  }

  if (plainObject(fn)) {
    var obj = fn;

    fn = function fn() {
      return obj;
    };
  }

  var storeOldPos = function storeOldPos(node, i) {
    return node._private.bbAtOldPos = fn(node, i);
  };

  var getOldPos = function getOldPos(node) {
    return node._private.bbAtOldPos;
  };

  cy.startBatch();
  nodes.forEach(storeOldPos).silentPositions(fn);

  if (hasCompoundNodes) {
    this.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
  }

  var bb = copyBoundingBox(this.boundingBox({
    useCache: false
  }));
  nodes.silentPositions(getOldPos);
  cy.endBatch();
  return bb;
};

fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
var bounds = elesfn$k;

var fn$4, elesfn$l;
fn$4 = elesfn$l = {};

var defineDimFns = function defineDimFns(opts) {
  opts.uppercaseName = capitalize(opts.name);
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = capitalize(opts.outerName);

  fn$4[opts.name] = function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();
          return _p[opts.autoName] || 0;
        }

        var d = ele.pstyle(opts.name);

        switch (d.strValue) {
          case 'label':
            ele.recalculateRenderedStyle();
            return _p.rstyle[opts.labelName] || 0;

          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn$4['outer' + opts.uppercaseName] = function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        var dim = ele[opts.name]();
        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side

        var padding = 2 * ele.padding();
        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn$4['rendered' + opts.uppercaseName] = function renderedDimImpl() {
    var ele = this[0];

    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  };

  fn$4['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
    var ele = this[0];

    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width'
});
defineDimFns({
  name: 'height'
});

elesfn$l.padding = function () {
  var ele = this[0];
  var _p = ele._private;

  if (ele.isParent()) {
    ele.updateCompoundBounds();

    if (_p.autoPadding !== undefined) {
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
};

elesfn$l.paddedHeight = function () {
  var ele = this[0];
  return ele.height() + 2 * ele.padding();
};

elesfn$l.paddedWidth = function () {
  var ele = this[0];
  return ele.width() + 2 * ele.padding();
};

var widthHeight = elesfn$l;

var ifEdge = function ifEdge(ele, getValue) {
  if (ele.isEdge()) {
    return getValue(ele);
  }
};

var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
  }
};

var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    var pan = cy.pan();
    var zoom = cy.zoom();
    return getPoints(ele).map(function (p) {
      return modelToRenderedPosition(p, zoom, pan);
    });
  }
};

var controlPoints = function controlPoints(ele) {
  return ele.renderer().getControlPoints(ele);
};

var segmentPoints = function segmentPoints(ele) {
  return ele.renderer().getSegmentPoints(ele);
};

var sourceEndpoint = function sourceEndpoint(ele) {
  return ele.renderer().getSourceEndpoint(ele);
};

var targetEndpoint = function targetEndpoint(ele) {
  return ele.renderer().getTargetEndpoint(ele);
};

var midpoint = function midpoint(ele) {
  return ele.renderer().getEdgeMidpoint(ele);
};

var pts = {
  controlPoints: {
    get: controlPoints,
    mult: true
  },
  segmentPoints: {
    get: segmentPoints,
    mult: true
  },
  sourceEndpoint: {
    get: sourceEndpoint
  },
  targetEndpoint: {
    get: targetEndpoint
  },
  midpoint: {
    get: midpoint
  }
};

var renderedName = function renderedName(name) {
  return 'rendered' + name[0].toUpperCase() + name.substr(1);
};

var edgePoints = Object.keys(pts).reduce(function (obj, name) {
  var spec = pts[name];
  var rName = renderedName(name);

  obj[name] = function () {
    return ifEdge(this, spec.get);
  };

  if (spec.mult) {
    obj[rName] = function () {
      return ifEdgeRenderedPositions(this, spec.get);
    };
  } else {
    obj[rName] = function () {
      return ifEdgeRenderedPosition(this, spec.get);
    };
  }

  return obj;
}, {});

var dimensions = extend({}, position, bounds, widthHeight, edgePoints);

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
var Event = function Event(src, props) {
  this.recycle(src, props);
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
} // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


Event.prototype = {
  instanceString: function instanceString() {
    return 'event';
  },
  recycle: function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

    if (src != null && src.preventDefault) {
      // Browser Event object
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      // Plain object containing all event details
      props = src;
    } else {
      // Event string
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props != null) {
      // more efficient to manually copy fields we use
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }

    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
      var pos = this.position;
      var zoom = this.cy.zoom();
      var pan = this.cy.pan();
      this.renderedPosition = {
        x: pos.x * zoom + pan.x,
        y: pos.y * zoom + pan.y
      };
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now();
  },
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if preventDefault exists run it on the original event


    if (e.preventDefault) {
      e.preventDefault();
    }
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if stopPropagation exists run it on the original event


    if (e.stopPropagation) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")

var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

var defaults$8 = {
  qualifierCompare: function qualifierCompare(q1, q2) {
    return q1 === q2;
  },
  eventMatches: function eventMatches()
  /*context, listener, eventObj*/
  {
    return true;
  },
  addEventFields: function addEventFields()
  /*context, evt*/
  {},
  callbackContext: function callbackContext(context
  /*, listener, eventObj*/
  ) {
    return context;
  },
  beforeEmit: function beforeEmit()
  /* context, listener, eventObj */
  {},
  afterEmit: function afterEmit()
  /* context, listener, eventObj */
  {},
  bubble: function bubble()
  /*context*/
  {
    return false;
  },
  parent: function parent()
  /*context*/
  {
    return null;
  },
  context: null
};
var defaultsKeys = Object.keys(defaults$8);
var emptyOpts = {};

function Emitter() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
  var context = arguments.length > 1 ? arguments[1] : undefined;

  // micro-optimisation vs Object.assign() -- reduces Element instantiation time
  for (var i = 0; i < defaultsKeys.length; i++) {
    var key = defaultsKeys[i];
    this[key] = opts[key] || defaults$8[key];
  }

  this.context = context || this.context;
  this.listeners = [];
  this.emitting = 0;
}

var p = Emitter.prototype;

var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
  if (fn(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }

  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = extend({}, conf, confOverrides);
    }
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

      if (ret === false) {
        break;
      } // allow exiting early

    }
  }
};

var makeEventObj = function makeEventObj(self, obj) {
  self.addEventFields(self.context, obj);
  return new Event(obj.type, obj);
};

var forEachEventObj = function forEachEventObj(self, handler, events) {
  if (event(events)) {
    handler(self, events);
    return;
  } else if (plainObject(events)) {
    handler(self, makeEventObj(self, events));
    return;
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var eventObj = makeEventObj(self, {
        type: type,
        namespace: namespace,
        target: self.context
      });
      handler(self, eventObj);
    }
  }
};

p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
    if (fn(callback)) {
      self.listeners.push({
        event: event,
        // full event string
        callback: callback,
        // callback to run
        type: type,
        // the event type (e.g. 'click')
        namespace: namespace,
        // the event namespace (e.g. ".foo")
        qualifier: qualifier,
        // a restriction on whether to match this emitter
        conf: conf // additional configuration

      });
    }
  }, events, qualifier, callback, conf, confOverrides);
  return this;
};

p.one = function (events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, {
    one: true
  });
};

p.removeListener = p.off = function (events, qualifier, callback, conf) {
  var _this = this;

  if (this.emitting !== 0) {
    this.listeners = copyArray(this.listeners);
  }

  var listeners = this.listeners;

  var _loop = function _loop(i) {
    var listener = listeners[i];
    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback
    /*, conf*/
    ) {
      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
        listeners.splice(i, 1);
        return false;
      }
    }, events, qualifier, callback, conf);
  };

  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }

  return this;
};

p.removeAllListeners = function () {
  return this.removeListener('*');
};

p.emit = p.trigger = function (events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;
  this.emitting++;

  if (!array(extraParams)) {
    extraParams = [extraParams];
  }

  forEachEventObj(this, function (self, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];
      numListenersBeforeEmit = listeners.length;
    }

    var _loop2 = function _loop2(i) {
      var listener = listeners[i];

      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
        var args = [eventObj];

        if (extraParams != null) {
          push(args, extraParams);
        }

        self.beforeEmit(self.context, listener, eventObj);

        if (listener.conf && listener.conf.one) {
          self.listeners = self.listeners.filter(function (l) {
            return l !== listener;
          });
        }

        var context = self.callbackContext(self.context, listener, eventObj);
        var ret = listener.callback.apply(context, args);
        self.afterEmit(self.context, listener, eventObj);

        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      } // if listener matches

    };

    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2(i);
    } // for listener


    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
      self.parent(self.context).emit(eventObj, extraParams);
    }
  }, events);
  this.emitting--;
  return this;
};

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(ele, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(ele, evt) {
    evt.cy = ele.cy();
    evt.target = ele;
  },
  callbackContext: function callbackContext(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  },
  beforeEmit: function beforeEmit(context, listener
  /*, eventObj*/
  ) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  },
  bubble: function bubble() {
    return true;
  },
  parent: function parent(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }
};

var argSelector = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$m = {
  createEmitter: function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;

      if (!_p.emitter) {
        _p.emitter = new Emitter(emitterOptions, ele);
      }
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback);
    }

    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeListener(events, argSel, callback);
    }

    return this;
  },
  removeAllListeners: function removeAllListeners() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeAllListeners();
    }

    return this;
  },
  one: function one(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().one(events, argSel, callback);
    }

    return this;
  },
  once: function once(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback, {
        once: true,
        onceCollection: this
      });
    }
  },
  emit: function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().emit(events, extraParams);
    }

    return this;
  },
  emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
    if (this.length === 0) {
      return;
    } // empty collections don't need to notify anything
    // notify renderer


    this.cy().notify(event, this);
    this.emit(event, extraParams);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$m);

var elesfn$n = {
  nodes: function nodes(selector) {
    return this.filter(function (ele) {
      return ele.isNode();
    }).filter(selector);
  },
  edges: function edges(selector) {
    return this.filter(function (ele) {
      return ele.isEdge();
    }).filter(selector);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function byGroup() {
    var nodes = this.spawn();
    var edges = this.spawn();

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      if (ele.isNode()) {
        nodes.merge(ele);
      } else {
        edges.merge(ele);
      }
    }

    return {
      nodes: nodes,
      edges: edges
    };
  },
  filter: function filter(_filter, thisArg) {
    if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
      return this;
    } else if (string(_filter) || elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (fn(_filter)) {
      var filterEles = this.spawn();
      var eles = this;

      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

        if (include) {
          filterEles.merge(ele);
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },
  not: function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {
      if (string(toRemove)) {
        toRemove = this.filter(toRemove);
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for (var i = 0; i < this.length; i++) {
        var element = this[i];
        var remove = rMap.has(element.id());

        if (!remove) {
          elements.push(element);
        }
      }

      return this.spawn(elements);
    }
  },
  absoluteComplement: function absoluteComplement() {
    var cy = this.cy();
    return cy.mutableElements().not(this);
  },
  intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
    if (string(other)) {
      var selector = other;
      return this.filter(selector);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for (var i = 0; i < col.length; i++) {
      var id = col[i]._private.data.id;
      var entry = map2.get(id);

      if (entry) {
        elements.push(entry.ele);
      }
    }

    return this.spawn(elements);
  },
  xor: function xor(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (!inOther) {
          elements.push(ele);
        }
      }
    };

    add(col1, col2);
    add(col2, col1);
    return this.spawn(elements);
  },
  diff: function diff(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other, retEles) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (inOther) {
          both.push(ele);
        } else {
          retEles.push(ele);
        }
      }
    };

    add(col1, col2, left);
    add(col2, col1, right);
    return {
      left: this.spawn(left, {
        unique: true
      }),
      right: this.spawn(right, {
        unique: true
      }),
      both: this.spawn(both, {
        unique: true
      })
    };
  },
  add: function add(toAdd) {
    var cy = this._private.cy;

    if (!toAdd) {
      return this;
    }

    if (string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var elements = [];

    for (var i = 0; i < this.length; i++) {
      elements.push(this[i]);
    }

    var map = this._private.map;

    for (var _i = 0; _i < toAdd.length; _i++) {
      var add = !map.has(toAdd[_i].id());

      if (add) {
        elements.push(toAdd[_i]);
      }
    }

    return this.spawn(elements);
  },
  // in place merge on calling collection
  merge: function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;

    if (!toAdd) {
      return this;
    }

    if (toAdd && string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var map = _p.map;

    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id = toAddEle._private.data.id;
      var add = !map.has(id);

      if (add) {
        var index = this.length++;
        this[index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: index
        });
      } else {
        // replace
        var _index = map.get(id).index;
        this[_index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: _index
        });
      }
    }

    return this; // chaining
  },
  unmergeAt: function unmergeAt(i) {
    var ele = this[i];
    var id = ele.id();
    var _p = this._private;
    var map = _p.map; // remove ele

    this[i] = undefined;
    map["delete"](id);
    var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection

    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;
      this[lastEleI] = undefined;
      this[i] = lastEle;
      map.set(lastEleId, {
        ele: lastEle,
        index: i
      });
    } // the collection is now 1 ele smaller


    this.length--;
    return this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function unmergeOne(ele) {
    ele = ele[0];
    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry = map.get(id);

    if (!entry) {
      return this; // no need to remove
    }

    var i = entry.index;
    this.unmergeAt(i);
    return this;
  },
  // remove eles in place on calling collection
  unmerge: function unmerge(toRemove) {
    var cy = this._private.cy;

    if (!toRemove) {
      return this;
    }

    if (toRemove && string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }

    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }

    return this; // chaining
  },
  unmergeBy: function unmergeBy(toRmFn) {
    for (var i = this.length - 1; i >= 0; i--) {
      var ele = this[i];

      if (toRmFn(ele)) {
        this.unmergeAt(i);
      }
    }

    return this;
  },
  map: function map(mapFn, thisArg) {
    var arr = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
      arr.push(ret);
    }

    return arr;
  },
  reduce: function reduce(fn, initialValue) {
    var val = initialValue;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      val = fn(val, eles[i], i, eles);
    }

    return val;
  },
  max: function max(valFn, thisArg) {
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val > max) {
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },
  min: function min(valFn, thisArg) {
    var min = Infinity;
    var minEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val < min) {
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
}; // aliases

var fn$5 = elesfn$n;
fn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;
fn$5['\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;
fn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;
fn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;
fn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;
fn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;

var elesfn$o = {
  isNode: function isNode() {
    return this.group() === 'nodes';
  },
  isEdge: function isEdge() {
    return this.group() === 'edges';
  },
  isLoop: function isLoop() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function isSimple() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function group() {
    var ele = this[0];

    if (ele) {
      return ele._private.group;
    }
  }
};

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */

var zIndexSort = function zIndexSort(a, b) {
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele) {
    var style = ele.pstyle('z-compound-depth');

    if (style.value === 'auto') {
      return hasCompoundNodes ? ele.zDepth() : 0;
    } else if (style.value === 'bottom') {
      return -1;
    } else if (style.value === 'top') {
      return MAX_INT;
    } // 'orphan'


    return 0;
  }

  var depthDiff = getDepth(a) - getDepth(b);

  if (depthDiff !== 0) {
    return depthDiff;
  }

  function getEleDepth(ele) {
    var style = ele.pstyle('z-index-compare');

    if (style.value === 'auto') {
      return ele.isNode() ? 1 : 0;
    } // 'manual'


    return 0;
  }

  var eleDiff = getEleDepth(a) - getEleDepth(b);

  if (eleDiff !== 0) {
    return eleDiff;
  }

  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;

  if (zDiff !== 0) {
    return zDiff;
  } // compare indices in the core (order added to graph w/ last on top)


  return a.poolIndex() - b.poolIndex();
};

var elesfn$p = {
  forEach: function forEach(fn$1, thisArg) {
    if (fn(fn$1)) {
      var N = this.length;

      for (var i = 0; i < N; i++) {
        var ele = this[i];
        var ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);

        if (ret === false) {
          break;
        } // exit each early on return false

      }
    }

    return this;
  },
  toArray: function toArray() {
    var array = [];

    for (var i = 0; i < this.length; i++) {
      array.push(this[i]);
    }

    return array;
  },
  slice: function slice(start, end) {
    var array = [];
    var thisSize = this.length;

    if (end == null) {
      end = thisSize;
    }

    if (start == null) {
      start = 0;
    }

    if (start < 0) {
      start = thisSize + start;
    }

    if (end < 0) {
      end = thisSize + end;
    }

    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array.push(this[i]);
    }

    return this.spawn(array);
  },
  size: function size() {
    return this.length;
  },
  eq: function eq(i) {
    return this[i] || this.spawn();
  },
  first: function first() {
    return this[0] || this.spawn();
  },
  last: function last() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function empty() {
    return this.length === 0;
  },
  nonempty: function nonempty() {
    return !this.empty();
  },
  sort: function sort(sortFn) {
    if (!fn(sortFn)) {
      return this;
    }

    var sorted = this.toArray().sort(sortFn);
    return this.spawn(sorted);
  },
  sortByZIndex: function sortByZIndex() {
    return this.sort(zIndexSort);
  },
  zDepth: function zDepth() {
    var ele = this[0];

    if (!ele) {
      return undefined;
    } // let cy = ele.cy();


    var _p = ele._private;
    var group = _p.group;

    if (group === 'nodes') {
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if (!ele.isParent()) {
        return MAX_INT - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();
      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
    }
  }
};
elesfn$p.each = elesfn$p.forEach;

var getLayoutDimensionOptions = defaults({
  nodeDimensionsIncludeLabels: false
});
var elesfn$q = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function layoutDimensions(options) {
    options = getLayoutDimensionOptions(options);
    var dims;

    if (!this.takesUpSpace()) {
      dims = {
        w: 0,
        h: 0
      };
    } else if (options.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      dims = {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      dims = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    } // sanitise the dimensions for external layouts (avoid division by zero)


    if (dims.w === 0 || dims.h === 0) {
      dims.w = dims.h = 1;
    }

    return dims;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function layoutPositions(layout, options, fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges

    var getMemoizeKey = function getMemoizeKey(node) {
      return node.id();
    };

    var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function

    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
    layout.animations = [];

    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };
      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

    var spacingBb = function spacingBb() {
      if (!useSpacingFactor) {
        return null;
      }

      var bb = makeBoundingBox();

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = fnMem(node, i);
        expandBoundingBoxByPoint(bb, pos.x, pos.y);
      }

      return bb;
    };

    var bb = spacingBb();
    var getFinalPos = memoize(function (node, i) {
      var newPos = fnMem(node, i);

      if (useSpacingFactor) {
        var spacing = Math.abs(options.spacingFactor);
        newPos = calculateSpacing(spacing, bb, newPos);
      }

      if (options.transform != null) {
        newPos = options.transform(node, newPos);
      }

      return newPos;
    }, getMemoizeKey);

    if (options.animate) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options.animateFilter == null || options.animateFilter(node, i);

        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options.animationDuration,
            easing: options.animationEasing
          });
          layout.animations.push(ani);
        } else {
          node.position(newPos);
        }
      }

      if (options.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(fitAni);
      } else if (options.zoom !== undefined && options.pan !== undefined) {
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(zoomPanAni);
      }

      layout.animations.forEach(function (ani) {
        return ani.play();
      });
      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      Promise$1.all(layout.animations.map(function (ani) {
        return ani.promise();
      })).then(function () {
        layout.one('layoutstop', options.stop);
        layout.emit({
          type: 'layoutstop',
          layout: layout
        });
      });
    } else {
      nodes.positions(getFinalPos);

      if (options.fit) {
        cy.fit(options.eles, options.padding);
      }

      if (options.zoom != null) {
        cy.zoom(options.zoom);
      }

      if (options.pan) {
        cy.pan(options.pan);
      }

      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    }

    return this; // chaining
  },
  layout: function layout(options) {
    var cy = this.cy();
    return cy.makeLayout(extend({}, options, {
      eles: this
    }));
  }
}; // aliases:

elesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;

function styleCache(key, fn, ele) {
  var _p = ele._private;
  var cache = _p.styleCache = _p.styleCache || [];
  var val;

  if ((val = cache[key]) != null) {
    return val;
  } else {
    val = cache[key] = fn(ele);
    return val;
  }
}

function cacheStyleFunction(key, fn) {
  key = hashString(key);
  return function cachedStyleFunction(ele) {
    return styleCache(key, fn, ele);
  };
}

function cachePrototypeStyleFunction(key, fn) {
  key = hashString(key);

  var selfFn = function selfFn(ele) {
    return fn.call(ele);
  };

  return function cachedPrototypeStyleFunction() {
    var ele = this[0];

    if (ele) {
      return styleCache(key, selfFn, ele);
    }
  };
}

var elesfn$r = {
  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer = cy.renderer();
    var styleEnabled = cy.styleEnabled();

    if (renderer && styleEnabled) {
      renderer.recalculateRenderedStyle(this, useCache);
    }

    return this;
  },
  dirtyStyleCache: function dirtyStyleCache() {
    var cy = this.cy();

    var dirty = function dirty(ele) {
      return ele._private.styleCache = null;
    };

    if (cy.hasCompoundNodes()) {
      var eles;
      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
      eles.merge(eles.connectedEdges());
      eles.forEach(dirty);
    } else {
      this.forEach(function (ele) {
        dirty(ele);
        ele.connectedEdges().forEach(dirty);
      });
    }

    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function updateStyle(notifyRenderer) {
    var cy = this._private.cy;

    if (!cy.styleEnabled()) {
      return this;
    }

    if (cy.batching()) {
      var bEles = cy._private.batchStyleEles;
      bEles.merge(this);
      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (hasCompounds) {
      // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }

    var changedEles = style.apply(updatedEles);

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }

    return this; // chaining
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function parsedStyle(property) {
    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var ele = this[0];
    var cy = ele.cy();

    if (!cy.styleEnabled()) {
      return;
    }

    if (ele) {
      var overriddenStyle = ele._private.style[property];

      if (overriddenStyle != null) {
        return overriddenStyle;
      } else if (includeNonDefault) {
        return cy.style().getDefaultProperty(property);
      } else {
        return null;
      }
    }
  },
  numericStyle: function numericStyle(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      var pstyle = ele.pstyle(property);
      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },
  numericStyleUnits: function numericStyleUnits(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      return ele.pstyle(property).units;
    }
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function renderedStyle(property) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var ele = this[0];

    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function style(name, value) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();

    if (plainObject(name)) {
      // then extend the bypass
      var props = name;
      style.applyBypass(this, props, updateTransitions);
      this.emitAndNotify('style'); // let the renderer know we've updated style
    } else if (string(name)) {
      if (value === undefined) {
        // then get the property from the style
        var ele = this[0];

        if (ele) {
          return style.getStylePropertyValue(ele, name);
        } else {
          // empty collection => can't get any value
          return;
        }
      } else {
        // then set the bypass with the property value
        style.applyBypass(this, name, value, updateTransitions);
        this.emitAndNotify('style'); // let the renderer know we've updated style
      }
    } else if (name === undefined) {
      var _ele = this[0];

      if (_ele) {
        return style.getRawStyle(_ele);
      } else {
        // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },
  removeStyle: function removeStyle(names) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if (names === undefined) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        style.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);

      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];
        style.removeBypasses(_ele2, names, updateTransitions);
      }
    }

    this.emitAndNotify('style'); // let the renderer know we've updated style

    return this; // chaining
  },
  show: function show() {
    this.css('display', 'element');
    return this; // chaining
  },
  hide: function hide() {
    this.css('display', 'none');
    return this; // chaining
  },
  effectiveOpacity: function effectiveOpacity() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return 1;
    }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle('opacity').value;

      if (!hasCompoundNodes) {
        return parentOpacity;
      }

      var parents = !_p.data.parent ? null : ele.parents();

      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
          var opacity = parent.pstyle('opacity').value;
          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },
  transparent: function transparent() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if (ele) {
      if (!hasCompoundNodes) {
        return ele.pstyle('opacity').value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },
  backgrounding: function backgrounding() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    return ele._private.backgrounding ? true : false;
  }
};

function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents = _p.data.parent ? ele.parents() : null;

  if (parents) {
    for (var i = 0; i < parents.length; i++) {
      var parent = parents[i];

      if (!parentOk(parent)) {
        return false;
      }
    }
  }

  return true;
}

function defineDerivedStateFunction(specs) {
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;
  return function () {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return true;
    }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele) {
      var _p = ele._private;

      if (!ok(ele)) {
        return false;
      }

      if (ele.isNode()) {
        return !hasCompoundNodes || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;
        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}

var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});
elesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));
var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
});
var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
});
elesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));

elesfn$r.noninteractive = function () {
  var ele = this[0];

  if (ele) {
    return !ele.interactive();
  }
};

var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
});
var edgeVisibleViaNode = eleTakesUpSpace;
elesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));

elesfn$r.hidden = function () {
  var ele = this[0];

  if (ele) {
    return !ele.visible();
  }
};

elesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {
  if (!this.cy().styleEnabled()) {
    return false;
  }

  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();
});
elesfn$r.bypass = elesfn$r.css = elesfn$r.style;
elesfn$r.renderedCss = elesfn$r.renderedStyle;
elesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;
elesfn$r.pstyle = elesfn$r.parsedStyle;

var elesfn$s = {};

function defineSwitchFunction(params) {
  return function () {
    var args = arguments;
    var changedEles = []; // e.g. cy.nodes().select( data, handler )

    if (args.length === 2) {
      var data = args[0];
      var handler = args[1];
      this.on(params.event, data, handler);
    } // e.g. cy.nodes().select( handler )
    else if (args.length === 1 && fn(args[0])) {
        var _handler = args[0];
        this.on(params.event, _handler);
      } // e.g. cy.nodes().select()
      // e.g. (private) cy.nodes().select(['tapselect'])
      else if (args.length === 0 || args.length === 1 && array(args[0])) {
          var addlEvents = args.length === 1 ? args[0] : null;

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var able = !params.ableField || ele._private[params.ableField];
            var changed = ele._private[params.field] != params.value;

            if (params.overrideAble) {
              var overrideAble = params.overrideAble(ele);

              if (overrideAble !== undefined) {
                able = overrideAble;

                if (!overrideAble) {
                  return this;
                } // to save cycles assume not able for all on override

              }
            }

            if (able) {
              ele._private[params.field] = params.value;

              if (changed) {
                changedEles.push(ele);
              }
            }
          }

          var changedColl = this.spawn(changedEles);
          changedColl.updateStyle(); // change of state => possible change of style

          changedColl.emit(params.event);

          if (addlEvents) {
            changedColl.emit(addlEvents);
          }
        }

    return this;
  };
}

function defineSwitchSet(params) {
  elesfn$s[params.field] = function () {
    var ele = this[0];

    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);

        if (val !== undefined) {
          return val;
        }
      }

      return ele._private[params.field];
    }
  };

  elesfn$s[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });
  elesfn$s[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function overrideField(ele) {
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});
defineSwitchSet({
  field: 'grabbable',
  overrideField: function overrideField(ele) {
    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});
defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});
defineSwitchSet({
  field: 'selectable',
  overrideField: function overrideField(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});
elesfn$s.deselect = elesfn$s.unselect;

elesfn$s.grabbed = function () {
  var ele = this[0];

  if (ele) {
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});
defineSwitchSet({
  field: 'pannable',
  on: 'panify',
  off: 'unpanify'
});

elesfn$s.inactive = function () {
  var ele = this[0];

  if (ele) {
    return !ele._private.active;
  }
};

var elesfn$t = {}; // DAG functions
////////////////

var defineDagExtremity = function defineDagExtremity(params) {
  return function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }

      if (!disqualified) {
        ret.push(ele);
      }
    }

    return this.spawn(ret, {
      unique: true
    }).filter(selector);
  };
};

var defineDagOneHop = function defineDagOneHop(params) {
  return function (selector) {
    var eles = this;
    var oEles = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }

    return this.spawn(oEles, {
      unique: true
    }).filter(selector);
  };
};

var defineDagAllHops = function defineDagAllHops(params) {
  return function (selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for (;;) {
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if (next.length === 0) {
        break;
      } // done if none left


      var newNext = false;

      for (var i = 0; i < next.length; i++) {
        var n = next[i];
        var nid = n.id();

        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }

      if (!newNext) {
        break;
      } // done if touched all outgoers already


      eles = next;
    }

    return this.spawn(sEles, {
      unique: true
    }).filter(selector);
  };
};

elesfn$t.clearTraversalCache = function () {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};

extend(elesfn$t, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({
    noIncomingEdges: true
  }),
  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({
    noOutgoingEdges: true
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({
    outgoing: true
  }), 'outgoers'),
  // aka DAG descendants
  successors: defineDagAllHops({
    outgoing: true
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({
    incoming: true
  }), 'incomers'),
  // aka DAG ancestors
  predecessors: defineDagAllHops({
    incoming: true
  })
}); // Neighbourhood functions
//////////////////////////

extend(elesfn$t, {
  neighborhood: cache(function (selector) {
    var elements = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node

      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src; // need check in case of loop

        if (otherNode.length > 0) {
          elements.push(otherNode[0]); // add node 1 hop away
        } // add connected edge


        elements.push(edge[0]);
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }, 'neighborhood'),
  closedNeighborhood: function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  },
  openNeighborhood: function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }
}); // aliases

elesfn$t.neighbourhood = elesfn$t.neighborhood;
elesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;
elesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions
/////////////////

extend(elesfn$t, {
  source: cache(function sourceImpl(selector) {
    var ele = this[0];
    var src;

    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter(selector) : src;
  }, 'source'),
  target: cache(function targetImpl(selector) {
    var ele = this[0];
    var tgt;

    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter(selector) : tgt;
  }, 'target'),
  sources: defineSourceFunction({
    attr: 'source'
  }),
  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction(params) {
  return function sourceImpl(selector) {
    var sources = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];

      if (src) {
        sources.push(src);
      }
    }

    return this.spawn(sources, {
      unique: true
    }).filter(selector);
  };
}

extend(elesfn$t, {
  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),
  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), 'edgesTo')
});

function defineEdgesWithFunction(params) {
  return function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p = params || {}; // get elements if a selector is specified

    if (string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }

    for (var h = 0; h < otherNodes.length; h++) {
      var edges = otherNodes[h]._private.edges;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if (!edgeConnectsThisAndOther) {
          continue;
        }

        if (p.thisIsSrc || p.thisIsTgt) {
          if (p.thisIsSrc && !thisToOther) {
            continue;
          }

          if (p.thisIsTgt && !otherToThis) {
            continue;
          }
        }

        elements.push(edge);
      }
    }

    return this.spawn(elements, {
      unique: true
    });
  };
}

extend(elesfn$t, {
  connectedEdges: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];

      if (!node.isNode()) {
        continue;
      }

      var edges = node._private.edges;

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        retEles.push(edge);
      }
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedEdges'),
  connectedNodes: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];

      if (!edge.isEdge()) {
        continue;
      }

      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedNodes'),
  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),
  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), 'codirectedEdges')
});

function defineParallelEdgesFunction(params) {
  var defaults = {
    codirected: false
  };
  params = extend({}, defaults, params);
  return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params; // look at all the edges in the collection

    for (var i = 0; i < edges.length; i++) {
      var edge1 = edges[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge

      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;
        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  };
} // Misc functions
/////////////////


extend(elesfn$t, {
  components: function components(root) {
    var self = this;
    var cy = self.cy();
    var visited = cy.collection();
    var unvisited = root == null ? self.nodes() : root.nodes();
    var components = [];

    if (root != null && unvisited.empty()) {
      // root may contain only edges
      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
    }

    var visitInComponent = function visitInComponent(node, component) {
      visited.merge(node);
      unvisited.unmerge(node);
      component.merge(node);
    };

    if (unvisited.empty()) {
      return self.spawn();
    }

    var _loop = function _loop() {
      // each iteration yields a component
      var cmpt = cy.collection();
      components.push(cmpt);
      var root = unvisited[0];
      visitInComponent(root, cmpt);
      self.bfs({
        directed: false,
        roots: root,
        visit: function visit(v) {
          return visitInComponent(v, cmpt);
        }
      });
      cmpt.forEach(function (node) {
        node.connectedEdges().forEach(function (e) {
          // connectedEdges() usually cached
          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
            // has() is cheap
            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
          }
        });
      });
    };

    do {
      _loop();
    } while (unvisited.length > 0);

    return components;
  },
  component: function component() {
    var ele = this[0];
    return ele.cy().mutableElements().components(ele)[0];
  }
});
elesfn$t.componentsOf = elesfn$t.components;

var idFactory = {
  generate: function generate(cy, element, tryThisId) {
    var id = tryThisId != null ? tryThisId : uuid();

    while (cy.hasElementWithId(id)) {
      id = uuid();
    }

    return id;
  }
}; // represents a set of nodes, edges, or both together

var Collection = function Collection(cy, elements, options) {
  if (cy === undefined || !core(cy)) {
    error('A collection must have a reference to the core');
    return;
  }

  var map = new Map$1();
  var createdElements = false;

  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
    createdElements = true; // make elements from json and restore all at once later

    var eles = [];
    var elesIds = new Set$1();

    for (var i = 0, l = elements.length; i < l; i++) {
      var json = elements[i];

      if (json.data == null) {
        json.data = {};
      }

      var _data = json.data; // make sure newly created elements have valid ids

      if (_data.id == null) {
        _data.id = idFactory.generate(cy, json);
      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
        continue; // can't create element if prior id already exists
      }

      var ele = new Element(cy, json, false);
      eles.push(ele);
      elesIds.add(_data.id);
    }

    elements = eles;
  }

  this.length = 0;

  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements

    if (element$1 == null) {
      continue;
    }

    var id = element$1._private.data.id;

    if (options == null || options.unique && !map.has(id)) {
      map.set(id, {
        index: this.length,
        ele: element$1
      });
      this[this.length] = element$1;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  }; // restore the elements if we created them from json

  if (createdElements) {
    this.restore();
  }
}; // Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes


var elesfn$u = Element.prototype = Collection.prototype;

elesfn$u.instanceString = function () {
  return 'collection';
};

elesfn$u.spawn = function (cy, eles, opts) {
  if (!core(cy)) {
    // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection(cy, eles, opts);
};

elesfn$u.spawnSelf = function () {
  return this.spawn(this);
};

elesfn$u.cy = function () {
  return this._private.cy;
};

elesfn$u.renderer = function () {
  return this._private.cy.renderer();
};

elesfn$u.element = function () {
  return this[0];
};

elesfn$u.collection = function () {
  if (collection(this)) {
    return this;
  } else {
    // an element
    return new Collection(this._private.cy, [this]);
  }
};

elesfn$u.unique = function () {
  return new Collection(this._private.cy, this, {
    unique: true
  });
};

elesfn$u.hasElementWithId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.has(id);
};

elesfn$u.getElementById = function (id) {
  id = '' + id; // id must be string

  var cy = this._private.cy;

  var entry = this._private.map.get(id);

  return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};

elesfn$u.$id = elesfn$u.getElementById;

elesfn$u.poolIndex = function () {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this[0]._private.data.id;
  return eles._private.map.get(id).index;
};

elesfn$u.indexOf = function (ele) {
  var id = ele[0]._private.data.id;
  return this._private.map.get(id).index;
};

elesfn$u.indexOfId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.get(id).index;
};

elesfn$u.json = function (obj) {
  var ele = this.element();
  var cy = this.cy();

  if (ele == null && obj) {
    return this;
  } // can't set to no eles


  if (ele == null) {
    return undefined;
  } // can't get from no eles


  var p = ele._private;

  if (plainObject(obj)) {
    // set
    cy.startBatch();

    if (obj.data) {
      ele.data(obj.data);
      var _data2 = p.data;

      if (ele.isEdge()) {
        // source and target are immutable via data()
        var move = false;
        var spec = {};
        var src = obj.data.source;
        var tgt = obj.data.target;

        if (src != null && src != _data2.source) {
          spec.source = '' + src; // id must be string

          move = true;
        }

        if (tgt != null && tgt != _data2.target) {
          spec.target = '' + tgt; // id must be string

          move = true;
        }

        if (move) {
          ele = ele.move(spec);
        }
      } else {
        // parent is immutable via data()
        var parent = obj.data.parent;

        if ((parent != null || _data2.parent != null) && parent != _data2.parent) {
          if (parent === undefined) {
            // can't set undefined imperatively, so use null
            parent = null;
          }

          if (parent != null) {
            parent = '' + parent; // id must be string
          }

          ele = ele.move({
            parent: parent
          });
        }
      }
    }

    if (obj.position) {
      ele.position(obj.position);
    } // ignore group -- immutable


    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
      var obj_k = obj[k];

      if (obj_k != null && obj_k !== p[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    };

    checkSwitch('removed', 'remove', 'restore');
    checkSwitch('selected', 'select', 'unselect');
    checkSwitch('selectable', 'selectify', 'unselectify');
    checkSwitch('locked', 'lock', 'unlock');
    checkSwitch('grabbable', 'grabify', 'ungrabify');
    checkSwitch('pannable', 'panify', 'unpanify');

    if (obj.classes != null) {
      ele.classes(obj.classes);
    }

    cy.endBatch();
    return this;
  } else if (obj === undefined) {
    // get
    var json = {
      data: copy(p.data),
      position: copy(p.position),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      pannable: p.pannable,
      classes: null
    };
    json.classes = '';
    var i = 0;
    p.classes.forEach(function (cls) {
      return json.classes += i++ === 0 ? cls : ' ' + cls;
    });
    return json;
  }
};

elesfn$u.jsons = function () {
  var jsons = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    jsons.push(json);
  }

  return jsons;
};

elesfn$u.clone = function () {
  var cy = this.cy();
  var elesArr = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push(clone);
  }

  return new Collection(cy, elesArr);
};

elesfn$u.copy = elesfn$u.clone;

elesfn$u.restore = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private; // create arrays of nodes and edges, since we need to
  // restore the nodes first

  var nodes = [];
  var edges = [];
  var elements;

  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
    var ele = self[_i2];

    if (addToPool && !ele.removed()) {
      // don't need to handle this ele
      continue;
    } // keep nodes first in the array and edges after


    if (ele.isNode()) {
      // put to front of array if node
      nodes.push(ele);
    } else {
      // put to end of array if edge
      edges.push(ele);
    }
  }

  elements = nodes.concat(edges);
  var i;

  var removeFromElements = function removeFromElements() {
    elements.splice(i, 1);
    i--;
  }; // now, restore each element


  for (i = 0; i < elements.length; i++) {
    var _ele = elements[i];
    var _private = _ele._private;
    var _data3 = _private.data; // the traversal cache should start fresh when ele is added

    _ele.clearTraversalCache(); // set id and validate


    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {
      _data3.id = idFactory.generate(cy, _ele);
    } else if (number(_data3.id)) {
      _data3.id = '' + _data3.id; // now it's a string
    } else if (emptyString(_data3.id) || !string(_data3.id)) {
      error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id

      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(_data3.id)) {
      error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id

      removeFromElements();
      continue;
    }

    var id = _data3.id; // id is finalised, now let's keep a ref

    if (_ele.isNode()) {
      // extra checks for nodes
      var pos = _private.position; // make sure the nodes have a defined position

      if (pos.x == null) {
        pos.x = 0;
      }

      if (pos.y == null) {
        pos.y = 0;
      }
    }

    if (_ele.isEdge()) {
      // extra checks for edges
      var edge = _ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;

      for (var j = 0; j < fieldsLength; j++) {
        var field = fields[j];
        var val = _data3[field];

        if (number(val)) {
          val = _data3[field] = '' + _data3[field]; // now string
        }

        if (val == null || val === '') {
          // can't create if source or target is not defined properly
          error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if (badSourceOrTarget) {
        removeFromElements();
        continue;
      } // can't create this


      var src = cy.getElementById(_data3.source);
      var tgt = cy.getElementById(_data3.target); // only one edge in node if loop

      if (src.same(tgt)) {
        src._private.edges.push(edge);
      } else {
        src._private.edges.push(edge);

        tgt._private.edges.push(edge);
      }

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge
    // create mock ids / indexes maps for element so it can be used like collections


    _private.map = new Map$1();

    _private.map.set(id, {
      ele: _ele,
      index: 0
    });

    _private.removed = false;

    if (addToPool) {
      cy.addToPool(_ele);
    }
  } // for each element
  // do compound node sanity checks


  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // each node
    var node = nodes[_i3];
    var _data4 = node._private.data;

    if (number(_data4.parent)) {
      // then automake string
      _data4.parent = '' + _data4.parent;
    }

    var parentId = _data4.parent;
    var specifiedParent = parentId != null;

    if (specifiedParent) {
      var parent = cy.getElementById(parentId);

      if (parent.empty()) {
        // non-existant parent; just remove it
        _data4.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;

        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            // mark self as parent and remove from data
            selfAsParent = true;
            _data4.parent = undefined; // remove parent reference
            // exit or we loop forever

            break;
          }

          ancestor = ancestor.parent();
        }

        if (!selfAsParent) {
          // connect with children
          parent[0]._private.children.push(node);

          node._private.parent = parent[0]; // let the core know we have a compound graph

          cy_p.hasCompoundNodes = true;
        }
      } // else

    } // if specified parent

  } // for each node


  if (elements.length > 0) {
    var restored = new Collection(cy, elements);

    for (var _i4 = 0; _i4 < restored.length; _i4++) {
      var _ele2 = restored[_i4];

      if (_ele2.isNode()) {
        continue;
      } // adding an edge invalidates the traversal caches for the parallel edges


      _ele2.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes


      _ele2.source().clearTraversalCache();

      _ele2.target().clearTraversalCache();
    }

    var toUpdateStyle;

    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);

    if (notifyRenderer) {
      restored.emitAndNotify('add');
    } else if (addToPool) {
      restored.emit('add');
    }
  }

  return self; // chainability
};

elesfn$u.removed = function () {
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn$u.inside = function () {
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn$u.remove = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy; // add connected edges

  function addConnectedEdges(node) {
    var edges = node._private.edges;

    for (var i = 0; i < edges.length; i++) {
      add(edges[i]);
    }
  } // add descendant nodes


  function addChildren(node) {
    var children = node._private.children;

    for (var i = 0; i < children.length; i++) {
      add(children[i]);
    }
  }

  function add(ele) {
    var alreadyAdded = elesToRemoveIds[ele.id()];

    if (removeFromPool && ele.removed() || alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele.id()] = true;
    }

    if (ele.isNode()) {
      elesToRemove.push(ele); // nodes are removed last

      addConnectedEdges(ele);
      addChildren(ele);
    } else {
      elesToRemove.unshift(ele); // edges are removed first
    }
  } // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)


  for (var i = 0, l = self.length; i < l; i++) {
    var ele = self[i];
    add(ele);
  }

  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;
    removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes

    node.clearTraversalCache();
  }

  function removeParallelRef(pllEdge) {
    // removing an edge invalidates the traversal caches for the parallel edges
    pllEdge.clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef(parent, ele) {
    ele = ele[0];
    parent = parent[0];
    var children = parent._private.children;
    var pid = parent.id();
    removeFromArray(children, ele); // remove parent => child ref

    ele._private.parent = null; // remove child => parent ref

    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent);
    }
  }

  self.dirtyCompoundBoundsCache();

  if (removeFromPool) {
    cy.removeFromPool(elesToRemove); // remove from core pool
  }

  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
    var _ele3 = elesToRemove[_i5];

    if (_ele3.isEdge()) {
      // remove references to this edge in its connected nodes
      var src = _ele3.source()[0];

      var tgt = _ele3.target()[0];

      removeEdgeRef(src, _ele3);
      removeEdgeRef(tgt, _ele3);

      var pllEdges = _ele3.parallelEdges();

      for (var j = 0; j < pllEdges.length; j++) {
        var pllEdge = pllEdges[j];
        removeParallelRef(pllEdge);

        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      }
    } else {
      // remove reference to parent
      var parent = _ele3.parent();

      if (parent.length !== 0) {
        removeChildRef(parent, _ele3);
      }
    }

    if (removeFromPool) {
      // mark as removed
      _ele3._private.removed = true;
    }
  } // check to see if we have a compound graph or not


  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;

  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
    var _ele4 = elesStillInside[_i6];

    if (_ele4.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection(this.cy(), elesToRemove);

  if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed
    if (notifyRenderer) {
      removedElements.emitAndNotify('remove');
    } else if (removeFromPool) {
      removedElements.emit('remove');
    }
  } // the parents who were modified by the removal need their style updated


  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
    var _ele5 = alteredParents[_i7];

    if (!removeFromPool || !_ele5.removed()) {
      _ele5.updateStyle();
    }
  }

  return removedElements;
};

elesfn$u.move = function (struct) {
  var cy = this._private.cy;
  var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
  // (our calls to remove/restore do not remove from the graph or make events)

  var notifyRenderer = false;
  var modifyPool = false;

  var toString = function toString(id) {
    return id == null ? id : '' + id;
  }; // id must be string


  if (struct.source !== undefined || struct.target !== undefined) {
    var srcId = toString(struct.source);
    var tgtId = toString(struct.target);
    var srcExists = srcId != null && cy.hasElementWithId(srcId);
    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);

    if (srcExists || tgtExists) {
      cy.batch(function () {
        // avoid duplicate style updates
        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        eles.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data5 = ele._private.data;

          if (ele.isEdge()) {
            if (srcExists) {
              _data5.source = srcId;
            }

            if (tgtExists) {
              _data5.target = tgtId;
            }
          }
        }

        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  } else if (struct.parent !== undefined) {
    // move node to new parent
    var parentId = toString(struct.parent);
    var parentExists = parentId === null || cy.hasElementWithId(parentId);

    if (parentExists) {
      var pidToAssign = parentId === null ? undefined : parentId;
      cy.batch(function () {
        // avoid duplicate style updates
        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        updated.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data6 = ele._private.data;

          if (ele.isNode()) {
            _data6.parent = pidToAssign;
          }
        }

        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  }

  return this;
};

[elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {
  extend(elesfn$u, props);
});

var corefn = {
  add: function add(opts) {
    var elements;
    var cy = this; // add the elements

    if (elementOrCollection(opts)) {
      var eles = opts;

      if (eles._private.cy === cy) {
        // same instance => just restore
        elements = eles.restore();
      } else {
        // otherwise, copy from json
        var jsons = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }

        elements = new Collection(cy, jsons);
      }
    } // specify an array of options
    else if (array(opts)) {
        var _jsons = opts;
        elements = new Collection(cy, _jsons);
      } // specify via opts.nodes and opts.edges
      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
          var elesByGroup = opts;
          var _jsons2 = [];
          var grs = ['nodes', 'edges'];

          for (var _i = 0, il = grs.length; _i < il; _i++) {
            var group = grs[_i];
            var elesArray = elesByGroup[group];

            if (array(elesArray)) {
              for (var j = 0, jl = elesArray.length; j < jl; j++) {
                var json = extend({
                  group: group
                }, elesArray[j]);

                _jsons2.push(json);
              }
            }
          }

          elements = new Collection(cy, _jsons2);
        } // specify options for one element
        else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
          }

    return elements;
  },
  remove: function remove(collection) {
    if (elementOrCollection(collection)) ; else if (string(collection)) {
      var selector = collection;
      collection = this.$(selector);
    }

    return collection.remove();
  }
};

/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4,
      NEWTON_MIN_SLOPE = 0.001,
      SUBDIVISION_PRECISION = 0.0000001,
      SUBDIVISION_MAX_ITERATIONS = 10,
      kSplineTableSize = 11,
      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
      float32ArraySupported = typeof Float32Array !== 'undefined';
  /* Must contain four arguments. */

  if (arguments.length !== 4) {
    return false;
  }
  /* Arguments must be numbers. */


  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }
  /* X values must be in the [0, 1] range. */


  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);
  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }

  function binarySubdivide(aX, aA, aB) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function getTForX(aX) {
    var intervalStart = 0.0,
        currentSample = 1,
        lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
        guessForT = intervalStart + dist * kSampleStepSize,
        initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }

  var _precomputed = false;

  function precompute() {
    _precomputed = true;

    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }

  var f = function f(aX) {
    if (!_precomputed) {
      precompute();
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }

    if (aX === 0) {
      return 0;
    }

    if (aX === 1) {
      return 1;
    }

    return calcBezier(getTForX(aX), mY1, mY2);
  };

  f.getControlPoints = function () {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };

  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";

  f.toString = function () {
    return str;
  };

  return f;
}

/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */

/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
var generateSpringRK4 = function () {
  function springAccelerationForState(state) {
    return -state.tension * state.x - state.friction * state.v;
  }

  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };
    return {
      dx: state.v,
      dv: springAccelerationForState(state)
    };
  }

  function springIntegrateState(state, dt) {
    var a = {
      dx: state.v,
      dv: springAccelerationForState(state)
    },
        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
        d = springEvaluateStateWithDerivative(state, dt, c),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }

  return function springRK4Factory(tension, friction, duration) {
    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration,
        dt,
        last_state;
    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;
    initState.tension = tension;
    initState.friction = friction;
    have_duration = duration !== null;
    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */

    if (have_duration) {
      /* Run the simulation without a duration. */
      time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */

      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }

    for (;;) {
      /* Next/step function .*/
      last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */

      path.push(1 + last_state.x);
      time_lapsed += 16;
      /* If the change threshold is reached, break. */

      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }
    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */


    return !have_duration ? time_lapsed : function (percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  };
}();

var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);
  return function (start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
};

var easings = {
  'linear': function linear(start, end, percent) {
    return start + (end - start) * percent;
  },
  // default easings
  'ease': cubicBezier(0.25, 0.1, 0.25, 1),
  'ease-in': cubicBezier(0.42, 0, 1, 1),
  'ease-out': cubicBezier(0, 0, 0.58, 1),
  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
  // sine
  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),
  // quad
  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),
  // cubic
  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),
  // quart
  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),
  // quint
  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),
  // expo
  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),
  // circ
  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  'spring': function spring(tension, friction, duration) {
    if (duration === 0) {
      // can't get a spring w/ duration 0
      return easings.linear; // duration 0 => jump to end so impl doesn't matter
    }

    var spring = generateSpringRK4(tension, friction, duration);
    return function (start, end, percent) {
      return start + (end - start) * spring(percent);
    };
  },
  'cubic-bezier': cubicBezier
};

function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }

  var val = easingFn(start, end, percent);

  if (type == null) {
    return val;
  }

  if (type.roundValue || type.color) {
    val = Math.round(val);
  }

  if (type.min !== undefined) {
    val = Math.max(val, type.min);
  }

  if (type.max !== undefined) {
    val = Math.min(val, type.max);
  }

  return val;
}

function getValue(prop, spec) {
  if (prop.pfValue != null || prop.value != null) {
    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
      return prop.pfValue;
    } else {
      return prop.value;
    }
  } else {
    return prop;
  }
}

function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  var start = getValue(startProp, propSpec);
  var end = getValue(endProp, propSpec);

  if (number(start) && number(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (array(start) && array(end)) {
    var easedArr = [];

    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];

      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);
        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }

    return easedArr;
  }

  return undefined;
}

function step(self, ani, now, isCore) {
  var isEles = !isCore;
  var _p = self._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (!ani_p.easingImpl) {
    if (pEasing == null) {
      // use default
      ani_p.easingImpl = easings['linear'];
    } else {
      // then define w/ name
      var easingVals;

      if (string(pEasing)) {
        var easingProp = style.parse('transition-timing-function', pEasing);
        easingVals = easingProp.value;
      } else {
        // then assume preparsed array
        easingVals = pEasing;
      }

      var name, args;

      if (string(easingVals)) {
        name = easingVals;
        args = [];
      } else {
        name = easingVals[1];
        args = easingVals.slice(2).map(function (n) {
          return +n;
        });
      }

      if (args.length > 0) {
        // create with args
        if (name === 'spring') {
          args.push(ani_p.duration); // need duration to generate spring
        }

        ani_p.easingImpl = easings[name].apply(null, args);
      } else {
        // static impl by name
        ani_p.easingImpl = easings[name];
      }
    }
  }

  var easing = ani_p.easingImpl;
  var percent;

  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now - startTime) / ani_p.duration;
  }

  if (ani_p.applying) {
    percent = ani_p.progress;
  }

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  if (ani_p.delay == null) {
    // then update
    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;

    if (endPos && isEles && !self.locked()) {
      var newPos = {};

      if (valid(startPos.x, endPos.x)) {
        newPos.x = ease(startPos.x, endPos.x, percent, easing);
      }

      if (valid(startPos.y, endPos.y)) {
        newPos.y = ease(startPos.y, endPos.y, percent, easing);
      }

      self.position(newPos);
    }

    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan = _p.pan;
    var animatingPan = endPan != null && isCore;

    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan.x = ease(startPan.x, endPan.x, percent, easing);
      }

      if (valid(startPan.y, endPan.y)) {
        pan.y = ease(startPan.y, endPan.y, percent, easing);
      }

      self.emit('pan');
    }

    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;

    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
      }

      self.emit('zoom');
    }

    if (animatingPan || animatingZoom) {
      self.emit('viewport');
    }

    var props = ani_p.style;

    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var _name = prop.name;
        var end = prop;
        var start = ani_p.startStyle[_name];
        var propSpec = style.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);
        style.overrideBypass(self, _name, easedVal);
      } // for props


      self.emit('style');
    } // if

  }

  ani_p.progress = percent;
  return percent;
}

function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }

  if (number(start) && number(end)) {
    return true;
  } else if (start && end) {
    return true;
  }

  return false;
}

function startAnimation(self, ani, now, isCore) {
  var ani_p = ani._private;
  ani_p.started = true;
  ani_p.startTime = now - ani_p.progress * ani_p.duration;
}

function stepAll(now, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];

  function stepOne(ele, isCore) {
    var _p = ele._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false; // cancel all animations on display:none ele

    if (!isCore && ele.pstyle('display').value === 'none') {
      // put all current and queue animations in this tick's current list
      // and empty the lists for the element
      current = current.splice(0, current.length).concat(queue.splice(0, queue.length)); // stop all animations

      for (var i = 0; i < current.length; i++) {
        current[i].stop();
      }
    } // if nothing currently animating, get something from the queue


    if (current.length === 0) {
      var next = queue.shift();

      if (next) {
        current.push(next);
      }
    }

    var callbacks = function callbacks(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];
        cb();
      }

      _callbacks.splice(0, _callbacks.length);
    }; // step and remove if done


    for (var _i = current.length - 1; _i >= 0; _i--) {
      var ani = current[_i];
      var ani_p = ani._private;

      if (ani_p.stopped) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.frames);
        continue;
      }

      if (!ani_p.playing && !ani_p.applying) {
        continue;
      } // an apply() while playing shouldn't do anything


      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }

      if (!ani_p.started) {
        startAnimation(ele, ani, now);
      }

      step(ele, ani, now, isCore);

      if (ani_p.applying) {
        ani_p.applying = false;
      }

      callbacks(ani_p.frames);

      if (ani_p.step != null) {
        ani_p.step(now);
      }

      if (ani.completed()) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.completes);
      }

      ranAnis = true;
    }

    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele);
    }

    return ranAnis;
  } // stepElement
  // handle all eles


  var ranEleAni = false;

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);
    ranEleAni = ranEleAni || handledThisEle;
  } // each element


  var ranCoreAni = stepOne(cy, true); // notify renderer

  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      cy.notify('draw', eles);
    } else {
      cy.notify('draw');
    }
  } // remove elements from list of currently animating if its queues are empty


  eles.unmerge(doneEles);
  cy.emit('step');
} // stepAll

var corefn$1 = {
  // pull in animation functions
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop(),
  addToAnimationPool: function addToAnimationPool(eles) {
    var cy = this;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used


    cy._private.aniEles.merge(eles);
  },
  stopAnimationLoop: function stopAnimationLoop() {
    this._private.animationsRunning = false;
  },
  startAnimationLoop: function startAnimationLoop() {
    var cy = this;
    cy._private.animationsRunning = true;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used
    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop


    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }

      requestAnimationFrame(function animationStep(now) {
        stepAll(now, cy);
        headlessStep();
      });
    }

    var renderer = cy.renderer();

    if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
        stepAll(now, cy);
      }, renderer.beforeRenderPriorities.animations);
    } else {
      // manage the animation loop ourselves
      headlessStep(); // first call
    }
  }
};

var emitterOptions$1 = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(cy, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(cy, evt) {
    evt.cy = cy;
    evt.target = cy;
  },
  callbackContext: function callbackContext(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }
};

var argSelector$1 = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$v = {
  createEmitter: function createEmitter() {
    var _p = this._private;

    if (!_p.emitter) {
      _p.emitter = new Emitter(emitterOptions$1, this);
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    this.emitter().on(events, argSelector$1(selector), callback);
    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    this.emitter().removeListener(events, argSelector$1(selector), callback);
    return this;
  },
  removeAllListeners: function removeAllListeners() {
    this.emitter().removeAllListeners();
    return this;
  },
  one: function one(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  once: function once(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  emit: function emit(events, extraParams) {
    this.emitter().emit(events, extraParams);
    return this;
  },
  emitAndNotify: function emitAndNotify(event, eles) {
    this.emit(event);
    this.notify(event, eles);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$v);

var corefn$2 = {
  png: function png(options) {
    var renderer = this._private.renderer;
    options = options || {};
    return renderer.png(options);
  },
  jpg: function jpg(options) {
    var renderer = this._private.renderer;
    options = options || {};
    options.bg = options.bg || '#fff';
    return renderer.jpg(options);
  }
};
corefn$2.jpeg = corefn$2.jpg;

var corefn$3 = {
  layout: function layout(options) {
    var cy = this;

    if (options == null) {
      error('Layout options must be specified to make a layout');
      return;
    }

    if (options.name == null) {
      error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if (Layout == null) {
      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');
      return;
    }

    var eles;

    if (string(options.eles)) {
      eles = cy.$(options.eles);
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout(extend({}, options, {
      cy: cy,
      eles: eles
    }));
    return layout;
  }
};
corefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;

var corefn$4 = {
  notify: function notify(eventName, eventEles) {
    var _p = this._private;

    if (this.batching()) {
      _p.batchNotifications = _p.batchNotifications || {};
      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();

      if (eventEles != null) {
        eles.merge(eventEles);
      }

      return; // notifications are disabled during batching
    }

    if (!_p.notificationsEnabled) {
      return;
    } // exit on disabled


    var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528

    if (this.destroyed() || !renderer) {
      return;
    }

    renderer.notify(eventName, eventEles);
  },
  notifications: function notifications(bool) {
    var p = this._private;

    if (bool === undefined) {
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }

    return this;
  },
  noNotifications: function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  },
  batching: function batching() {
    return this._private.batchCount > 0;
  },
  startBatch: function startBatch() {
    var _p = this._private;

    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }

    if (_p.batchCount === 0) {
      _p.batchStyleEles = this.collection();
      _p.batchNotifications = {};
    }

    _p.batchCount++;
    return this;
  },
  endBatch: function endBatch() {
    var _p = this._private;

    if (_p.batchCount === 0) {
      return this;
    }

    _p.batchCount--;

    if (_p.batchCount === 0) {
      // update style for dirty eles
      _p.batchStyleEles.updateStyle();

      var renderer = this.renderer(); // notify the renderer of queued eles and event types

      Object.keys(_p.batchNotifications).forEach(function (eventName) {
        var eles = _p.batchNotifications[eventName];

        if (eles.empty()) {
          renderer.notify(eventName);
        } else {
          renderer.notify(eventName, eles);
        }
      });
    }

    return this;
  },
  batch: function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();
    return this;
  },
  // for backwards compatibility
  batchData: function batchData(map) {
    var cy = this;
    return this.batch(function () {
      var ids = Object.keys(map);

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = map[id];
        var ele = cy.getElementById(id);
        ele.data(data);
      }
    });
  }
};

var rendererDefaults = defaults({
  hideEdgesOnViewport: false,
  textureOnViewport: false,
  motionBlur: false,
  motionBlurOpacity: 0.05,
  pixelRatio: undefined,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: false,
  showFps: false
});
var corefn$5 = {
  renderTo: function renderTo(context, zoom, pan, pxRatio) {
    var r = this._private.renderer;
    r.renderTo(context, zoom, pan, pxRatio);
    return this;
  },
  renderer: function renderer() {
    return this._private.renderer;
  },
  forceRender: function forceRender() {
    this.notify('draw');
    return this;
  },
  resize: function resize() {
    this.invalidateSize();
    this.emitAndNotify('resize');
    return this;
  },
  initRenderer: function initRenderer(options) {
    var cy = this;
    var RendererProto = cy.extension('renderer', options.name);

    if (RendererProto == null) {
      error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }

    if (options.wheelSensitivity !== undefined) {
      warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    }

    var rOpts = rendererDefaults(options);
    rOpts.cy = cy;
    cy._private.renderer = new RendererProto(rOpts);
    this.notify('init');
  },
  destroyRenderer: function destroyRenderer() {
    var cy = this;
    cy.notify('destroy'); // destroy the renderer

    var domEle = cy.container();

    if (domEle) {
      domEle._cyreg = null;

      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref

    cy.mutableElements().forEach(function (ele) {
      var _p = ele._private;
      _p.rscratch = {};
      _p.rstyle = {};
      _p.animation.current = [];
      _p.animation.queue = [];
    });
  },
  onRender: function onRender(fn) {
    return this.on('render', fn);
  },
  offRender: function offRender(fn) {
    return this.off('render', fn);
  }
};
corefn$5.invalidateDimensions = corefn$5.resize;

var corefn$6 = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function collection(eles, opts) {
    if (string(eles)) {
      return this.$(eles);
    } else if (elementOrCollection(eles)) {
      return eles.collection();
    } else if (array(eles)) {
      return new Collection(this, eles, opts);
    }

    return new Collection(this);
  },
  nodes: function nodes(selector) {
    var nodes = this.$(function (ele) {
      return ele.isNode();
    });

    if (selector) {
      return nodes.filter(selector);
    }

    return nodes;
  },
  edges: function edges(selector) {
    var edges = this.$(function (ele) {
      return ele.isEdge();
    });

    if (selector) {
      return edges.filter(selector);
    }

    return edges;
  },
  // search the graph like jQuery
  $: function $(selector) {
    var eles = this._private.elements;

    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  },
  mutableElements: function mutableElements() {
    return this._private.elements;
  }
}; // aliases

corefn$6.elements = corefn$6.filter = corefn$6.$;

var styfn = {}; // keys for style blocks, e.g. ttfftt

var TRUE = 't';
var FALSE = 'f'; // (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it

styfn.apply = function (eles) {
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if (_p.newStyle) {
    // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};
    self.cleanElements(eles, true);
  }

  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];
    var cxtMeta = self.getContextMeta(ele);

    if (cxtMeta.empty) {
      continue;
    }

    var cxtStyle = self.getContextStyle(cxtMeta);
    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

    if (!_p.newStyle) {
      self.updateTransitions(ele, app.diffProps);
    }

    var hintsDiff = self.updateStyleHints(ele);

    if (hintsDiff) {
      updatedEles.merge(ele);
    }
  } // for elements


  _p.newStyle = false;
  return updatedEles;
};

styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if (cachedVal) {
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === TRUE;
    var newHasCxt = newCxtKey[i] === TRUE;
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
      var props = void 0;

      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if (cxtHasDiffed) {
        props = cxt.properties; // need to check them all
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties; // only need to check mapped
      }

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)

        var laterCxtOverrides = false;

        for (var k = i + 1; k < self.length; k++) {
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === TRUE;

          if (!hasLaterCxt) {
            continue;
          } // can't override unless the context is active


          laterCxtOverrides = laterCxt.properties[prop.name] != null;

          if (laterCxtOverrides) {
            break;
          } // exit early as long as one later context overrides

        }

        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      } // for props

    } // if

  } // for contexts


  cache[dualCxtKey] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function (ele) {
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if (self._private.newStyle) {
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  } // get the cxt key


  for (var i = 0; i < self.length; i++) {
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

    if (contextSelectorMatches) {
      cxtKey += TRUE;
    } else {
      cxtKey += FALSE;
    }
  } // for context


  diffProps = self.getPropertiesDiff(prevKey, cxtKey);
  ele._private.styleCxtKey = cxtKey;
  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
}; // gets a computed ele style object based on matched contexts


styfn.getContextStyle = function (cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy

  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var hasCxt = cxtKey[i] === TRUE;

    if (!hasCxt) {
      continue;
    }

    for (var j = 0; j < cxt.properties.length; j++) {
      var prop = cxt.properties[j];
      style[prop.name] = prop;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};
  var types = self.types;

  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);

    if (!cxtProp) {
      // no context prop means delete
      if (!eleProp) {
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if (eleProp.bypass) {
        cxtProp = {
          name: diffPropName,
          deleteBypassed: true
        };
      } else {
        cxtProp = {
          name: diffPropName,
          "delete": true
        };
      }
    } // save cycles when the context prop doesn't need to be applied


    if (eleProp === cxtProp) {
      continue;
    } // save cycles when a mapped context prop doesn't need to be applied


    if (cxtProp.mapped === types.fn // context prop is function mapper
    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
    && eleProp.mapping != null // ele prop is a concrete value from from a mapper
    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
    ) {
        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy

        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss

        if (fnValue === mapping.prevFnValue) {
          continue;
        }
      }

    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };
    self.applyParsedProperty(ele, cxtProp);
    retDiffProp.next = ele.pstyle(diffPropName);

    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function (ele) {
  var _p = ele._private;
  var self = this;
  var propNames = self.propertyGroupNames;
  var propGrKeys = self.propertyGroupKeys;

  var propHash = function propHash(ele, propNames, seedKey) {
    return self.getPropertiesHash(ele, propNames, seedKey);
  };

  var oldStyleKey = _p.styleKey;

  if (ele.removed()) {
    return false;
  }

  var isNode = _p.group === 'nodes'; // get the style key hashes per prop group
  // but lazily -- only use non-default prop values to reduce the number of hashes
  //

  var overriddenStyles = ele._private.style;
  propNames = Object.keys(overriddenStyles);

  for (var i = 0; i < propGrKeys.length; i++) {
    var grKey = propGrKeys[i];
    _p.styleKeys[grKey] = 0;
  }

  var updateGrKey = function updateGrKey(val, grKey) {
    return _p.styleKeys[grKey] = hashInt(val, _p.styleKeys[grKey]);
  };

  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
    for (var j = 0; j < strVal.length; j++) {
      updateGrKey(strVal.charCodeAt(j), grKey);
    }
  }; // - hashing works on 32 bit ints b/c we use bitwise ops
  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
  // - raise up small numbers so more significant digits are seen by hashing
  // - make small numbers larger than a normal value to avoid collisions
  // - works in practice and it's relatively cheap


  var N = 2000000000;

  var cleanNum = function cleanNum(val) {
    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
  };

  for (var _i = 0; _i < propNames.length; _i++) {
    var name = propNames[_i];
    var parsedProp = overriddenStyles[name];

    if (parsedProp == null) {
      continue;
    }

    var propInfo = this.properties[name];
    var type = propInfo.type;
    var _grKey = propInfo.groupKey;
    var normalizedNumberVal = void 0;

    if (propInfo.hashOverride != null) {
      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
    } else if (parsedProp.pfValue != null) {
      normalizedNumberVal = parsedProp.pfValue;
    } // might not be a number if it allows enums


    var numberVal = propInfo.enums == null ? parsedProp.value : null;
    var haveNormNum = normalizedNumberVal != null;
    var haveUnitedNum = numberVal != null;
    var haveNum = haveNormNum || haveUnitedNum;
    var units = parsedProp.units; // numbers are cheaper to hash than strings
    // 1 hash op vs n hash ops (for length n string)

    if (type.number && haveNum) {
      var v = haveNormNum ? normalizedNumberVal : numberVal;

      if (type.multiple) {
        for (var _i2 = 0; _i2 < v.length; _i2++) {
          updateGrKey(cleanNum(v[_i2]), _grKey);
        }
      } else {
        updateGrKey(cleanNum(v), _grKey);
      }

      if (!haveNormNum && units != null) {
        updateGrKeyWStr(units, _grKey);
      }
    } else {
      updateGrKeyWStr(parsedProp.strValue, _grKey);
    }
  } // overall style key
  //


  var hash = 0;

  for (var _i3 = 0; _i3 < propGrKeys.length; _i3++) {
    var _grKey2 = propGrKeys[_i3];
    var grHash = _p.styleKeys[_grKey2];
    hash = hashInt(grHash, hash);
  }

  _p.styleKey = hash; // label dims
  //

  var labelDimsKey = _p.labelDimsKey = _p.styleKeys.labelDimensions;
  _p.labelKey = propHash(ele, ['label'], labelDimsKey);
  _p.labelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.labelKey);

  if (!isNode) {
    _p.sourceLabelKey = propHash(ele, ['source-label'], labelDimsKey);
    _p.sourceLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.sourceLabelKey);
    _p.targetLabelKey = propHash(ele, ['target-label'], labelDimsKey);
    _p.targetLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.targetLabelKey);
  } // node
  //


  if (isNode) {
    var _p$styleKeys = _p.styleKeys,
        nodeBody = _p$styleKeys.nodeBody,
        nodeBorder = _p$styleKeys.nodeBorder,
        backgroundImage = _p$styleKeys.backgroundImage,
        compound = _p$styleKeys.compound,
        pie = _p$styleKeys.pie;
    _p.nodeKey = hashIntsArray([nodeBorder, backgroundImage, compound, pie], nodeBody);
    _p.hasPie = pie != 0;
  }

  return oldStyleKey !== _p.styleKey;
};

styfn.clearStyleHints = function (ele) {
  var _p = ele._private;
  _p.styleKeys = {};
  _p.styleKey = null;
  _p.labelKey = null;
  _p.labelStyleKey = null;
  _p.sourceLabelKey = null;
  _p.sourceLabelStyleKey = null;
  _p.targetLabelKey = null;
  _p.targetLabelStyleKey = null;
  _p.nodeKey = null;
  _p.hasPie = null;
}; // apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }


styfn.applyParsedProperty = function (ele, parsedProp) {
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var flatProp;
  var types = self.types;
  var type = self.properties[prop.name].type;
  var propIsBypass = prop.bypass;
  var origProp = style[prop.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  var getVal = function getVal(p) {
    if (p == null) {
      return null;
    } else if (p.pfValue != null) {
      return p.pfValue;
    } else {
      return p.value;
    }
  };

  var checkTriggers = function checkTriggers() {
    var fromVal = getVal(origProp);
    var toVal = getVal(prop);
    self.checkTriggers(ele, prop.name, fromVal, toVal);
  }; // edge sanity checks to prevent the client from making serious mistakes


  if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers
  parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks
  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {
    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
  }

  if (prop["delete"]) {
    // delete the property and use the default value on falsey value
    style[prop.name] = undefined;
    checkTriggers();
    return true;
  }

  if (prop.deleteBypassed) {
    // delete the property that the
    if (!origProp) {
      checkTriggers();
      return true; // can't delete if no prop
    } else if (origProp.bypass) {
      // delete bypassed
      origProp.bypassed = undefined;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  } // check if we need to delete the current bypass


  if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
    if (!origProp) {
      checkTriggers();
      return true; // property is already not defined
    } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[prop.name] = origProp.bypassed;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function printMappingErr() {
    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
  }; // put the property in the style objects


  switch (prop.mapped) {
    // flatten the property if mapped
    case types.mapData:
      {
        // flatten the field (e.g. data.foo.bar)
        var fields = prop.field.split('.');
        var fieldVal = _p.data;

        for (var i = 0; i < fields.length && fieldVal; i++) {
          var field = fields[i];
          fieldVal = fieldVal[field];
        }

        if (fieldVal == null) {
          printMappingErr();
          return false;
        }

        var percent;

        if (!number(fieldVal)) {
          // then don't apply and fall back on the existing style
          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');
          return false;
        } else {
          var fieldWidth = prop.fieldMax - prop.fieldMin;

          if (fieldWidth === 0) {
            // safety check -- not strictly necessary as no props of zero range should be passed here
            percent = 0;
          } else {
            percent = (fieldVal - prop.fieldMin) / fieldWidth;
          }
        } // make sure to bound percent value


        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (type.color) {
          var r1 = prop.valueMin[0];
          var r2 = prop.valueMax[0];
          var g1 = prop.valueMin[1];
          var g2 = prop.valueMax[1];
          var b1 = prop.valueMin[2];
          var b2 = prop.valueMax[2];
          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
          flatProp = {
            // colours are simple, so just create the flat property instead of expensive string parsing
            bypass: prop.bypass,
            // we're a bypass if the mapping property is a bypass
            name: prop.name,
            value: clr,
            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
          };
        } else if (type.number) {
          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
        } else {
          return false; // can only map to colours and numbers
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply the property and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }
    // direct mapping

    case types.data:
      {
        // flatten the field (e.g. data.foo.bar)
        var _fields = prop.field.split('.');

        var _fieldVal = _p.data;

        for (var _i4 = 0; _i4 < _fields.length && _fieldVal; _i4++) {
          var _field = _fields[_i4];
          _fieldVal = _fieldVal[_field];
        }

        if (_fieldVal != null) {
          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case types.fn:
      {
        var fn = prop.value;
        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function

        prop.prevFnValue = fnRetVal;

        if (fnRetVal == null) {
          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');
          return false;
        }

        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);

        if (!flatProp) {
          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');
          return false;
        }

        flatProp.mapping = copy(prop); // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case undefined:
      break;
    // just set the property

    default:
      return false;
    // not a valid mapping
  } // if the property is a bypass property, then link the resultant property to the original one


  if (propIsBypass) {
    if (origPropIsBypass) {
      // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else {
      // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[prop.name] = prop; // and set
  } else {
    // prop is not bypass
    if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else {
      // then just replace the old prop with the new one
      style[prop.name] = prop;
    }
  }

  checkTriggers();
  return true;
};

styfn.cleanElements = function (eles, keepBypasses) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    this.clearStyleHints(ele);
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache();

    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style = ele._private.style;
      var propNames = Object.keys(style);

      for (var j = 0; j < propNames.length; j++) {
        var propName = propNames[j];
        var eleProp = style[propName];

        if (eleProp != null) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style[propName] = null;
          }
        }
      }
    }
  }
}; // updates the visual style for all elements (useful for manual style modification after init)


styfn.update = function () {
  var cy = this._private.cy;
  var eles = cy.mutableElements();
  eles.updateStyle();
}; // diffProps : { name => { prev, next } }


styfn.updateTransitions = function (ele, diffProps) {
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle('transition-property').value;
  var duration = ele.pstyle('transition-duration').pfValue;
  var delay = ele.pstyle('transition-delay').pfValue;

  if (props.length > 0 && duration > 0) {
    var style = {}; // build up the style to animate towards

    var anyPrev = false;

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var styProp = ele.pstyle(prop);
      var diffProp = diffProps[prop];

      if (!diffProp) {
        continue;
      }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal = void 0;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if (!fromProp) {
        continue;
      } // consider px values


      if (number(fromProp.pfValue) && number(toProp.pfValue)) {
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy

        initVal = fromProp.pfValue + initDt * diff; // consider numerical values
      } else if (number(fromProp.value) && number(toProp.value)) {
        diff = toProp.value - fromProp.value; // nonzero is truthy

        initVal = fromProp.value + initDt * diff; // consider colour values
      } else if (array(fromProp.value) && array(toProp.value)) {
        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
        initVal = fromProp.strValue;
      } // the previous value is good for an animation only if it's different


      if (diff) {
        style[prop] = toProp.strValue; // to val

        this.applyBypass(ele, prop, initVal); // from val

        anyPrev = true;
      }
    } // end if props allow ani
    // can't transition if there's nothing previous to transition from


    if (!anyPrev) {
      return;
    }

    _p.transitioning = true;
    new Promise$1(function (resolve) {
      if (delay > 0) {
        ele.delayAnimation(delay).play().promise().then(resolve);
      } else {
        resolve();
      }
    }).then(function () {
      return ele.animation({
        style: style,
        duration: duration,
        easing: ele.pstyle('transition-timing-function').value,
        queue: false
      }).play().promise();
    }).then(function () {
      // if( !isBypass ){
      self.removeBypasses(ele, props);
      ele.emitAndNotify('style'); // }

      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify('style');
    _p.transitioning = false;
  }
};

styfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {
  var prop = this.properties[name];
  var triggerCheck = getTrigger(prop);

  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {
    onTrigger(prop);
  }
};

styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
  var _this = this;

  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersZOrder;
  }, function () {
    _this._private.cy.notify('zorder', ele);
  });
};

styfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersBounds;
  }, function (prop) {
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
    // then dirty the pll edge bb cache as well

    if ( // only for beziers -- so performance of other edges isn't affected
    (ele.pstyle('curve-style').value === 'bezier' // already a bezier
    // was just now changed to or from a bezier:
    || name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier')) && prop.triggersBoundsOfParallelBeziers) {
      ele.parallelEdges().forEach(function (pllEdge) {
        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      });
    }
  });
};

styfn.checkTriggers = function (ele, name, fromValue, toValue) {
  ele.dirtyStyleCache();
  this.checkZOrderTrigger(ele, name, fromValue, toValue);
  this.checkBoundsTrigger(ele, name, fromValue, toValue);
};

var styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property

styfn$1.applyBypass = function (eles, name, value, updateTransitions) {
  var self = this;
  var props = [];
  var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them

  if (name === '*' || name === '**') {
    // apply to all property names
    if (value !== undefined) {
      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var _name = prop.name;
        var parsedProp = this.parse(_name, value, true);

        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (string(name)) {
    // then parse the single property
    var _parsedProp = this.parse(name, value, true);

    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (plainObject(name)) {
    // then parse each property
    var specifiedProps = name;
    updateTransitions = value;
    var names = Object.keys(specifiedProps);

    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _value = specifiedProps[_name2];

      if (_value === undefined) {
        // try camel case name too
        _value = specifiedProps[dash2camel(_name2)];
      }

      if (_value !== undefined) {
        var _parsedProp2 = this.parse(_name2, _value, true);

        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    // can't do anything without well defined properties
    return false;
  } // we've failed if there are no valid properties


  if (props.length === 0) {
    return false;
  } // now, apply the bypass properties on the elements


  var ret = false; // return true if at least one succesful bypass applied

  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;

    for (var j = 0; j < props.length; j++) {
      // for each prop
      var _prop = props[j];

      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop.name);
        diffProp = diffProps[_prop.name] = {
          prev: prevProp
        };
      }

      ret = this.applyParsedProperty(ele, _prop) || ret;

      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop.name);
      }
    } // for props


    if (ret) {
      this.updateStyleHints(ele);
    }

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles


  return ret;
}; // only useful in specific cases like animation


styfn$1.overrideBypass = function (eles, name, value) {
  name = camel2dash(name);

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;
    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;

    if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
      this.applyBypass(ele, name, value);
    } else {
      prop.value = value;

      if (prop.pfValue != null) {
        prop.pfValue = value;
      }

      if (isColor) {
        prop.strValue = 'rgb(' + value.join(',') + ')';
      } else if (isMulti) {
        prop.strValue = value.join(' ');
      } else {
        prop.strValue = '' + value;
      }

      this.updateStyleHints(ele);
    }

    this.checkTriggers(ele, name, oldValue, value);
  }
};

styfn$1.removeAllBypasses = function (eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};

styfn$1.removeBypasses = function (eles, props, updateTransitions) {
  var isBypass = true;

  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};

    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop = this.properties[name];
      var prevProp = ele.pstyle(prop.name);

      if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass

      var parsedProp = this.parse(name, value, true);
      var diffProp = diffProps[prop.name] = {
        prev: prevProp
      };
      this.applyParsedProperty(ele, parsedProp);
      diffProp.next = ele.pstyle(prop.name);
    } // for props


    this.updateStyleHints(ele);

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles

};

var styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element

styfn$2.getEmSizeInPixels = function () {
  var px = this.containerCss('font-size');

  if (px != null) {
    return parseFloat(px);
  } else {
    return 1; // for headless
  }
}; // gets css property from the core container


styfn$2.containerCss = function (propName) {
  var cy = this._private.cy;
  var domElement = cy.container();

  if (window$1 && domElement && window$1.getComputedStyle) {
    return window$1.getComputedStyle(domElement).getPropertyValue(propName);
  }
};

var styfn$3 = {}; // gets the rendered style for an element

styfn$3.getRenderedStyle = function (ele, prop) {
  if (prop) {
    return this.getStylePropertyValue(ele, prop, true);
  } else {
    return this.getRawStyle(ele, true);
  }
}; // gets the raw style for an element


styfn$3.getRawStyle = function (ele, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var rstyle = {};

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

      if (val != null) {
        rstyle[prop.name] = val;
        rstyle[dash2camel(prop.name)] = val;
      }
    }

    return rstyle;
  }
};

styfn$3.getIndexedStyle = function (ele, property, subproperty, index) {
  var pstyle = ele.pstyle(property)[subproperty][index];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};

styfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var prop = self.properties[propName];

    if (prop.alias) {
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle(prop.name);

    if (styleProp) {
      var value = styleProp.value,
          units = styleProp.units,
          strValue = styleProp.strValue;

      if (isRenderedVal && type.number && value != null && number(value)) {
        var zoom = ele.cy().zoom();

        var getRenderedValue = function getRenderedValue(val) {
          return val * zoom;
        };

        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {
          return getRenderedValue(val) + units;
        };

        var isArrayValue = array(value);
        var haveUnits = isArrayValue ? units.every(function (u) {
          return u != null;
        }) : units != null;

        if (haveUnits) {
          if (isArrayValue) {
            return value.map(function (v, i) {
              return getValueStringWithUnits(v, units[i]);
            }).join(' ');
          } else {
            return getValueStringWithUnits(value, units);
          }
        } else {
          if (isArrayValue) {
            return value.map(function (v) {
              return string(v) ? v : '' + getRenderedValue(v);
            }).join(' ');
          } else {
            return '' + getRenderedValue(value);
          }
        }
      } else if (strValue != null) {
        return strValue;
      }
    }

    return null;
  }
};

styfn$3.getAnimationStartStyle = function (ele, aniProps) {
  var rstyle = {};

  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;
    var styleProp = ele.pstyle(name);

    if (styleProp !== undefined) {
      // then make a prop of it
      if (plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }

    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }

  return rstyle;
};

styfn$3.getPropsList = function (propsObj) {
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if (style) {
    var names = Object.keys(style);

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style[name];
      var prop = props[name] || props[camel2dash(name)];
      var styleProp = this.parse(prop.name, val);

      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }

  return rstyle;
};

styfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {
  var hash = seed;
  var name, val, strVal, chVal;
  var i, j;

  for (i = 0; i < propNames.length; i++) {
    name = propNames[i];
    val = ele.pstyle(name, false);

    if (val == null) {
      continue;
    } else if (val.pfValue != null) {
      hash = hashInt(chVal, hash);
    } else {
      strVal = val.strValue;

      for (j = 0; j < strVal.length; j++) {
        chVal = strVal.charCodeAt(j);
        hash = hashInt(chVal, hash);
      }
    }
  }

  return hash;
};

styfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;

var styfn$4 = {};

styfn$4.appendFromJson = function (json) {
  var style = this;

  for (var i = 0; i < json.length; i++) {
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);
    style.selector(selector); // apply selector

    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value = props[name];
      style.css(name, value); // apply property
    }
  }

  return style;
}; // accessible cy.style() function


styfn$4.fromJson = function (json) {
  var style = this;
  style.resetToDefault();
  style.appendFromJson(json);
  return style;
}; // get json from cy.style() api


styfn$4.json = function () {
  var json = [];

  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      css[prop.name] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

var styfn$5 = {};

styfn$5.appendFromString = function (string) {
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr; // remove comments from the style string

  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = '';
    }
  }

  for (;;) {
    var nothingLeftToParse = remaining.match(/^\s*$/);

    if (nothingLeftToParse) {
      break;
    }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if (!selAndBlock) {
      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0]; // parse the selector

    var selectorStr = selAndBlock[1];

    if (selectorStr !== 'core') {
      var selector = new Selector(selectorStr);

      if (selector.invalid) {
        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block

        removeSelAndBlockFromRemaining();
        continue;
      }
    } // parse the block of properties and values


    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    for (;;) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);

      if (_nothingLeftToParse) {
        break;
      }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if (!propAndVal) {
        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];
      var prop = self.properties[propStr];

      if (!prop) {
        warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse(propStr, valStr);

      if (!parsedProp) {
        warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    } // put the parsed block in the style


    style.selector(selectorStr);

    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style.css(_prop.name, _prop.val);
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn$5.fromString = function (string) {
  var style = this;
  style.resetToDefault();
  style.appendFromString(string);
  return style;
};

var styfn$6 = {};

(function () {
  var number = number$1;
  var rgba = rgbaNoBackRefs;
  var hsla = hslaNoBackRefs;
  var hex3$1 = hex3;
  var hex6$1 = hex6;

  var data = function data(prefix) {
    return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
  };

  var mapData = function mapData(prefix) {
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it

  styfn$6.types = {
    time: {
      number: true,
      min: 0,
      units: 's|ms',
      implicitUnits: 'ms'
    },
    percent: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%'
    },
    percentages: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%',
      multiple: true
    },
    zeroOneNumber: {
      number: true,
      min: 0,
      max: 1,
      unitless: true
    },
    zeroOneNumbers: {
      number: true,
      min: 0,
      max: 1,
      unitless: true,
      multiple: true
    },
    nOneOneNumber: {
      number: true,
      min: -1,
      max: 1,
      unitless: true
    },
    nonNegativeInt: {
      number: true,
      min: 0,
      integer: true,
      unitless: true
    },
    position: {
      enums: ['parent', 'origin']
    },
    nodeSize: {
      number: true,
      min: 0,
      enums: ['label']
    },
    number: {
      number: true,
      unitless: true
    },
    numbers: {
      number: true,
      unitless: true,
      multiple: true
    },
    positiveNumber: {
      number: true,
      unitless: true,
      min: 0,
      strictMin: true
    },
    size: {
      number: true,
      min: 0
    },
    bidirectionalSize: {
      number: true
    },
    // allows negative
    bidirectionalSizes: {
      number: true,
      multiple: true
    },
    // allows negative
    sizeMaybePercent: {
      number: true,
      min: 0,
      allowPercent: true
    },
    axisDirection: {
      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']
    },
    paddingRelativeTo: {
      enums: ['width', 'height', 'average', 'min', 'max']
    },
    bgWH: {
      number: true,
      min: 0,
      allowPercent: true,
      enums: ['auto'],
      multiple: true
    },
    bgPos: {
      number: true,
      allowPercent: true,
      multiple: true
    },
    bgRelativeTo: {
      enums: ['inner', 'include-padding'],
      multiple: true
    },
    bgRepeat: {
      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
      multiple: true
    },
    bgFit: {
      enums: ['none', 'contain', 'cover'],
      multiple: true
    },
    bgCrossOrigin: {
      enums: ['anonymous', 'use-credentials'],
      multiple: true
    },
    bgClip: {
      enums: ['none', 'node'],
      multiple: true
    },
    color: {
      color: true
    },
    colors: {
      color: true,
      multiple: true
    },
    fill: {
      enums: ['solid', 'linear-gradient', 'radial-gradient']
    },
    bool: {
      enums: ['yes', 'no']
    },
    lineStyle: {
      enums: ['solid', 'dotted', 'dashed']
    },
    lineCap: {
      enums: ['butt', 'round', 'square']
    },
    borderStyle: {
      enums: ['solid', 'dotted', 'dashed', 'double']
    },
    curveStyle: {
      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ['italic', 'normal', 'oblique']
    },
    fontWeight: {
      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ['none', 'underline', 'overline', 'line-through']
    },
    textTransform: {
      enums: ['none', 'uppercase', 'lowercase']
    },
    textWrap: {
      enums: ['none', 'wrap', 'ellipsis']
    },
    textOverflowWrap: {
      enums: ['whitespace', 'anywhere']
    },
    textBackgroundShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle']
    },
    nodeShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']
    },
    compoundIncludeLabels: {
      enums: ['include', 'exclude']
    },
    arrowShape: {
      enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']
    },
    arrowFill: {
      enums: ['filled', 'hollow']
    },
    display: {
      enums: ['element', 'none']
    },
    visibility: {
      enums: ['hidden', 'visible']
    },
    zCompoundDepth: {
      enums: ['bottom', 'orphan', 'auto', 'top']
    },
    zIndexCompare: {
      enums: ['auto', 'manual']
    },
    valign: {
      enums: ['top', 'center', 'bottom']
    },
    halign: {
      enums: ['left', 'center', 'right']
    },
    justification: {
      enums: ['left', 'center', 'right', 'auto']
    },
    text: {
      string: true
    },
    data: {
      mapping: true,
      regex: data('data')
    },
    layoutData: {
      mapping: true,
      regex: data('layoutData')
    },
    scratch: {
      mapping: true,
      regex: data('scratch')
    },
    mapData: {
      mapping: true,
      regex: mapData('mapData')
    },
    mapLayoutData: {
      mapping: true,
      regex: mapData('mapLayoutData')
    },
    mapScratch: {
      mapping: true,
      regex: mapData('mapScratch')
    },
    fn: {
      mapping: true,
      fn: true
    },
    url: {
      regexes: urlRegexes,
      singleRegexMatchValue: true
    },
    urls: {
      regexes: urlRegexes,
      singleRegexMatchValue: true,
      multiple: true
    },
    propList: {
      propList: true
    },
    angle: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad'
    },
    textRotation: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad',
      enums: ['none', 'autorotate']
    },
    polygonPointList: {
      number: true,
      multiple: true,
      evenMultiple: true,
      min: -1,
      max: 1,
      unitless: true
    },
    edgeDistances: {
      enums: ['intersection', 'node-position']
    },
    edgeEndpoint: {
      number: true,
      multiple: true,
      units: '%|px|em|deg|rad',
      implicitUnits: 'px',
      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],
      singleEnum: true,
      validate: function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';

          case 1:
            // can be enum, deg, or rad only
            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';

          default:
            return false;
        }
      }
    },
    easing: {
      regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
    },
    gradientDirection: {
      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']
    },
    boundsExpansion: {
      number: true,
      multiple: true,
      min: 0,
      validate: function validate(valArr) {
        var length = valArr.length;
        return length === 1 || length === 2 || length === 4;
      }
    }
  };
  var diff = {
    zeroNonZero: function zeroNonZero(val1, val2) {
      if ((val1 == null || val2 == null) && val1 !== val2) {
        return true; // null cases could represent any value
      }

      if (val1 == 0 && val2 != 0) {
        return true;
      } else if (val1 != 0 && val2 == 0) {
        return true;
      } else {
        return false;
      }
    },
    any: function any(val1, val2) {
      return val1 != val2;
    }
  }; // define visual style properties
  //
  // - n.b. adding a new group of props may require updates to updateStyleHints()
  // - adding new props to an existing group gets handled automatically

  var t = styfn$6.types;
  var mainLabel = [{
    name: 'label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }];
  var sourceLabel = [{
    name: 'source-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'source-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var targetLabel = [{
    name: 'target-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'target-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var labelDimensions = [{
    name: 'font-family',
    type: t.fontFamily,
    triggersBounds: diff.any
  }, {
    name: 'font-style',
    type: t.fontStyle,
    triggersBounds: diff.any
  }, {
    name: 'font-weight',
    type: t.fontWeight,
    triggersBounds: diff.any
  }, {
    name: 'font-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-transform',
    type: t.textTransform,
    triggersBounds: diff.any
  }, {
    name: 'text-wrap',
    type: t.textWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-overflow-wrap',
    type: t.textOverflowWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-max-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-outline-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'line-height',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }];
  var commonLabel = [{
    name: 'text-valign',
    type: t.valign,
    triggersBounds: diff.any
  }, {
    name: 'text-halign',
    type: t.halign,
    triggersBounds: diff.any
  }, {
    name: 'color',
    type: t.color
  }, {
    name: 'text-outline-color',
    type: t.color
  }, {
    name: 'text-outline-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-color',
    type: t.color
  }, {
    name: 'text-background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-border-color',
    type: t.color
  }, {
    name: 'text-border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-style',
    type: t.borderStyle,
    triggersBounds: diff.any
  }, {
    name: 'text-background-shape',
    type: t.textBackgroundShape,
    triggersBounds: diff.any
  }, {
    name: 'text-justification',
    type: t.justification
  }];
  var behavior = [{
    name: 'events',
    type: t.bool
  }, {
    name: 'text-events',
    type: t.bool
  }];
  var visibility = [{
    name: 'display',
    type: t.display,
    triggersZOrder: diff.any,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'visibility',
    type: t.visibility,
    triggersZOrder: diff.any
  }, {
    name: 'opacity',
    type: t.zeroOneNumber,
    triggersZOrder: diff.zeroNonZero
  }, {
    name: 'text-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'min-zoomed-font-size',
    type: t.size
  }, {
    name: 'z-compound-depth',
    type: t.zCompoundDepth,
    triggersZOrder: diff.any
  }, {
    name: 'z-index-compare',
    type: t.zIndexCompare,
    triggersZOrder: diff.any
  }, {
    name: 'z-index',
    type: t.nonNegativeInt,
    triggersZOrder: diff.any
  }];
  var overlay = [{
    name: 'overlay-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'overlay-color',
    type: t.color
  }, {
    name: 'overlay-opacity',
    type: t.zeroOneNumber,
    triggersBounds: diff.zeroNonZero
  }];
  var transition = [{
    name: 'transition-property',
    type: t.propList
  }, {
    name: 'transition-duration',
    type: t.time
  }, {
    name: 'transition-delay',
    type: t.time
  }, {
    name: 'transition-timing-function',
    type: t.easing
  }];

  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
    if (parsedProp.value === 'label') {
      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
    } else {
      return parsedProp.pfValue;
    }
  };

  var nodeBody = [{
    name: 'height',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'width',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'shape',
    type: t.nodeShape,
    triggersBounds: diff.any
  }, {
    name: 'shape-polygon-points',
    type: t.polygonPointList,
    triggersBounds: diff.any
  }, {
    name: 'background-color',
    type: t.color
  }, {
    name: 'background-fill',
    type: t.fill
  }, {
    name: 'background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'background-blacken',
    type: t.nOneOneNumber
  }, {
    name: 'background-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'background-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'background-gradient-direction',
    type: t.gradientDirection
  }, {
    name: 'padding',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'padding-relative-to',
    type: t.paddingRelativeTo,
    triggersBounds: diff.any
  }, {
    name: 'bounds-expansion',
    type: t.boundsExpansion,
    triggersBounds: diff.any
  }];
  var nodeBorder = [{
    name: 'border-color',
    type: t.color
  }, {
    name: 'border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'border-style',
    type: t.borderStyle
  }];
  var backgroundImage = [{
    name: 'background-image',
    type: t.urls
  }, {
    name: 'background-image-crossorigin',
    type: t.bgCrossOrigin
  }, {
    name: 'background-image-opacity',
    type: t.zeroOneNumbers
  }, {
    name: 'background-position-x',
    type: t.bgPos
  }, {
    name: 'background-position-y',
    type: t.bgPos
  }, {
    name: 'background-width-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-height-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-repeat',
    type: t.bgRepeat
  }, {
    name: 'background-fit',
    type: t.bgFit
  }, {
    name: 'background-clip',
    type: t.bgClip
  }, {
    name: 'background-width',
    type: t.bgWH
  }, {
    name: 'background-height',
    type: t.bgWH
  }, {
    name: 'background-offset-x',
    type: t.bgPos
  }, {
    name: 'background-offset-y',
    type: t.bgPos
  }];
  var compound = [{
    name: 'position',
    type: t.position,
    triggersBounds: diff.any
  }, {
    name: 'compound-sizing-wrt-labels',
    type: t.compoundIncludeLabels,
    triggersBounds: diff.any
  }, {
    name: 'min-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-left',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-right',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-top',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-bottom',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }];
  var edgeLine = [{
    name: 'line-style',
    type: t.lineStyle
  }, {
    name: 'line-color',
    type: t.color
  }, {
    name: 'line-fill',
    type: t.fill
  }, {
    name: 'line-cap',
    type: t.lineCap
  }, {
    name: 'line-dash-pattern',
    type: t.numbers
  }, {
    name: 'line-dash-offset',
    type: t.number
  }, {
    name: 'line-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'line-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'curve-style',
    type: t.curveStyle,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'haystack-radius',
    type: t.zeroOneNumber,
    triggersBounds: diff.any
  }, {
    name: 'source-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'target-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'control-point-step-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'control-point-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'control-point-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'segment-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'segment-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn-min-distance',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'taxi-direction',
    type: t.axisDirection,
    triggersBounds: diff.any
  }, {
    name: 'edge-distances',
    type: t.edgeDistances,
    triggersBounds: diff.any
  }, {
    name: 'arrow-scale',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }, {
    name: 'loop-direction',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'loop-sweep',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'source-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'target-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }];
  var ghost = [{
    name: 'ghost',
    type: t.bool,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-opacity',
    type: t.zeroOneNumber
  }];
  var core = [{
    name: 'selection-box-color',
    type: t.color
  }, {
    name: 'selection-box-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'selection-box-border-color',
    type: t.color
  }, {
    name: 'selection-box-border-width',
    type: t.size
  }, {
    name: 'active-bg-color',
    type: t.color
  }, {
    name: 'active-bg-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'active-bg-size',
    type: t.size
  }, {
    name: 'outside-texture-bg-color',
    type: t.color
  }, {
    name: 'outside-texture-bg-opacity',
    type: t.zeroOneNumber
  }]; // pie backgrounds for nodes

  var pie = [];
  styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)

  pie.push({
    name: 'pie-size',
    type: t.sizeMaybePercent
  });

  for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
    pie.push({
      name: 'pie-' + i + '-background-color',
      type: t.color
    });
    pie.push({
      name: 'pie-' + i + '-background-size',
      type: t.percent
    });
    pie.push({
      name: 'pie-' + i + '-background-opacity',
      type: t.zeroOneNumber
    });
  } // edge arrows


  var edgeArrow = [];
  var arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [{
    name: 'arrow-shape',
    type: t.arrowShape,
    triggersBounds: diff.any
  }, {
    name: 'arrow-color',
    type: t.color
  }, {
    name: 'arrow-fill',
    type: t.arrowFill
  }].forEach(function (prop) {
    arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var type = prop.type,
          triggersBounds = prop.triggersBounds;
      edgeArrow.push({
        name: name,
        type: type,
        triggersBounds: triggersBounds
      });
    });
  }, {});
  var props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
  var propGroups = styfn$6.propertyGroups = {
    // common to all eles
    behavior: behavior,
    transition: transition,
    visibility: visibility,
    overlay: overlay,
    ghost: ghost,
    // labels
    commonLabel: commonLabel,
    labelDimensions: labelDimensions,
    mainLabel: mainLabel,
    sourceLabel: sourceLabel,
    targetLabel: targetLabel,
    // node props
    nodeBody: nodeBody,
    nodeBorder: nodeBorder,
    backgroundImage: backgroundImage,
    pie: pie,
    compound: compound,
    // edge props
    edgeLine: edgeLine,
    edgeArrow: edgeArrow,
    core: core
  };
  var propGroupNames = styfn$6.propertyGroupNames = {};
  var propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);
  propGroupKeys.forEach(function (key) {
    propGroupNames[key] = propGroups[key].map(function (prop) {
      return prop.name;
    });
    propGroups[key].forEach(function (prop) {
      return prop.groupKey = key;
    });
  }); // define aliases

  var aliases = styfn$6.aliases = [{
    name: 'content',
    pointsTo: 'label'
  }, {
    name: 'control-point-distance',
    pointsTo: 'control-point-distances'
  }, {
    name: 'control-point-weight',
    pointsTo: 'control-point-weights'
  }, {
    name: 'edge-text-rotation',
    pointsTo: 'text-rotation'
  }, {
    name: 'padding-left',
    pointsTo: 'padding'
  }, {
    name: 'padding-right',
    pointsTo: 'padding'
  }, {
    name: 'padding-top',
    pointsTo: 'padding'
  }, {
    name: 'padding-bottom',
    pointsTo: 'padding'
  }]; // list of property names

  styfn$6.propertyNames = props.map(function (p) {
    return p.name;
  }); // allow access of properties by name ( e.g. style.properties.height )

  for (var _i = 0; _i < props.length; _i++) {
    var prop = props[_i];
    props[prop.name] = prop; // allow lookup by name
  } // map aliases


  for (var _i2 = 0; _i2 < aliases.length; _i2++) {
    var alias = aliases[_i2];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    }; // add alias prop for parsing

    props.push(aliasProp);
    props[alias.name] = aliasProp; // allow lookup by name
  }
})();

styfn$6.getDefaultProperty = function (name) {
  return this.getDefaultProperties()[name];
};

styfn$6.getDefaultProperties = function () {
  var _p = this._private;

  if (_p.defaultProperties != null) {
    return _p.defaultProperties;
  }

  var rawProps = extend({
    // core props
    'selection-box-color': '#ddd',
    'selection-box-opacity': 0.65,
    'selection-box-border-color': '#aaa',
    'selection-box-border-width': 1,
    'active-bg-color': 'black',
    'active-bg-opacity': 0.15,
    'active-bg-size': 30,
    'outside-texture-bg-color': '#000',
    'outside-texture-bg-opacity': 0.125,
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'text-justification': 'auto',
    'line-height': 1,
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-overflow-wrap': 'whitespace',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',
    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-fill': 'solid',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-offset-x': 0,
    'background-offset-y': 0,
    'background-width-relative-to': 'include-padding',
    'background-height-relative-to': 'include-padding',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
    'bounds-expansion': 0,
    // node gradient
    'background-gradient-direction': 'to-bottom',
    'background-gradient-stop-colors': '#999',
    'background-gradient-stop-positions': '0%',
    // ghost props
    'ghost': 'no',
    'ghost-offset-y': 0,
    'ghost-offset-x': 0,
    'ghost-opacity': 0,
    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [{
    name: 'pie-{{i}}-background-color',
    value: 'black'
  }, {
    name: 'pie-{{i}}-background-size',
    value: '0%'
  }, {
    name: 'pie-{{i}}-background-opacity',
    value: 1
  }].reduce(function (css, prop) {
    for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
      var name = prop.name.replace('{{i}}', i);
      var val = prop.value;
      css[name] = val;
    }

    return css;
  }, {}), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'line-fill': 'solid',
    'line-cap': 'butt',
    'line-gradient-stop-colors': '#999',
    'line-gradient-stop-positions': '0%',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'taxi-turn': '50%',
    'taxi-turn-min-distance': 10,
    'taxi-direction': 'auto',
    'edge-distances': 'intersection',
    'curve-style': 'haystack',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-45deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node',
    'line-dash-pattern': [6, 3],
    'line-dash-offset': 0
  }, [{
    name: 'arrow-shape',
    value: 'none'
  }, {
    name: 'arrow-color',
    value: '#999'
  }, {
    name: 'arrow-fill',
    value: 'filled'
  }].reduce(function (css, prop) {
    styfn$6.arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var val = prop.value;
      css[name] = val;
    });
    return css;
  }, {}));
  var parsedProps = {};

  for (var i = 0; i < this.properties.length; i++) {
    var prop = this.properties[i];

    if (prop.pointsTo) {
      continue;
    }

    var name = prop.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);
    parsedProps[name] = parsedProp;
  }

  _p.defaultProperties = parsedProps;
  return _p.defaultProperties;
};

styfn$6.addDefaultStylesheet = function () {
  this.selector(':parent').css({
    'shape': 'rectangle',
    'padding': 10,
    'background-color': '#eee',
    'border-color': '#ccc',
    'border-width': 1
  }).selector('edge').css({
    'width': 3
  }).selector(':loop').css({
    'curve-style': 'bezier'
  }).selector('edge:compound').css({
    'curve-style': 'bezier',
    'source-endpoint': 'outside-to-line',
    'target-endpoint': 'outside-to-line'
  }).selector(':selected').css({
    'background-color': '#0169D9',
    'line-color': '#0169D9',
    'source-arrow-color': '#0169D9',
    'target-arrow-color': '#0169D9',
    'mid-source-arrow-color': '#0169D9',
    'mid-target-arrow-color': '#0169D9'
  }).selector(':parent:selected').css({
    'background-color': '#CCE1F9',
    'border-color': '#aec8e5'
  }).selector(':active').css({
    'overlay-color': 'black',
    'overlay-padding': 10,
    'overlay-opacity': 0.25
  });
  this.defaultLength = this.length;
};

var styfn$7 = {}; // a caching layer for property parsing

styfn$7.parse = function (name, value, propIsBypass, propIsFlat) {
  var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway

  if (fn(value)) {
    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
  var bypassKey = propIsBypass ? 't' : 'f';
  var valueKey = '' + value;
  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
  var propCache = self.propCache = self.propCache || [];
  var ret;

  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element


  if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
    ret = copy(ret);

    if (ret) {
      ret.value = copy(ret.value); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

  if (!prop && value != null) {
    warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
  }

  return prop;
}; // parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property


styfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {
  var self = this;
  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[name];
  var passedValue = value;
  var types = self.types;

  if (!property) {
    return null;
  } // return null on property of unknown name


  if (value === undefined) {
    return null;
  } // can't assign undefined
  // the property may be an alias


  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = string(value);

  if (valueIsString) {
    // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;

  if (!type) {
    return null;
  } // no type, no luck
  // check if bypass is null or empty string (i.e. indication to delete bypass property)


  if (propIsBypass && (value === '' || value === null)) {
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  } // check if value is a function used as a mapper


  if (fn(value)) {
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  } // check if value is mapped


  var data, mapData;

  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    var mapped = types.data;
    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };
  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    if (type.multiple) {
      return false;
    } // impossible to map to num


    var _mapped = types.mapData; // we can map only if the type is a colour or a number

    if (!(type.color || type.number)) {
      return false;
    }

    var valueMin = this.parse(name, mapData[4]); // parse to validate

    if (!valueMin || valueMin.mapped) {
      return false;
    } // can't be invalid or mapped


    var valueMax = this.parse(name, mapData[5]); // parse to validate

    if (!valueMax || valueMax.mapped) {
      return false;
    } // can't be invalid or mapped
    // check if valueMin and valueMax are the same


    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');
      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;
      var same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
      c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
      c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

      if (same) {
        return false;
      } // can't make a mapper without a range

    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]),
      // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if (type.multiple && propIsFlat !== 'multiple') {
    var vals;

    if (valueIsString) {
      vals = value.split(/\s+/);
    } else if (array(value)) {
      vals = value;
    } else {
      vals = [value];
    }

    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var strVal = '';
    var hasEnum = false;

    for (var i = 0; i < vals.length; i++) {
      var p = self.parse(name, vals[i], propIsBypass, 'multiple');
      hasEnum = hasEnum || string(p.value);
      valArr.push(p.value);
      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
      unitsArr.push(p.units);
      strVal += (i > 0 ? ' ' : '') + p.strValue;
    }

    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }

    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && string(valArr[0])) {
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: strVal,
      bypass: propIsBypass,
      units: unitsArr
    };
  } // several types also allow enums


  var checkEnums = function checkEnums() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];

      if (en === value) {
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  }; // check the type and return the appropriate object


  if (type.number) {
    var units;
    var implicitUnits = 'px'; // not set => px

    if (type.units) {
      // use specified units if set
      units = type.units;
    }

    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }

    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');

        if (units) {
          unitsRegex = units;
        } // only allow explicit units if so set


        var match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');

        if (match) {
          value = match[1];
          units = match[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid

    if (isNaN(value) && type.enums === undefined) {
      return null;
    } // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)


    if (isNaN(value) && type.enums !== undefined) {
      value = passedValue;
      return checkEnums();
    } // check if value must be an integer


    if (type.integer && !integer(value)) {
      return null;
    } // check value is within range


    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    }; // normalise value in pixels

    if (type.unitless || units !== 'px' && units !== 'em') {
      ret.pfValue = value;
    } else {
      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
    } // normalise value in ms


    if (units === 'ms' || units === 's') {
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    } // normalise value in rad


    if (units === 'deg' || units === 'rad') {
      ret.pfValue = units === 'rad' ? value : deg2rad(value);
    } // normalize value in %


    if (units === '%') {
      ret.pfValue = value / 100;
    }

    return ret;
  } else if (type.propList) {
    var props = [];
    var propsStr = '' + value;

    if (propsStr === 'none') ; else {
      // go over each prop
      var propsSplit = propsStr.split(/\s*,\s*|\s+/);

      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();

        if (self.properties[propName]) {
          props.push(propName);
        } else {
          warn('`' + propName + '` is not a valid property name');
        }
      }

      if (props.length === 0) {
        return null;
      }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(' '),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple = color2tuple(value);

    if (!tuple) {
      return null;
    }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',
      // n.b. no spaces b/c of multiple support
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {
    // first check enums
    if (type.enums) {
      var enumProp = checkEnums();

      if (enumProp) {
        return enumProp;
      }
    }

    var regexes = type.regexes ? type.regexes : [type.regex];

    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex = new RegExp(regexes[_i3]); // make a regex from the type string

      var m = regex.exec(value);

      if (m) {
        // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null; // didn't match any
  } else if (type.string) {
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    // check enums last because it's a combo type in others
    return checkEnums();
  } else {
    return null; // not a type we can handle
  }
};

var Style = function Style(cy) {
  if (!(this instanceof Style)) {
    return new Style(cy);
  }

  if (!core(cy)) {
    error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };
  this.length = 0;
  this.resetToDefault();
};

var styfn$8 = Style.prototype;

styfn$8.instanceString = function () {
  return 'style';
}; // remove all contexts


styfn$8.clear = function () {
  for (var i = 0; i < this.length; i++) {
    this[i] = undefined;
  }

  this.length = 0;
  var _p = this._private;
  _p.newStyle = true;
  return this; // chaining
};

styfn$8.resetToDefault = function () {
  this.clear();
  this.addDefaultStylesheet();
  return this;
}; // builds a style object for the 'core' selector


styfn$8.core = function (propName) {
  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
}; // create a new context from the specified selector string and switch to that context


styfn$8.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);
  var i = this.length++; // new context means new index

  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };
  return this; // chaining
}; // add one or many css rules to the current context


styfn$8.css = function () {
  var self = this;
  var args = arguments;

  if (args.length === 1) {
    var map = args[0];

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var mapVal = map[prop.name];

      if (mapVal === undefined) {
        mapVal = map[dash2camel(prop.name)];
      }

      if (mapVal !== undefined) {
        this.cssRule(prop.name, mapVal);
      }
    }
  } else if (args.length === 2) {
    this.cssRule(args[0], args[1]);
  } // do nothing if args are invalid


  return this; // chaining
};

styfn$8.style = styfn$8.css; // add a single css rule to the current context

styfn$8.cssRule = function (name, value) {
  // name-value pair
  var property = this.parse(name, value); // add property to current context if valid

  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property; // allow access by name as well

    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }

    if (property.mapped) {
      this[i].mappedProperties.push(property);
    } // add to core style if necessary


    var currentSelectorIsCore = !this[i].selector;

    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }

  return this; // chaining
};

styfn$8.append = function (style) {
  if (stylesheet(style)) {
    style.appendToStyle(this);
  } else if (array(style)) {
    this.appendFromJson(style);
  } else if (string(style)) {
    this.appendFromString(style);
  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts


  return this;
}; // static function


Style.fromJson = function (cy, json) {
  var style = new Style(cy);
  style.fromJson(json);
  return style;
};

Style.fromString = function (cy, string) {
  return new Style(cy).fromString(string);
};

[styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {
  extend(styfn$8, props);
});
Style.types = styfn$8.types;
Style.properties = styfn$8.properties;
Style.propertyGroups = styfn$8.propertyGroups;
Style.propertyGroupNames = styfn$8.propertyGroupNames;
Style.propertyGroupKeys = styfn$8.propertyGroupKeys;

var corefn$7 = {
  style: function style(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);
      s.update();
    }

    return this._private.style;
  },
  setStyle: function setStyle(style) {
    var _p = this._private;

    if (stylesheet(style)) {
      _p.style = style.generateStyle(this);
    } else if (array(style)) {
      _p.style = Style.fromJson(this, style);
    } else if (string(style)) {
      _p.style = Style.fromString(this, style);
    } else {
      _p.style = Style(this);
    }

    return _p.style;
  }
};

var defaultSelectionType = 'single';
var corefn$8 = {
  autolock: function autolock(bool) {
    if (bool !== undefined) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },
  autoungrabify: function autoungrabify(bool) {
    if (bool !== undefined) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },
  autounselectify: function autounselectify(bool) {
    if (bool !== undefined) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },
  selectionType: function selectionType(selType) {
    var _p = this._private;

    if (_p.selectionType == null) {
      _p.selectionType = defaultSelectionType;
    }

    if (selType !== undefined) {
      if (selType === 'additive' || selType === 'single') {
        _p.selectionType = selType;
      }
    } else {
      return _p.selectionType;
    }

    return this;
  },
  panningEnabled: function panningEnabled(bool) {
    if (bool !== undefined) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },
  userPanningEnabled: function userPanningEnabled(bool) {
    if (bool !== undefined) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },
  zoomingEnabled: function zoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },
  userZoomingEnabled: function userZoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },
  boxSelectionEnabled: function boxSelectionEnabled(bool) {
    if (bool !== undefined) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },
  pan: function pan() {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch (args.length) {
      case 0:
        // .pan()
        return pan;

      case 1:
        if (string(args[0])) {
          // .pan('x')
          dim = args[0];
          return pan[dim];
        } else if (plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
          if (!this._private.panningEnabled) {
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x = x;
          }

          if (number(y)) {
            pan.y = y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .pan('x', 100)
        if (!this._private.panningEnabled) {
          return this;
        }

        dim = args[0];
        val = args[1];

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] = val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  panBy: function panBy(arg0, arg1) {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if (!this._private.panningEnabled) {
      return this;
    }

    switch (args.length) {
      case 1:
        if (plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x += x;
          }

          if (number(y)) {
            pan.y += y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .panBy('x', 100)
        dim = arg0;
        val = arg1;

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] += val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  fit: function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);

    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;
      this.emit('pan zoom viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getFitViewport: function getFitViewport(elements, padding) {
    if (number(elements) && padding === undefined) {
      // elements is optional
      padding = elements;
      elements = undefined;
    }

    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }

    var bb;

    if (string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (boundingBox(elements)) {
      // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elementOrCollection(elements) && elements.empty()) {
      return;
    } // can't fit to nothing


    bb = bb || elements.boundingBox();
    var w = this.width();
    var h = this.height();
    var zoom;
    padding = number(padding) ? padding : 0;

    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom

      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
      var pan = {
        // now pan to middle
        x: (w - zoom * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom * (bb.y1 + bb.y2)) / 2
      };
      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },
  zoomRange: function zoomRange(min, max) {
    var _p = this._private;

    if (max == null) {
      var opts = min;
      min = opts.min;
      max = opts.max;
    }

    if (number(min) && number(max) && min <= max) {
      _p.minZoom = min;
      _p.maxZoom = max;
    } else if (number(min) && max === undefined && min <= _p.maxZoom) {
      _p.minZoom = min;
    } else if (number(max) && min === undefined && max >= _p.minZoom) {
      _p.maxZoom = max;
    }

    return this;
  },
  minZoom: function minZoom(zoom) {
    if (zoom === undefined) {
      return this._private.minZoom;
    } else {
      return this.zoomRange({
        min: zoom
      });
    }
  },
  maxZoom: function maxZoom(zoom) {
    if (zoom === undefined) {
      return this._private.maxZoom;
    } else {
      return this.zoomRange({
        max: zoom
      });
    }
  },
  getZoomedViewport: function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos; // in rendered px

    var zoom;
    var bail = false;

    if (!_p.zoomingEnabled) {
      // zooming disabled
      bail = true;
    }

    if (number(params)) {
      // then set the zoom
      zoom = params;
    } else if (plainObject(params)) {
      // then zoom about a point
      zoom = params.level;

      if (params.position != null) {
        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }

      if (pos != null && !_p.panningEnabled) {
        // panning disabled
        bail = true;
      }
    } // crop zoom


    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
    zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params

    if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {
      return null;
    }

    if (pos != null) {
      // set zoom about position
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom2 = zoom;
      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };
      return {
        zoomed: true,
        panned: true,
        zoom: zoom2,
        pan: pan2
      };
    } else {
      // just set the zoom
      return {
        zoomed: true,
        panned: false,
        zoom: zoom,
        pan: currentPan
      };
    }
  },
  zoom: function zoom(params) {
    if (params === undefined) {
      // get
      return this._private.zoom;
    } else {
      // set
      var vp = this.getZoomedViewport(params);
      var _p = this._private;

      if (vp == null || !vp.zoomed) {
        return this;
      }

      _p.zoom = vp.zoom;

      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }

      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');
      this.notify('viewport');
      return this; // chaining
    }
  },
  viewport: function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger

    var zoomFailed = false;
    var panFailed = false;

    if (!opts) {
      return this;
    }

    if (!number(opts.zoom)) {
      zoomDefd = false;
    }

    if (!plainObject(opts.pan)) {
      panDefd = false;
    }

    if (!zoomDefd && !panDefd) {
      return this;
    }

    if (zoomDefd) {
      var z = opts.zoom;

      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;
        events.push('zoom');
      }
    }

    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p = opts.pan;

      if (number(p.x)) {
        _p.pan.x = p.x;
        panFailed = false;
      }

      if (number(p.y)) {
        _p.pan.y = p.y;
        panFailed = false;
      }

      if (!panFailed) {
        events.push('pan');
      }
    }

    if (events.length > 0) {
      events.push('viewport');
      this.emit(events.join(' '));
      this.notify('viewport');
    }

    return this; // chaining
  },
  center: function center(elements) {
    var pan = this.getCenterPan(elements);

    if (pan) {
      this._private.pan = pan;
      this.emit('pan viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getCenterPan: function getCenterPan(elements, zoom) {
    if (!this._private.panningEnabled) {
      return;
    }

    if (string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elements.length === 0) {
      return;
    } // can't centre pan to nothing


    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;
    var pan = {
      // middle
      x: (w - zoom * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom * (bb.y1 + bb.y2)) / 2
    };
    return pan;
  },
  reset: function reset() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }

    this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    });
    return this; // chaining
  },
  invalidateSize: function invalidateSize() {
    this._private.sizeCache = null;
  },
  size: function size() {
    var _p = this._private;
    var container = _p.container;
    return _p.sizeCache = _p.sizeCache || (container ? function () {
      var style = window$1.getComputedStyle(container);

      var val = function val(name) {
        return parseFloat(style.getPropertyValue(name));
      };

      return {
        width: container.clientWidth - val('padding-left') - val('padding-right'),
        height: container.clientHeight - val('padding-top') - val('padding-bottom')
      };
    }() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function width() {
    return this.size().width;
  },
  height: function height() {
    return this.size().height;
  },
  extent: function extent() {
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();
    var b = {
      x1: (rb.x1 - pan.x) / zoom,
      x2: (rb.x2 - pan.x) / zoom,
      y1: (rb.y1 - pan.y) / zoom,
      y2: (rb.y2 - pan.y) / zoom
    };
    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;
    return b;
  },
  renderedExtent: function renderedExtent() {
    var width = this.width();
    var height = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
}; // aliases

corefn$8.centre = corefn$8.center; // backwards compatibility

corefn$8.autolockNodes = corefn$8.autolock;
corefn$8.autoungrabifyNodes = corefn$8.autoungrabify;

var fn$6 = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })
}; // aliases

fn$6.attr = fn$6.data;
fn$6.removeAttr = fn$6.removeData;

var Core = function Core(opts) {
  var cy = this;
  opts = extend({}, opts);
  var container = opts.container; // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })

  if (container && !htmlElement(container) && htmlElement(container[0])) {
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery

  reg = reg || {};

  if (reg && reg.cy) {
    reg.cy.destroy();
    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if (container) {
    container._cyreg = reg;
  } // make sure container assoc'd reg points to this cy


  reg.cy = cy;
  var head = window$1 !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = extend({
    name: head ? 'grid' : 'null'
  }, options.layout);
  options.renderer = extend({
    name: head ? 'canvas' : 'null'
  }, options.renderer);

  var defVal = function defVal(def, val, altVal) {
    if (val !== undefined) {
      return val;
    } else if (altVal !== undefined) {
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container,
    // html dom ele container
    ready: false,
    // whether ready has been triggered
    options: options,
    // cached options
    elements: new Collection(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new Collection(this),
    // elements being animated
    data: {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false,
    // whether destroy was called
    notificationsEnabled: true,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: number(options.zoom) ? options.zoom : 1,
    pan: {
      x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,
      y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  this.createEmitter(); // set selection type

  this.selectionType(options.selectionType); // init zoom bounds

  this.zoomRange({
    min: options.minZoom,
    max: options.maxZoom
  });

  var loadExtData = function loadExtData(extData, next) {
    var anyIsPromise = extData.some(promise);

    if (anyIsPromise) {
      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
    } else {
      next(extData); // exec synchronously for convenience
    }
  }; // start with the default stylesheet so we have something before loading an external stylesheet


  if (_p.styleEnabled) {
    cy.setStyle([]);
  } // create the renderer


  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options

  cy.initRenderer(rendererOptions);

  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
    cy.notifications(false); // remove old elements

    var oldEles = cy.mutableElements();

    if (oldEles.length > 0) {
      oldEles.remove();
    }

    if (elements != null) {
      if (plainObject(elements) || array(elements)) {
        cy.add(elements);
      }
    }

    cy.one('layoutready', function (e) {
      cy.notifications(true);
      cy.emit(e); // we missed this event by turning notifications off, so pass it on

      cy.one('load', onload);
      cy.emitAndNotify('load');
    }).one('layoutstop', function () {
      cy.one('done', ondone);
      cy.emit('done');
    });
    var layoutOpts = extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();
    cy.layout(layoutOpts).run();
  };

  loadExtData([options.style, options.elements], function (thens) {
    var initStyle = thens[0];
    var initEles = thens[1]; // init style

    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    } // initial load


    setElesAndLayout(initEles, function () {
      // onready
      cy.startAnimationLoop();
      _p.ready = true; // if a ready callback is specified as an option, the bind it

      if (fn(options.ready)) {
        cy.on('ready', options.ready);
      } // bind all the ready handlers registered before creating this instance


      for (var i = 0; i < readies.length; i++) {
        var fn$1 = readies[i];
        cy.on('ready', fn$1);
      }

      if (reg) {
        reg.readies = [];
      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc


      cy.emit('ready');
    }, options.done);
  });
};

var corefn$9 = Core.prototype; // short alias

extend(corefn$9, {
  instanceString: function instanceString() {
    return 'core';
  },
  isReady: function isReady() {
    return this._private.ready;
  },
  destroyed: function destroyed() {
    return this._private.destroyed;
  },
  ready: function ready(fn) {
    if (this.isReady()) {
      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },
  destroy: function destroy() {
    var cy = this;
    if (cy.destroyed()) return;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    this.emit('destroy');
    cy._private.destroyed = true;
    return cy;
  },
  hasElementWithId: function hasElementWithId(id) {
    return this._private.elements.hasElementWithId(id);
  },
  getElementById: function getElementById(id) {
    return this._private.elements.getElementById(id);
  },
  hasCompoundNodes: function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  },
  headless: function headless() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function styleEnabled() {
    return this._private.styleEnabled;
  },
  addToPool: function addToPool(eles) {
    this._private.elements.merge(eles);

    return this; // chaining
  },
  removeFromPool: function removeFromPool(eles) {
    this._private.elements.unmerge(eles);

    return this;
  },
  container: function container() {
    return this._private.container || null;
  },
  mount: function mount(container) {
    if (container == null) {
      return;
    }

    var cy = this;
    var _p = cy._private;
    var options = _p.options;

    if (!htmlElement(container) && htmlElement(container[0])) {
      container = container[0];
    }

    cy.stopAnimationLoop();
    cy.destroyRenderer();
    _p.container = container;
    _p.styleEnabled = true;
    cy.invalidateSize();
    cy.initRenderer(extend({}, options, options.renderer, {
      // allow custom renderer name to be re-used, otherwise use canvas
      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name
    }));
    cy.startAnimationLoop();
    cy.style(options.style);
    cy.emit('mount');
    return cy;
  },
  unmount: function unmount() {
    var cy = this;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    cy.initRenderer({
      name: 'null'
    });
    cy.emit('unmount');
    return cy;
  },
  options: function options() {
    return copy(this._private.options);
  },
  json: function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    var getFreshRef = function getFreshRef(ele) {
      return cy.getElementById(ele.id());
    };

    if (plainObject(obj)) {
      // set
      cy.startBatch();

      if (obj.elements) {
        var idInJson = {};

        var updateEles = function updateEles(jsons, gr) {
          var toAdd = [];
          var toMod = [];

          for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            var id = '' + json.data.id; // id must be string

            var ele = cy.getElementById(id);
            idInJson[id] = true;

            if (ele.length !== 0) {
              // existing element should be updated
              toMod.push({
                ele: ele,
                json: json
              });
            } else {
              // otherwise should be added
              if (gr) {
                json.group = gr;
                toAdd.push(json);
              } else {
                toAdd.push(json);
              }
            }
          }

          cy.add(toAdd);

          for (var _i = 0; _i < toMod.length; _i++) {
            var _toMod$_i = toMod[_i],
                _ele = _toMod$_i.ele,
                _json = _toMod$_i.json;

            _ele.json(_json);
          }
        };

        if (array(obj.elements)) {
          // elements: []
          updateEles(obj.elements);
        } else {
          // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];

          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];

            if (array(elements)) {
              updateEles(elements, gr);
            }
          }
        }

        var parentsToRemove = cy.collection();
        eles.filter(function (ele) {
          return !idInJson[ele.id()];
        }).forEach(function (ele) {
          if (ele.isParent()) {
            parentsToRemove.merge(ele);
          } else {
            ele.remove();
          }
        }); // so that children are not removed w/parent

        parentsToRemove.forEach(function (ele) {
          return ele.children().move({
            parent: null
          });
        }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs

        parentsToRemove.forEach(function (ele) {
          return getFreshRef(ele).remove();
        });
      }

      if (obj.style) {
        cy.style(obj.style);
      }

      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }

      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }

      if (obj.data) {
        cy.data(obj.data);
      }

      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

      for (var _i2 = 0; _i2 < fields.length; _i2++) {
        var f = fields[_i2];

        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }

      cy.endBatch();
      return this; // chaining
    } else {
      // get
      var flat = !!obj;
      var json = {};

      if (flat) {
        json.elements = this.elements().map(function (ele) {
          return ele.json();
        });
      } else {
        json.elements = {};
        eles.forEach(function (ele) {
          var group = ele.group();

          if (!json.elements[group]) {
            json.elements[group] = [];
          }

          json.elements[group].push(ele.json());
        });
      }

      if (this._private.styleEnabled) {
        json.style = cy.style().json();
      }

      json.data = copy(cy.data());
      var options = _p.options;
      json.zoomingEnabled = _p.zoomingEnabled;
      json.userZoomingEnabled = _p.userZoomingEnabled;
      json.zoom = _p.zoom;
      json.minZoom = _p.minZoom;
      json.maxZoom = _p.maxZoom;
      json.panningEnabled = _p.panningEnabled;
      json.userPanningEnabled = _p.userPanningEnabled;
      json.pan = copy(_p.pan);
      json.boxSelectionEnabled = _p.boxSelectionEnabled;
      json.renderer = copy(options.renderer);
      json.hideEdgesOnViewport = options.hideEdgesOnViewport;
      json.textureOnViewport = options.textureOnViewport;
      json.wheelSensitivity = options.wheelSensitivity;
      json.motionBlur = options.motionBlur;
      return json;
    }
  }
});
corefn$9.$id = corefn$9.getElementById;
[corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {
  extend(corefn$9, props);
});

/* eslint-disable no-unused-vars */

var defaults$9 = {
  fit: true,
  // whether to fit the viewport to the graph
  directed: false,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30,
  // padding on fit
  circle: false,
  // put depths in concentric circles if true, put depths top down if false
  grid: false,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: undefined,
  // the roots of the trees
  maximal: false,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled,
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};
/* eslint-enable */

var getInfo = function getInfo(ele) {
  return ele.scratch('breadthfirst');
};

var setInfo = function setInfo(ele, obj) {
  return ele.scratch('breadthfirst', obj);
};

function BreadthFirstLayout(options) {
  this.options = extend({}, defaults$9, options);
}

BreadthFirstLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().filter(function (n) {
    return !n.isParent();
  });
  var graph = eles;
  var directed = options.directed;
  var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var roots;

  if (elementOrCollection(options.roots)) {
    roots = options.roots;
  } else if (array(options.roots)) {
    var rootsArray = [];

    for (var i = 0; i < options.roots.length; i++) {
      var id = options.roots[i];
      var ele = cy.getElementById(id);
      rootsArray.push(ele);
    }

    roots = cy.collection(rootsArray);
  } else if (string(options.roots)) {
    roots = cy.$(options.roots);
  } else {
    if (directed) {
      roots = nodes.roots();
    } else {
      var components = eles.components();
      roots = cy.collection();

      var _loop = function _loop(_i) {
        var comp = components[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function (ele) {
          return ele.degree(false) === maxDegree;
        });
        roots = roots.add(compRoots);
      };

      for (var _i = 0; _i < components.length; _i++) {
        _loop(_i);
      }
    }
  }

  var depths = [];
  var foundByBfs = {};

  var addToDepth = function addToDepth(ele, d) {
    if (depths[d] == null) {
      depths[d] = [];
    }

    var i = depths[d].length;
    depths[d].push(ele);
    setInfo(ele, {
      index: i,
      depth: d
    });
  };

  var changeDepth = function changeDepth(ele, newDepth) {
    var _getInfo = getInfo(ele),
        depth = _getInfo.depth,
        index = _getInfo.index;

    depths[depth][index] = null;
    addToDepth(ele, newDepth);
  }; // find the depths of the nodes


  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function visit(node, edge, pNode, i, depth) {
      var ele = node[0];
      var id = ele.id();
      addToDepth(ele, depth);
      foundByBfs[id] = true;
    }
  }); // check for nodes not found by bfs

  var orphanNodes = [];

  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _ele = nodes[_i2];

    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  } // assign the nodes a depth and index


  var assignDepthsAt = function assignDepthsAt(i) {
    var eles = depths[i];

    for (var j = 0; j < eles.length; j++) {
      var _ele2 = eles[j];

      if (_ele2 == null) {
        eles.splice(j, 1);
        j--;
        continue;
      }

      setInfo(_ele2, {
        depth: i,
        index: j
      });
    }
  };

  var assignDepths = function assignDepths() {
    for (var _i3 = 0; _i3 < depths.length; _i3++) {
      assignDepthsAt(_i3);
    }
  };

  var adjustMaximally = function adjustMaximally(ele, shifted) {
    var eInfo = getInfo(ele);
    var incomers = ele.incomers().filter(function (el) {
      return el.isNode() && eles.has(el);
    });
    var maxDepth = -1;
    var id = ele.id();

    for (var k = 0; k < incomers.length; k++) {
      var incmr = incomers[k];
      var iInfo = getInfo(incmr);
      maxDepth = Math.max(maxDepth, iInfo.depth);
    }

    if (eInfo.depth <= maxDepth) {
      if (shifted[id]) {
        return null;
      }

      changeDepth(ele, maxDepth + 1);
      shifted[id] = true;
      return true;
    }

    return false;
  }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)


  if (directed && maximal) {
    var Q = [];
    var shifted = {};

    var enqueue = function enqueue(n) {
      return Q.push(n);
    };

    var dequeue = function dequeue() {
      return Q.shift();
    };

    nodes.forEach(function (n) {
      return Q.push(n);
    });

    while (Q.length > 0) {
      var _ele3 = dequeue();

      var didShift = adjustMaximally(_ele3, shifted);

      if (didShift) {
        _ele3.outgoers().filter(function (el) {
          return el.isNode() && eles.has(el);
        }).forEach(enqueue);
      } else if (didShift === null) {
        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');
        break; // exit on failure
      }
    }
  }

  assignDepths(); // clear holes
  // find min distance we need to leave between nodes

  var minDistance = 0;

  if (options.avoidOverlap) {
    for (var _i4 = 0; _i4 < nodes.length; _i4++) {
      var n = nodes[_i4];
      var nbb = n.layoutDimensions(options);
      var w = nbb.w;
      var h = nbb.h;
      minDistance = Math.max(minDistance, w, h);
    }
  } // get the weighted percent for an element based on its connectivity to other levels


  var cachedWeightedPercent = {};

  var getWeightedPercent = function getWeightedPercent(ele) {
    if (cachedWeightedPercent[ele.id()]) {
      return cachedWeightedPercent[ele.id()];
    }

    var eleDepth = getInfo(ele).depth;
    var neighbors = ele.neighborhood();
    var percent = 0;
    var samples = 0;

    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {
      var neighbor = neighbors[_i5];

      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {
        continue;
      }

      var bf = getInfo(neighbor);
      var index = bf.index;
      var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering

      if (index == null || depth == null) {
        continue;
      }

      var nDepth = depths[depth].length;

      if (depth < eleDepth) {
        // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if (samples === 0) {
      // put lone nodes at the start
      percent = 0;
    }

    cachedWeightedPercent[ele.id()] = percent;
    return percent;
  }; // rearrange the indices in each depth level based on connectivity


  var sortFn = function sortFn(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);
    var diff = apct - bpct;

    if (diff === 0) {
      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
    } else {
      return diff;
    }
  }; // sort each level to make connected nodes closer


  for (var _i6 = 0; _i6 < depths.length; _i6++) {
    depths[_i6].sort(sortFn);

    assignDepthsAt(_i6);
  } // assign orphan nodes to a new top-level depth


  var orphanDepth = [];

  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {
    orphanDepth.push(orphanNodes[_i7]);
  }

  depths.unshift(orphanDepth);
  assignDepths();
  var biggestDepthSize = 0;

  for (var _i8 = 0; _i8 < depths.length; _i8++) {
    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };
  var maxDepthSize = depths.reduce(function (max, eles) {
    return Math.max(max, eles.length);
  }, 0);

  var getPosition = function getPosition(ele) {
    var _getInfo2 = getInfo(ele),
        depth = _getInfo2.depth,
        index = _getInfo2.index;

    var depthSize = depths[depth].length;
    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
    radiusStepSize = Math.max(radiusStepSize, minDistance);

    if (!options.circle) {
      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };
      return epos;
    } else {
      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
      var theta = 2 * Math.PI / depths[depth].length * index;

      if (depth === 0 && depths[0].length === 1) {
        radius = 1;
      }

      return {
        x: center.x + radius * Math.cos(theta),
        y: center.y + radius * Math.sin(theta)
      };
    }
  };

  nodes.layoutPositions(this, options, getPosition);
  return this; // chaining
};

var defaults$a = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function CircleLayout(options) {
  this.options = extend({}, defaults$a, options);
}

CircleLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
  var dTheta = sweep / Math.max(1, nodes.length - 1);
  var r;
  var minDistance = 0;

  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var w = nbb.w;
    var h = nbb.h;
    minDistance = Math.max(minDistance, w, h);
  }

  if (number(options.radius)) {
    r = options.radius;
  } else if (nodes.length <= 1) {
    r = 0;
  } else {
    r = Math.min(bb.h, bb.w) / 2 - minDistance;
  } // calculate the radius


  if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

    r = Math.max(rMin, r);
  }

  var getPos = function getPos(ele, i) {
    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
    var rx = r * Math.cos(theta);
    var ry = r * Math.sin(theta);
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };
    return pos;
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var defaults$b = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: undefined,
  // height of layout area (overrides container height)
  width: undefined,
  // width of layout area (overrides container width)
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function levelWidth(nodes) {
    // the letiation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function ConcentricLayout(options) {
  this.options = extend({}, defaults$b, options);
}

ConcentricLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var nodeValues = []; // { node, value }

  var maxNodeSize = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var value = void 0; // calculate the node value

    value = options.concentric(node);
    nodeValues.push({
      value: value,
      node: node
    }); // for style mapping

    node._private.scratch.concentric = value;
  } // in case we used the `concentric` in style


  nodes.updateStyle(); // calculate max size now based on potentially updated mappers

  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];

    var nbb = _node.layoutDimensions(options);

    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  } // sort node values in descreasing order


  nodeValues.sort(function (a, b) {
    return b.value - a.value;
  });
  var levelWidth = options.levelWidth(nodes); // put the values into levels

  var levels = [[]];
  var currentLevel = levels[0];

  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];

    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0].value - val.value);

      if (diff >= levelWidth) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(val);
  } // create positions from levels


  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if (!options.avoidOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
    minDist = Math.min(minDist, rStep);
  } // find the metrics for each level


  var r = 0;

  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius

    if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;
    r += minDist;
  }

  if (options.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;

    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;
      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    _r = 0;

    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];

      if (_i5 === 0) {
        _r = _level2.r;
      }

      _level2.r = _r;
      _r += rDeltaMax;
    }
  } // calculate the node positions


  var pos = {}; // id => position

  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;

    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
      var p = {
        x: center.x + _r2 * Math.cos(theta),
        y: center.y + _r2 * Math.sin(theta)
      };
      pos[_val.node.id()] = p;
    }
  } // position the nodes


  nodes.layoutPositions(this, options, function (ele) {
    var id = ele.id();
    return pos[id];
  });
  return this; // chaining
};

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/
var DEBUG;
/**
 * @brief :  default layout options
 */

var defaults$c = {
  // Called on `layoutready`
  ready: function ready() {},
  // Called on `layoutstop`
  stop: function stop() {},
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,
  // Easing of the animation for animate:'end'
  animationEasing: undefined,
  // The duration of the animation for animate:'end'
  animationDuration: undefined,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: true,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function nodeRepulsion(node) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function idealEdgeLength(edge) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function edgeElasticity(edge) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1000,
  // Initial temperature (maximum node displacement)
  initialTemp: 1000,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0
};
/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */

function CoseLayout(options) {
  this.options = extend({}, defaults$c, options);
  this.options.layout = this;
}
/**
 * @brief : runs the layout
 */


CoseLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var layout = this;
  layout.stopped = false;

  if (options.animate === true || options.animate === false) {
    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
  } // Set DEBUG - Global variable


  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  } // Initialize layout info


  var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging

  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  } // If required, randomize node positions


  if (options.randomize) {
    randomizePositions(layoutInfo);
  }

  var startTime = performanceNow();

  var refresh = function refresh() {
    refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary

    if (true === options.fit) {
      cy.fit(options.padding);
    }
  };

  var mainLoop = function mainLoop(i) {
    if (layout.stopped || i >= options.numIter) {
      // logDebug("Layout manually stopped. Stopping computation in step " + i);
      return false;
    } // Do one step in the phisical simulation


    step$1(layoutInfo, options); // Update temperature

    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);

    if (layoutInfo.temperature < options.minTemp) {
      // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
      return false;
    }

    return true;
  };

  var done = function done() {
    if (options.animate === true || options.animate === false) {
      refresh(); // Layout has finished

      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    } else {
      var nodes = options.eles.nodes();
      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
      nodes.layoutPositions(layout, options, getScaledPos);
    }
  };

  var i = 0;
  var loopRet = true;

  if (options.animate === true) {
    var frame = function frame() {
      var f = 0;

      while (loopRet && f < options.refresh) {
        loopRet = mainLoop(i);
        i++;
        f++;
      }

      if (!loopRet) {
        // it's done
        separateComponents(layoutInfo, options);
        done();
      } else {
        var now = performanceNow();

        if (now - startTime >= options.animationThreshold) {
          refresh();
        }

        requestAnimationFrame(frame);
      }
    };

    frame();
  } else {
    while (loopRet) {
      loopRet = mainLoop(i);
      i++;
    }

    separateComponents(layoutInfo, options);
    done();
  }

  return this; // chaining
};
/**
 * @brief : called on continuous layouts to stop them before they finish
 */


CoseLayout.prototype.stop = function () {
  this.stopped = true;

  if (this.thread) {
    this.thread.stop();
  }

  this.emit('layoutstop');
  return this; // chaining
};

CoseLayout.prototype.destroy = function () {
  if (this.thread) {
    this.thread.stop();
  }

  return this; // chaining
};
/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */


var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();
  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
      x1: 0,
      y1: 0,
      w: cy.width(),
      h: cy.height()
    })
  };
  var components = options.eles.components();
  var id2cmptId = {};

  for (var i = 0; i < components.length; i++) {
    var component = components[i];

    for (var j = 0; j < component.length; j++) {
      var node = component[j];
      id2cmptId[node.id()] = i;
    }
  } // Iterate over all nodes, creating layout nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data('id');
    tempNode.parentId = n.data('parent');
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position('x');
    tempNode.positionY = n.position('y');
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style('padding'));
    tempNode.padRight = parseFloat(n.style('padding'));
    tempNode.padTop = parseFloat(n.style('padding'));
    tempNode.padBottom = parseFloat(n.style('padding')); // forces

    tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node

    layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map

    layoutInfo.idToIndex[tempNode.id] = i;
  } // Inline implementation of a queue, used for traversing the graph in BFS order


  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue

  var tempGraph = []; // Second pass to add child information and
  // initialize queue for hierarchical traversal

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId; // Check if node n has a parent node

    if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  } // Add root graph to graphSet


  layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;

    if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children); // Add children to que queue to be visited

      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  } // Create indexToGraph map


  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];

    for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
    }
  } // Iterate over all edges, creating Layout Edges


  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target'); // Compute ideal length

    var idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge

    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph

      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0; // Source depth

      var tempNode = layoutInfo.layoutNodes[sourceIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // Target depth


      tempNode = layoutInfo.layoutNodes[targetIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);
      // Update idealLength


      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;
    layoutInfo.layoutEdges.push(tempEdge);
  } // Finally, return layoutInfo object


  return layoutInfo;
};
/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */


var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);

  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};
/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */


var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx

  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {
      count: 2,
      graph: graphIx
    };
  } // Make recursive calls for all subgraphs


  var c = 0;

  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it

    if (0 === children.length) {
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);

    if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;

      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {
    count: c,
    graph: graphIx
  };
};
/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */


if (false) { var printLayoutInfo; }
/**
 * @brief : Randomizes the position of all nodes
 */


var randomizePositions = function randomizePositions(layoutInfo, cy) {
  var width = layoutInfo.clientWidth;
  var height = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes

    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};

var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
  var bb = layoutInfo.boundingBox;
  var coseBB = {
    x1: Infinity,
    x2: -Infinity,
    y1: Infinity,
    y2: -Infinity
  };

  if (options.boundingBox) {
    nodes.forEach(function (node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });
    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  return function (ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];

    if (options.boundingBox) {
      // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  };
};
/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);
  var layout = options.layout;
  var nodes = options.eles.nodes();
  var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
  nodes.positions(getScaledPos); // Trigger layoutReady only on first call

  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.emit({
      type: 'layoutready',
      layout: this
    });
  }
};
/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

/**
 * @brief          : Performs one iteration of the physical simulation
 * @arg layoutInfo : LayoutInfo object already initialized
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var step$1 = function step(layoutInfo, options, _step) {
  // var s = "\n\n###############################";
  // s += "\nSTEP: " + step;
  // s += "\n###############################\n";
  // logDebug(s);
  // Calculate node repulsions
  calculateNodeForces(layoutInfo, options); // Calculate edge forces

  calculateEdgeForces(layoutInfo); // Calculate gravity forces

  calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child

  propagateForces(layoutInfo); // Update positions based on calculated forces

  updatePositions(layoutInfo);
};
/**
 * @brief : Computes the node repulsion forces
 */


var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
  // Go through each of the graphs in graphSet
  // Nodes only repel each other if they belong to the same graph
  // var s = 'calculateNodeForces';
  // logDebug(s);
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Now get all the pairs of nodes
    // Only get each pair once, (A, B) = (B, A)

    for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, options);
      }
    }
  }
};

var randomDistance = function randomDistance(max) {
  return -max + 2 * max * Math.random();
};
/**
 * @brief : Compute the node repulsion forces between a pair of nodes
 */


var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
  // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
  var cmptId1 = node1.cmptId;
  var cmptId2 = node2.cmptId;

  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
    return;
  } // Get direction of line connecting both node centers


  var directionX = node2.positionX - node1.positionX;
  var directionY = node2.positionY - node1.positionY;
  var maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
  // If both centers are the same, apply a random force

  if (0 === directionX && 0 === directionY) {
    directionX = randomDistance(maxRandDist);
    directionY = randomDistance(maxRandDist);
  }

  var overlap = nodesOverlap(node1, node2, directionX, directionY);

  if (overlap > 0) {
    // s += "\nNodes DO overlap.";
    // s += "\nOverlap: " + overlap;
    // If nodes overlap, repulsion force is proportional
    // to the overlap
    var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector

    var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;

    var forceX = force * directionX / distance;
    var forceY = force * directionY / distance;
  } else {
    // s += "\nNodes do NOT overlap.";
    // If there's no overlap, force is inversely proportional
    // to squared distance
    // Get clipping points for both nodes
    var point1 = findClippingPoint(node1, directionX, directionY);
    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance

    var distanceX = point2.x - point1.x;
    var distanceY = point2.y - point1.y;
    var distanceSqr = distanceX * distanceX + distanceY * distanceY;
    var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
    // Compute the module and components of the force vector

    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
    var forceX = force * distanceX / distance;
    var forceY = force * distanceY / distance;
  } // Apply force


  if (!node1.isLocked) {
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
  }

  if (!node2.isLocked) {
    node2.offsetX += forceX;
    node2.offsetY += forceY;
  } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
  // logDebug(s);


  return;
};
/**
 * @brief  : Determines whether two nodes overlap or not
 * @return : Amount of overlapping (0 => no overlap)
 */


var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
  if (dX > 0) {
    var overlapX = node1.maxX - node2.minX;
  } else {
    var overlapX = node2.maxX - node1.minX;
  }

  if (dY > 0) {
    var overlapY = node1.maxY - node2.minY;
  } else {
    var overlapY = node2.maxY - node1.minY;
  }

  if (overlapX >= 0 && overlapY >= 0) {
    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
  } else {
    return 0;
  }
};
/**
 * @brief : Finds the point in which an edge (direction dX, dY) intersects
 *          the rectangular bounding box of it's source/target node
 */


var findClippingPoint = function findClippingPoint(node, dX, dY) {
  // Shorcuts
  var X = node.positionX;
  var Y = node.positionY;
  var H = node.height || 1;
  var W = node.width || 1;
  var dirSlope = dY / dX;
  var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
  //   " . Height:  " + H + ", Width: " + W +
  //   "\nDirection " + dX + ", " + dY;
  //
  // Compute intersection

  var res = {}; // Case: Vertical direction (up)

  if (0 === dX && 0 < dY) {
    res.x = X; // s += "\nUp direction";

    res.y = Y + H / 2;
    return res;
  } // Case: Vertical direction (down)


  if (0 === dX && 0 > dY) {
    res.x = X;
    res.y = Y + H / 2; // s += "\nDown direction";

    return res;
  } // Case: Intersects the right border


  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X + W / 2;
    res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";

    return res;
  } // Case: Intersects the left border


  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X - W / 2;
    res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";

    return res;
  } // Case: Intersects the top border


  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X + H * dX / 2 / dY;
    res.y = Y + H / 2; // s += "\nTop border";

    return res;
  } // Case: Intersects the bottom border


  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X - H * dX / 2 / dY;
    res.y = Y - H / 2; // s += "\nBottom border";

    return res;
  } // s += "\nClipping point found at " + res.x + ", " + res.y;
  // logDebug(s);


  return res;
};
/**
 * @brief : Calculates all edge forces
 */


var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
  // Iterate over all edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    // Get edge, source & target nodes
    var edge = layoutInfo.layoutEdges[i];
    var sourceIx = layoutInfo.idToIndex[edge.sourceId];
    var source = layoutInfo.layoutNodes[sourceIx];
    var targetIx = layoutInfo.idToIndex[edge.targetId];
    var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers

    var directionX = target.positionX - source.positionX;
    var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
    // A random force has already been applied as node repulsion

    if (0 === directionX && 0 === directionY) {
      continue;
    } // Get clipping points for both nodes


    var point1 = findClippingPoint(source, directionX, directionY);
    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
    var lx = point2.x - point1.x;
    var ly = point2.y - point1.y;
    var l = Math.sqrt(lx * lx + ly * ly);
    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

    if (0 !== l) {
      var forceX = force * lx / l;
      var forceY = force * ly / l;
    } else {
      var forceX = 0;
      var forceY = 0;
    } // Add this force to target and source nodes


    if (!source.isLocked) {
      source.offsetX += forceX;
      source.offsetY += forceY;
    }

    if (!target.isLocked) {
      target.offsetX -= forceX;
      target.offsetY -= forceY;
    } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
    // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
    // logDebug(s);

  }
};
/**
 * @brief : Computes gravity forces for all nodes
 */


var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
  var distThreshold = 1; // var s = 'calculateGravityForces';
  // logDebug(s);

  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Compute graph center

    if (0 === i) {
      var centerX = layoutInfo.clientHeight / 2;
      var centerY = layoutInfo.clientWidth / 2;
    } else {
      // Get Parent node for this graph, and use its position as center
      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
      var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
      var centerX = parent.positionX;
      var centerY = parent.positionY;
    } // s = "Center found at: " + centerX + ", " + centerY;
    // logDebug(s);
    // Apply force to all nodes in graph


    for (var j = 0; j < numNodes; j++) {
      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;

      if (node.isLocked) {
        continue;
      }

      var dx = centerX - node.positionX;
      var dy = centerY - node.positionY;
      var d = Math.sqrt(dx * dx + dy * dy);

      if (d > distThreshold) {
        var fx = options.gravity * dx / d;
        var fy = options.gravity * dy / d;
        node.offsetX += fx;
        node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
      } // s += ": skypped since it's too close to center";
        // logDebug(s);

    }
  }
};
/**
 * @brief          : This function propagates the existing offsets from
 *                   parent nodes to its descendents.
 * @arg layoutInfo : layoutInfo Object
 * @arg cy         : cytoscape Object
 * @arg options    : Layout options
 */


var propagateForces = function propagateForces(layoutInfo, options) {
  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue
  // logDebug('propagateForces');
  // Start by visiting the nodes in the root graph

  queue.push.apply(queue, layoutInfo.graphSet[0]);
  end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var nodeId = queue[start++];
    var nodeIndex = layoutInfo.idToIndex[nodeId];
    var node = layoutInfo.layoutNodes[nodeIndex];
    var children = node.children; // We only need to process the node if it's compound

    if (0 < children.length && !node.isLocked) {
      var offX = node.offsetX;
      var offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);

      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset

        childNode.offsetX += offX;
        childNode.offsetY += offY; // Add children to queue to be visited

        queue[++end] = children[i];
      } // Reset parent offsets


      node.offsetX = 0;
      node.offsetY = 0;
    }
  }
};
/**
 * @brief : Updates the layout model positions, based on
 *          the accumulated forces
 */


var updatePositions = function updatePositions(layoutInfo, options) {
  // var s = 'Updating positions';
  // logDebug(s);
  // Reset boundaries for compound nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length) {
      // logDebug("Resetting boundaries of compound node: " + n.id);
      n.maxX = undefined;
      n.minX = undefined;
      n.maxY = undefined;
      n.minY = undefined;
    }
  }

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length || n.isLocked) {
      // No need to set compound or locked node position
      // logDebug("Skipping position update of node: " + n.id);
      continue;
    } // s = "Node: " + n.id + " Previous position: (" +
    // n.positionX + ", " + n.positionY + ").";
    // Limit displacement in order to improve stability


    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
    n.positionX += tempForce.x;
    n.positionY += tempForce.y;
    n.offsetX = 0;
    n.offsetY = 0;
    n.minX = n.positionX - n.width;
    n.maxX = n.positionX + n.width;
    n.minY = n.positionY - n.height;
    n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
    // logDebug(s);
    // Update ancestry boudaries

    updateAncestryBoundaries(n, layoutInfo);
  } // Update size, position of compund nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length && !n.isLocked) {
      n.positionX = (n.maxX + n.minX) / 2;
      n.positionY = (n.maxY + n.minY) / 2;
      n.width = n.maxX - n.minX;
      n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
      // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
      // s += "\nWidth: " + n.width + ", Height: " + n.height;
      // logDebug(s);
    }
  }
};
/**
 * @brief : Limits a force (forceX, forceY) to be not
 *          greater (in modulo) than max.
 8          Preserves force direction.
  */


var limitForce = function limitForce(forceX, forceY, max) {
  // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
  var force = Math.sqrt(forceX * forceX + forceY * forceY);

  if (force > max) {
    var res = {
      x: max * forceX / force,
      y: max * forceY / force
    };
  } else {
    var res = {
      x: forceX,
      y: forceY
    };
  } // s += ".\nResult: (" + res.x + ", " + res.y + ")";
  // logDebug(s);


  return res;
};
/**
 * @brief : Function used for keeping track of compound node
 *          sizes, since they should bound all their subnodes.
 */


var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
  // var s = "Propagating new position/size of node " + node.id;
  var parentId = node.parentId;

  if (null == parentId) {
    // If there's no parent, we are done
    // s += ". No parent node.";
    // logDebug(s);
    return;
  } // Get Parent Node


  var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
  var flag = false; // MaxX

  if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
    p.maxX = node.maxX + p.padRight;
    flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
  } // MinX


  if (null == p.minX || node.minX - p.padLeft < p.minX) {
    p.minX = node.minX - p.padLeft;
    flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
  } // MaxY


  if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
    p.maxY = node.maxY + p.padBottom;
    flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
  } // MinY


  if (null == p.minY || node.minY - p.padTop < p.minY) {
    p.minY = node.minY - p.padTop;
    flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
  } // If updated boundaries, propagate changes upward


  if (flag) {
    // logDebug(s);
    return updateAncestryBoundaries(p, layoutInfo);
  } // s += ". No changes in boundaries/position of parent node " + p.id;
  // logDebug(s);


  return;
};

var separateComponents = function separateComponents(layoutInfo, options) {
  var nodes = layoutInfo.layoutNodes;
  var components = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var cid = node.cmptId;
    var component = components[cid] = components[cid] || [];
    component.push(node);
  }

  var totalA = 0;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    c.x1 = Infinity;
    c.x2 = -Infinity;
    c.y1 = Infinity;
    c.y2 = -Infinity;

    for (var j = 0; j < c.length; j++) {
      var n = c[j];
      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
    }

    c.w = c.x2 - c.x1;
    c.h = c.y2 - c.y1;
    totalA += c.w * c.h;
  }

  components.sort(function (c1, c2) {
    return c2.w * c2.h - c1.w * c1.h;
  });
  var x = 0;
  var y = 0;
  var usedW = 0;
  var rowH = 0;
  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    for (var j = 0; j < c.length; j++) {
      var n = c[j];

      if (!n.isLocked) {
        n.positionX += x - c.x1;
        n.positionY += y - c.y1;
      }
    }

    x += c.w + options.componentSpacing;
    usedW += c.w + options.componentSpacing;
    rowH = Math.max(rowH, c.h);

    if (usedW > maxRowW) {
      y += rowH + options.componentSpacing;
      x = 0;
      usedW = 0;
      rowH = 0;
    }
  }
};

var defaults$d = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false,
  // uses all available space on false, uses minimal space on true
  rows: undefined,
  // force num of rows in the grid
  cols: undefined,
  // force num of columns in the grid
  position: function position(node) {},
  // returns { row, col } for element
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function GridLayout(options) {
  this.options = extend({}, defaults$d, options);
}

GridLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  if (bb.h === 0 || bb.w === 0) {
    nodes.layoutPositions(this, options, function (ele) {
      return {
        x: bb.x1,
        y: bb.y1
      };
    });
  } else {
    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);

    var small = function small(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);

        if (min == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function large(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);

        if (max == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values

    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    } // otherwise use the automatic values and adjust accordingly
    // if rounding was up, see if we can reduce rows or columns
    else if (cols * rows > cells) {
        var sm = small();
        var lg = large(); // reducing the small side takes away the most cells, so try it first

        if ((sm - 1) * lg >= cells) {
          small(sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(lg - 1);
        }
      } else {
        // if rounding was too low, add rows or columns
        while (cols * rows < cells) {
          var _sm = small();

          var _lg = large(); // try to add to larger side first (adds less in multiplication)


          if ((_lg + 1) * _sm >= cells) {
            large(_lg + 1);
          } else {
            small(_sm + 1);
          }
        }
      }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if (options.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }

    if (options.avoidOverlap) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = node._private.position;

        if (pos.x == null || pos.y == null) {
          // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.layoutDimensions(options);
        var p = options.avoidOverlapPadding;
        var w = nbb.w + p;
        var h = nbb.h + p;
        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function used(row, col) {
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function use(row, col) {
      cellUsed['c-' + row + '-' + col] = true;
    }; // to keep track of current cell position


    var row = 0;
    var col = 0;

    var moveToNextCell = function moveToNextCell() {
      col++;

      if (col >= cols) {
        col = 0;
        row++;
      }
    }; // get a cache of all the manual positions


    var id2manPos = {};

    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
      var rcPos = options.position(_node);

      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if (_pos.col === undefined) {
          // find unused col
          _pos.col = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === undefined) {
          // find unused row
          _pos.row = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }

        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }

    var getPos = function getPos(element, i) {
      var x, y;

      if (element.locked() || element.isParent()) {
        return false;
      } // see if we have a manual position set


      var rcPos = id2manPos[element.id()];

      if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        // otherwise set automatically
        while (used(row, col)) {
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);
        moveToNextCell();
      }

      return {
        x: x,
        y: y
      };
    };

    nodes.layoutPositions(this, options, getPos);
  }

  return this; // chaining
};

var defaults$e = {
  ready: function ready() {},
  // on layoutready
  stop: function stop() {} // on layoutstop

}; // constructor
// options : object containing layout options

function NullLayout(options) {
  this.options = extend({}, defaults$e, options);
} // runs the layout


NullLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout

  var layout = this; // cy is automatically populated for us in the constructor
  // (disable eslint for next line as this serves as example layout code to external developers)
  // eslint-disable-next-line no-unused-vars

  var cy = options.cy;
  layout.emit('layoutstart'); // puts all nodes at (0, 0)
  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events

  eles.nodes().positions(function () {
    return {
      x: 0,
      y: 0
    };
  }); // trigger layoutready when each node has had its position set at least once

  layout.one('layoutready', options.ready);
  layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)

  layout.one('layoutstop', options.stop);
  layout.emit('layoutstop');
  return this; // chaining
}; // called on continuous layouts to stop them before they finish


NullLayout.prototype.stop = function () {
  return this; // chaining
};

var defaults$f = {
  positions: undefined,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined,
  // the zoom level to set (prob want fit = false if set)
  pan: undefined,
  // the pan level to set (prob want fit = false if set)
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function PresetLayout(options) {
  this.options = extend({}, defaults$f, options);
}

PresetLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles;
  var nodes = eles.nodes();
  var posIsFn = fn(options.positions);

  function getPosition(node) {
    if (options.positions == null) {
      return copyPosition(node.position());
    }

    if (posIsFn) {
      return options.positions(node);
    }

    var pos = options.positions[node._private.data.id];

    if (pos == null) {
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function (node, i) {
    var position = getPosition(node);

    if (node.locked() || position == null) {
      return false;
    }

    return position;
  });
  return this; // chaining
};

var defaults$g = {
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function RandomLayout(options) {
  this.options = extend({}, defaults$g, options);
}

RandomLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  var getPos = function getPos(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var layout = [{
  name: 'breadthfirst',
  impl: BreadthFirstLayout
}, {
  name: 'circle',
  impl: CircleLayout
}, {
  name: 'concentric',
  impl: ConcentricLayout
}, {
  name: 'cose',
  impl: CoseLayout
}, {
  name: 'grid',
  impl: GridLayout
}, {
  name: 'null',
  impl: NullLayout
}, {
  name: 'preset',
  impl: PresetLayout
}, {
  name: 'random',
  impl: RandomLayout
}];

function NullRenderer(options) {
  this.options = options;
  this.notifications = 0; // for testing
}

var noop$1 = function noop() {};

var throwImgErr = function throwImgErr() {
  throw new Error('A headless instance can not render images');
};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop$1,
  notify: function notify() {
    this.notifications++;
  },
  init: noop$1,
  isHeadless: function isHeadless() {
    return true;
  },
  png: throwImgErr,
  jpg: throwImgErr
};

var BRp = {};
BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function () {
  var arrowShapes = this.arrowShapes = {};
  var renderer = this; // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;
    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
    return inside;
  };

  var transform = function transform(x, y, size, angle, translation) {
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;
    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function transformPoints(pts, size, angle, translation) {
    var retPts = [];

    for (var i = 0; i < pts.length; i += 2) {
      var x = pts[i];
      var y = pts[i + 1];
      retPts.push(transform(x, y, size, angle, translation));
    }

    return retPts;
  };

  var pointsToArr = function pointsToArr(pts) {
    var ret = [];

    for (var i = 0; i < pts.length; i++) {
      var p = pts[i];
      ret.push(p.x, p.y);
    }

    return ret;
  };

  var standardGap = function standardGap(edge) {
    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
  };

  var defineArrowShape = function defineArrowShape(name, defn) {
    if (string(defn)) {
      defn = arrowShapes[defn];
    }

    arrowShapes[name] = extend({
      name: name,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function collide(x, y, size, angle, translation, padding) {
        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
        var inside = pointInsidePolygonPoints(x, y, points);
        return inside;
      },
      roughCollide: bbCollide,
      draw: function draw(context, size, angle, translation) {
        var points = transformPoints(this.points, size, angle, translation);
        renderer.arrowShapeImpl('polygon')(context, points);
      },
      spacing: function spacing(edge) {
        return 0;
      },
      gap: standardGap
    }, defn);
  };

  defineArrowShape('none', {
    collide: falsify,
    roughCollide: falsify,
    draw: noop,
    spacing: zeroify,
    gap: zeroify
  });
  defineArrowShape('triangle', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });
  defineArrowShape('arrow', 'triangle');
  defineArrowShape('triangle-backcurve', {
    points: arrowShapes['triangle'].points,
    controlPoint: [0, -0.15],
    roughCollide: bbCollide,
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var ptsTrans = transformPoints(this.points, size, angle, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    },
    gap: function gap(edge) {
      return standardGap(edge) * 0.8;
    }
  });
  defineArrowShape('triangle-tee', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var teePts = transformPoints(this.pointsTee, size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
    }
  });
  defineArrowShape('triangle-cross', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
    0.15, -0.4],
    crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
      var p = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size;
      var y0 = 3;
      var y1 = 5;
      p[y0] = p[y0] - shiftFactor;
      p[y1] = p[y1] - shiftFactor;
      return p;
    },
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }
  });
  defineArrowShape('vee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function gap(edge) {
      return standardGap(edge) * 0.525;
    }
  });
  defineArrowShape('circle', {
    radius: 0.15,
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
    },
    spacing: function spacing(edge) {
      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
    }
  });
  defineArrowShape('tee', {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function spacing(edge) {
      return 1;
    },
    gap: function gap(edge) {
      return 1;
    }
  });
  defineArrowShape('square', {
    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
  });
  defineArrowShape('diamond', {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function gap(edge) {
      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
  defineArrowShape('chevron', {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function gap(edge) {
      return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
};

var BRp$1 = {}; // Project mouse

BRp$1.projectIntoViewport = function (clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale = offsets[4];
  var pan = cy.pan();
  var zoom = cy.zoom();
  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;
  return [x, y];
};

BRp$1.findContainerClientCoords = function () {
  if (this.containerBB) {
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window$1.getComputedStyle(container);

  var styleValue = function styleValue(name) {
    return parseFloat(style.getPropertyValue(name));
  };

  var padding = {
    left: styleValue('padding-left'),
    right: styleValue('padding-right'),
    top: styleValue('padding-top'),
    bottom: styleValue('padding-bottom')
  };
  var border = {
    left: styleValue('border-left-width'),
    right: styleValue('border-right-width'),
    top: styleValue('border-top-width'),
    bottom: styleValue('border-bottom-width')
  };
  var clientWidth = container.clientWidth;
  var clientHeight = container.clientHeight;
  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;
  var borderHor = border.left + border.right;
  var scale = rect.width / (clientWidth + borderHor);
  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;
  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;
  return this.containerBB = [left, top, unscaledW, unscaledH, scale];
};

BRp$1.invalidateContainerClientCoordsCache = function () {
  this.containerBB = null;
};

BRp$1.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};

BRp$1.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max

  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }

  function addEle(ele, sqDist) {
    if (ele.isNode()) {
      if (nearNode) {
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push(ele);
      }
    }

    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
          for (var i = 0; i < near.length; i++) {
            if (near[i].isEdge()) {
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele);
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode(node) {
    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = node.position();

    if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
    ) {
        var shape = r.nodeShapes[self.getNodeShape(node)];

        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
          addEle(node, 0);
          return true;
        }
      }
  }

  function checkEdge(edge) {
    var _p = edge._private;
    var rs = _p.rscratch;
    var styleWidth = edge.pstyle('width').pfValue;
    var scale = edge.pstyle('arrow-scale').value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre

    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var sqDist;

    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
      var pts = rs.allpts;

      for (var i = 0; i + 3 < pts.length; i += 2) {
        if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
      var pts = rs.allpts;

      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
        if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } // if we're close to the edge but didn't hit it, maybe we hit its arrows


    var src = src || _p.source;
    var tgt = tgt || _p.target;
    var arSize = self.getArrowWidth(styleWidth, scale);
    var arrows = [{
      name: 'source',
      x: rs.arrowStartX,
      y: rs.arrowStartY,
      angle: rs.srcArrowAngle
    }, {
      name: 'target',
      x: rs.arrowEndX,
      y: rs.arrowEndY,
      angle: rs.tgtArrowAngle
    }, {
      name: 'mid-source',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midsrcArrowAngle
    }, {
      name: 'mid-target',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midtgtArrowAngle
    }];

    for (var i = 0; i < arrows.length; i++) {
      var ar = arrows[i];
      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
      var edgeWidth = edge.pstyle('width').pfValue;

      if (shape.roughCollide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)


    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }

  function preprop(obj, name, pre) {
    return getPrefixedProperty(obj, name, pre);
  }

  function checkLabel(ele, prefix) {
    var _p = ele._private;
    var th = labelThreshold;
    var prefixDash;

    if (prefix) {
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    ele.boundingBox();
    var bb = _p.labelBounds[prefix || 'main'];
    var text = ele.pstyle(prefixDash + 'label').value;
    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

    if (!eventsEnabled || !text) {
      return;
    }

    var rstyle = _p.rstyle;
    var lx = preprop(rstyle, 'labelX', prefix);
    var ly = preprop(rstyle, 'labelY', prefix);
    var theta = preprop(_p.rscratch, 'labelAngle', prefix);
    var lx1 = bb.x1 - th;
    var lx2 = bb.x2 + th;
    var ly1 = bb.y1 - th;
    var ly2 = bb.y2 + th;

    if (theta) {
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - lx;
        y = y - ly;
        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

      if (pointInsidePolygonPoints(x, y, points)) {
        addEle(ele);
        return true;
      }
    } else {
      // do a cheaper bb check
      if (inBoundingBox(bb, x, y)) {
        addEle(ele);
        return true;
      }
    }
  }

  for (var i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
    var ele = eles[i];

    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      // then edge
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
    }
  }

  return near;
}; // 'Give me everything from this box'


BRp$1.getAllInBox = function (x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];
  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);
  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;
  var boxBb = makeBoundingBox({
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  });

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];

    if (ele.isNode()) {
      var node = ele;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      });

      if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {
        box.push(node);
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
        continue;
      }

      if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
        continue;
      }

      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {
        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for (var i = 0; i < pts.length; i++) {
          if (!pointInBoundingBox(boxBb, pts[i])) {
            allInside = false;
            break;
          }
        }

        if (allInside) {
          box.push(edge);
        }
      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
        box.push(edge);
      }
    }
  }

  return box;
};

var BRp$2 = {};

BRp$2.calculateArrowAngles = function (edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation

  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  if (isHaystack) {
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY; // source
  //

  if (isSegments) {
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
    var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if (isHaystack) {
    midX = (startX + endX) / 2;
    midY = (startY + endY) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      var i2 = pts.length / 2;
      var i1 = i2 - 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts.length / 2 - 1; // startpt

      var ic = p0 + 2;
      var p1 = ic + 2;
      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
    } else {
      var ic = pts.length / 2 - 1; // ctrpt

      var p0 = ic - 2; // startpt

      var p1 = ic + 2; // endpt

      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
    }

    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }

  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
  rs.midDispX = dispX;
  rs.midDispY = dispY; // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) ; else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;
      dispX = -(pts[i3] - pts[i2]);
      dispY = -(pts[i3 + 1] - pts[i2 + 1]);
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
  //

  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var l = pts.length;
    var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
    var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
};

BRp$2.getArrowWidth = BRp$2.getArrowHeight = function (edgeWidth, scale) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};
  var cachedVal = cache[edgeWidth + ', ' + scale];

  if (cachedVal) {
    return cachedVal;
  }

  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
  cache[edgeWidth + ', ' + scale] = cachedVal;
  return cachedVal;
};

var BRp$3 = {};

BRp$3.findHaystackPoints = function (edges) {
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var rs = _p.rscratch;

    if (!rs.haystack) {
      var angle = Math.random() * 2 * Math.PI;
      rs.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
      angle = Math.random() * 2 * Math.PI;
      rs.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle('haystack-radius').value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously

    rs.edgeType = 'haystack';
    rs.haystack = true;
    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};

BRp$3.findSegmentsPoints = function (edge, pairInfo) {
  // Segments (multiple straight lines)
  var rs = edge._private.rscratch;
  var posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts,
      vectorNormInverse = pairInfo.vectorNormInverse;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var segmentWs = edge.pstyle('segment-weights');
  var segmentDs = edge.pstyle('segment-distances');
  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
  rs.edgeType = 'segments';
  rs.segpts = [];

  for (var s = 0; s < segmentsN; s++) {
    var w = segmentWs.pfValue[s];
    var d = segmentDs.pfValue[s];
    var w1 = 1 - w;
    var w2 = w;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
  }
};

BRp$3.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Self-edge
  var rs = edge._private.rscratch;
  var dirCounts = pairInfo.dirCounts,
      srcPos = pairInfo.srcPos;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var loopDir = edge.pstyle('loop-direction').pfValue;
  var loopSwp = edge.pstyle('loop-sweep').pfValue;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  rs.edgeType = 'self';
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopAngle = loopDir - Math.PI / 2;
  var outAngle = loopAngle - loopSwp / 2;
  var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values

  var dc = String(loopDir + '_' + loopSwp);
  j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
};

BRp$3.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Compound edge
  var rs = edge._private.rscratch;
  rs.edgeType = 'compound';
  var srcPos = pairInfo.srcPos,
      tgtPos = pairInfo.tgtPos,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopW = 50;
  var loopaPos = {
    x: srcPos.x - srcW / 2,
    y: srcPos.y - srcH / 2
  };
  var loopbPos = {
    x: tgtPos.x - tgtW / 2,
    y: tgtPos.y - tgtH / 2
  };
  var loopPos = {
    x: Math.min(loopaPos.x, loopbPos.x),
    y: Math.min(loopaPos.y, loopbPos.y)
  }; // avoids cases with impossible beziers

  var minCompoundStretch = 0.5;
  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
};

BRp$3.findStraightEdgePoints = function (edge) {
  // Straight edge within bundle
  edge._private.rscratch.edgeType = 'straight';
};

BRp$3.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
  var rs = edge._private.rscratch;
  var vectorNormInverse = pairInfo.vectorNormInverse,
      posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptWs = edge.pstyle('control-point-weights');
  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier

  var multi = edgeIsUnbundled;
  rs.edgeType = multi ? 'multibezier' : 'bezier';
  rs.ctrlpts = [];

  for (var b = 0; b < bezierN; b++) {
    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
    var manctrlptDist = void 0;
    var sign = signum(normctrlptDist);

    if (multi) {
      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size

      ctrlptWeight = ctrlptWs.value[b];
    }

    if (edgeIsUnbundled) {
      // multi or single unbundled
      manctrlptDist = ctrlptDist;
    } else {
      manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
    }

    var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
    var w1 = 1 - ctrlptWeight;
    var w2 = ctrlptWeight;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
  }
};

BRp$3.findTaxiPoints = function (edge, pairInfo) {
  // Taxicab geometry with two turns maximum
  var rs = edge._private.rscratch;
  rs.edgeType = 'segments';
  var VERTICAL = 'vertical';
  var HORIZONTAL = 'horizontal';
  var LEFTWARD = 'leftward';
  var RIGHTWARD = 'rightward';
  var DOWNWARD = 'downward';
  var UPWARD = 'upward';
  var AUTO = 'auto';
  var posPts = pairInfo.posPts,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var dIncludesNodeBody = edgeDistances !== 'node-position';
  var taxiDir = edge.pstyle('taxi-direction').value;
  var rawTaxiDir = taxiDir; // unprocessed value

  var taxiTurn = edge.pstyle('taxi-turn');
  var taxiTurnPfVal = taxiTurn.pfValue;
  var minD = edge.pstyle('taxi-turn-min-distance').pfValue;
  var turnIsPercent = taxiTurn.units === '%';
  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
  var pdx = posPts.x2 - posPts.x1;
  var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value

  var subDWH = function subDWH(dxy, dwh) {
    if (dxy > 0) {
      return Math.max(dxy - dwh, 0);
    } else {
      return Math.min(dxy + dwh, 0);
    }
  };

  var dx = subDWH(pdx, dw);
  var dy = subDWH(pdy, dh);
  var isExplicitDir = false;

  if (taxiDir === AUTO) {
    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
  } else if (taxiDir === UPWARD || taxiDir === DOWNWARD) {
    taxiDir = VERTICAL;
    isExplicitDir = true;
  } else if (taxiDir === LEFTWARD || taxiDir === RIGHTWARD) {
    taxiDir = HORIZONTAL;
    isExplicitDir = true;
  }

  var isVert = taxiDir === VERTICAL;
  var l = isVert ? dy : dx;
  var pl = isVert ? pdy : pdx;
  var sgnL = signum(pl);
  var forcedDir = false;

  if (!(isExplicitDir && turnIsPercent) // forcing in this case would cause weird growing in the opposite direction
  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
    sgnL *= -1;
    l = sgnL * Math.abs(l);
    forcedDir = true;
  }

  var d = turnIsPercent ? taxiTurnPfVal * l : taxiTurnPfVal * sgnL;

  var getIsTooClose = function getIsTooClose(d) {
    return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
  };

  var isTooCloseSrc = getIsTooClose(d);
  var isTooCloseTgt = getIsTooClose(l - d);
  var isTooClose = isTooCloseSrc || isTooCloseTgt;

  if (isTooClose && !forcedDir) {
    // non-ideal routing
    if (isVert) {
      // vertical fallbacks
      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;

      if (lShapeInsideSrc) {
        // horizontal Z-shape (direction not respected)
        var x = (posPts.x1 + posPts.x2) / 2;
        var y1 = posPts.y1,
            y2 = posPts.y2;
        rs.segpts = [x, y1, x, y2];
      } else if (lShapeInsideTgt) {
        // vertical Z-shape (distance not respected)
        var y = (posPts.y1 + posPts.y2) / 2;
        var x1 = posPts.x1,
            x2 = posPts.x2;
        rs.segpts = [x1, y, x2, y];
      } else {
        // L-shape fallback (turn distance not respected, but works well with tree siblings)
        rs.segpts = [posPts.x1, posPts.y2];
      }
    } else {
      // horizontal fallbacks
      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;

      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;

      if (_lShapeInsideSrc) {
        // vertical Z-shape (direction not respected)
        var _y = (posPts.y1 + posPts.y2) / 2;

        var _x = posPts.x1,
            _x2 = posPts.x2;
        rs.segpts = [_x, _y, _x2, _y];
      } else if (_lShapeInsideTgt) {
        // horizontal Z-shape (turn distance not respected)
        var _x3 = (posPts.x1 + posPts.x2) / 2;

        var _y2 = posPts.y1,
            _y3 = posPts.y2;
        rs.segpts = [_x3, _y2, _x3, _y3];
      } else {
        // L-shape (turn distance not respected, but works well for tree siblings)
        rs.segpts = [posPts.x2, posPts.y1];
      }
    }
  } else {
    // ideal routing
    if (isVert) {
      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);

      var _x4 = posPts.x1,
          _x5 = posPts.x2;
      rs.segpts = [_x4, _y4, _x5, _y4];
    } else {
      // horizontal
      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);

      var _y5 = posPts.y1,
          _y6 = posPts.y2;
      rs.segpts = [_x6, _y5, _x6, _y6];
    }
  }
};

BRp$3.tryToCorrectInvalidPoints = function (edge, pairInfo) {
  var rs = edge._private.rscratch; // can only correct beziers for now...

  if (rs.edgeType === 'bezier') {
    var srcPos = pairInfo.srcPos,
        tgtPos = pairInfo.tgtPos,
        srcW = pairInfo.srcW,
        srcH = pairInfo.srcH,
        tgtW = pairInfo.tgtW,
        tgtH = pairInfo.tgtH,
        srcShape = pairInfo.srcShape,
        tgtShape = pairInfo.tgtShape;
    var badStart = !number(rs.startX) || !number(rs.startY);
    var badAStart = !number(rs.arrowStartX) || !number(rs.arrowStartY);
    var badEnd = !number(rs.endX) || !number(rs.endY);
    var badAEnd = !number(rs.arrowEndX) || !number(rs.arrowEndY);
    var minCpADistFactor = 3;
    var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
    var minCpADist = minCpADistFactor * arrowW;
    var startACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.startX,
      y: rs.startY
    });
    var closeStartACp = startACpDist < minCpADist;
    var endACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.endX,
      y: rs.endY
    });
    var closeEndACp = endACpDist < minCpADist;
    var overlapping = false;

    if (badStart || badAStart || closeStartACp) {
      overlapping = true; // project control point along line from src centre to outside the src shape
      // (otherwise intersection will yield nothing)

      var cpD = {
        // delta
        x: rs.ctrlpts[0] - srcPos.x,
        y: rs.ctrlpts[1] - srcPos.y
      };
      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line

      var cpM = {
        // normalised delta
        x: cpD.x / cpL,
        y: cpD.y / cpL
      };
      var radius = Math.max(srcW, srcH);
      var cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + cpM.x * 2 * radius,
        y: rs.ctrlpts[1] + cpM.y * 2 * radius
      };
      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

      if (closeStartACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
      } else {
        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
      }
    }

    if (badEnd || badAEnd || closeEndACp) {
      overlapping = true; // project control point along line from tgt centre to outside the tgt shape
      // (otherwise intersection will yield nothing)

      var _cpD = {
        // delta
        x: rs.ctrlpts[0] - tgtPos.x,
        y: rs.ctrlpts[1] - tgtPos.y
      };

      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line


      var _cpM = {
        // normalised delta
        x: _cpD.x / _cpL,
        y: _cpD.y / _cpL
      };

      var _radius = Math.max(srcW, srcH);

      var _cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
      };
      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);

      if (closeEndACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
      } else {
        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
      }
    }

    if (overlapping) {
      // recalc endpts
      this.findEndpoints(edge);
    }
  }
};

BRp$3.storeAllpts = function (edge) {
  var rs = edge._private.rscratch;

  if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);

    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
      // ctrl pt itself
      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts

      if (b + 3 < rs.ctrlpts.length) {
        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
      }
    }

    rs.allpts.push(rs.endX, rs.endY);
    var m, mt;

    if (rs.ctrlpts.length / 2 % 2 === 0) {
      m = rs.allpts.length / 2 - 1;
      rs.midX = rs.allpts[m];
      rs.midY = rs.allpts[m + 1];
    } else {
      m = rs.allpts.length / 2 - 3;
      mt = 0.5;
      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
    }
  } else if (rs.edgeType === 'straight') {
    // need to calc these after endpts
    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc

    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
  } else if (rs.edgeType === 'segments') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);
    rs.allpts.push.apply(rs.allpts, rs.segpts);
    rs.allpts.push(rs.endX, rs.endY);

    if (rs.segpts.length % 4 === 0) {
      var i2 = rs.segpts.length / 2;
      var i1 = i2 - 2;
      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
    } else {
      var _i = rs.segpts.length / 2 - 1;

      rs.midX = rs.segpts[_i];
      rs.midY = rs.segpts[_i + 1];
    }
  }
};

BRp$3.checkForInvalidEdgeWarning = function (edge) {
  var rs = edge[0]._private.rscratch;

  if (rs.nodesOverlap || number(rs.startX) && number(rs.startY) && number(rs.endX) && number(rs.endY)) {
    rs.loggedErr = false;
  } else {
    if (!rs.loggedErr) {
      rs.loggedErr = true;
      warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');
    }
  }
};

BRp$3.findEdgeControlPoints = function (edges) {
  var _this = this;

  if (!edges || edges.length === 0) {
    return;
  }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {
    map: new Map$1(),
    get: function get(pairId) {
      var map2 = this.map.get(pairId[0]);

      if (map2 != null) {
        return map2.get(pairId[1]);
      } else {
        return null;
      }
    },
    set: function set(pairId, val) {
      var map2 = this.map.get(pairId[0]);

      if (map2 == null) {
        map2 = new Map$1();
        this.map.set(pairId[0], map2);
      }

      map2.set(pairId[1], val);
    }
  };
  var pairIds = [];
  var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed
    // they shouldn't take up space

    if (edge.removed() || !edge.takesUpSpace()) {
      continue;
    }

    if (curveStyle === 'haystack') {
      haystackEdges.push(edge);
      continue;
    }

    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'taxi';
    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';
    var src = _p.source;
    var tgt = _p.target;
    var srcIndex = src.poolIndex();
    var tgtIndex = tgt.poolIndex();
    var pairId = [srcIndex, tgtIndex].sort();
    var tableEntry = hashTable.get(pairId);

    if (tableEntry == null) {
      tableEntry = {
        eles: []
      };
      hashTable.set(pairId, tableEntry);
      pairIds.push(pairId);
    }

    tableEntry.eles.push(edge);

    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }

    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  } // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount


  var _loop = function _loop(p) {
    var pairId = pairIds[p];
    var pairInfo = hashTable.get(pairId);
    var swappedpairInfo = void 0;

    if (!pairInfo.hasUnbundled) {
      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {
        return e.isBundledBezier();
      });
      clearArray(pairInfo.eles);
      pllEdges.forEach(function (edge) {
        return pairInfo.eles.push(edge);
      }); // for each pair id, the edges should be sorted by index

      pairInfo.eles.sort(function (edge1, edge2) {
        return edge1.poolIndex() - edge2.poolIndex();
      });
    }

    var firstEdge = pairInfo.eles[0];
    var src = firstEdge.source();
    var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId

    if (src.poolIndex() > tgt.poolIndex()) {
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    var srcPos = pairInfo.srcPos = src.position();
    var tgtPos = pairInfo.tgtPos = tgt.position();
    var srcW = pairInfo.srcW = src.outerWidth();
    var srcH = pairInfo.srcH = src.outerHeight();
    var tgtW = pairInfo.tgtW = tgt.outerWidth();
    var tgtH = pairInfo.tgtH = tgt.outerHeight();

    var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];

    var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];

    pairInfo.dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
      var _edge = pairInfo.eles[_i2];
      var rs = _edge[0]._private.rscratch;

      var _curveStyle = _edge.pstyle('curve-style').value;

      var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order


      var edgeIsSwapped = !src.same(_edge.source());

      if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
        pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt

        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
        var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt

        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
        var tgtIntn = pairInfo.tgtIntn = tgtOutside;
        var intersectionPts = pairInfo.intersectionPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };
        var posPts = pairInfo.posPts = {
          x1: srcPos.x,
          x2: tgtPos.x,
          y1: srcPos.y,
          y2: tgtPos.y
        };
        var dy = tgtOutside[1] - srcOutside[1];
        var dx = tgtOutside[0] - srcOutside[0];
        var l = Math.sqrt(dx * dx + dy * dy);
        var vector = pairInfo.vector = {
          x: dx,
          y: dy
        };
        var vectorNorm = pairInfo.vectorNorm = {
          x: vector.x / l,
          y: vector.y / l
        };
        var vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        }; // if node shapes overlap, then no ctrl pts to draw

        pairInfo.nodesOverlap = !number(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
        pairInfo.vectorNormInverse = vectorNormInverse;
        swappedpairInfo = {
          nodesOverlap: pairInfo.nodesOverlap,
          dirCounts: pairInfo.dirCounts,
          calculatedIntersection: true,
          hasBezier: pairInfo.hasBezier,
          hasUnbundled: pairInfo.hasUnbundled,
          eles: pairInfo.eles,
          srcPos: tgtPos,
          tgtPos: srcPos,
          srcW: tgtW,
          srcH: tgtH,
          tgtW: srcW,
          tgtH: srcH,
          srcIntn: tgtIntn,
          tgtIntn: srcIntn,
          srcShape: tgtShape,
          tgtShape: srcShape,
          posPts: {
            x1: posPts.x2,
            y1: posPts.y2,
            x2: posPts.x1,
            y2: posPts.y1
          },
          intersectionPts: {
            x1: intersectionPts.x2,
            y1: intersectionPts.y2,
            x2: intersectionPts.x1,
            y2: intersectionPts.y1
          },
          vector: {
            x: -vector.x,
            y: -vector.y
          },
          vectorNorm: {
            x: -vectorNorm.x,
            y: -vectorNorm.y
          },
          vectorNormInverse: {
            x: -vectorNormInverse.x,
            y: -vectorNormInverse.y
          }
        };
      }

      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
      rs.nodesOverlap = passedPairInfo.nodesOverlap;
      rs.srcIntn = passedPairInfo.srcIntn;
      rs.tgtIntn = passedPairInfo.tgtIntn;

      if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {
        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (src === tgt) {
        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (_curveStyle === 'segments') {
        _this.findSegmentsPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'taxi') {
        _this.findTaxiPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
        _this.findStraightEdgePoints(_edge);
      } else {
        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
      }

      _this.findEndpoints(_edge);

      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);

      _this.checkForInvalidEdgeWarning(_edge);

      _this.storeAllpts(_edge);

      _this.storeEdgeProjections(_edge);

      _this.calculateArrowAngles(_edge);

      _this.recalculateEdgeLabelProjections(_edge);

      _this.calculateLabelAngles(_edge);
    } // for pair edges

  };

  for (var p = 0; p < pairIds.length; p++) {
    _loop(p);
  } // for pair ids
  // haystacks avoid the expense of pairInfo stuff (intersections etc.)


  this.findHaystackPoints(haystackEdges);
};

function getPts(pts) {
  var retPts = [];

  if (pts == null) {
    return;
  }

  for (var i = 0; i < pts.length; i += 2) {
    var x = pts[i];
    var y = pts[i + 1];
    retPts.push({
      x: x,
      y: y
    });
  }

  return retPts;
}

BRp$3.getSegmentPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'segments') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.segpts);
  }
};

BRp$3.getControlPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.ctrlpts);
  }
};

BRp$3.getEdgeMidpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  return {
    x: rs.midX,
    y: rs.midY
  };
};

var BRp$4 = {};

BRp$4.manualEndptToPx = function (node, prop) {
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if (prop.value.length === 2) {
    var p = [prop.pfValue[0], prop.pfValue[1]];

    if (prop.units[0] === '%') {
      p[0] = p[0] * w;
    }

    if (prop.units[1] === '%') {
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;
    return p;
  } else {
    var angle = prop.pfValue[0];
    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max(w, h);
    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];
    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
  }
};

BRp$4.findEndpoints = function (edge) {
  var r = this;
  var intersect;
  var source = edge.source()[0];
  var target = edge.target()[0];
  var srcPos = source.position();
  var tgtPos = target.position();
  var tgtArShape = edge.pstyle('target-arrow-shape').value;
  var srcArShape = edge.pstyle('source-arrow-shape').value;
  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
  var srcDist = edge.pstyle('source-distance-from-node').pfValue;
  var curveStyle = edge.pstyle('curve-style').value;
  var rs = edge._private.rscratch;
  var et = rs.edgeType;
  var taxi = curveStyle === 'taxi';
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var overrideEndpts = self || taxi;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;
  var tgtManEndpt = edge.pstyle('target-endpoint');
  var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;
  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;
  var p1; // last known point of edge on target side

  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape

  var p2_i; // point to intersect with source shape

  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);
    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if (tgtManEndptVal === 'inside-to-node') {
    intersect = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === 'outside-to-line') {
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {
      p1_i = p1;
    } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {
      p1_i = [srcPos.x, srcPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);

    if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {
      var trs = target._private.rscratch;
      var lw = trs.labelWidth;
      var lh = trs.labelHeight;
      var lx = trs.labelX;
      var ly = trs.labelY;
      var va = target.pstyle('text-valign').value;

      if (va === 'top') {
        ly -= lh / 2;
      } else if (va === 'bottom') {
        ly += lh / 2;
      }

      var ha = target.pstyle('text-halign').value;

      if (ha === 'left') {
        lx -= lw / 2;
      } else if (ha === 'right') {
        lx += lw / 2;
      }

      var labelIntersect = r.nodeShapes['rectangle'].intersectLine(lx, ly, lw, lh, p1_i[0], p1_i[1], 0);
      var refPt = srcPos;
      var intSqdist = sqdist(refPt, array2point(intersect));
      var labIntSqdist = sqdist(refPt, array2point(labelIntersect));

      if (labIntSqdist < intSqdist) {
        intersect = labelIntersect;
      }
    }
  }

  var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];
  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if (srcManEndptVal === 'inside-to-node') {
    intersect = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect = this.manualEndptToPx(source, srcManEndpt);
  } else if (srcManEndptVal === 'outside-to-line') {
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {
      p2_i = p2;
    } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {
      p2_i = [tgtPos.x, tgtPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);

    if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {
      var srs = source._private.rscratch;
      var _lw = srs.labelWidth;
      var _lh = srs.labelHeight;
      var _lx = srs.labelX;
      var _ly = srs.labelY;
      var _va = source.pstyle('text-valign').value;

      if (_va === 'top') {
        _ly -= _lh / 2;
      } else if (_va === 'bottom') {
        _ly += _lh / 2;
      }

      var _ha = source.pstyle('text-halign').value;

      if (_ha === 'left') {
        _lx -= _lw / 2;
      } else if (_ha === 'right') {
        _lx += _lw / 2;
      }

      var _labelIntersect = r.nodeShapes['rectangle'].intersectLine(_lx, _ly, _lw, _lh, p2_i[0], p2_i[1], 0);

      var _refPt = tgtPos;

      var _intSqdist = sqdist(_refPt, array2point(intersect));

      var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));

      if (_labIntSqdist < _intSqdist) {
        intersect = _labelIntersect;
      }
    }
  }

  var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];
  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if (hasEndpts) {
    if (!number(rs.startX) || !number(rs.startY) || !number(rs.endX) || !number(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp$4.getSourceEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };

    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};

BRp$4.getTargetEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };

    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};

var BRp$5 = {};

function pushBezierPts(r, edge, pts) {
  var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
    return qbezierAt(p1, p2, p3, t);
  };

  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for (var i = 0; i < r.bezierProjPcts.length; i++) {
    var p = r.bezierProjPcts[i];
    bpts.push({
      x: qbezierAt$1(pts[0], pts[2], pts[4], p),
      y: qbezierAt$1(pts[1], pts[3], pts[5], p)
    });
  }
}

BRp$5.storeEdgeProjections = function (edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType; // clear the cached points state

  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
    _p.rstyle.bezierPts = [];

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === 'segments') {
    var lpts = _p.rstyle.linePts = [];

    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === 'haystack') {
    var hpts = rs.haystackPts;
    _p.rstyle.haystackPts = [{
      x: hpts[0],
      y: hpts[1]
    }, {
      x: hpts[2],
      y: hpts[3]
    }];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
};

BRp$5.recalculateEdgeProjections = function (edges) {
  this.findEdgeControlPoints(edges);
};

var BRp$6 = {};

BRp$6.recalculateNodeLabelProjection = function (node) {
  var content = node.pstyle('label').strValue;

  if (emptyString(content)) {
    return;
  }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle('text-halign').strValue;
  var textValign = node.pstyle('text-valign').strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch (textHalign) {
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default:
      // e.g. center
      textX = nodePos.x;
  }

  switch (textValign) {
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default:
      // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;
  this.applyLabelDimensions(node);
};

var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
  var angle = Math.atan(dy / dx);

  if (dx === 0 && angle < 0) {
    angle = angle * -1;
  }

  return angle;
};

var lineAngle = function lineAngle(p0, p1) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  return lineAngleFromDelta(dx, dy);
};

var bezierAngle = function bezierAngle(p0, p1, p2, t) {
  var t0 = bound(0, t - 0.001, 1);
  var t1 = bound(0, t + 0.001, 1);
  var lp0 = qbezierPtAt(p0, p1, p2, t0);
  var lp1 = qbezierPtAt(p0, p1, p2, t1);
  return lineAngle(lp0, lp1);
};

BRp$6.recalculateEdgeLabelProjections = function (edge) {
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if (content.mid || content.source || content.target) ; else {
      return; // no labels => no calcs
    } // add center point to style so bounding box calculations can use it
  //


  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function setRs(propName, prefix, value) {
    setPrefixedProperty(_p.rscratch, propName, prefix, value);
    setPrefixedProperty(_p.rstyle, propName, prefix, value);
  };

  setRs('labelX', null, p.x);
  setRs('labelY', null, p.y);
  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
  setRs('labelAutoAngle', null, midAngle);

  var createControlPointInfo = function createControlPointInfo() {
    if (createControlPointInfo.cache) {
      return createControlPointInfo.cache;
    } // use cache so only 1x per edge


    var ctrlpts = []; // store each ctrlpt info init

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = {
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      };
      var p1 = {
        x: rs.allpts[i + 2],
        y: rs.allpts[i + 3]
      }; // ctrlpt

      var p2 = {
        x: rs.allpts[i + 4],
        y: rs.allpts[i + 5]
      };
      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment(cp, p0, p1, t0, t1) {
      var length = dist(p0, p1);
      var prevSegment = cp.segments[cp.segments.length - 1];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };
      cp.segments.push(segment);
      cp.length += length;
    } // update each ctrlpt with segment info


    for (var _i = 0; _i < ctrlpts.length; _i++) {
      var cp = ctrlpts[_i];
      var prevCp = ctrlpts[_i - 1];

      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first

      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
      }

      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
    }

    return createControlPointInfo.cache = ctrlpts;
  };

  var calculateEndProjection = function calculateEndProjection(prefix) {
    var angle;
    var isSrc = prefix === 'source';

    if (!content[prefix]) {
      return;
    }

    var offset = edge.pstyle(prefix + '-text-offset').pfValue;

    switch (rs.edgeType) {
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        {
          var cps = createControlPointInfo();
          var selected;
          var startDist = 0;
          var totalDist = 0; // find the segment we're on

          for (var i = 0; i < cps.length; i++) {
            var _cp = cps[isSrc ? i : cps.length - 1 - i];

            for (var j = 0; j < _cp.segments.length; j++) {
              var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
              var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
              startDist = totalDist;
              totalDist += _seg.length;

              if (totalDist >= offset || lastSeg) {
                selected = {
                  cp: _cp,
                  segment: _seg
                };
                break;
              }
            }

            if (selected) {
              break;
            }
          }

          var cp = selected.cp;
          var seg = selected.segment;
          var tSegment = (offset - startDist) / seg.length;
          var segDt = seg.t1 - seg.t0;
          var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
          t = bound(0, t, 1);
          p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
          angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
          break;
        }

      case 'straight':
      case 'segments':
      case 'haystack':
        {
          var d = 0,
              di,
              d0;
          var p0, p1;
          var l = rs.allpts.length;

          for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {
            if (isSrc) {
              p0 = {
                x: rs.allpts[_i2],
                y: rs.allpts[_i2 + 1]
              };
              p1 = {
                x: rs.allpts[_i2 + 2],
                y: rs.allpts[_i2 + 3]
              };
            } else {
              p0 = {
                x: rs.allpts[l - 2 - _i2],
                y: rs.allpts[l - 1 - _i2]
              };
              p1 = {
                x: rs.allpts[l - 4 - _i2],
                y: rs.allpts[l - 3 - _i2]
              };
            }

            di = dist(p0, p1);
            d0 = d;
            d += di;

            if (d >= offset) {
              break;
            }
          }

          var pD = offset - d0;

          var _t = pD / di;

          _t = bound(0, _t, 1);
          p = lineAt(p0, p1, _t);
          angle = lineAngle(p0, p1);
          break;
        }
    }

    setRs('labelX', prefix, p.x);
    setRs('labelY', prefix, p.y);
    setRs('labelAutoAngle', prefix, angle);
  };

  calculateEndProjection('source');
  calculateEndProjection('target');
  this.applyLabelDimensions(edge);
};

BRp$6.applyLabelDimensions = function (ele) {
  this.applyPrefixedLabelDimensions(ele);

  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, 'source');
    this.applyPrefixedLabelDimensions(ele, 'target');
  }
};

BRp$6.applyPrefixedLabelDimensions = function (ele, prefix) {
  var _p = ele._private;
  var text = this.getLabelText(ele, prefix);
  var labelDims = this.calculateLabelDimensions(ele, text);
  var lineHeight = ele.pstyle('line-height').pfValue;
  var textWrap = ele.pstyle('text-wrap').strValue;
  var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];
  var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);
  var normPerLineHeight = labelDims.height / numLines;
  var labelLineHeight = normPerLineHeight * lineHeight;
  var width = labelDims.width;
  var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
  setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);
};

BRp$6.getLabelText = function (ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle(pfd + 'label').strValue;
  var textTransform = ele.pstyle('text-transform').value;

  var rscratch = function rscratch(propName, value) {
    if (value) {
      setPrefixedProperty(_p.rscratch, propName, prefix, value);
      return value;
    } else {
      return getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  }; // for empty text, skip all processing


  if (!text) {
    return '';
  }

  if (textTransform == 'none') ; else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle('text-wrap').value;

  if (wrapStyle === 'wrap') {
    var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before

    if (labelKey != null && rscratch('labelWrapKey') === labelKey) {
      return rscratch('labelWrapCachedText');
    }

    var zwsp = "\u200B";
    var lines = text.split('\n');
    var maxW = ele.pstyle('text-max-width').pfValue;
    var overflow = ele.pstyle('text-overflow-wrap').value;
    var overflowAny = overflow === 'anywhere';
    var wrappedLines = [];
    var wordsRegex = /[\s\u200b]+/;
    var wordSeparator = overflowAny ? '' : ' ';

    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line);
      var lineW = lineDims.width;

      if (overflowAny) {
        var processedLine = line.split('').join(zwsp);
        line = processedLine;
      }

      if (lineW > maxW) {
        // line is too long
        var words = line.split(wordsRegex);
        var subline = '';

        for (var w = 0; w < words.length; w++) {
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + wordSeparator + word;
          var testDims = this.calculateLabelDimensions(ele, testLine);
          var testW = testDims.width;

          if (testW <= maxW) {
            // word fits on current line
            subline += word + wordSeparator;
          } else {
            // word starts new line
            if (subline) {
              wrappedLines.push(subline);
            }

            subline = word + wordSeparator;
          }
        } // if there's remaining text, put it in a wrapped line


        if (!subline.match(/^[\s\u200b]+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        // line is already short enough
        wrappedLines.push(line);
      }
    } // for


    rscratch('labelWrapCachedLines', wrappedLines);
    text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
    rscratch('labelWrapKey', labelKey);
  } else if (wrapStyle === 'ellipsis') {
    var _maxW = ele.pstyle('text-max-width').pfValue;
    var ellipsized = '';
    var ellipsis = "\u2026";
    var incLastCh = false;

    for (var i = 0; i < text.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

      if (widthWithNextCh > _maxW) {
        break;
      }

      ellipsized += text[i];

      if (i === text.length - 1) {
        incLastCh = true;
      }
    }

    if (!incLastCh) {
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize


  return text;
};

BRp$6.getLabelJustification = function (ele) {
  var justification = ele.pstyle('text-justification').strValue;
  var textHalign = ele.pstyle('text-halign').strValue;

  if (justification === 'auto') {
    if (ele.isNode()) {
      switch (textHalign) {
        case 'left':
          return 'right';

        case 'right':
          return 'left';

        default:
          return 'center';
      }
    } else {
      return 'center';
    }
  } else {
    return justification;
  }
};

BRp$6.calculateLabelDimensions = function (ele, text) {
  var r = this;
  var cacheKey = hashString(text, ele._private.labelDimsKey);
  var cache = r.labelDimCache || (r.labelDimCache = []);
  var existingVal = cache[cacheKey];

  if (existingVal != null) {
    return existingVal;
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text

  var fStyle = ele.pstyle('font-style').strValue;
  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  var weight = ele.pstyle('font-weight').strValue;
  var div = this.labelCalcDiv;

  if (!div) {
    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef

    document.body.appendChild(div); // eslint-disable-line no-undef
  }

  var ds = div.style; // from ele style

  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight; // forced style

  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if (ele.pstyle('text-wrap').value === 'wrap') {
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  } // put label content in div


  div.textContent = text;
  return cache[cacheKey] = {
    width: Math.ceil(div.clientWidth / sizeMult),
    height: Math.ceil(div.clientHeight / sizeMult)
  };
};

BRp$6.calculateLabelAngle = function (ele, prefix) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var prefixDash = prefix ? prefix + '-' : '';
  var rot = ele.pstyle(prefixDash + 'text-rotation');
  var rotStr = rot.strValue;

  if (rotStr === 'none') {
    return 0;
  } else if (isEdge && rotStr === 'autorotate') {
    return rs.labelAutoAngle;
  } else if (rotStr === 'autorotate') {
    return 0;
  } else {
    return rot.pfValue;
  }
};

BRp$6.calculateLabelAngles = function (ele) {
  var r = this;
  var isEdge = ele.isEdge();
  var _p = ele._private;
  var rs = _p.rscratch;
  rs.labelAngle = r.calculateLabelAngle(ele);

  if (isEdge) {
    rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');
    rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');
  }
};

var BRp$7 = {};
var TOO_SMALL_CUT_RECT = 28;
var warnedCutRect = false;

BRp$7.getNodeShape = function (node) {
  var r = this;
  var shape = node.pstyle('shape').value;

  if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
    if (!warnedCutRect) {
      warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');
      warnedCutRect = true;
    }

    return 'rectangle';
  }

  if (node.isParent()) {
    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if (shape === 'polygon') {
    var points = node.pstyle('shape-polygon-points').value;
    return r.nodeShapes.makePolygon(points).name;
  }

  return shape;
};

var BRp$8 = {};

BRp$8.registerCalculationListeners = function () {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function enqueue(eles) {
    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    elesToUpdate.merge(eles);

    if (dirtyStyleCaches) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle;
        rstyle.clean = false;
        rstyle.cleanConnected = false;
      }
    }
  };

  r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {
    var ele = e.target;
    enqueue(ele);
  }).on('style.* background.*', function onDirtyStyle(e) {
    var ele = e.target;
    enqueue(ele, false);
  });

  var updateEleCalcs = function updateEleCalcs(willDraw) {
    if (willDraw) {
      var fns = r.onUpdateEleCalcsFns;

      for (var i = 0; i < elesToUpdate.length; i++) {
        var ele = elesToUpdate[i];
        var rstyle = ele._private.rstyle;

        if (ele.isNode() && !rstyle.cleanConnected) {
          enqueue(ele.connectedEdges());
          rstyle.cleanConnected = true;
        }
      }

      if (fns) {
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];
          fn(willDraw, elesToUpdate);
        }
      }

      r.recalculateRenderedStyle(elesToUpdate);
      elesToUpdate = cy.collection();
    }
  };

  r.flushRenderedStyleQueue = function () {
    updateEleCalcs(true);
  };

  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};

BRp$8.onUpdateEleCalcs = function (fn) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  fns.push(fn);
};

BRp$8.recalculateRenderedStyle = function (eles, useCache) {
  var edges = [];
  var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()

  if (this.destroyed) {
    return;
  } // use cache by default for perf


  if (useCache === undefined) {
    useCache = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle; // only update if dirty and in graph

    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    } // only update if not display: none


    if (ele.pstyle('display').value === 'none') {
      continue;
    }

    if (_p.group === 'nodes') {
      nodes.push(ele);
    } else {
      // edges
      edges.push(ele);
    }

    rstyle.clean = true;
  } // update node data from projections


  for (var i = 0; i < nodes.length; i++) {
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = ele.position();
    this.recalculateNodeLabelProjection(ele);
    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle('width').pfValue;
    rstyle.nodeH = ele.pstyle('height').pfValue;
  }

  this.recalculateEdgeProjections(edges); // update edge data from projections

  for (var i = 0; i < edges.length; i++) {
    var ele = edges[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch; // update rstyle positions

    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

var BRp$9 = {};

BRp$9.updateCachedGrabbedEles = function () {
  var eles = this.cachedZSortedEles;

  if (!eles) {
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];
  var grabTargets = [];

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  } // put the grab target nodes last so it's on top of its neighbourhood


  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];
    eles.drag.push(ele);
  }
};

BRp$9.invalidateCachedZSortedEles = function () {
  this.cachedZSortedEles = null;
};

BRp$9.getCachedZSortedEles = function (forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    var eles = this.cy.mutableElements().toArray();
    eles.sort(zIndexSort);
    eles.interactive = eles.filter(function (ele) {
      return ele.interactive();
    });
    this.cachedZSortedEles = eles;
    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

var BRp$a = {};
[BRp$1, BRp$2, BRp$3, BRp$4, BRp$5, BRp$6, BRp$7, BRp$8, BRp$9].forEach(function (props) {
  extend(BRp$a, props);
});

var BRp$b = {};

BRp$b.getCachedImage = function (url, crossOrigin, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[url];

  if (cache) {
    if (!cache.image.complete) {
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[url] = imageCache[url] || {};
    var image = cache.image = new Image(); // eslint-disable-line no-undef

    image.addEventListener('load', onLoad);
    image.addEventListener('error', function () {
      image.error = true;
    }); // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978

    var dataUriPrefix = 'data:';
    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;

    if (!isDataUri) {
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;
    return image;
  }
};

var BRp$c = {};
/* global document, window, ResizeObserver, MutationObserver */

BRp$c.registerBinding = function (target, event, handler, useCapture) {
  // eslint-disable-line no-unused-vars
  var args = Array.prototype.slice.apply(arguments, [1]); // copy

  var b = this.binder(target);
  return b.on.apply(b, args);
};

BRp$c.binder = function (tgt) {
  var r = this;
  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);

  if (r.supportsPassiveEvents == null) {
    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
          return true;
        }
      });
      window.addEventListener('test', null, opts);
    } catch (err) {// not supported
    }

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function on(event, handler, useCapture) {
    var args = Array.prototype.slice.call(arguments);

    if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });
    (tgt.addEventListener || tgt.on).apply(tgt, args);
    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp$c.nodeIsDraggable = function (node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};

BRp$c.nodeIsGrabbable = function (node) {
  return this.nodeIsDraggable(node) && node.interactive();
};

BRp$c.load = function () {
  var r = this;

  var isSelected = function isSelected(ele) {
    return ele.selected();
  };

  var triggerEvents = function triggerEvents(target, names, e, position) {
    if (target == null) {
      target = r.cy;
    }

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      target.emit({
        originalEvent: e,
        type: name,
        position: position
      });
    }
  };

  var isMultSelKeyDown = function isMultSelKeyDown(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
    var allowPassthrough = true;

    if (r.cy.hasCompoundNodes() && down && down.pannable()) {
      // a grabbable compound node below the ele => no passthrough panning
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];

        if (down.isNode() && down.isParent()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var setGrabbed = function setGrabbed(ele) {
    ele[0]._private.grabbed = true;
  };

  var setFreed = function setFreed(ele) {
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function setInDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function setOutDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function setGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function removeGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function addToDragList(ele, opts) {
    var list = opts.addToList;
    var listHasEle = list.has(ele);

    if (!listHasEle) {
      list.merge(ele);
      setGrabbed(ele);
    }
  }; // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes


  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    var innerNodes = node.descendants();

    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }

    if (opts.addToList) {
      opts.addToList.unmerge(innerNodes);
    }
  }; // adds the given nodes and its neighbourhood to the drag layer


  var addNodesToDrag = function addNodesToDrag(nodes, opts) {
    opts = opts || {};
    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if (opts.inDragLayer) {
      nodes.forEach(setInDragLayer);
      nodes.neighborhood().stdFilter(function (ele) {
        return !hasCompoundNodes || ele.isEdge();
      }).forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }

    addDescendantsToDrag(nodes, opts); // always add to drag
    // also add nodes and edges related to the topmost ancestor

    updateAncestorsInDragLayer(nodes, {
      inDragLayer: opts.inDragLayer
    });
    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function freeDraggedElements(grabbedEles) {
    if (!grabbedEles) {
      return;
    } // just go over all elements rather than doing a bunch of (possibly expensive) traversals


    r.getCachedZSortedEles().forEach(function (ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });
    r.updateCachedGrabbedEles();
  }; // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).


  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    if (!node.cy().hasCompoundNodes()) {
      return;
    } // find top-level parent


    var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer

    if (parent.same(node)) {
      return;
    }

    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
    var edges = nodes.connectedEdges();

    if (opts.inDragLayer) {
      edges.forEach(setInDragLayer);
      nodes.forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  var blurActiveDomElement = function blurActiveDomElement() {
    if (document.activeElement != null && document.activeElement.blur != null) {
      document.activeElement.blur();
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';
  var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom

  if (haveMutationsApi) {
    r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];

            if (rNode === r.container) {
              r.destroy();
              break;
            }
          }
        }
      }
    });

    if (r.container.parentNode) {
      r.removeObserver.observe(r.container.parentNode, {
        childList: true
      });
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      // eslint-disable-line no-unused-vars
      r.destroy();
    });
  }

  var onResize = util(function () {
    r.cy.resize();
  }, 100);

  if (haveMutationsApi) {
    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

    r.styleObserver.observe(r.container, {
      attributes: true
    });
  } // auto resize


  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

  if (haveResizeObserverApi) {
    r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef

    r.resizeObserver.observe(r.container);
  }

  var forEachUp = function forEachUp(domEle, fn) {
    while (domEle != null) {
      fn(domEle);
      domEle = domEle.parentNode;
    }
  };

  var invalidateCoords = function invalidateCoords() {
    r.invalidateContainerClientCoordsCache();
  };

  forEachUp(r.container, function (domEle) {
    r.registerBinding(domEle, 'transitionend', invalidateCoords);
    r.registerBinding(domEle, 'animationend', invalidateCoords);
    r.registerBinding(domEle, 'scroll', invalidateCoords);
  }); // stop right click menu from appearing on cy

  r.registerBinding(r.container, 'contextmenu', function (e) {
    e.preventDefault();
  });

  var inBoxSelection = function inBoxSelection() {
    return r.selection[4] !== 0;
  };

  var eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];
    var positions = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];

      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
        atLeastOnePosInside = true;
        break;
      }
    }

    if (!atLeastOnePosInside) {
      return false;
    }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while (tParent) {
      if (tParent === container) {
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if (!containerIsTarget) {
      return false;
    } // if target is outisde cy container, then this event is not for us


    return true;
  }; // Primary key


  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    e.preventDefault();
    blurActiveDomElement();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;
    var cy = r.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var select = r.selection;
    var nears = r.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;
    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function checkForTaphold() {
      r.hoverData.tapholdCancelled = false;
      clearTimeout(r.hoverData.tapholdTimeout);
      r.hoverData.tapholdTimeout = setTimeout(function () {
        if (r.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r.hoverData.down;

          if (ele) {
            ele.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          } else {
            cy.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      }, r.tapholdDuration);
    }; // Right click button


    if (e.which == 3) {
      r.hoverData.cxtStarted = true;
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapstart',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (near) {
        near.activate();
        near.emit(cxtEvt);
        r.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }

      r.hoverData.downTime = new Date().getTime();
      r.hoverData.cxtDragged = false; // Primary button
    } else if (e.which == 1) {
      if (near) {
        near.activate();
      } // Element dragging


      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {
          if (r.nodeIsGrabbable(near)) {
            var makeEvent = function makeEvent(type) {
              return {
                originalEvent: e,
                type: type,
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              };
            };

            var triggerGrab = function triggerGrab(ele) {
              ele.emit(makeEvent('grab'));
            };

            setGrabTarget(near);

            if (!near.selected()) {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              addNodeToDrag(near, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
            } else {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              var selectedNodes = cy.$(function (ele) {
                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
              });
              addNodesToDrag(selectedNodes, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon'));
              selectedNodes.forEach(triggerGrab);
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }
        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = new Date().getTime();
      }
      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (near == null) {
        select[4] = 1;
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } else if (near.pannable()) {
        select[4] = 1; // for future pan
      }

      checkForTaphold();
    } // Initialize selection box coordinates


    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, false);
  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;
    var near = null;

    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }

    var last = r.hoverData.last;
    var down = r.hoverData.down;
    var disp = [pos[0] - select[2], pos[1] - select[3]];
    var draggedElements = r.dragData.possibleDragElements;
    var isOverThresholdDrag;

    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown(e);

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function updateDragDelta() {
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if (dragDelta.length === 0) {
        dragDelta.push(disp[0]);
        dragDelta.push(disp[1]);
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };

    preventDefault = true;
    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      x: pos[0],
      y: pos[1]
    });

    var goIntoBoxMode = function goIntoBoxMode() {
      r.data.bgActivePosistion = undefined;

      if (!r.hoverData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: pos[0],
            y: pos[1]
          }
        });
      }

      select[4] = 1;
      r.hoverData.selecting = true;
      r.redrawHint('select', true);
      r.redraw();
    }; // trigger context drag if rmouse down


    if (r.hoverData.which === 3) {
      // but only if over threshold
      if (isOverThresholdDrag) {
        var cxtEvt = {
          originalEvent: e,
          type: 'cxtdrag',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }

        r.hoverData.cxtDragged = true;

        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
          if (r.hoverData.cxtOver) {
            r.hoverData.cxtOver.emit({
              originalEvent: e,
              type: 'cxtdragout',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }

          r.hoverData.cxtOver = near;

          if (near) {
            near.emit({
              originalEvent: e,
              type: 'cxtdragover',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      } // Check if we are drag panning the entire graph

    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;

        if (r.hoverData.justStartedPan) {
          var mdPos = r.hoverData.mdownPos;
          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom,
            y: (pos[1] - mdPos[1]) * zoom
          };
          r.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };
        }

        cy.panBy(deltaP);
        r.hoverData.dragged = true;
      } // Needs reproject due to pan changing viewport


      pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
    } else if (select[4] == 1 && (down == null || down.pannable())) {
      if (isOverThresholdDrag) {
        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

          if (allowPassthrough) {
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;
            r.data.bgActivePosistion = array2point(mdownPos);
            r.redrawHint('select', true);
            r.redraw();
          }
        }

        if (down && down.pannable() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.pannable() && down.active()) {
        down.unactivate();
      }

      if ((!down || !down.grabbed()) && near != last) {
        if (last) {
          triggerEvents(last, ['mouseout', 'tapdragout'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        if (near) {
          triggerEvents(near, ['mouseover', 'tapdragover'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        r.hoverData.last = near;
      }

      if (down) {
        if (isOverThresholdDrag) {
          // then we can take action
          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);
              down.emit('freeon');
              draggedElements.emit('free');

              if (r.dragData.didDrag) {
                down.emit('dragfreeon');
                draggedElements.emit('dragfree');
              }
            }

            goIntoBoxMode();
          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              r.redrawHint('eles', true);
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = cy.collection(); // now, add the elements to the drag layer if not done already

            if (!r.hoverData.draggingEles) {
              addNodesToDrag(draggedElements, {
                inDragLayer: true
              });
            }

            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                var dragDelta = r.hoverData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            for (var i = 0; i < draggedElements.length; i++) {
              var dEle = draggedElements[i];

              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                toTrigger.merge(dEle);
              }
            }

            r.hoverData.draggingEles = true;
            toTrigger.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);
            r.redraw();
          }
        } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      } // prevent the dragging from triggering text selection on the page


      preventDefault = true;
    }

    select[2] = pos[0];
    select[3] = pos[1];

    if (preventDefault) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, false);
  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture) {
      return;
    }

    r.hoverData.capture = false;
    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;
    var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);

    if (r.data.bgActivePosistion) {
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;
    r.data.bgActivePosistion = undefined; // not active bg now

    if (down) {
      down.unactivate();
    }

    if (r.hoverData.which === 3) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (!r.hoverData.cxtDragged) {
        var cxtTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;
    } else if (r.hoverData.which === 1) {
      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
      ) {
          triggerEvents(down, ['click', 'tap', 'vclick'], e, {
            x: pos[0],
            y: pos[1]
          });
        } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something


      if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {
        cy.$(isSelected).unselect(['tapunselect']);

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = cy.collection();
      } // Single selection


      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
        if (near != null && near._private.selectable) {
          if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {
            if (near.selected()) {
              near.unselect(['tapunselect']);
            } else {
              near.select(['tapselect']);
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(isSelected).unmerge(near).unselect(['tapunselect']);
              near.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if (r.hoverData.selecting) {
        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
        r.redrawHint('select', true);

        if (box.length > 0) {
          r.redrawHint('eles', true);
        }

        cy.emit({
          type: 'boxend',
          originalEvent: e,
          position: {
            x: pos[0],
            y: pos[1]
          }
        });

        var eleWouldBeSelected = function eleWouldBeSelected(ele) {
          return ele.selectable() && !ele.selected();
        };

        if (cy.selectionType() === 'additive') {
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } else {
          if (!multSelKeyDown) {
            cy.$(isSelected).unmerge(box).unselect();
          }

          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } // always need redraw in case eles unselectable


        r.redraw();
      } // Cancel drag pan


      if (r.hoverData.dragging) {
        r.hoverData.dragging = false;
        r.redrawHint('select', true);
        r.redrawHint('eles', true);
        r.redraw();
      }

      if (!select[4]) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);
        var downWasGrabbed = down && down.grabbed();
        freeDraggedElements(draggedElements);

        if (downWasGrabbed) {
          down.emit('freeon');
          draggedElements.emit('free');

          if (r.dragData.didDrag) {
            down.emit('dragfreeon');
            draggedElements.emit('dragfree');
          }
        }
      }
    } // else not right mouse


    select[4] = 0;
    r.hoverData.down = null;
    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.hoverData.isOverThresholdDrag = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;
  }, false);

  var wheelHandler = function wheelHandler(e) {
    if (r.scrollingPage) {
      return;
    } // while scrolling, ignore wheel-to-zoom


    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();
      r.data.wheelZooming = true;
      clearTimeout(r.data.wheelTimeout);
      r.data.wheelTimeout = setTimeout(function () {
        r.data.wheelZooming = false;
        r.redrawHint('eles', true);
        r.redraw();
      }, 150);
      var diff;

      if (e.deltaY != null) {
        diff = e.deltaY / -250;
      } else if (e.wheelDeltaY != null) {
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;
      var needsWheelFix = e.deltaMode === 1;

      if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: {
          x: rpos[0],
          y: rpos[1]
        }
      });
    }
  }; // Functions to help with whether mouse wheel should trigger zooming
  // --


  r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-unused-vars
    r.scrollingPage = true;
    clearTimeout(r.scrollingPageTimeout);
    r.scrollingPageTimeout = setTimeout(function () {
      r.scrollingPage = false;
    }, 250);
  }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container

  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseout',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseover',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom

  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom

  var center1, modelCenter1; // center point on start pinch to zoom

  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  var distanceSq = function distanceSq(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    blurActiveDomElement();
    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    } // record starting points for pinch-to-zoom


    if (e.touches[1]) {
      r.touchData.singleTouchMoved = true;
      freeDraggedElements(r.dragData.touchDragEles);
      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];
      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;
      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;
      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
      var pan = cy.pan();
      var zoom = cy.zoom();
      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap

      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;

      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if (near1 && near1.isNode()) {
          near1.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near2;
        } else {
          cy.emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        if (r.touchData.start) {
          r.touchData.start._private.grabbed = false;
        }

        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;
        r.redraw();
        return;
      }
    }

    if (e.touches[2]) {
      // ignore
      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
      if (cy.boxSelectionEnabled()) {
        e.preventDefault();
      }
    } else if (e.touches[1]) ; else if (e.touches[0]) {
      var nears = r.findNearestElements(now[0], now[1], true, true);
      var near = nears[0];

      if (near != null) {
        near.activate();
        r.touchData.start = near;
        r.touchData.starts = nears;

        if (r.nodeIsGrabbable(near)) {
          var draggedEles = r.dragData.touchDragEles = cy.collection();
          var selectedNodes = null;
          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if (near.selected()) {
            // reset drag elements, since near will be added again
            selectedNodes = cy.$(function (ele) {
              return ele.selected() && r.nodeIsGrabbable(ele);
            });
            addNodesToDrag(selectedNodes, {
              addToList: draggedEles
            });
          } else {
            addNodeToDrag(near, {
              addToList: draggedEles
            });
          }

          setGrabTarget(near);

          var makeEvent = function makeEvent(type) {
            return {
              originalEvent: e,
              type: type,
              position: {
                x: now[0],
                y: now[1]
              }
            };
          };

          near.emit(makeEvent('grabon'));

          if (selectedNodes) {
            selectedNodes.forEach(function (n) {
              n.emit(makeEvent('grab'));
            });
          } else {
            near.emit(makeEvent('grab'));
          }
        }
      }

      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        x: now[0],
        y: now[1]
      });

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } // Tap, taphold
      // -----


      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();
      clearTimeout(r.touchData.tapholdTimeout);
      r.touchData.tapholdTimeout = setTimeout(function () {
        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
        ) {
            triggerEvents(r.touchData.start, ['taphold'], e, {
              x: now[0],
              y: now[1]
            });
          }
      }, r.tapholdDuration);
    }

    if (e.touches.length >= 1) {
      var sPos = r.touchData.startPosition = [];

      for (var i = 0; i < now.length; i++) {
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];
      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, false);
  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if (capture && e.touches[0] && startGPos) {
      var disp = [];

      for (var j = 0; j < now.length; j++) {
        disp[j] = now[j] - earlier[j];
      }

      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    } // context swipe cancelling


    if (capture && r.touchData.cxt) {
      e.preventDefault();
      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );

      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;
      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases

      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r.touchData.cxt = false;
        r.data.bgActivePosistion = undefined;
        r.redrawHint('select', true);
        var cxtEvt = {
          originalEvent: e,
          type: 'cxttapend',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (r.touchData.start) {
          r.touchData.start.unactivate().emit(cxtEvt);
          r.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    } // context swipe


    if (capture && r.touchData.cxt) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxtdrag',
        position: {
          x: now[0],
          y: now[1]
        }
      };
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if (r.touchData.start) {
        r.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxtDragged = true;
      var near = r.findNearestElement(now[0], now[1], true, true);

      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
        if (r.touchData.cxtOver) {
          r.touchData.cxtOver.emit({
            originalEvent: e,
            type: 'cxtdragout',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        r.touchData.cxtOver = near;

        if (near) {
          near.emit({
            originalEvent: e,
            type: 'cxtdragover',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }
      } // box selection

    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      this.lastThreeTouch = +new Date();

      if (!r.touchData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: now[0],
            y: now[1]
          }
        });
      }

      r.touchData.selecting = true;
      r.touchData.didSelect = true;
      select[4] = 1;

      if (!select || select.length === 0 || select[0] === undefined) {
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      r.redrawHint('select', true);
      r.redraw(); // pinch to zoom
    } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (draggedEles) {
        r.redrawHint('drag', true);

        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;
          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2

      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;
      var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );

      var factor = distance2 / distance1;

      if (twoFingersStartInside) {
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1; // delta finger 2

        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans

        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2; // now calculate the zoom

        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan(); // the model center point converted to the current rendered pos

        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;
        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        }; // remove dragged eles

        if (_start && _start.active()) {
          var draggedEles = r.dragData.touchDragEles;
          freeDraggedElements(draggedEles);
          r.redrawHint('drag', true);
          r.redrawHint('eles', true);

          _start.unactivate().emit('freeon');

          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            _start.emit('dragfreeon');

            draggedEles.emit('dragfree');
          }
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });
        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;
        r.pinching = true;
      } // Re-project


      if (e.touches[0]) {
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0];
        now[1] = pos[1];
      }

      if (e.touches[1]) {
        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
        now[2] = pos[0];
        now[3] = pos[1];
      }

      if (e.touches[2]) {
        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
        now[4] = pos[0];
        now[5] = pos[1];
      }
    } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
    ) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near;

        if (!r.hoverData.draggingEles && !r.swipePanning) {
          near = r.findNearestElement(now[0], now[1], true, true);
        }

        if (capture && start != null) {
          e.preventDefault();
        } // dragging nodes


        if (capture && start != null && r.nodeIsDraggable(start)) {
          if (isOverThresholdDrag) {
            // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              addNodesToDrag(draggedEles, {
                inDragLayer: true
              });
            }

            r.dragData.didDrag = true;
            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                r.redrawHint('eles', true);
                var dragDelta = r.touchData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            r.hoverData.draggingEles = true;
            draggedEles.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);

            if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          } else {
            // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        } // touchmove


        {
          triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
            x: now[0],
            y: now[1]
          });

          if ((!start || !start.grabbed()) && near != last) {
            if (last) {
              last.emit({
                originalEvent: e,
                type: 'tapdragout',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }

            if (near) {
              near.emit({
                originalEvent: e,
                type: 'tapdragover',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
          }

          r.touchData.last = near;
        } // check to cancel taphold

        if (capture) {
          for (var i = 0; i < now.length; i++) {
            if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {
              r.touchData.singleTouchMoved = true;
            }
          }
        } // panning


        if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

          if (allowPassthrough) {
            e.preventDefault();

            if (!r.data.bgActivePosistion) {
              r.data.bgActivePosistion = array2point(r.touchData.startPosition);
            }

            if (r.swipePanning) {
              cy.panBy({
                x: disp[0] * zoom,
                y: disp[1] * zoom
              });
            } else if (isOverThresholdDrag) {
              r.swipePanning = true;
              cy.panBy({
                x: dx * zoom,
                y: dy * zoom
              });

              if (start) {
                start.unactivate();
                r.redrawHint('select', true);
                r.touchData.start = null;
              }
            }
          } // Re-project


          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
      }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning


    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      r.redraw();
    }
  }, false);
  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    r.touchData.capture = false;

    if (start) {
      start.unactivate();
    }
  });
  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    var capture = r.touchData.capture;

    if (capture) {
      if (e.touches.length === 0) {
        r.touchData.capture = false;
      }

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;
    r.swipePanning = false;
    r.hoverData.draggingEles = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    if (start) {
      start.unactivate();
    }

    var ctxTapend;

    if (r.touchData.cxt) {
      ctxTapend = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: now[0],
          y: now[1]
        }
      };

      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }

      if (!r.touchData.cxtDragged) {
        var ctxTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxt = false;
      r.touchData.start = null;
      r.redraw();
      return;
    } // no more box selection if we don't have three fingers


    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
      r.touchData.selecting = false;
      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;
      r.redrawHint('select', true);
      cy.emit({
        type: 'boxend',
        originalEvent: e,
        position: {
          x: now[0],
          y: now[1]
        }
      });

      var eleWouldBeSelected = function eleWouldBeSelected(ele) {
        return ele.selectable() && !ele.selected();
      };

      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

      if (box.nonempty()) {
        r.redrawHint('eles', true);
      }

      r.redraw();
    }

    if (start != null) {
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (start != null) {
        var startWasGrabbed = start._private.grabbed;
        freeDraggedElements(draggedEles);
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if (startWasGrabbed) {
          start.emit('freeon');
          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            start.emit('dragfreeon');
            draggedEles.emit('dragfree');
          }
        }

        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
        start.unactivate();
        r.touchData.start = null;
      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);
        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch

      if (!r.touchData.singleTouchMoved) {
        if (!start) {
          cy.$(':selected').unselect(['tapunselect']);
        }

        triggerEvents(start, ['tap', 'vclick'], e, {
          x: now[0],
          y: now[1]
        });
      } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance


      if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
      ) {
          if (cy.selectionType() === 'single') {
            cy.$(isSelected).unmerge(start).unselect(['tapunselect']);
            start.select(['tapselect']);
          } else {
            if (start.selected()) {
              start.unselect(['tapunselect']);
            } else {
              start.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }

      r.touchData.singleTouchMoved = true;
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }

    r.dragData.didDrag = false; // reset for next touchstart

    if (e.touches.length === 0) {
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
      r.touchData.didSelect = false;
    }

    if (e.touches.length < 2) {
      if (e.touches.length === 1) {
        // the old start global pos'n may not be the same finger that remains
        r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
      }

      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    } //r.redraw();

  }, false); // fallback compatibility layer for ms pointer events

  if (typeof TouchEvent === 'undefined') {
    var pointers = [];

    var makeTouch = function makeTouch(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function makePointer(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function addPointer(e) {
      pointers.push(makePointer(e));
    };

    var removePointer = function removePointer(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p = pointers[i];

        if (p.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    };

    var updatePointer = function updatePointer(e) {
      var p = pointers.filter(function (p) {
        return p.event.pointerId === e.pointerId;
      })[0];
      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function addTouchesToEvent(e) {
      e.touches = pointers.map(function (p) {
        return p.touch;
      });
    };

    var pointerIsMouse = function pointerIsMouse(e) {
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      addPointer(e);
      addTouchesToEvent(e);
      touchstartHandler(e);
    });
    r.registerBinding(r.container, 'pointerup', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchendHandler(e);
    });
    r.registerBinding(r.container, 'pointercancel', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchcancelHandler(e);
    });
    r.registerBinding(r.container, 'pointermove', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      updatePointer(e);
      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};

var BRp$d = {};

BRp$d.generatePolygon = function (name, points) {
  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: points,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
    }
  };
};

BRp$d.generateEllipse = function () {
  return this.nodeShapes['ellipse'] = {
    renderer: this,
    name: 'ellipse',
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return checkInEllipse(x, y, width, height, centerX, centerY, padding);
    }
  };
};

BRp$d.generateRoundPolygon = function (name, points) {
  // Pre-compute control points
  // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
  // the unit vectors.
  // For simplicity the layout will be:
  // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
  var allPoints = new Array(points.length * 2);

  for (var i = 0; i < points.length / 2; i++) {
    var sourceIndex = i * 2;
    var destIndex = void 0;

    if (i < points.length / 2 - 1) {
      destIndex = (i + 1) * 2;
    } else {
      destIndex = 0;
    }

    allPoints[i * 4] = points[sourceIndex];
    allPoints[i * 4 + 1] = points[sourceIndex + 1];
    var xDest = points[destIndex] - points[sourceIndex];
    var yDest = points[destIndex + 1] - points[sourceIndex + 1];
    var norm = Math.sqrt(xDest * xDest + yDest * yDest);
    allPoints[i * 4 + 2] = xDest / norm;
    allPoints[i * 4 + 3] = yDest / norm;
  }

  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: allPoints,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
    }
  };
};

BRp$d.generateRoundRectangle = function () {
  return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {
    renderer: this,
    name: 'round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = cornerRadius * 2; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // Check top left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check top right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.generateCutRectangle = function () {
  return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {
    renderer: this,
    name: 'cut-rectangle',
    cornerLength: getCutRectangleCornerLength(),
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]

      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
        return true;
      }

      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
    }
  };
};

BRp$d.generateBarrel = function () {
  return this.nodeShapes['barrel'] = {
    renderer: this,
    name: 'barrel',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      // use two fixed t values for the bezier curve approximation
      var t0 = 0.15;
      var t1 = 0.5;
      var t2 = 0.85;
      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
        // approximate curve pts based on the two t values
        var m0 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t0);
        var m1 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t1);
        var m2 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t2);
        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
      };

      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]

      var pts = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };
      pts.topLeft.isTop = true;
      pts.topRight.isTop = true;
      pts.bottomLeft.isBottom = true;
      pts.bottomRight.isBottom = true;
      return pts;
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
        return true;
      }

      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

      var getCurveT = function getCurveT(x, y, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x2 = curvePts[0];
        var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];

        var y2 = curvePts[1];
        var xMin = Math.min(x0, x2);
        var xMax = Math.max(x0, x2);
        var yMin = Math.min(y0, y2);
        var yMax = Math.max(y0, y2);

        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
          var coeff = bezierPtsToQuadCoeff(x0, x1, x2);
          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
          var validRoots = roots.filter(function (r) {
            return 0 <= r && r <= 1;
          });

          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }

        return null;
      };

      var curveRegions = Object.keys(barrelCurvePts);

      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x, y, cornerPts);

        if (t == null) {
          continue;
        }

        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y2 = cornerPts[1];
        var bezY = qbezierAt(y0, y1, y2, t);

        if (cornerPts.isTop && bezY <= y) {
          return true;
        }

        if (cornerPts.isBottom && y <= bezY) {
          return true;
        }
      }

      return false;
    }
  };
};

BRp$d.generateBottomRoundrectangle = function () {
  return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {
    renderer: this,
    name: 'bottom-round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var topStartX = nodeX - (width / 2 + padding);
      var topStartY = nodeY - (height / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width / 2 + padding);
      var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

      if (topIntersections.length > 0) {
        return topIntersections;
      }

      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = 2 * cornerRadius; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // check non-rounded top side


      var outerWidth = width / 2 + 2 * padding;
      var outerHeight = height / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];

      if (pointInsidePolygonPoints(x, y, points)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.registerNodeShapes = function () {
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;
  this.generateEllipse();
  this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes['square'] = nodeShapes['rectangle'];
  this.generateRoundRectangle();
  this.generateCutRectangle();
  this.generateBarrel();
  this.generateBottomRoundrectangle();
  {
    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon('diamond', diamondPoints);
    this.generateRoundPolygon('round-diamond', diamondPoints);
  }
  this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));
  this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));
  var star5Points = new Array(20);
  {
    var outerPoints = generateUnitNgonPoints(5, 0);
    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller

    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }

    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }
  star5Points = fitPolygonToSquare(star5Points);
  this.generatePolygon('star', star5Points);
  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);
  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
  this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon('tag', tagPoints);
    this.generateRoundPolygon('round-tag', tagPoints);
  }

  nodeShapes.makePolygon = function (points) {
    // use caching on user-specified polygons so they are as fast as native shapes
    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if (shape = this[name]) {
      // got cached shape
      return shape;
    } // create and cache new shape


    return renderer.generatePolygon(name, points);
  };
};

var BRp$e = {};

BRp$e.timeToRender = function () {
  return this.redrawTotalTime / this.redrawCount;
};

BRp$e.redraw = function (options) {
  options = options || staticEmptyObject();
  var r = this;

  if (r.averageRedrawTime === undefined) {
    r.averageRedrawTime = 0;
  }

  if (r.lastRedrawTime === undefined) {
    r.lastRedrawTime = 0;
  }

  if (r.lastDrawTime === undefined) {
    r.lastDrawTime = 0;
  }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp$e.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
  if (this.destroyed) {
    return;
  }

  if (priority == null) {
    error('Priority is not optional for beforeRender');
  }

  var cbs = this.beforeRenderCallbacks;
  cbs.push({
    fn: fn,
    priority: priority
  }); // higher priority callbacks executed first

  cbs.sort(function (a, b) {
    return b.priority - a.priority;
  });
};

var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
  var cbs = r.beforeRenderCallbacks;

  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
};

BRp$e.startRenderLoop = function () {
  var r = this;
  var cy = r.cy;

  if (r.renderLoopStarted) {
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function renderFn(requestTime) {
    if (r.destroyed) {
      return;
    }

    if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {
      beforeRenderCallbacks(r, true, requestTime);
      var startTime = performanceNow();
      r.render(r.renderOptions);
      var endTime = r.lastDrawTime = performanceNow();

      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = endTime - startTime;
      }

      if (r.redrawCount === undefined) {
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if (r.redrawTotalTime === undefined) {
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;
      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily

      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r, false, requestTime);
    }

    r.skipFrame = false;
    requestAnimationFrame(renderFn);
  };

  requestAnimationFrame(renderFn);
};

var BaseRenderer = function BaseRenderer(options) {
  this.init(options);
};

var BR = BaseRenderer;
var BRp$f = BR.prototype;
BRp$f.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

BRp$f.init = function (options) {
  var r = this;
  r.options = options;
  r.cy = options.cy;
  var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that

  if (window$1) {
    var document = window$1.document;
    var head = document.head;
    var stylesheetId = '__________cytoscape_stylesheet';
    var className = '__________cytoscape_container';
    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || '') + ' ' + className;
    }

    if (!stylesheetAlreadyExists) {
      var stylesheet = document.createElement('style');
      stylesheet.id = stylesheetId;
      stylesheet.innerHTML = '.' + className + ' { position: relative; }';
      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
    }

    var computedStyle = window$1.getComputedStyle(ctr);
    var position = computedStyle.getPropertyValue('position');

    if (position === 'static') {
      warn('A Cytoscape container has style position:static and so can not use UI extensions properly');
    }
  }

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data

  r.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: false,
    initialPan: [null, null],
    capture: false
  };
  r.dragData = {
    possibleDragElements: []
  };
  r.touchData = {
    start: null,
    capture: false,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };
  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;
  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default

  r.forcedPixelRatio = number(options.pixelRatio) ? options.pixelRatio : null;
  r.motionBlur = options.motionBlur; // for initial kick off

  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;

  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;
  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  };
  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
};

BRp$f.notify = function (eventName, eles) {
  var r = this;
  var cy = r.cy; // the renderer can't be notified after it's destroyed

  if (this.destroyed) {
    return;
  }

  if (eventName === 'init') {
    r.load();
    return;
  }

  if (eventName === 'destroy') {
    r.destroy();
    return;
  }

  if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {
    r.invalidateCachedZSortedEles();
  }

  if (eventName === 'viewport') {
    r.redrawHint('select', true);
  }

  if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize(r.container);
  }

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  this.startRenderLoop();
  this.redraw();
};

BRp$f.destroy = function () {
  var r = this;
  r.destroyed = true;
  r.cy.stopAnimationLoop();

  for (var i = 0; i < r.bindings.length; i++) {
    var binding = r.bindings[i];
    var b = binding;
    var tgt = b.target;
    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if (r.removeObserver) {
    r.removeObserver.disconnect();
  }

  if (r.styleObserver) {
    r.styleObserver.disconnect();
  }

  if (r.resizeObserver) {
    r.resizeObserver.disconnect();
  }

  if (r.labelCalcDiv) {
    try {
      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {// ie10 issue #1014
    }
  }
};

BRp$f.isHeadless = function () {
  return false;
};

[BRp, BRp$a, BRp$b, BRp$c, BRp$d, BRp$e].forEach(function (props) {
  extend(BRp$f, props);
});

var fullFpsTime = 1000 / 60; // assume 60 frames per second

var defs = {
  setupDequeueing: function setupDequeueing(opts) {
    return function setupDequeueingImpl() {
      var self = this;
      var r = this.renderer;

      if (self.dequeueingSetup) {
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util(function () {
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, opts.deqRedrawThreshold);

      var dequeue = function dequeue(willDraw, frameStartTime) {
        var startTime = performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
        // queue won't automatically be flushed before dequeueing starts

        if (!willDraw) {
          r.flushRenderedStyleQueue();
        }

        while (true) {
          // eslint-disable-line no-constant-condition
          var now = performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time
            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }

          var thisDeqd = opts.deq(self, pixelRatio, extent);

          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        } // callbacks on dequeue


        if (deqd.length > 0) {
          opts.onDeqd(self, deqd);

          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || noop;
      r.beforeRender(dequeue, priority(self));
    };
  }
};

// Uses keys so elements may share the same cache.

var ElementTextureCacheLookup =
/*#__PURE__*/
function () {
  function ElementTextureCacheLookup(getKey) {
    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;

    _classCallCheck(this, ElementTextureCacheLookup);

    this.idsByKey = new Map$1();
    this.keyForId = new Map$1();
    this.cachesByLvl = new Map$1();
    this.lvls = [];
    this.getKey = getKey;
    this.doesEleInvalidateKey = doesEleInvalidateKey;
  }

  _createClass(ElementTextureCacheLookup, [{
    key: "getIdsFor",
    value: function getIdsFor(key) {
      if (key == null) {
        error("Can not get id list for null key");
      }

      var idsByKey = this.idsByKey;
      var ids = this.idsByKey.get(key);

      if (!ids) {
        ids = new Set$1();
        idsByKey.set(key, ids);
      }

      return ids;
    }
  }, {
    key: "addIdForKey",
    value: function addIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key).add(id);
      }
    }
  }, {
    key: "deleteIdForKey",
    value: function deleteIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key)["delete"](id);
      }
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function getNumberOfIdsForKey(key) {
      if (key == null) {
        return 0;
      } else {
        return this.getIdsFor(key).size;
      }
    }
  }, {
    key: "updateKeyMappingFor",
    value: function updateKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var currKey = this.getKey(ele);
      this.deleteIdForKey(prevKey, id);
      this.addIdForKey(currKey, id);
      this.keyForId.set(id, currKey);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function deleteKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      this.deleteIdForKey(prevKey, id);
      this.keyForId["delete"](id);
    }
  }, {
    key: "keyHasChangedFor",
    value: function keyHasChangedFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var newKey = this.getKey(ele);
      return prevKey !== newKey;
    }
  }, {
    key: "isInvalid",
    value: function isInvalid(ele) {
      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
    }
  }, {
    key: "getCachesAt",
    value: function getCachesAt(lvl) {
      var cachesByLvl = this.cachesByLvl,
          lvls = this.lvls;
      var caches = cachesByLvl.get(lvl);

      if (!caches) {
        caches = new Map$1();
        cachesByLvl.set(lvl, caches);
        lvls.push(lvl);
      }

      return caches;
    }
  }, {
    key: "getCache",
    value: function getCache(key, lvl) {
      return this.getCachesAt(lvl).get(key);
    }
  }, {
    key: "get",
    value: function get(ele, lvl) {
      var key = this.getKey(ele);
      var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys

      if (cache != null) {
        this.updateKeyMappingFor(ele);
      }

      return cache;
    }
  }, {
    key: "getForCachedKey",
    value: function getForCachedKey(ele, lvl) {
      var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key

      var cache = this.getCache(key, lvl);
      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(key, lvl) {
      return this.getCachesAt(lvl).has(key);
    }
  }, {
    key: "has",
    value: function has(ele, lvl) {
      var key = this.getKey(ele);
      return this.hasCache(key, lvl);
    }
  }, {
    key: "setCache",
    value: function setCache(key, lvl, cache) {
      cache.key = key;
      this.getCachesAt(lvl).set(key, cache);
    }
  }, {
    key: "set",
    value: function set(ele, lvl, cache) {
      var key = this.getKey(ele);
      this.setCache(key, lvl, cache);
      this.updateKeyMappingFor(ele);
    }
  }, {
    key: "deleteCache",
    value: function deleteCache(key, lvl) {
      this.getCachesAt(lvl)["delete"](key);
    }
  }, {
    key: "delete",
    value: function _delete(ele, lvl) {
      var key = this.getKey(ele);
      this.deleteCache(key, lvl);
    }
  }, {
    key: "invalidateKey",
    value: function invalidateKey(key) {
      var _this = this;

      this.lvls.forEach(function (lvl) {
        return _this.deleteCache(key, lvl);
      });
    } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)

  }, {
    key: "invalidate",
    value: function invalidate(ele) {
      var id = ele.id();
      var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)

      this.deleteKeyMappingFor(ele);
      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);

      if (entireKeyInvalidated) {
        // clear mapping for current key
        this.invalidateKey(key);
      }

      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
    }
  }]);

  return ElementTextureCacheLookup;
}();

var minTxrH = 25; // the size of the texture cache for small height eles (special case)

var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up

var minLvl = -4; // when scaling smaller than that we don't need to re-render

var maxLvl = 3; // when larger than this scale just render directly (caching is not helpful)

var maxZoom = 7.99; // beyond this zoom level, layered textures are not used

var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps

var defTxrWidth = 1024; // default/minimum texture width

var maxTxrW = 1024; // the maximum width of a texture

var maxTxrH = 1024; // the maximum height of a texture

var minUtility = 0.2; // if usage of texture is less than this, it is retired

var maxFullness = 0.8; // fullness of texture after which queue removal is checked

var maxFullnessChecks = 10; // dequeued after this many checks

var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost = 0.9; // % of frame time to be used when >60fps

var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};
var initDefaults = defaults({
  getKey: null,
  doesEleInvalidateKey: falsify,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: trueify,
  allowEdgeTxrCaching: true,
  allowParentTxrCaching: true
});

var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
  var self = this;
  self.renderer = renderer;
  self.onDequeues = [];
  var opts = initDefaults(initOptions);
  extend(self, opts);
  self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;
ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed

ETCp.getTextureQueue = function (txrH) {
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};
  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
}; // the list of usused textures which can be recycled (in use in texture queue)


ETCp.getRetiredTextureQueue = function (txrH) {
  var self = this;
  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
  return rtxtrQ;
}; // queue of element draw requests at different scale levels


ETCp.getElementQueue = function () {
  var self = this;
  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
    return b.reqs - a.reqs;
  });
  return q;
}; // queue of element draw requests at different scale levels (element id lookup)


ETCp.getElementKeyToQueue = function () {
  var self = this;
  var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
  return k2q;
};

ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
  var self = this;
  var r = this.renderer;
  var zoom = r.cy.zoom();
  var lookup = this.lookup;

  if (bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible()) {
    return null;
  }

  if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {
    return null;
  }

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));
  }

  if (lvl < minLvl) {
    lvl = minLvl;
  } else if (zoom >= maxZoom || lvl > maxLvl) {
    return null;
  }

  var scale = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);

  if (!this.isVisible(ele, scaledLabelShown)) {
    return null;
  }

  var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric

  if (eleCache && eleCache.invalidated) {
    eleCache.invalidated = false;
    eleCache.texture.invalidatedWidth -= eleCache.width;
  }

  if (eleCache) {
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }

  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end

  var txr = txrQ[txrQ.length - 2];

  var addNewTxr = function addNewTxr() {
    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
  }; // try the last one if there is no second last one


  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  } // if the last one doesn't exist, we need a first one


  if (!txr) {
    txr = addNewTxr();
  } // if there's no room in the current texture, we need a new one


  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }

  var scalableFrom = function scalableFrom(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;
  var higherCache; // the nearest cache with a higher level

  for (var l = lvl + 1; l <= maxLvl; l++) {
    var c = lookup.get(ele, l);

    if (c) {
      higherCache = c;
      break;
    }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function downscale() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  }; // reset ele area in texture


  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

  if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
  } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level
    if (highQualityReq) {
      for (var _l = higherCache.level; _l > lvl; _l--) {
        oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
      }

      downscale();
    } else {
      self.queueElement(ele, higherCache.level - 1);
      return higherCache;
    }
  } else {
    var lowerCache; // the nearest cache with a lower level

    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var _l2 = lvl - 1; _l2 >= minLvl; _l2--) {
        var _c = lookup.get(ele, _l2);

        if (_c) {
          lowerCache = _c;
          break;
        }
      }
    }

    if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later
      self.queueElement(ele, lvl);
      return lowerCache;
    }

    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale, scale);
    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
    txr.context.scale(1 / scale, 1 / scale);
    txr.context.translate(-txr.usedWidth, 0);
  }

  eleCache = {
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };
  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
  txr.eleCaches.push(eleCache);
  lookup.set(ele, lvl, eleCache);
  self.checkTextureFullness(txr);
  return eleCache;
};

ETCp.invalidateElements = function (eles) {
  for (var i = 0; i < eles.length; i++) {
    this.invalidateElement(eles[i]);
  }
};

ETCp.invalidateElement = function (ele) {
  var self = this;
  var lookup = self.lookup;
  var caches = [];
  var invalid = lookup.isInvalid(ele);

  if (!invalid) {
    return; // override the invalidation request if the element key has not changed
  }

  for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
    var cache = lookup.getForCachedKey(ele, lvl);

    if (cache) {
      caches.push(cache);
    }
  }

  var noOtherElesUseCache = lookup.invalidate(ele);

  if (noOtherElesUseCache) {
    for (var i = 0; i < caches.length; i++) {
      var _cache = caches[i];
      var txr = _cache.texture; // remove space from the texture it belongs to

      txr.invalidatedWidth += _cache.width; // mark the cache as invalidated

      _cache.invalidated = true; // retire the texture if its utility is low

      self.checkTextureUtility(txr);
    }
  } // remove from queue since the old req was for the old state


  self.removeFromQueue(ele);
};

ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};

ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things
  var self = this;
  var txrQ = self.getTextureQueue(txr.height);

  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function (txr) {
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue(txrH);
  var lookup = this.lookup; // retire the texture from the active / searchable queue:

  removeFromArray(txrQ, txr);
  txr.retired = true; // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    lookup.deleteCache(eleCache.key, eleCache.level);
  }

  clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue(txrH);
  rtxtrQ.push(txr);
};

ETCp.addTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var txr = {};
  txrQ.push(txr);
  txr.eleCaches = [];
  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;
  txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
  txr.context = txr.canvas.getContext('2d');
  return txr;
};

ETCp.recycleTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];

    if (txr.width >= minW) {
      txr.retired = false;
      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;
      clearArray(txr.eleCaches);
      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);
      removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);
      return txr;
    }
  }
};

ETCp.queueElement = function (ele, lvl) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var existingReq = k2q[key];

  if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.eles.merge(ele);
    existingReq.reqs++;
    q.updateItem(existingReq);
  } else {
    var req = {
      eles: ele.spawn().merge(ele),
      level: lvl,
      reqs: 1,
      key: key
    };
    q.push(req);
    k2q[key] = req;
  }
};

ETCp.dequeue = function (pxRatio
/*, extent*/
) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var dequeued = [];
  var lookup = self.lookup;

  for (var i = 0; i < maxDeqSize; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var key = req.key;
      var ele = req.eles[0]; // all eles have the same key

      var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup

      k2q[key] = null; // dequeueing isn't necessary with an existing cache

      if (cacheExists) {
        continue;
      }

      dequeued.push(req);
      var bb = self.getBoundingBox(ele);
      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.removeFromQueue = function (ele) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var req = k2q[key];

  if (req != null) {
    if (req.eles.length === 1) {
      // remove if last ele in the req
      // bring to front of queue
      req.reqs = MAX_INT;
      q.updateItem(req);
      q.pop(); // remove from queue

      k2q[key] = null; // remove from lookup map
    } else {
      // otherwise just remove ele from req
      req.eles.unmerge(ele);
    }
  }
};

ETCp.onDequeue = function (fn) {
  this.onDequeues.push(fn);
};

ETCp.offDequeue = function (fn) {
  removeFromArray(this.onDequeues, fn);
};

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio, extent) {
    return self.dequeue(pxRatio, extent);
  },
  onDeqd: function onDeqd(self, deqd) {
    for (var i = 0; i < self.onDequeues.length; i++) {
      var fn = self.onDequeues[i];
      fn(deqd);
    }
  },
  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
    for (var i = 0; i < deqd.length; i++) {
      var eles = deqd[i].eles;

      for (var j = 0; j < eles.length; j++) {
        var bb = eles[j].boundingBox();

        if (boundingBoxesIntersect(bb, extent)) {
          return true;
        }
      }
    }

    return false;
  },
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

var defNumLayers = 1; // default number of layers to use

var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render

var maxLvl$1 = 2; // when larger than this scale just render directly (caching is not helpful)

var maxZoom$1 = 3.99; // beyond this zoom level, layered textures are not used

var deqRedrawThreshold$1 = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates

var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps

var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch

var invalidThreshold = 250; // time threshold for disabling b/c of invalidations

var maxLayerArea = 4000 * 4000; // layers can't be bigger than this

var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function LayeredTextureCache(renderer) {
  var self = this;
  var r = self.renderer = renderer;
  var cy = r.cy;
  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;
  self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
  self.skipping = false;
  self.eleTxrDeqs = cy.collection();
  self.scheduleElementRefinement = util(function () {
    self.refineElementTextures(self.eleTxrDeqs);
    self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
  }, refineEleDebounceTime);
  r.beforeRender(function (willDraw, now) {
    if (now - self.lastInvalidationTime <= invalidThreshold) {
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  }, r.beforeRenderPriorities.lyrTxrSkip);

  var qSort = function qSort(a, b) {
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap(qSort);
  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;
var layerIdPool = 0;
var MAX_INT$1 = Math.pow(2, 53) - 1;

LTCp.makeLayer = function (bb, lvl) {
  var scale = Math.pow(2, lvl);
  var w = Math.ceil(bb.w * scale);
  var h = Math.ceil(bb.h * scale);
  var canvas = this.renderer.makeOffscreenCanvas(w, h);
  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT$1,
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)

  cxt.scale(scale, scale);
  cxt.translate(dx, dy);
  return layer;
};

LTCp.getLayers = function (eles, pxRatio, lvl) {
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;
  self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));

    if (lvl < minLvl$1) {
      lvl = minLvl$1;
    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {
      return null;
    }
  }

  self.validateLayersElesOrdering(lvl, eles);
  var layersByLvl = self.layersByLevel;
  var scale = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;
  var lvlComplete = self.levelIsComplete(lvl, eles);
  var tmpLayers;

  var checkTempLevels = function checkTempLevels() {
    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
      self.validateLayersElesOrdering(l, eles);

      if (self.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function checkLvls(dir) {
      if (tmpLayers) {
        return;
      }

      for (var l = lvl + dir; minLvl$1 <= l && l <= maxLvl$1; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    };

    checkLvls(+1);
    checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function

    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (layer.invalid) {
        removeFromArray(layers, layer);
      }
    }
  };

  if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon
    checkTempLevels();
  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function getBb() {
    if (!bb) {
      bb = makeBoundingBox();

      for (var i = 0; i < eles.length; i++) {
        updateBoundingBox(bb, eles[i].boundingBox());
      }
    }

    return bb;
  };

  var makeLayer = function makeLayer(opts) {
    opts = opts || {};
    var after = opts.after;
    getBb();
    var area = bb.w * scale * (bb.h * scale);

    if (area > maxLayerArea) {
      return null;
    }

    var layer = self.makeLayer(bb, lvl);

    if (after != null) {
      var index = layers.indexOf(after) + 1;
      layers.splice(index, 0, layer);
    } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
      layers.unshift(layer);
    } // if( tmpLayers ){
    //self.queueLayer( layer );
    // }


    return layer;
  };

  if (self.skipping && !firstGet) {
    // log('skip layers');
    return null;
  } // log('do layers');


  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing =  !firstGet;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());

    var existingLayer = caches[lvl];

    if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());
      layer = makeLayer({
        insert: true,
        after: layer
      }); // if now layer can be built then we can't use layers at this level

      if (!layer) {
        return null;
      } // log('new layer with id %s', layer.id);

    }

    if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer(layer, ele);
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer(layer, ele, lvl, pxRatio);
    }

    layer.eles.push(ele);
    caches[lvl] = layer;
  } // log('--');


  if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
}; // a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level


LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
  return lvl;
};

LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

  {
    r.setImgSmoothing(context, false);
  }

  {
    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
  }

  {
    r.setImgSmoothing(context, true);
  }
};

LTCp.levelIsComplete = function (lvl, eles) {
  var self = this;
  var layers = self.layersByLevel[lvl];

  if (!layers || layers.length === 0) {
    return false;
  }

  var numElesInLayers = 0;

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete

    if (layer.reqs > 0) {
      return false;
    } // if the layer is invalid, the level is not complete


    if (layer.invalid) {
      return false;
    }

    numElesInLayers += layer.eles.length;
  } // we should have exactly the number of eles passed in to be complete


  if (numElesInLayers !== eles.length) {
    return false;
  }

  return true;
};

LTCp.validateLayersElesOrdering = function (lvl, eles) {
  var layers = this.layersByLevel[lvl];

  if (!layers) {
    return;
  } // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)


  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1; // find the offset

    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }

    if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer(layer);
      continue;
    } // the eles in the layer must be in the same continuous order, else the layer is invalid


    var o = offset;

    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);
        this.invalidateLayer(layer);
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function (eles, update) {
  var self = this;
  var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way

  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for (var l = minLvl$1; l <= maxLvl$1; l++) {
      var layer = caches[l];

      if (!layer) {
        continue;
      } // if update is a request from the ele cache, then it affects only
      // the matching level


      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }

      update(layer, ele, req);
    }
  }
};

LTCp.haveLayers = function () {
  var self = this;
  var haveLayers = false;

  for (var l = minLvl$1; l <= maxLvl$1; l++) {
    var layers = self.layersByLevel[l];

    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function (eles) {
  var self = this;

  if (eles.length === 0) {
    return;
  }

  self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');

  if (eles.length === 0 || !self.haveLayers()) {
    return;
  }

  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
    self.invalidateLayer(layer);
  });
};

LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');
  this.lastInvalidationTime = performanceNow();

  if (layer.invalid) {
    return;
  } // save cycles


  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );

  removeFromArray(layers, layer); // layer.eles = [];

  layer.elesQueue = [];
  layer.invalid = true;

  if (layer.replacement) {
    layer.replacement.invalid = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if (caches) {
      caches[lvl] = null;
    }
  }
};

LTCp.refineElementTextures = function (eles) {
  var self = this; // log('refine', eles.length);

  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;

    if (!rLyr) {
      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self.queueLayer(rLyr, rLyr.eles[i]);
      } // log('queue replacement layer refinement', rLyr.id);

    }
  });
};

LTCp.enqueueElementRefinement = function (ele) {

  this.eleTxrDeqs.merge(ele);
  this.scheduleElementRefinement();
};

LTCp.queueLayer = function (layer, ele) {
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time

  if (layer.replacement) {
    return;
  }

  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }

    elesQ.push(ele);
    hasId[ele.id()] = true;
  }

  if (layer.reqs) {
    layer.reqs++;
    q.updateItem(layer);
  } else {
    layer.reqs = 1;
    q.push(layer);
  }
};

LTCp.dequeue = function (pxRatio) {
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while (eleDeqs < maxDeqSize$1) {
    if (q.size() === 0) {
      break;
    }

    var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it

    if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    } // if this is a replacement layer that has been superceded, then forget it


    if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if (ele) {
      // log('dequeue layer %s', layer.id);
      self.drawEleInLayer(layer, ele, layer.level, pxRatio);
      eleDeqs++;
    }

    if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
      deqd.push(true);
    } // if the layer has all its eles done, then remove from the queue


    if (layer.elesQueue.length === 0) {
      q.pop();
      layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
      // when a replacement layer is dequeued, it replaces the old layer in the level

      if (layer.replaces) {
        self.applyLayerReplacement(layer);
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function (layer) {
  var self = this;
  var layersInLevel = self.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)

  if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[index] = layer; // replace level ref
  // replace refs in eles

  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if (cache) {
      cache[layer.level] = layer;
    }
  } // log('apply replacement layer %s over %s', layer.id, replaced.id);


  self.requestRedraw();
};

LTCp.requestRedraw = util(function () {
  var r = this.renderer;
  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  r.redraw();
}, 100);
LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold$1,
  deqCost: deqCost$1,
  deqAvgCost: deqAvgCost$1,
  deqNoDrawCost: deqNoDrawCost$1,
  deqFastCost: deqFastCost$1,
  deq: function deq(self, pxRatio) {
    return self.dequeue(pxRatio);
  },
  onDeqd: noop,
  shouldRedraw: trueify,
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

var CRp = {};
var impl;

function polygon(context, points) {
  for (var i = 0; i < points.length; i++) {
    var pt = points[i];
    context.lineTo(pt.x, pt.y);
  }
}

function triangleBackcurve(context, points, controlPoint) {
  var firstPt;

  for (var i = 0; i < points.length; i++) {
    var pt = points[i];

    if (i === 0) {
      firstPt = pt;
    }

    context.lineTo(pt.x, pt.y);
  }

  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
}

function triangleTee(context, trianglePoints, teePoints) {
  if (context.beginPath) {
    context.beginPath();
  }

  var triPts = trianglePoints;

  for (var i = 0; i < triPts.length; i++) {
    var pt = triPts[i];
    context.lineTo(pt.x, pt.y);
  }

  var teePts = teePoints;
  var firstTeePt = teePoints[0];
  context.moveTo(firstTeePt.x, firstTeePt.y);

  for (var i = 1; i < teePts.length; i++) {
    var pt = teePts[i];
    context.lineTo(pt.x, pt.y);
  }

  if (context.closePath) {
    context.closePath();
  }
}

function circle(context, rx, ry, r) {
  context.arc(rx, ry, r, 0, Math.PI * 2, false);
}

CRp.arrowShapeImpl = function (name) {
  return (impl || (impl = {
    'polygon': polygon,
    'triangle-backcurve': triangleBackcurve,
    'triangle-tee': triangleTee,
    'triangle-cross': triangleTee,
    'circle': circle
  }))[name];
};

var CRp$1 = {};

CRp$1.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
  var r = this;

  if (ele.isNode()) {
    r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  } else {
    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  }
};

CRp$1.drawElementOverlay = function (context, ele) {
  var r = this;

  if (ele.isNode()) {
    r.drawNodeOverlay(context, ele);
  } else {
    r.drawEdgeOverlay(context, ele);
  }
};

CRp$1.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
  var r = this;
  var bb = eleTxrCache.getBoundingBox(ele);

  if (bb.w === 0 || bb.h === 0) {
    return;
  } // ignore zero size case


  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);

  if (eleCache != null) {
    var opacity = getOpacity(r, ele);

    if (opacity === 0) {
      return;
    }

    var theta = getRotation(r, ele);
    var x1 = bb.x1,
        y1 = bb.y1,
        w = bb.w,
        h = bb.h;
    var x, y, sx, sy, smooth;

    if (theta !== 0) {
      var rotPt = eleTxrCache.getRotationPoint(ele);
      sx = rotPt.x;
      sy = rotPt.y;
      context.translate(sx, sy);
      context.rotate(theta);
      smooth = r.getImgSmoothing(context);

      if (!smooth) {
        r.setImgSmoothing(context, true);
      }

      var off = eleTxrCache.getRotationOffset(ele);
      x = off.x;
      y = off.y;
    } else {
      x = x1;
      y = y1;
    }

    var oldGlobalAlpha;

    if (opacity !== 1) {
      oldGlobalAlpha = context.globalAlpha;
      context.globalAlpha = oldGlobalAlpha * opacity;
    }

    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);

    if (opacity !== 1) {
      context.globalAlpha = oldGlobalAlpha;
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-sx, -sy);

      if (!smooth) {
        r.setImgSmoothing(context, false);
      }
    }
  } else {
    eleTxrCache.drawElement(context, ele); // direct draw fallback
  }
};

var getZeroRotation = function getZeroRotation() {
  return 0;
};

var getLabelRotation = function getLabelRotation(r, ele) {
  return r.getTextAngle(ele, null);
};

var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'source');
};

var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'target');
};

var getOpacity = function getOpacity(r, ele) {
  return ele.effectiveOpacity();
};

var getTextOpacity = function getTextOpacity(e, ele) {
  return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();
};

CRp$1.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {
  var r = this;
  var _r$data = r.data,
      eleTxrCache = _r$data.eleTxrCache,
      lblTxrCache = _r$data.lblTxrCache,
      slbTxrCache = _r$data.slbTxrCache,
      tlbTxrCache = _r$data.tlbTxrCache;
  var bb = ele.boundingBox();
  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  if (!extent || boundingBoxesIntersect(bb, extent)) {
    var isEdge = ele.isEdge();

    var badLine = ele.element()._private.rscratch.badLine;

    r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);

    if (!isEdge || !badLine) {
      r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
    }

    if (isEdge && !badLine) {
      r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
      r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
    }

    r.drawElementOverlay(context, ele);
  }
};

CRp$1.drawElements = function (context, eles) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawElement(context, ele);
  }
};

CRp$1.drawCachedElements = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawCachedNodes = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.isNode()) {
      continue;
    }

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawLayeredElements = function (context, eles, pxRatio, extent) {
  var r = this;
  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;

      if (bb.w === 0 || bb.h === 0) {
        continue;
      }

      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
  }
};

/* global Path2D */
var CRp$2 = {};

CRp$2.drawEdge = function (context, edge, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var rs = edge._private.rscratch;

  if (shouldDrawOpacity && !edge.visible()) {
    return;
  } // if bezier ctrl pts can not be calculated, then die


  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;
  var lineStyle = edge.pstyle('line-style').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var lineCap = edge.pstyle('line-cap').value;

  var drawLine = function drawLine() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    context.lineWidth = edgeWidth;
    context.lineCap = lineCap;
    r.eleStrokeStyle(context, edge, strokeOpacity);
    r.drawEdgePath(edge, context, rs.allpts, lineStyle);
    context.lineCap = 'butt'; // reset for other drawing functions
  };

  var drawOverlay = function drawOverlay() {
    if (!shouldDrawOverlay) {
      return;
    }

    r.drawEdgeOverlay(context, edge);
  };

  var drawArrows = function drawArrows() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    r.drawArrowheads(context, edge, arrowOpacity);
  };

  var drawText = function drawText() {
    r.drawElementText(context, edge, null, drawLabel);
  };

  context.lineJoin = 'round';
  var ghost = edge.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = edge.pstyle('ghost-offset-x').pfValue;
    var gy = edge.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = edge.pstyle('ghost-opacity').value;
    var effectiveGhostOpacity = opacity * ghostOpacity;
    context.translate(gx, gy);
    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);
    context.translate(-gx, -gy);
  }

  drawLine();
  drawArrows();
  drawOverlay();
  drawText();

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$2.drawEdgeOverlay = function (context, edge) {
  if (!edge.visible()) {
    return;
  }

  var overlayOpacity = edge.pstyle('overlay-opacity').value;

  if (overlayOpacity === 0) {
    return;
  }

  var r = this;
  var usePaths = r.usePaths();
  var rs = edge._private.rscratch;
  var overlayPadding = edge.pstyle('overlay-padding').pfValue;
  var overlayWidth = 2 * overlayPadding;
  var overlayColor = edge.pstyle('overlay-color').value;
  context.lineWidth = overlayWidth;

  if (rs.edgeType === 'self' && !usePaths) {
    context.lineCap = 'butt';
  } else {
    context.lineCap = 'round';
  }

  r.colorStrokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
  r.drawEdgePath(edge, context, rs.allpts, 'solid');
};

CRp$2.drawEdgePath = function (edge, context, pts, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();
  var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;
  var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;

  if (usePaths) {
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if (canvasCxt.setLineDash) {
    // for very outofdate browsers
    switch (type) {
      case 'dotted':
        canvasCxt.setLineDash([1, 1]);
        break;

      case 'dashed':
        canvasCxt.setLineDash(lineDashPattern);
        canvasCxt.lineDashOffset = lineDashOffset;
        break;

      case 'solid':
        canvasCxt.setLineDash([]);
        break;
    }
  }

  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }

    context.moveTo(pts[0], pts[1]);

    switch (rs.edgeType) {
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for (var i = 2; i + 3 < pts.length; i += 4) {
          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
        }

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for (var _i = 2; _i + 1 < pts.length; _i += 2) {
          context.lineTo(pts[_i], pts[_i + 1]);
        }

        break;
    }
  }

  context = canvasCxt;

  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  } // reset any line dashes


  if (context.setLineDash) {
    // for very outofdate browsers
    context.setLineDash([]);
  }
};

CRp$2.drawArrowheads = function (context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }

  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};

CRp$2.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
    return;
  }

  var self = this;
  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;

  if (arrowShape === 'none') {
    return;
  }

  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var edgeOpacity = edge.pstyle('opacity').value;

  if (opacity === undefined) {
    opacity = edgeOpacity;
  }

  var gco = context.globalCompositeOperation;

  if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';
    self.colorFillStyle(context, 255, 255, 255, 1);
    self.colorStrokeStyle(context, 255, 255, 255, 1);
    self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)


  var color = edge.pstyle(prefix + '-arrow-color').value;
  self.colorFillStyle(context, color[0], color[1], color[2], opacity);
  self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
  self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};

CRp$2.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths() && shape !== 'triangle-cross';
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = {
    x: x,
    y: y
  };
  var scale = edge.pstyle('arrow-scale').value;
  var size = this.getArrowWidth(edgeWidth, scale);
  var shapeImpl = r.arrowShapes[shape];

  if (usePaths) {
    var cache = r.arrowPathCache = r.arrowPathCache || [];
    var key = hashString(shape);
    var cachedPath = cache[key];

    if (cachedPath != null) {
      path = context = cachedPath;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      cache[key] = path;
    }
  }

  if (context.beginPath) {
    context.beginPath();
  }

  if (!pathCacheHit) {
    if (usePaths) {
      // store in the path cache with values easily manipulated later
      shapeImpl.draw(context, 1, 0, {
        x: 0,
        y: 0
      }, 1);
    } else {
      shapeImpl.draw(context, size, angle, translation, edgeWidth);
    }
  }

  if (context.closePath) {
    context.closePath();
  }

  context = canvasContext;

  if (usePaths) {
    // set transform to arrow position/orientation
    context.translate(x, y);
    context.rotate(angle);
    context.scale(size, size);
  }

  if (fill === 'filled' || fill === 'both') {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }

  if (fill === 'hollow' || fill === 'both') {
    context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
    context.lineJoin = 'miter';

    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }

  if (usePaths) {
    // reset transform by applying inverse
    context.scale(1 / size, 1 / size);
    context.rotate(-angle);
    context.translate(-x, -y);
  }
};

var CRp$3 = {};

CRp$3.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }

  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
};

CRp$3.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
  var r = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit = getIndexedStyle(node, 'background-fit', 'value', index);
  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = getIndexedStyle(node, 'background-clip', 'value', index);
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;
  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH; // workaround for broken browsers like ie

  if (null == imgW || null == imgH) {
    document.body.appendChild(img); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;
    document.body.removeChild(img); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
    } else {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index);
    }
  }

  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
    } else {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index);
    }
  }

  if (w === 0 || h === 0) {
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if (fit === 'contain') {
    var scale = Math.min(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  } else if (fit === 'cover') {
    var scale = Math.max(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  }

  var x = nodeX - nodeTW / 2; // left

  var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);
  var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);

  if (posXUnits === '%') {
    x += (nodeTW - w) * posXPfVal;
  } else {
    x += posXPfVal;
  }

  var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);
  var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);

  if (offXUnits === '%') {
    x += (nodeTW - w) * offXPfVal;
  } else {
    x += offXPfVal;
  }

  var y = nodeY - nodeTH / 2; // top

  var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);
  var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);

  if (posYUnits === '%') {
    y += (nodeTH - h) * posYPfVal;
  } else {
    y += posYPfVal;
  }

  var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);
  var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);

  if (offYUnits === '%') {
    y += (nodeTH - h) * offYPfVal;
  } else {
    y += offYPfVal;
  }

  if (rs.pathCache) {
    x -= nodeX;
    y -= nodeY;
    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;
  context.globalAlpha = imgOpacity;

  if (repeat === 'no-repeat') {
    if (shouldClip) {
      context.save();

      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
        context.clip();
      }
    }

    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;
    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
    context.translate(x, y);
    context.fill();
    context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;
};

var CRp$4 = {};

CRp$4.eleTextBiggerThanMin = function (ele, scale) {
  if (!scale) {
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level

    scale = Math.pow(2, lvl);
  }

  var computedSize = ele.pstyle('font-size').pfValue * scale;
  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

  if (computedSize < minSize) {
    return false;
  }

  return true;
};

CRp$4.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {
  var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;

  if (force == null) {
    if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else if (force === false) {
    return;
  }

  if (ele.isNode()) {
    var label = ele.pstyle('label');

    if (!label || !label.value) {
      return;
    }

    var justification = r.getLabelJustification(ele);
    context.textAlign = justification;
    context.textBaseline = 'bottom';
  } else {
    var badLine = ele.element()._private.rscratch.badLine;

    var _label = ele.pstyle('label');

    var srcLabel = ele.pstyle('source-label');
    var tgtLabel = ele.pstyle('target-label');

    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }

  var applyRotation = !shiftToOriginWithBb;
  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  if (prefix == null) {
    r.drawText(context, ele, null, applyRotation, useEleOpacity);

    if (ele.isEdge()) {
      r.drawText(context, ele, 'source', applyRotation, useEleOpacity);
      r.drawText(context, ele, 'target', applyRotation, useEleOpacity);
    }
  } else {
    r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
  }

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$4.getFontCache = function (context) {
  var cache;
  this.fontCaches = this.fontCaches || [];

  for (var i = 0; i < this.fontCaches.length; i++) {
    cache = this.fontCaches[i];

    if (cache.context === context) {
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);
  return cache;
}; // set up canvas context with font
// returns transformed text string


CRp$4.setupTextStyle = function (context, ele) {
  var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // Font style
  var labelStyle = ele.pstyle('font-style').strValue;
  var labelSize = ele.pstyle('font-size').pfValue + 'px';
  var labelFamily = ele.pstyle('font-family').strValue;
  var labelWeight = ele.pstyle('font-weight').strValue;
  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;
  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
  var color = ele.pstyle('color').value;
  var outlineColor = ele.pstyle('text-outline-color').value;
  context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
  context.lineJoin = 'round'; // so text outlines aren't jagged

  this.colorFillStyle(context, color[0], color[1], color[2], opacity);
  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
}; // TODO ensure re-used


function roundRect(ctx, x, y, width, height) {
  var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

CRp$4.getTextAngle = function (ele, prefix) {
  var theta;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var pdash = prefix ? prefix + '-' : '';
  var rotation = ele.pstyle(pdash + 'text-rotation');
  var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);

  if (rotation.strValue === 'autorotate') {
    theta = ele.isEdge() ? textAngle : 0;
  } else if (rotation.strValue === 'none') {
    theta = 0;
  } else {
    theta = rotation.pfValue;
  }

  return theta;
};

CRp$4.drawText = function (context, ele, prefix) {
  var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;

  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {
    return;
  } // use 'main' as an alias for the main label (i.e. null prefix)


  if (prefix === 'main') {
    prefix = null;
  }

  var textX = getPrefixedProperty(rscratch, 'labelX', prefix);
  var textY = getPrefixedProperty(rscratch, 'labelY', prefix);
  var orgTextX, orgTextY; // used for rotation

  var text = this.getLabelText(ele, prefix);

  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele, useEleOpacity);
    var pdash = prefix ? prefix + '-' : '';
    var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);
    var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);
    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var halign = ele.pstyle('text-halign').value;
    var valign = ele.pstyle('text-valign').value;

    if (isEdge) {
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;
    var theta;

    if (!applyRotation) {
      theta = 0;
    } else {
      theta = this.getTextAngle(ele, prefix);
    }

    if (theta !== 0) {
      orgTextX = textX;
      orgTextY = textY;
      context.translate(orgTextX, orgTextY);
      context.rotate(theta);
      textX = 0;
      textY = 0;
    }

    switch (valign) {
      case 'top':
        break;

      case 'center':
        textY += textH / 2;
        break;

      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle('text-background-opacity').value;
    var borderOpacity = ele.pstyle('text-border-opacity').value;
    var textBorderWidth = ele.pstyle('text-border-width').pfValue;
    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var bgX = textX - backgroundPadding;

      switch (halign) {
        case 'left':
          bgX -= textW;
          break;

        case 'center':
          bgX -= textW / 2;
          break;

        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;

      if (backgroundOpacity > 0) {
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle('text-background-color').value;
        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle('text-background-shape').strValue;

        if (styleShape.indexOf('round') === 0) {
          roundRect(context, bgX, bgY, bgW, bgH, 2);
        } else {
          context.fillRect(bgX, bgY, bgW, bgH);
        }

        context.fillStyle = textFill;
      }

      if (textBorderWidth > 0 && borderOpacity > 0) {
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle('text-border-color').value;
        var textBorderStyle = ele.pstyle('text-border-style').value;
        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if (context.setLineDash) {
          // for very outofdate browsers
          switch (textBorderStyle) {
            case 'dotted':
              context.setLineDash([1, 1]);
              break;

            case 'dashed':
              context.setLineDash([4, 2]);
              break;

            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders

              context.setLineDash([]);
              break;

            case 'solid':
              context.setLineDash([]);
              break;
          }
        }

        context.strokeRect(bgX, bgY, bgW, bgH);

        if (textBorderStyle === 'double') {
          var whiteWidth = textBorderWidth / 2;
          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
        }

        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }

        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }
    }

    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }

    if (ele.pstyle('text-wrap').value === 'wrap') {
      var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
      var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);
      var halfTextW = textW / 2;
      var justification = this.getLabelJustification(ele);

      if (justification === 'auto') ; else if (halign === 'left') {
        // auto justification : right
        if (justification === 'left') {
          textX += -textW;
        } else if (justification === 'center') {
          textX += -halfTextW;
        } // else same as auto

      } else if (halign === 'center') {
        // auto justfication : center
        if (justification === 'left') {
          textX += -halfTextW;
        } else if (justification === 'right') {
          textX += halfTextW;
        } // else same as auto

      } else if (halign === 'right') {
        // auto justification : left
        if (justification === 'center') {
          textX += halfTextW;
        } else if (justification === 'right') {
          textX += textW;
        } // else same as auto

      }

      switch (valign) {
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;

        case 'center':
        case 'bottom':
          textY -= (lines.length - 1) * lineHeight;
          break;
      }

      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }

        context.fillText(lines[l], textX, textY);
        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};

/* global Path2D */
var CRp$5 = {};

CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var nodeWidth, nodeHeight;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();

  if (!number(pos.x) || !number(pos.y)) {
    return; // can't draw node with undefined position
  }

  if (shouldDrawOpacity && !node.visible()) {
    return;
  }

  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
  var usePaths = r.usePaths();
  var path;
  var pathCacheHit = false;
  var padding = node.padding();
  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding; //
  // setup shift

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  } //
  // load bg image


  var bgImgProp = node.pstyle('background-image');
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;

  for (var i = 0; i < urls.length; i++) {
    var url = urls[i];
    var defd = urlDefined[i] = url != null && url !== 'none';

    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);
      numImages++; // get image, and if not loaded then ask to redraw when later loaded

      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
        _p.backgroundTimestamp = Date.now();
        node.emitAndNotify('background');
      });
    }
  } //
  // setup styles


  var darkness = node.pstyle('background-blacken').value;
  var borderWidth = node.pstyle('border-width').pfValue;
  var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;
  var borderColor = node.pstyle('border-color').value;
  var borderStyle = node.pstyle('border-style').value;
  var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;
  context.lineJoin = 'miter'; // so borders are square with the node shape

  var setupShapeColor = function setupShapeColor() {
    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
    r.eleFillStyle(context, node, bgOpy);
  };

  var setupBorderColor = function setupBorderColor() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
    r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  }; //
  // setup shape


  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if (usePaths) {
    context.translate(pos.x, pos.y);
    var pathCache = r.nodePathCache = r.nodePathCache || [];
    var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);
    var cachedPath = pathCache[key];

    if (cachedPath != null) {
      path = cachedPath;
      pathCacheHit = true;
      rs.pathCache = path;
    } else {
      path = new Path2D();
      pathCache[key] = rs.pathCache = path;
    }
  }

  var drawShape = function drawShape() {
    if (!pathCacheHit) {
      var npos = pos;

      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
    }

    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  };

  var drawImages = function drawImages() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var prevBging = _p.backgrounding;
    var totalCompleted = 0;

    for (var _i = 0; _i < image.length; _i++) {
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }

    _p.backgrounding = !(totalCompleted === numImages);

    if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
      node.updateStyle(false);
    }
  };

  var drawPie = function drawPie() {
    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;

    if (r.hasPie(node)) {
      r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it

      if (redrawShape) {
        if (!usePaths) {
          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
        }
      }
    }
  };

  var darken = function darken() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;

    if (darkness !== 0) {
      r.colorFillStyle(context, c, c, c, opacity);

      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  };

  var drawBorder = function drawBorder() {
    if (borderWidth > 0) {
      context.lineWidth = borderWidth;
      context.lineCap = 'butt';

      if (context.setLineDash) {
        // for very outofdate browsers
        switch (borderStyle) {
          case 'dotted':
            context.setLineDash([1, 1]);
            break;

          case 'dashed':
            context.setLineDash([4, 2]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([]);
            break;
        }
      }

      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      }

      if (borderStyle === 'double') {
        context.lineWidth = borderWidth / 3;
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      } // reset in case we changed the border style


      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    }
  };

  var drawOverlay = function drawOverlay() {
    if (shouldDrawOverlay) {
      r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
    }
  };

  var drawText = function drawText() {
    r.drawElementText(context, node, null, drawLabel);
  };

  var ghost = node.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = node.pstyle('ghost-offset-x').pfValue;
    var gy = node.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = node.pstyle('ghost-opacity').value;
    var effGhostOpacity = ghostOpacity * eleOpacity;
    context.translate(gx, gy);
    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity);
    drawPie(darkness !== 0 || borderWidth !== 0);
    darken(effGhostOpacity);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();
    context.translate(-gx, -gy);
  }

  setupShapeColor();
  drawShape();
  drawImages();
  drawPie(darkness !== 0 || borderWidth !== 0);
  darken();
  setupBorderColor();
  drawBorder();

  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }

  drawText();
  drawOverlay(); //
  // clean up shift

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$5.drawNodeOverlay = function (context, node, pos, nodeWidth, nodeHeight) {
  var r = this;

  if (!node.visible()) {
    return;
  }

  var overlayPadding = node.pstyle('overlay-padding').pfValue;
  var overlayOpacity = node.pstyle('overlay-opacity').value;
  var overlayColor = node.pstyle('overlay-color').value;

  if (overlayOpacity > 0) {
    pos = pos || node.position();

    if (nodeWidth == null || nodeHeight == null) {
      var padding = node.padding();
      nodeWidth = node.width() + 2 * padding;
      nodeHeight = node.height() + 2 * padding;
    }

    r.colorFillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
    r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);
    context.fill();
  }
}; // does the node have at least one pie piece?


CRp$5.hasPie = function (node) {
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp$5.drawPie = function (context, node, nodeOpacity, pos) {
  node = node[0]; // ensure ele ref

  pos = pos || node.position();
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle('pie-size');
  var x = pos.x;
  var y = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node

  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]

  var usePaths = this.usePaths();

  if (usePaths) {
    x = 0;
    y = 0;
  }

  if (pieSize.units === '%') {
    radius = radius * pieSize.pfValue;
  } else if (pieSize.pfValue !== undefined) {
    radius = pieSize.pfValue / 2;
  }

  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
    var size = node.pstyle('pie-' + i + '-background-size').value;
    var color = node.pstyle('pie-' + i + '-background-color').value;
    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]
    // percent can't push beyond 1

    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise

    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta; // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle

    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc(x, y, radius, angleStart, angleEnd);
    context.closePath();
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    context.fill();
    lastPercent += percent;
  }
};

var CRp$6 = {};
var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';

CRp$6.getPixelRatio = function () {
  var context = this.data.contexts[0];

  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp$6.paintCache = function (context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for (var i = 0; i < caches.length; i++) {
    cache = caches[i];

    if (cache.context === context) {
      needToCreateCache = false;
      break;
    }
  }

  if (needToCreateCache) {
    cache = {
      context: context
    };
    caches.push(cache);
  }

  return cache;
};

CRp$6.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {
  var gradientStyle;
  var usePaths = this.usePaths();
  var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,
      positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;

  if (fill === 'radial-gradient') {
    if (ele.isEdge()) {
      var start = ele.sourceEndpoint(),
          end = ele.targetEndpoint(),
          mid = ele.midpoint();
      var d1 = dist(start, mid);
      var d2 = dist(end, mid);
      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
    } else {
      var pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          width = ele.paddedWidth(),
          height = ele.paddedHeight();
      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
    }
  } else {
    if (ele.isEdge()) {
      var _start = ele.sourceEndpoint(),
          _end = ele.targetEndpoint();

      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
    } else {
      var _pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          _width = ele.paddedWidth(),
          _height = ele.paddedHeight(),
          halfWidth = _width / 2,
          halfHeight = _height / 2;

      var direction = ele.pstyle('background-gradient-direction').value;

      switch (direction) {
        case 'to-bottom':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
          break;

        case 'to-top':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
          break;

        case 'to-left':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
          break;

        case 'to-right':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
          break;

        case 'to-bottom-right':
        case 'to-right-bottom':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-right':
        case 'to-right-top':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
          break;

        case 'to-bottom-left':
        case 'to-left-bottom':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-left':
        case 'to-left-top':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
          break;
      }
    }
  }

  if (!gradientStyle) return null; // invalid gradient style

  var hasPositions = positions.length === colors.length;
  var length = colors.length;

  for (var i = 0; i < length; i++) {
    gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');
  }

  return gradientStyle;
};

CRp$6.gradientFillStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.fillStyle = gradientStyle;
};

CRp$6.colorFillStyle = function (context, r, g, b, a) {
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp$6.eleFillStyle = function (context, ele, opacity) {
  var backgroundFill = ele.pstyle('background-fill').value;

  if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {
    this.gradientFillStyle(context, ele, backgroundFill, opacity);
  } else {
    var backgroundColor = ele.pstyle('background-color').value;
    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
  }
};

CRp$6.gradientStrokeStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.strokeStyle = gradientStyle;
};

CRp$6.colorStrokeStyle = function (context, r, g, b, a) {
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp$6.eleStrokeStyle = function (context, ele, opacity) {
  var lineFill = ele.pstyle('line-fill').value;

  if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {
    this.gradientStrokeStyle(context, ele, lineFill, opacity);
  } else {
    var lineColor = ele.pstyle('line-color').value;
    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
  }
}; // Resize canvas


CRp$6.matchCanvasSize = function (container) {
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
    canvas = data.canvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {
    canvas = data.bufferCanvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;

  if (pixelRatio <= 1) {
    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;
};

CRp$6.renderTo = function (cxt, zoom, pan, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp$6.render = function (options) {
  options = options || staticEmptyObject();
  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy;
  var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if (!forcedContext) {
    if (r.prevPxRatio !== pixelRatio) {
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);
      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if (!forcedContext && r.motionBlurTimeout) {
    clearTimeout(r.motionBlurTimeout);
  }

  if (motionBlur) {
    if (r.mbFrames == null) {
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)


    if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if (r.clearingMotionBlur) {
    r.motionBlurPxRatio = 1;
  } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw


  if (r.textureDrawLastFrame && !textureDraw) {
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var style = cy.style();
  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };
  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)

  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
    r.motionBlurPxRatio = 1;
  }

  if (forcedPan) {
    effectivePan = forcedPan;
  } // apply pixel ratio


  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;
  var eles = r.getCachedZSortedEles();

  function mbclear(context, x, y, w, h) {
    var gco = context.globalCompositeOperation;
    context.globalCompositeOperation = 'destination-out';
    r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
    context.fillRect(x, y, w, h);
    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear) {
    var ePan, eZoom, w, h;

    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };
      eZoom = zoom * mbPxRatio;
      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;
      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (clear === 'motionBlur') {
      mbclear(context, 0, 0, w, h);
    } else if (!forcedContext && (clear === undefined || clear)) {
      context.clearRect(0, 0, w, h);
    }

    if (!drawAllLayers) {
      context.translate(ePan.x, ePan.y);
      context.scale(eZoom, eZoom);
    }

    if (forcedPan) {
      context.translate(forcedPan.x, forcedPan.y);
    }

    if (forcedZoom) {
      context.scale(forcedZoom, forcedZoom);
    }
  }

  if (!textureDraw) {
    r.textureDrawLastFrame = false;
  }

  if (textureDraw) {
    r.textureDrawLastFrame = true;

    if (!r.textureCache) {
      r.textureCache = {};
      r.textureCache.bb = cy.mutableElements().boundingBox();
      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });
      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };
      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;
    var context = data.contexts[r.NODE];
    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    context.setTransform(1, 0, 0, 1, 0, 0);

    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = style.core('outside-texture-bg-color').value;
    var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;
    r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);
    var zoom = cy.zoom();
    setContextTransform(context, false);
    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
  var hideEdges = r.hideEdgesOnViewport && vpManip;
  var needMbClear = [];
  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;

  if (needMbClear[r.NODE]) {
    r.clearedForMotionBlur[r.NODE] = true;
  }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;

  if (needMbClear[r.DRAG]) {
    r.clearedForMotionBlur[r.DRAG] = true;
  }

  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
    setContextTransform(context, clear);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
    } else {
      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.nondrag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.NODE] = false;
    }
  }

  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
    } else {
      r.drawCachedElements(context, eles.drag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.drag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.DRAG] = false;
    }
  }

  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];
    setContextTransform(context);

    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var zoom = r.cy.zoom();
      var borderWidth = style.core('selection-box-border-width').value / zoom;
      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
      }
    }

    if (data.bgActivePosistion && !r.hoverData.selecting) {
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;
      context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';
      context.beginPath();
      context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;

    if (r.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1000 / timeToRender);
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
    }

    if (!drawAllLayers) {
      needDraw[r.SELECT_BOX] = false;
    }
  } // motionblur: blit rendered blurry frames


  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if (needClear || !motionBlurFadeEffect) {
        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
      } else {
        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
      }

      var pxr = mbPxRatio;
      cxt.drawImage(txt, // img
      0, 0, // sx, sy
      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
      0, 0, // x, y
      r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if (needDraw[r.NODE] || needMbClear[r.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
      needDraw[r.NODE] = false;
    }

    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
      needDraw[r.DRAG] = false;
    }
  }

  r.prevViewport = vp;

  if (r.clearingMotionBlur) {
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if (motionBlur) {
    r.motionBlurTimeout = setTimeout(function () {
      r.motionBlurTimeout = null;
      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;
      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;
      r.redraw();
    }, motionBlurDelay);
  }

  if (!forcedContext) {
    cy.emit('render');
  }
};

var CRp$7 = {}; // @O Polygon drawing

CRp$7.drawPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x + halfW * points[0], y + halfH * points[1]);

  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
  }

  context.closePath();
};

CRp$7.drawRoundPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  for (var _i = 0; _i < points.length / 4; _i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (_i === 0) {
      sourceUv = points.length - 2;
    } else {
      sourceUv = _i * 4 - 2;
    }

    destUv = _i * 4 + 2;
    var px = x + halfW * points[_i * 4];
    var py = y + halfH * points[_i * 4 + 1];
    var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * points[sourceUv];
    var cp0y = py - offset * points[sourceUv + 1];
    var cp1x = px + offset * points[destUv];
    var cp1y = py + offset * points[destUv + 1];

    if (_i === 0) {
      context.moveTo(cp0x, cp0y);
    } else {
      context.lineTo(cp0x, cp0y);
    }

    context.arcTo(px, py, cp1x, cp1y, cornerRadius);
  }

  context.closePath();
}; // Round rectangle drawing


CRp$7.drawRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight); // Arc from middle top to right side

  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom

  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side

  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder

  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line

  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawBottomRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight);
  context.lineTo(x + halfWidth, y);
  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
  context.lineTo(x - halfWidth, y - halfHeight);
  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawCutRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerLength = getCutRectangleCornerLength();

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
  context.closePath();
};

CRp$7.drawBarrelPath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xBegin = x - halfWidth;
  var xEnd = x + halfWidth;
  var yBegin = y - halfHeight;
  var yEnd = y + halfHeight;
  var barrelCurveConstants = getBarrelCurveConstants(width, height);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(xBegin, yBegin + hOffset);
  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
  context.closePath();
};

var sin0 = Math.sin(0);
var cos0 = Math.cos(0);
var sin = {};
var cos = {};
var ellipseStepSize = Math.PI / 40;

for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}

CRp$7.drawEllipsePath = function (context, centerX, centerY, width, height) {
  if (context.beginPath) {
    context.beginPath();
  }

  if (context.ellipse) {
    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width / 2;
    var rh = height / 2;

    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }

  context.closePath();
};

/* global atob, ArrayBuffer, Uint8Array, Blob */
var CRp$8 = {};

CRp$8.createBuffer = function (w, h) {
  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef

  buffer.width = w;
  buffer.height = h;
  return [buffer, buffer.getContext('2d')];
};

CRp$8.bufferCanvasImage = function (options) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = number(options.maxWidth) || number(options.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if (options.scale !== undefined) {
    width *= options.scale;
    height *= options.scale;
    scale = options.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if (number(options.maxWidth)) {
      maxScaleW = scale * options.maxWidth / width;
    }

    if (number(options.maxHeight)) {
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min(maxScaleW, maxScaleH);
    width *= scale;
    height *= scale;
  }

  if (!specdMaxDims) {
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;
  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';
  var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size

  if (width > 0 && height > 0) {
    buffCxt.clearRect(0, 0, width, height);
    buffCxt.globalCompositeOperation = 'source-over';
    var zsortedEles = this.getCachedZSortedEles();

    if (options.full) {
      // draw the full bounds of the graph
      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
    } else {
      // draw the current view
      var pan = cy.pan();
      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };
      scale *= cy.zoom();
      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(-translation.x, -translation.y);
    } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs


    if (options.bg) {
      buffCxt.globalCompositeOperation = 'destination-over';
      buffCxt.fillStyle = options.bg;
      buffCxt.rect(0, 0, width, height);
      buffCxt.fill();
    }
  }

  return buffCanvas;
};

function b64ToBlob(b64, mimeType) {
  var bytes = atob(b64);
  var buff = new ArrayBuffer(bytes.length);
  var buffUint8 = new Uint8Array(buff);

  for (var i = 0; i < bytes.length; i++) {
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob([buff], {
    type: mimeType
  });
}

function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(',');
  return b64uri.substr(i + 1);
}

function output(options, canvas, mimeType) {
  var getB64Uri = function getB64Uri() {
    return canvas.toDataURL(mimeType, options.quality);
  };

  switch (options.output) {
    case 'blob-promise':
      return new Promise$1(function (resolve, reject) {
        try {
          canvas.toBlob(function (blob) {
            if (blob != null) {
              resolve(blob);
            } else {
              reject(new Error('`canvas.toBlob()` sent a null value in its callback'));
            }
          }, mimeType, options.quality);
        } catch (err) {
          reject(err);
        }
      });

    case 'blob':
      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);

    case 'base64':
      return b64UriToB64(getB64Uri());

    case 'base64uri':
    default:
      return getB64Uri();
  }
}

CRp$8.png = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/png');
};

CRp$8.jpg = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/jpeg');
};

var CRp$9 = {};

CRp$9.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
  switch (name) {
    case 'ellipse':
      return this.drawEllipsePath(context, centerX, centerY, width, height);

    case 'polygon':
      return this.drawPolygonPath(context, centerX, centerY, width, height, points);

    case 'round-polygon':
      return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);

    case 'roundrectangle':
    case 'round-rectangle':
      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);

    case 'cutrectangle':
    case 'cut-rectangle':
      return this.drawCutRectanglePath(context, centerX, centerY, width, height);

    case 'bottomroundrectangle':
    case 'bottom-round-rectangle':
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);

    case 'barrel':
      return this.drawBarrelPath(context, centerX, centerY, width, height);
  }
};

var CR = CanvasRenderer;
var CRp$a = CanvasRenderer.prototype;
CRp$a.CANVAS_LAYERS = 3; //

CRp$a.SELECT_BOX = 0;
CRp$a.DRAG = 1;
CRp$a.NODE = 2;
CRp$a.BUFFER_COUNT = 3; //

CRp$a.TEXTURE_BUFFER = 0;
CRp$a.MOTIONBLUR_BUFFER_NODE = 1;
CRp$a.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;
  r.data = {
    canvases: new Array(CRp$a.CANVAS_LAYERS),
    contexts: new Array(CRp$a.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp$a.CANVAS_LAYERS),
    bufferCanvases: new Array(CRp$a.BUFFER_COUNT),
    bufferContexts: new Array(CRp$a.CANVAS_LAYERS)
  };
  var tapHlOffAttr = '-webkit-tap-highlight-color';
  var tapHlOffStyle = 'rgba(0,0,0,0)';
  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef

  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';
  var container = options.cy.container();
  container.appendChild(r.data.canvasContainer);
  container.style[tapHlOffAttr] = tapHlOffStyle;
  var styleMap = {
    '-webkit-user-select': 'none',
    '-moz-user-select': '-moz-none',
    'user-select': 'none',
    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
    'outline-style': 'none'
  };

  if (ms()) {
    styleMap['-ms-touch-action'] = 'none';
    styleMap['touch-action'] = 'none';
  }

  for (var i = 0; i < CRp$a.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.contexts[i] = canvas.getContext('2d');
    Object.keys(styleMap).forEach(function (k) {
      canvas.style[k] = styleMap[k];
    });
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp$a.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);
    r.data.canvasNeedsRedraw[i] = false;
  }

  r.data.topCanvas = r.data.canvases[0];
  r.data.canvases[CRp$a.NODE].setAttribute('data-id', 'layer' + CRp$a.NODE + '-node');
  r.data.canvases[CRp$a.SELECT_BOX].setAttribute('data-id', 'layer' + CRp$a.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp$a.DRAG].setAttribute('data-id', 'layer' + CRp$a.DRAG + '-drag');

  for (var i = 0; i < CRp$a.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;
  var emptyBb = makeBoundingBox();

  var getBoxCenter = function getBoxCenter(bb) {
    return {
      x: (bb.x1 + bb.x2) / 2,
      y: (bb.y1 + bb.y2) / 2
    };
  };

  var getCenterOffset = function getCenterOffset(bb) {
    return {
      x: -bb.w / 2,
      y: -bb.h / 2
    };
  };

  var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
    var _p = ele[0]._private;
    var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
    return !same;
  };

  var getStyleKey = function getStyleKey(ele) {
    return ele[0]._private.nodeKey;
  };

  var getLabelKey = function getLabelKey(ele) {
    return ele[0]._private.labelStyleKey;
  };

  var getSourceLabelKey = function getSourceLabelKey(ele) {
    return ele[0]._private.sourceLabelStyleKey;
  };

  var getTargetLabelKey = function getTargetLabelKey(ele) {
    return ele[0]._private.targetLabelStyleKey;
  };

  var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElement(context, ele, bb, false, false, useEleOpacity);
  };

  var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);
  };

  var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);
  };

  var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);
  };

  var getElementBox = function getElementBox(ele) {
    ele.boundingBox();
    return ele[0]._private.bodyBounds;
  };

  var getLabelBox = function getLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.main || emptyBb;
  };

  var getSourceLabelBox = function getSourceLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.source || emptyBb;
  };

  var getTargetLabelBox = function getTargetLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.target || emptyBb;
  };

  var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
    return scaledLabelShown;
  };

  var getElementRotationPoint = function getElementRotationPoint(ele) {
    return getBoxCenter(getElementBox(ele));
  };

  var addTextMargin = function addTextMargin(prefix, pt, ele) {
    var pre = prefix ? prefix + '-' : '';
    return {
      x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,
      y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue
    };
  };

  var getRsPt = function getRsPt(ele, x, y) {
    var rs = ele[0]._private.rscratch;
    return {
      x: rs[x],
      y: rs[y]
    };
  };

  var getLabelRotationPoint = function getLabelRotationPoint(ele) {
    return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);
  };

  var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
    return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);
  };

  var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
    return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);
  };

  var getElementRotationOffset = function getElementRotationOffset(ele) {
    return getCenterOffset(getElementBox(ele));
  };

  var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
    return getCenterOffset(getSourceLabelBox(ele));
  };

  var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
    return getCenterOffset(getTargetLabelBox(ele));
  };

  var getLabelRotationOffset = function getLabelRotationOffset(ele) {
    var bb = getLabelBox(ele);
    var p = getCenterOffset(getLabelBox(ele));

    if (ele.isNode()) {
      switch (ele.pstyle('text-halign').value) {
        case 'left':
          p.x = -bb.w;
          break;

        case 'right':
          p.x = 0;
          break;
      }

      switch (ele.pstyle('text-valign').value) {
        case 'top':
          p.y = -bb.h;
          break;

        case 'bottom':
          p.y = 0;
          break;
      }
    }

    return p;
  };

  var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
    getKey: getStyleKey,
    doesEleInvalidateKey: backgroundTimestampHasChanged,
    drawElement: drawElement,
    getBoundingBox: getElementBox,
    getRotationPoint: getElementRotationPoint,
    getRotationOffset: getElementRotationOffset,
    allowEdgeTxrCaching: false,
    allowParentTxrCaching: false
  });
  var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
    getKey: getLabelKey,
    drawElement: drawLabel,
    getBoundingBox: getLabelBox,
    getRotationPoint: getLabelRotationPoint,
    getRotationOffset: getLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
    getKey: getSourceLabelKey,
    drawElement: drawSourceLabel,
    getBoundingBox: getSourceLabelBox,
    getRotationPoint: getSourceLabelRotationPoint,
    getRotationOffset: getSourceLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
    getKey: getTargetLabelKey,
    drawElement: drawTargetLabel,
    getBoundingBox: getTargetLabelBox,
    getRotationPoint: getTargetLabelRotationPoint,
    getRotationOffset: getTargetLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    // each cache should check for sub-key diff to see that the update affects that cache particularly
    eleTxrCache.invalidateElements(eles);
    lblTxrCache.invalidateElements(eles);
    slbTxrCache.invalidateElements(eles);
    tlbTxrCache.invalidateElements(eles); // any change invalidates the layers

    lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches

    for (var _i = 0; _i < eles.length; _i++) {
      var _p = eles[_i]._private;
      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
    }
  });

  var refineInLayers = function refineInLayers(reqs) {
    for (var i = 0; i < reqs.length; i++) {
      lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
    }
  };

  eleTxrCache.onDequeue(refineInLayers);
  lblTxrCache.onDequeue(refineInLayers);
  slbTxrCache.onDequeue(refineInLayers);
  tlbTxrCache.onDequeue(refineInLayers);
}

CRp$a.redrawHint = function (group, bool) {
  var r = this;

  switch (group) {
    case 'eles':
      r.data.canvasNeedsRedraw[CRp$a.NODE] = bool;
      break;

    case 'drag':
      r.data.canvasNeedsRedraw[CRp$a.DRAG] = bool;
      break;

    case 'select':
      r.data.canvasNeedsRedraw[CRp$a.SELECT_BOX] = bool;
      break;
  }
}; // whether to use Path2D caching for drawing


var pathsImpld = typeof Path2D !== 'undefined';

CRp$a.path2dEnabled = function (on) {
  if (on === undefined) {
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp$a.usePaths = function () {
  return pathsImpld && this.pathsEnabled;
};

CRp$a.setImgSmoothing = function (context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
};

CRp$a.getImgSmoothing = function (context) {
  if (context.imageSmoothingEnabled != null) {
    return context.imageSmoothingEnabled;
  } else {
    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
  }
};

CRp$a.makeOffscreenCanvas = function (width, height) {
  var canvas;

  if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== ( "undefined" )) {
    canvas = new OffscreenCanvas(width, height);
  } else {
    canvas = document.createElement('canvas'); // eslint-disable-line no-undef

    canvas.width = width;
    canvas.height = height;
  }

  return canvas;
};

[CRp, CRp$1, CRp$2, CRp$3, CRp$4, CRp$5, CRp$6, CRp$7, CRp$8, CRp$9].forEach(function (props) {
  extend(CRp$a, props);
});

var renderer = [{
  name: 'null',
  impl: NullRenderer
}, {
  name: 'base',
  impl: BR
}, {
  name: 'canvas',
  impl: CR
}];

var incExts = [{
  type: 'layout',
  extensions: layout
}, {
  type: 'renderer',
  extensions: renderer
}];

var extensions = {}; // registered modules for extensions, indexed by name

var modules = {};

function setExtension(type, name, registrant) {
  var ext = registrant;

  var overrideErr = function overrideErr(field) {
    error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
  };

  if (type === 'core') {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === 'collection') {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === 'layout') {
    // fill in missing layout functions in the prototype
    var Layout = function Layout(options) {
      this.options = options;
      registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()

      if (!plainObject(this._private)) {
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
      this.createEmitter();
    };

    var layoutProto = Layout.prototype = Object.create(registrant.prototype);
    var optLayoutFns = [];

    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function () {
        return this;
      };
    } // either .start() or .run() is defined, so autogen the other


    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function () {
        this.start();
        return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function () {
        this.run();
        return this;
      };
    }

    var regStop = registrant.prototype.stop;

    layoutProto.stop = function () {
      var opts = this.options;

      if (opts && opts.animate) {
        var anis = this.animations;

        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }

      if (regStop) {
        regStop.call(this);
      } else {
        this.emit('layoutstop');
      }

      return this;
    };

    if (!layoutProto.destroy) {
      layoutProto.destroy = function () {
        return this;
      };
    }

    layoutProto.cy = function () {
      return this._private.cy;
    };

    var getCy = function getCy(layout) {
      return layout._private.cy;
    };

    var emitterOpts = {
      addEventFields: function addEventFields(layout, evt) {
        evt.layout = layout;
        evt.cy = getCy(layout);
        evt.target = layout;
      },
      bubble: function bubble() {
        return true;
      },
      parent: function parent(layout) {
        return getCy(layout);
      }
    };
    extend(layoutProto, {
      createEmitter: function createEmitter() {
        this._private.emitter = new Emitter(emitterOpts, this);
        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(evt, cb) {
        this.emitter().on(evt, cb);
        return this;
      },
      one: function one(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      once: function once(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      removeListener: function removeListener(evt, cb) {
        this.emitter().removeListener(evt, cb);
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        this.emitter().removeAllListeners();
        return this;
      },
      emit: function emit(evt, params) {
        this.emitter().emit(evt, params);
        return this;
      }
    });
    define$3.eventAliasesOn(layoutProto);
    ext = Layout; // replace with our wrapped layout
  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base
    var BaseRenderer = getExtension('renderer', 'base');
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function Renderer() {
      BaseRenderer.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    };

    var proto = Renderer.prototype;

    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;

      if (existsInR) {
        return overrideErr(pName);
      }

      proto[pName] = pVal; // take impl from base
    }

    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName]; // take impl from registrant
    }

    bProto.clientFunctions.forEach(function (name) {
      proto[name] = proto[name] || function () {
        error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });
    ext = Renderer;
  }

  return setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}

function getExtension(type, name) {
  return getMap({
    map: extensions,
    keys: [type, name]
  });
}

function setModule(type, name, moduleType, moduleName, registrant) {
  return setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName) {
  return getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}

var extension = function extension() {
  // e.g. extension('renderer', 'svg')
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  } // e.g. extension('renderer', 'svg', { ... })
  else if (arguments.length === 3) {
      return setExtension.apply(null, arguments);
    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if (arguments.length === 4) {
        return getModule.apply(null, arguments);
      } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
      else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          error('Invalid extension access syntax');
        }
}; // allows a core instance to access extensions internally


Core.prototype.extension = extension; // included extensions

incExts.forEach(function (group) {
  group.extensions.forEach(function (ext) {
    setExtension(group.type, ext.name, ext.impl);
  });
});

// (useful for init)

var Stylesheet = function Stylesheet() {
  if (!(this instanceof Stylesheet)) {
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function () {
  return 'stylesheet';
}; // just store the selector to be parsed later


sheetfn.selector = function (selector) {
  var i = this.length++;
  this[i] = {
    selector: selector,
    properties: []
  };
  return this; // chaining
}; // just store the property to be parsed later


sheetfn.css = function (name, value) {
  var i = this.length - 1;

  if (string(name)) {
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if (plainObject(name)) {
    var map = name;
    var propNames = Object.keys(map);

    for (var j = 0; j < propNames.length; j++) {
      var key = propNames[j];
      var mapVal = map[key];

      if (mapVal == null) {
        continue;
      }

      var prop = Style.properties[key] || Style.properties[dash2camel(key)];

      if (prop == null) {
        continue;
      }

      var _name = prop.name;
      var _value = mapVal;
      this[i].properties.push({
        name: _name,
        value: _value
      });
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet

sheetfn.generateStyle = function (cy) {
  var style = new Style(cy);
  return this.appendToStyle(style);
}; // append a dummy stylesheet object on a real style object


sheetfn.appendToStyle = function (style) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;
    style.selector(selector); // apply selector

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      style.css(prop.name, prop.value); // apply property
    }
  }

  return style;
};

var version = "3.12.1";

var cytoscape = function cytoscape(options) {
  // if no options specified, use default
  if (options === undefined) {
    options = {};
  } // create instance


  if (plainObject(options)) {
    return new Core(options);
  } // allow for registration of extensions
  else if (string(options)) {
      return extension.apply(extension, arguments);
    }
}; // e.g. cytoscape.use( require('cytoscape-foo'), bar )


cytoscape.use = function (ext) {
  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

  args.unshift(cytoscape); // cytoscape is first arg to ext

  ext.apply(null, args);
  return this;
};

cytoscape.warnings = function (bool) {
  return warnings(bool);
}; // replaced by build system


cytoscape.version = version; // expose public apis (mostly for extensions)

cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/heap */ "./node_modules/heap/lib/heap.js");


/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (true) {
      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(this, function() {
    return Heap;
  });

}).call(this);


/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.memoize/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.memoize/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return H; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return I; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toChildArray", function() { return b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_unmount", function() { return A; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return n; });
var n,l,u,t,i,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var t,i,o,r,f=arguments;if(l=s({},l),arguments.length>3)for(u=[u],t=3;t<arguments.length;t++)u.push(f[t]);if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps)for(i in n.defaultProps)void 0===l[i]&&(l[i]=n.defaultProps[i]);return r=l.key,null!=(o=l.ref)&&delete l.ref,null!=r&&delete l.key,v(n,l,r,o)}function v(l,u,t,i){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(o),o}function p(){return{}}function d(n){return n.children}function y(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__?m(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?m(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function g(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){var n,l,t,i,o,r,f;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();)n.__d&&(t=void 0,i=void 0,r=(o=(l=n).__v).__e,(f=l.__P)&&(t=[],i=T(f,o,s({},o),l.__n,void 0!==f.ownerSVGElement,null,t,null==r?m(o):r),$(t,o),i!=r&&w(o)))}function _(n,l,u,t,i,o,r,c,s){var h,v,p,d,y,w,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=o?o[0]:_?m(u,0):null),h=0,l.__k=b(l.__k,function(u){if(null!=u){if(u.__=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type)k[h]=void 0;else for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null}if(d=T(n,u,p=p||f,t,i,o,r,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,u),g.push(v,u.__c||d,u)),null!=d){if(null==w&&(w=d),null!=u.__d)d=u.__d,u.__d=null;else if(o==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n)n.appendChild(d);else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2)if(y==d)break n;n.insertBefore(d,c)}"option"==l.type&&(n.value="")}c=d.nextSibling,"function"==typeof l.type&&(l.__d=d)}}return h++,u}),l.__e=w,null!=o&&"function"!=typeof l.type)for(h=o.length;h--;)null!=o[h]&&a(o[h]);for(h=_;h--;)null!=k[h]&&A(k[h],k[h]);if(g)for(h=0;h<g.length;h++)z(g[h],g[++h],g[++h])}function b(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var t=0;t<n.length;t++)b(n[t],l,u);else u.push(l?l("string"==typeof n||"number"==typeof n?v(null,n,null,null):null!=n.__e||null!=n.__c?v(n.type,n.props,n.key,null):n):n);return u}function x(n,l,u,t,i){var o;for(o in u)o in l||P(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"value"===o||"checked"===o||u[o]===l[o]||P(n,o,l[o],u[o],t)}function C(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===c.test(l)?u+"px":null==u?"":u}function P(n,l,u,t,i){var o,r,f,e,c;if(i?"className"===l&&(l="class"):"class"===l&&(l="className"),"key"===l||"children"===l);else if("style"===l)if(o=n.style,"string"==typeof u)o.cssText=u;else{if("string"==typeof t&&(o.cssText="",t=null),t)for(r in t)u&&r in u||C(o,r,"");if(u)for(f in u)t&&u[f]===t[f]||C(o,f,u[f])}else"o"===l[0]&&"n"===l[1]?(e=l!==(l=l.replace(/Capture$/,"")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,N,e),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,N,e)):"list"!==l&&"tagName"!==l&&"form"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u))}function N(l){this.l[l.type](n.event?n.event(l):l)}function T(l,u,t,i,o,r,f,e,c){var a,h,v,p,m,w,g,k,x,C,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(k=u.props,x=(a=P.contextType)&&i[a.__c],C=a?x?x.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:("prototype"in P&&P.prototype.render?u.__c=h=new P(k,C):(u.__c=h=new y(k,C),h.constructor=P,h.render=D),x&&x.sub(h),h.props=k,h.state||(h.state={}),h.context=C,h.__n=i,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,P.getDerivedStateFromProps(k,h.__s))),p=h.props,m=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&null==h.__e&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,C),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,C)){for(h.props=k,h.state=h.__s,h.__d=!1,h.__v=u,u.__e=t.__e,u.__k=t.__k,h.__h.length&&f.push(h),a=0;a<u.__k.length;a++)u.__k[a]&&(u.__k[a].__=u);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,C),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,m,w)})}h.context=C,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),u.__k=b(null!=a&&a.type==d&&null==a.key?a.props.children:a),null!=h.getChildContext&&(i=s(s({},i),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(w=h.getSnapshotBeforeUpdate(p,m)),_(l,u,t,i,o,r,f,e,c),h.base=u.__e,h.__h.length&&f.push(h),g&&(h.__E=h.__=null),h.__e=null}else u.__e=j(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){n.__e(l,u,t)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,t,i,o,r,c){var s,a,h,v,p,d=u.props,y=l.props;if(i="svg"===l.type||i,null==n&&null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(y);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type),o=null}if(null===l.type)null!=o&&(o[o.indexOf(n)]=null),d!==y&&(n.data=y);else if(l!==u){if(null!=o&&(o=e.slice.call(n.childNodes)),h=(d=u.props||f).dangerouslySetInnerHTML,v=y.dangerouslySetInnerHTML,!c){if(d===f)for(d={},p=0;p<n.attributes.length;p++)d[n.attributes[p].name]=n.attributes[p].value;(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||""))}x(n,y,d,i,c),l.__k=l.props.children,v||_(n,l,u,t,"foreignObject"!==l.type&&i,o,r,f,c),c||("value"in y&&void 0!==y.value&&y.value!==n.value&&(n.value=null==y.value?"":y.value),"checked"in y&&void 0!==y.checked&&y.checked!==n.checked&&(n.checked=y.checked))}return n}function z(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function A(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&z(i,null,u),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=null,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&A(i[r],u,t);null!=o&&a(o)}function D(n,l,u){return this.constructor(n,u)}function E(l,u,t){var i,r,c;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],T(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:e.slice.call(u.childNodes),c,t||f,i),$(c,l)}function H(n,l){E(n,l,o)}function I(n,l){return l=s(s({},n.props),l),arguments.length>2&&(l.children=e.slice.call(arguments,2)),v(n.type,l,l.key||n.key,l.ref||n.ref)}function L(n){var l={},u={__c:"__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var t,i=this;return this.getChildContext||(t=[],this.getChildContext=function(){return l[u.__c]=i,l},this.shouldComponentUpdate=function(l){n.value!==l.value&&t.some(function(n){n.context=l.value,g(n)})},this.sub=function(n){t.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){t.splice(t.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u}n={__e:function(n,l){for(var u;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError)u.setState(u.constructor.getDerivedStateFromError(n));else{if(null==u.componentDidCatch)continue;u.componentDidCatch(n)}return g(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(u,this.props)),n&&s(u,n),null!=n&&this.__v&&(this.__e=!1,l&&this.__h.push(l),g(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),g(this))},y.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,o=f,r=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/client/components/app.js":
/*!**************************************!*\
  !*** ./src/client/components/app.js ***!
  \**************************************/
/*! exports provided: default, AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controller */ "./src/client/controller.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cytoscape */ "./node_modules/cytoscape/dist/cytoscape.cjs.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cytoscape__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _cy_conf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cy-conf */ "./src/client/cy-conf/index.js");
/* harmony import */ var _cytoscape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cytoscape */ "./src/client/components/cytoscape.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../env */ "./src/client/env.js");
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./menu */ "./src/client/components/menu.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



 //import fcose from 'cytoscape-fcose';
//Cytoscape.use( fcose );







var AppComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(AppComponent, _Component);

  function AppComponent(props) {
    var _this;

    _classCallCheck(this, AppComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AppComponent).call(this, props));
    var cy = new cytoscape__WEBPACK_IMPORTED_MODULE_2___default.a({
      elements: _cy_conf__WEBPACK_IMPORTED_MODULE_3__["elements"],
      style: _cy_conf__WEBPACK_IMPORTED_MODULE_3__["style"],
      //layout: { name: 'fcose' },
      layout: {
        name: 'preset'
      },
      //layout: { name: 'grid' },
      selectionType: 'single',
      boxSelectionEnabled: false,
      zoomingEnabled: true,
      userZoomingEnabled: true
    }); //cy.use(fcose)

    cy.nodes().panify().ungrabify();
    var controller = new _controller__WEBPACK_IMPORTED_MODULE_1__["Controller"]({
      cy: cy
    });
    var bus = controller.bus;

    if (_env__WEBPACK_IMPORTED_MODULE_5__["isDev"]) {
      window.cy = cy;
      window.controller = controller;
    }

    _this.state = {
      controller: controller,
      cy: cy
    };
    bus.on('showInfo', _this.onShowInfo = function (node) {
      _this.setState({
        infoNode: node
      });
    });
    bus.on('hideInfo', _this.onHideInfo = function () {
      _this.setState({
        infoNode: null
      });
    });
    return _this;
  }

  _createClass(AppComponent, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.state.controller.bus;
      bus.removeListener('showInfo', this.onShowInfo);
      bus.removeListener('hideInfo', this.onHideInfo);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          cy = _this$state.cy,
          controller = _this$state.controller,
          infoNode = _this$state.infoNode;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_cytoscape__WEBPACK_IMPORTED_MODULE_4__["default"], {
        cy: cy,
        controller: controller
      }), infoNode ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app-node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_6__["NodeInfo"], {
        node: infoNode
      })]) : null, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_menu__WEBPACK_IMPORTED_MODULE_7__["Menu"], {
        controller: controller
      })]);
    }
  }]);

  return AppComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (AppComponent);


/***/ }),

/***/ "./src/client/components/cytoscape.js":
/*!********************************************!*\
  !*** ./src/client/components/cytoscape.js ***!
  \********************************************/
/*! exports provided: default, CytoscapeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CytoscapeComponent", function() { return CytoscapeComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var CytoscapeComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(CytoscapeComponent, _Component);

  function CytoscapeComponent(props) {
    _classCallCheck(this, CytoscapeComponent);

    return _possibleConstructorReturn(this, _getPrototypeOf(CytoscapeComponent).call(this, props));
  }

  _createClass(CytoscapeComponent, [{
    key: "render",
    value: function render() {
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        id: 'cy'
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          cy = _this$props.cy,
          controller = _this$props.controller;
      var container = document.getElementById('cy');
      cy.mount(container);
      cy.fit(10);
      cy.on('tap', this.onTap = function (e) {
        if (e.target === cy) {
          controller.unhighlight();
          controller.hideInfo();
          controller.closeMenu();
        } else {
          controller.highlight(e.target);
          controller.showInfo(e.target);
          controller.closeMenu();
        }
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var cy = this.props.cy;
      cy.removeListener('tap', this.onTap);
    }
  }]);

  return CytoscapeComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (CytoscapeComponent);


/***/ }),

/***/ "./src/client/components/menu.js":
/*!***************************************!*\
  !*** ./src/client/components/menu.js ***!
  \***************************************/
/*! exports provided: default, Menu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Menu", function() { return Menu; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var Menu =
/*#__PURE__*/
function (_Component) {
  _inherits(Menu, _Component);

  function Menu(props) {
    var _this;

    _classCallCheck(this, Menu);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, props));
    var controller = props.controller;
    var bus = controller.bus;
    _this.state = {
      open: controller.isMenuOpen()
    };
    bus.on('openMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: true
      });

      _this.focusTextBox();
    });
    bus.on('closeMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: false
      });
    });
    bus.on('updateSearch', _this.onUpdateSearch = function (searchMatchNodes) {
      _this.setState({
        searchMatchNodes: searchMatchNodes
      });
    });
    _this.debouncedUpdateSearch = lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default()(function () {
      return _this.updateSearch();
    }, 250);
    return _this;
  }

  _createClass(Menu, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.props.controller.bus;
      bus.removeListener('openMenu', this.onOpenMenu);
      bus.removeListener('closeMenu', this.onCloseMenu);
      bus.removeListener('updateSearch', this.onUpdateSearch);
    }
  }, {
    key: "open",
    value: function open() {
      var controller = this.props.controller;
      controller.openMenu();
    }
  }, {
    key: "updateSearch",
    value: function updateSearch() {
      var controller = this.props.controller;
      var input = document.getElementById('menu-search');
      var results = document.getElementById('menu-search-results');
      var queryString = input.value;
      results.scrollTo(0, 0);
      controller.updateSearch(queryString);
    }
  }, {
    key: "focusTextBox",
    value: function focusTextBox() {
      var input = document.getElementById('menu-search');

      if (input) {
        input.focus();
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode(node) {
      var controller = this.props.controller;
      controller.closeMenu();
      controller.highlight(node);
      controller.showInfo(node);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var controller = this.props.controller;
      var _this$state = this.state,
          open = _this$state.open,
          searchMatchNodes = _this$state.searchMatchNodes;
      var closed = !open;
      var searchResults = [];

      if (searchMatchNodes) {
        searchResults = searchMatchNodes.map(function (node) {
          return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div.menu-node-info', {
            onClick: function onClick() {
              return _this2.selectNode(node);
            }
          }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_3__["NodeInfo"], {
            node: node
          })]);
        });
      }

      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-parent'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu-toggle': true,
          'menu-open': open
        }),
        onClick: function onClick() {
          return controller.toggleMenu();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu': true,
          'menu-closed': closed
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'text',
        "class": 'menu-search',
        placeholder: 'Search',
        id: 'menu-search',
        onClick: function onClick() {
          return _this2.open();
        },
        onKeyDown: function onKeyDown() {
          return _this2.debouncedUpdateSearch();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-search-results',
        id: 'menu-search-results'
      }, searchResults)])]);
    }
  }]);

  return Menu;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (Menu);


/***/ }),

/***/ "./src/client/components/node-info.js":
/*!********************************************!*\
  !*** ./src/client/components/node-info.js ***!
  \********************************************/
/*! exports provided: default, NodeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodeInfo", function() { return NodeInfo; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var NodeInfo =
/*#__PURE__*/
function (_Component) {
  _inherits(NodeInfo, _Component);

  function NodeInfo(props) {
    _classCallCheck(this, NodeInfo);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeInfo).call(this, props));
  }

  _createClass(NodeInfo, [{
    key: "render",
    value: function render() {
      var node = this.props.node;
      var data = node.data();
      var family_name = data.family_name;
      var country = data.birth_country;
      var hasCountry = country != null;
      var url = data.reference;
      var race = data.race;
      var hasRace = race != null;
      var gender = data.gender;
      var name = data.name;
      var birthyr = data.birth_year;
      var deathyr = data.death_year;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-name'
      }, name), hasCountry ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-country'
      }, country) : null, hasRace ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-more'
      }, race) : null, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-more'
      }, gender), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-more'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('a', {
        target: '_blank',
        href: "".concat(url)
      }, 'More information')])]);
    }
  }]);

  return NodeInfo;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (NodeInfo);


/***/ }),

/***/ "./src/client/controller.js":
/*!**********************************!*\
  !*** ./src/client/controller.js ***!
  \**********************************/
/*! exports provided: default, Controller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller", function() { return Controller; });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.memoize */ "./node_modules/lodash.memoize/index.js");
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_memoize__WEBPACK_IMPORTED_MODULE_1__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var layoutPadding = 10;
var animationDuration = 500;
var easing = 'ease'; // search parameters

var minMetricValue = 0.25; // filter out nodes from search results if they have total scores lower than this

var minSimilarityValue = 0; // only include in total metric if the individual sim val is on [0.5, 1]

var delayPromise = function delayPromise(duration) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, duration);
  });
};

var getOrgPos = function getOrgPos(n) {
  return Object.assign({}, n.data('orgPos'));
};

var Controller =
/*#__PURE__*/
function () {
  function Controller(_ref) {
    var cy = _ref.cy;

    _classCallCheck(this, Controller);

    this.cy = cy;
    this.bus = new eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a();
    this.menu = false;
    this.nodes = cy.nodes();
    this.searchMatchNodes = cy.collection();
  }

  _createClass(Controller, [{
    key: "isMenuOpen",
    value: function isMenuOpen() {
      return this.menu;
    }
  }, {
    key: "openMenu",
    value: function openMenu() {
      this.menu = true;
      this.bus.emit('openMenu');
      this.bus.emit('toggleMenu', true);
    }
  }, {
    key: "closeMenu",
    value: function closeMenu() {
      this.menu = false;
      this.bus.emit('closeMenu');
      this.bus.emit('toggleMenu', false);
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.isMenuOpen()) {
        this.closeMenu();
      } else {
        this.openMenu();
      }
    }
  }, {
    key: "isInfoShown",
    value: function isInfoShown() {
      return this.infoNode != null;
    }
  }, {
    key: "showInfo",
    value: function showInfo(node) {
      this.infoNode = node;
      this.bus.emit('showInfo', node);
    }
  }, {
    key: "hideInfo",
    value: function hideInfo() {
      this.bus.emit('hideInfo', this.infoNode);
      this.infoNode = null;
    }
  }, {
    key: "hasHighlight",
    value: function hasHighlight() {
      return this.lastHighlighted != null;
    }
  }, {
    key: "highlight",
    value: function highlight(node) {
      var _this = this;

      var cy = this.cy;

      if (this.highlightInProgress) {
        return Promise.resolve();
      }

      this.highlightInProgress = true;
      var allEles = cy.elements();
      var nhood = this.lastHighlighted = node.closedNeighborhood();
      var others = this.lastUnhighlighted = allEles.not(nhood);

      var showOverview = function showOverview() {
        cy.batch(function () {
          allEles.removeClass('faded highlighted hidden');
          nhood.addClass('highlighted');
          others.addClass('hidden');
          others.positions(getOrgPos);
        });
        var layout = nhood.layout({
          //name: 'fcose',
          name: 'preset',
          positions: getOrgPos,
          fit: true,
          animate: true,
          animationDuration: animationDuration,
          animationEasing: easing,
          padding: layoutPadding
        });
        layout.run();
        return layout.promiseOn('layoutstop');
      };

      var runLayout = function runLayout() {
        var p = getOrgPos(node);
        var layout = nhood.layout({
          name: 'concentric',
          fit: true,
          animate: true,
          animationDuration: animationDuration,
          animationEasing: easing,
          boundingBox: {
            x1: p.x - 1,
            x2: p.x + 1,
            y1: p.y - 1,
            y2: p.y + 1
          },
          avoidOverlap: true,
          concentric: function concentric(ele) {
            if (ele.same(node)) {
              return 2;
            } else {
              return 1;
            }
          },
          levelWidth: function levelWidth() {
            return 1;
          },
          padding: layoutPadding
        });
        var promise = layout.promiseOn('layoutstop');
        layout.run();
        return promise;
      };

      var showOthersFaded = function showOthersFaded() {
        cy.batch(function () {
          others.removeClass('hidden').addClass('faded');
        });
      };

      this.bus.emit('highlight', node);
      return Promise.resolve().then(showOverview).then(function () {
        return delayPromise(animationDuration);
      }).then(runLayout).then(showOthersFaded).then(function () {
        _this.highlightInProgress = false;

        _this.bus.emit('highlightend', node);
      });
    }
  }, {
    key: "unhighlight",
    value: function unhighlight() {
      if (!this.hasHighlight()) {
        return Promise.resolve();
      }

      var cy = this.cy;
      var allEles = cy.elements();
      var allNodes = cy.nodes();
      cy.stop();
      allNodes.stop();
      var nhood = this.lastHighlighted;
      var others = this.lastUnhighlighted;
      this.lastHighlighted = this.lastUnhighlighted = null;

      var hideOthers = function hideOthers() {
        others.addClass('hidden');
        return Promise.resolve();
      };

      var resetClasses = function resetClasses() {
        cy.batch(function () {
          allEles.removeClass('hidden').removeClass('faded').removeClass('highlighted');
        });
        return Promise.resolve();
      };

      var animateToOrgPos = function animateToOrgPos(nhood) {
        return Promise.all(nhood.nodes().map(function (n) {
          return n.animation({
            position: getOrgPos(n),
            duration: animationDuration,
            easing: easing
          }).play().promise();
        }));
      };

      var restorePositions = function restorePositions() {
        cy.batch(function () {
          others.nodes().positions(getOrgPos);
        });
        return animateToOrgPos(nhood.nodes());
      };

      this.bus.emit('unhighlight');
      return Promise.resolve().then(hideOthers).then(restorePositions).then(resetClasses);
    }
  }, {
    key: "updateSearch",
    value: function updateSearch(queryString) {
      var _this2 = this;

      var normalize = function normalize(str) {
        return str.toLowerCase();
      };

      var getWords = function getWords(str) {
        return str.split(/\s+/);
      };

      var queryWords = getWords(normalize(queryString));

      var addWords = function addWords(wordList, wordsStr) {
        if (wordsStr) {
          wordList.push.apply(wordList, _toConsumableArray(getWords(normalize(wordsStr))));
        }
      };

      var cacheNodeWords = function cacheNodeWords(node) {
        var data = node.data();
        var wordList = [];
        addWords(wordList, data.name);
        addWords(wordList, data.Synonym);
        addWords(wordList, data.NodeTypeFormatted);
        addWords(wordList, data.Milk);
        addWords(wordList, data.Type);
        addWords(wordList, data.Country);
        node.data('words', wordList);
      };

      var getStringSimilarity = function getStringSimilarity(queryWord, nodeWord) {
        var index = nodeWord.indexOf(queryWord);

        if (index === 0) {
          var diff = Math.abs(nodeWord.length - queryWord.length);
          var maxLength = Math.max(nodeWord.length, queryWord.length);
          return 1 - diff / maxLength;
        } else {
          return 0;
        }
      };

      var getMetric = function getMetric(node, queryWords) {
        var nodeWords = node.data('words');
        var score = 0;

        for (var i = 0; i < nodeWords.length; i++) {
          var nodeWord = nodeWords[i];

          for (var j = 0; j < queryWords.length; j++) {
            var queryWord = queryWords[j];
            var similarity = getStringSimilarity(queryWord, nodeWord);

            if (similarity > minSimilarityValue) {
              score += similarity;
            }
          }
        }

        return score;
      };

      var getNodeMetric = lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default()(function (node) {
        return getMetric(node, queryWords);
      }, function (node) {
        return node.id();
      });

      if (!this.cachedNodeWords) {
        this.cy.batch(function () {
          _this2.nodes.forEach(cacheNodeWords);
        });
        this.cachedNodeWords = true;
      }

      this.searchMatchNodes = this.nodes.filter(function (node) {
        return getNodeMetric(node) > minMetricValue;
      }).sort(function (nodeA, nodeB) {
        return getNodeMetric(nodeB) - getNodeMetric(nodeA);
      });
      this.bus.emit('updateSearch', this.searchMatchNodes);
      return this.searchMatchNodes;
    }
  }, {
    key: "getSearchMatchNodes",
    value: function getSearchMatchNodes() {
      return this.searchMatchNodes;
    }
  }]);

  return Controller;
}();

/* harmony default export */ __webpack_exports__["default"] = (Controller);


/***/ }),

/***/ "./src/client/cy-conf/elements.js":
/*!****************************************!*\
  !*** ./src/client/cy-conf/elements.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var elements = {
  "nodes": [{
    "data": {
      "id": "56",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Roger Cotes",
      "birth_year": 1682,
      "given_name": "Roger",
      "death_year": 1716,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Roger_Cotes",
      "family_name": "Cotes",
      "gender": "male"
    },
    "position": {
      "x": 3365.278741636996,
      "y": 3751.33114068792
    },
    "selected": false
  }, {
    "data": {
      "id": "35",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Eugène Cahen",
      "birth_year": 1865,
      "given_name": "Eugène",
      "death_year": 1941,
      "birth_country": "France",
      "race": "white",
      "reference": "https://g.co/kgs/857QZo",
      "family_name": "Cahen",
      "gender": "male"
    },
    "position": {
      "x": 6024.404990459159,
      "y": 3455.886252913103
    },
    "selected": false
  }, {
    "data": {
      "id": "425",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Warren Weaver",
      "birth_year": 1894,
      "given_name": "Warren",
      "death_year": 1978,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Warren_Weaver",
      "family_name": "Weaver",
      "gender": "male"
    },
    "position": {
      "x": 2721.255695394,
      "y": 4191.298825296711
    },
    "selected": false
  }, {
    "data": {
      "id": "429",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jeffrey Weiss",
      "birth_year": "missing",
      "given_name": "Jeffrey",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "missing",
      "family_name": "Weiss",
      "gender": "male"
    },
    "position": {
      "x": 3671.825770847149,
      "y": 4979.894499406849
    },
    "selected": false
  }, {
    "data": {
      "id": "60",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Crank",
      "birth_year": 1916,
      "given_name": "John",
      "death_year": 2006,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Crank",
      "family_name": "Crank",
      "gender": "male"
    },
    "position": {
      "x": 2943.8674311828972,
      "y": 4736.750179339464
    },
    "selected": false
  }, {
    "data": {
      "id": "220",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Henri Lebesgue",
      "birth_year": 1875,
      "given_name": "Henri",
      "death_year": 1941,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Henri_Lebesgue",
      "family_name": "Lebesgue",
      "gender": "male"
    },
    "position": {
      "x": 3792.8668903686134,
      "y": 3713.782385257151
    },
    "selected": false
  }, {
    "data": {
      "id": "308",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Earle Phelps",
      "birth_year": 1976,
      "given_name": "Earle",
      "death_year": 1953,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Earle_B._Phelps",
      "family_name": "Phelps",
      "gender": "male"
    },
    "position": {
      "x": 1616.4718158902028,
      "y": 3236.5009219167596
    },
    "selected": false
  }, {
    "data": {
      "id": "67",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Wander de Haas",
      "birth_year": 1878,
      "given_name": "Wander",
      "death_year": 1960,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Wander_Johannes_de_Haas",
      "family_name": "de Haas",
      "gender": "male"
    },
    "position": {
      "x": 3360.106545363309,
      "y": 3647.1096435366217
    },
    "selected": false
  }, {
    "data": {
      "id": "215",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edmund Landau",
      "birth_year": 1877,
      "given_name": "Edmund",
      "death_year": 1938,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edmund_Landau",
      "family_name": "Landau",
      "gender": "male"
    },
    "position": {
      "x": 3900.6344955522586,
      "y": 4287.386151530702
    },
    "selected": false
  }, {
    "data": {
      "id": "73",
      "selected": false,
      "NodeType": "Cheese",
      "name": "René Descartes",
      "birth_year": 1596,
      "given_name": "René",
      "death_year": 1650,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/René_Descartes",
      "family_name": "Descartes",
      "gender": "male"
    },
    "position": {
      "x": 1340.765104674454,
      "y": 3365.636771846598
    },
    "selected": false
  }, {
    "data": {
      "id": "319",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Pólya",
      "birth_year": 1887,
      "given_name": "George",
      "death_year": 1985,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Pólya",
      "family_name": "Pólya",
      "gender": "male"
    },
    "position": {
      "x": 3859.7249799073566,
      "y": 3921.653865934317
    },
    "selected": false
  }, {
    "data": {
      "id": "251",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Grigory Margulis",
      "birth_year": 1946,
      "given_name": "Grigory",
      "death_year": "missing",
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Grigory_Margulis",
      "family_name": "Margulis",
      "gender": "male"
    },
    "position": {
      "x": 2971.0409273318937,
      "y": 3897.8314402316873
    },
    "selected": false
  }, {
    "data": {
      "id": "115",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Paul Gordan",
      "birth_year": 1837,
      "given_name": "Paul",
      "death_year": 1912,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paul_Gordan",
      "family_name": "Gordan",
      "gender": "male"
    },
    "position": {
      "x": 5834.686017850937,
      "y": 3879.2386968626834
    },
    "selected": false
  }, {
    "data": {
      "id": "112",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vitaly Ginzburg",
      "birth_year": 1916,
      "given_name": "Vitaly",
      "death_year": 2009,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vitaly_Ginzburg",
      "family_name": "Ginzburg",
      "gender": "male"
    },
    "position": {
      "x": 5303.550385526005,
      "y": 3679.938390160334
    },
    "selected": false
  }, {
    "data": {
      "id": "185",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Arthur Kennelly",
      "birth_year": 1861,
      "given_name": "Arthur",
      "death_year": 1939,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Arthur_E._Kennelly",
      "family_name": "Kennelly",
      "gender": "male"
    },
    "position": {
      "x": 2476.251090513709,
      "y": 3190.4854454120236
    },
    "selected": false
  }, {
    "data": {
      "id": "348",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Runge",
      "birth_year": 1856,
      "given_name": "Carl",
      "death_year": 1927,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carl_Runge",
      "family_name": "Runge",
      "gender": "male"
    },
    "position": {
      "x": 3205.1461200833533,
      "y": 4873.9515159300245
    },
    "selected": false
  }, {
    "data": {
      "id": "420",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Herbert Wagner",
      "birth_year": 1935,
      "given_name": "Herbert",
      "death_year": "missing",
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Herbert_Wagner_(physicist)",
      "family_name": "Wagner",
      "gender": "male"
    },
    "position": {
      "x": 4236.997710445983,
      "y": 4924.454705978524
    },
    "selected": false
  }, {
    "data": {
      "id": "404",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edward Teller",
      "birth_year": 1908,
      "given_name": "Edward",
      "death_year": 2003,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edward_Teller",
      "family_name": "Teller",
      "gender": "male"
    },
    "position": {
      "x": 5619.672726207095,
      "y": 4312.557810421491
    },
    "selected": false
  }, {
    "data": {
      "id": "365",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Frederick Seitz",
      "birth_year": 1911,
      "given_name": "Frederick",
      "death_year": 2008,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Frederick_Seitz",
      "family_name": "Seitz",
      "gender": "male"
    },
    "position": {
      "x": 6164.745559826353,
      "y": 3404.7129485989694
    },
    "selected": false
  }, {
    "data": {
      "id": "417",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Theodore von Kármán",
      "birth_year": 1881,
      "given_name": "Theodore",
      "death_year": 1963,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Theodore_von_Kármán",
      "family_name": "von Kármán",
      "gender": "male"
    },
    "position": {
      "x": 3368.783484833983,
      "y": 3389.9448878535536
    },
    "selected": false
  }, {
    "data": {
      "id": "333",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lord* Rayleigh",
      "birth_year": 1842,
      "given_name": "Lord*",
      "death_year": 1919,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_William_Strutt,_3rd_Baron_Rayleigh",
      "family_name": "Rayleigh",
      "gender": "male"
    },
    "position": {
      "x": 4806.589866347051,
      "y": 3193.3292316004768
    },
    "selected": false
  }, {
    "data": {
      "id": "86",
      "selected": false,
      "NodeType": "Cheese",
      "name": "missing Euclid",
      "birth_year": -350,
      "given_name": "missing",
      "death_year": -250,
      "birth_country": "Greece",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Euclid",
      "family_name": "Euclid",
      "gender": "male"
    },
    "position": {
      "x": 5763.180557061345,
      "y": 3537.918657510656
    },
    "selected": false
  }, {
    "data": {
      "id": "168",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Børge Jessen",
      "birth_year": 1907,
      "given_name": "Børge",
      "death_year": 1993,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Børge_Jessen",
      "family_name": "Jessen",
      "gender": "male"
    },
    "position": {
      "x": 3531.5543782183727,
      "y": 4375.208581520395
    },
    "selected": false
  }, {
    "data": {
      "id": "364",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Philipp Seidel",
      "birth_year": 1821,
      "given_name": "Philipp",
      "death_year": 1896,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Philipp_Ludwig_von_Seidel",
      "family_name": "Seidel",
      "gender": "male"
    },
    "position": {
      "x": 4138.120629851309,
      "y": 3470.575389757888
    },
    "selected": false
  }, {
    "data": {
      "id": "207",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ryogo Kubo",
      "birth_year": 1920,
      "given_name": "Ryogo",
      "death_year": 1995,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Ryogo_Kubo",
      "family_name": "Kubo",
      "gender": "male"
    },
    "position": {
      "x": 1975.1018242512805,
      "y": 2965.2348819701137
    },
    "selected": false
  }, {
    "data": {
      "id": "263",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Theodor Meyer",
      "birth_year": 1882,
      "given_name": "Theodor",
      "death_year": 1972,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Theodor_Meyer",
      "family_name": "Meyer",
      "gender": "male"
    },
    "position": {
      "x": 4088.113897598802,
      "y": 4437.73256928887
    },
    "selected": false
  }, {
    "data": {
      "id": "422",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Fugao Wang",
      "birth_year": "missing",
      "given_name": "Fugao",
      "death_year": "missing",
      "birth_country": "China",
      "race": "East Asian",
      "reference": "missing",
      "family_name": "Wang",
      "gender": "male"
    },
    "position": {
      "x": 5265.394853813044,
      "y": 2926.9106750534793
    },
    "selected": false
  }, {
    "data": {
      "id": "431",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Weiss",
      "birth_year": 1865,
      "given_name": "Pierre",
      "death_year": 1940,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Weiss",
      "family_name": "Weiss",
      "gender": "male"
    },
    "position": {
      "x": 6334.071908000686,
      "y": 3185.215125428446
    },
    "selected": false
  }, {
    "data": {
      "id": "242",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Lusztig",
      "birth_year": 1946,
      "given_name": "George",
      "death_year": "missing",
      "birth_country": "Romania",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Lusztig",
      "family_name": "Lusztig",
      "gender": "male"
    },
    "position": {
      "x": 3218.9691171958643,
      "y": 3851.869441872337
    },
    "selected": false
  }, {
    "data": {
      "id": "183",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lord* Kelvin",
      "birth_year": 1824,
      "given_name": "Lord*",
      "death_year": 1907,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_Thomson,_1st_Baron_Kelvin",
      "family_name": "Kelvin",
      "gender": "male"
    },
    "position": {
      "x": 3623.3730435908324,
      "y": 3338.2582484480954
    },
    "selected": false
  }, {
    "data": {
      "id": "376",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stephen Smale",
      "birth_year": 1930,
      "given_name": "Stephen",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Stephen_Smale",
      "family_name": "Smale",
      "gender": "male"
    },
    "position": {
      "x": 2249.728543152437,
      "y": 4119.648998577475
    },
    "selected": false
  }, {
    "data": {
      "id": "224",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Leibler",
      "birth_year": 1914,
      "given_name": "Richard",
      "death_year": 2003,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Leibler",
      "family_name": "Leibler",
      "gender": "male"
    },
    "position": {
      "x": 6256.914200829632,
      "y": 3950.9508313913466
    },
    "selected": false
  }, {
    "data": {
      "id": "177",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Theodor Kaluza",
      "birth_year": 1885,
      "given_name": "Theodor",
      "death_year": 1954,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Theodor_Kaluza",
      "family_name": "Kaluza",
      "gender": "male"
    },
    "position": {
      "x": 1953.797200936915,
      "y": 4130.775714460824
    },
    "selected": false
  }, {
    "data": {
      "id": "430",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Weiss",
      "birth_year": 1905,
      "given_name": "Joseph",
      "death_year": 1972,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Joshua_Weiss",
      "family_name": "Weiss",
      "gender": "male"
    },
    "position": {
      "x": 3258.4329536608766,
      "y": 3316.0300472098734
    },
    "selected": false
  }, {
    "data": {
      "id": "12",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Eugenio Beltrami",
      "birth_year": 1835,
      "given_name": "Eugenio",
      "death_year": 1900,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Eugenio_Beltrami",
      "family_name": "Beltrami",
      "gender": "male"
    },
    "position": {
      "x": 4058.653291284928,
      "y": 3037.528450642461
    },
    "selected": false
  }, {
    "data": {
      "id": "75",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean Dieudonné",
      "birth_year": 1906,
      "given_name": "Jean",
      "death_year": 1992,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean_Dieudonné",
      "family_name": "Dieudonné",
      "gender": "male"
    },
    "position": {
      "x": 3760.5267018233153,
      "y": 3640.5192440271285
    },
    "selected": false
  }, {
    "data": {
      "id": "23",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Bohm",
      "birth_year": 1917,
      "given_name": "David",
      "death_year": 1992,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Bohm",
      "family_name": "Bohm",
      "gender": "male"
    },
    "position": {
      "x": 2190.5971274076514,
      "y": 4267.027239786954
    },
    "selected": false
  }, {
    "data": {
      "id": "111",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Josiah Gibbs",
      "birth_year": 1839,
      "given_name": "Josiah",
      "death_year": 1903,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Josiah_Willard_Gibbs",
      "family_name": "Gibbs",
      "gender": "male"
    },
    "position": {
      "x": 3629.4427988684165,
      "y": 3123.33821245347
    },
    "selected": false
  }, {
    "data": {
      "id": "264",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leonor Michaelis",
      "birth_year": 1875,
      "given_name": "Leonor",
      "death_year": 1949,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Leonor_Michaelis",
      "family_name": "Michaelis",
      "gender": "male"
    },
    "position": {
      "x": 1663.2593750701203,
      "y": 3736.2160199654454
    },
    "selected": false
  }, {
    "data": {
      "id": "41",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Cartier",
      "birth_year": 1932,
      "given_name": "Pierre",
      "death_year": "missing",
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Cartier_(mathematician)",
      "family_name": "Cartier",
      "gender": "male"
    },
    "position": {
      "x": 3983.3190877102666,
      "y": 3617.872238903952
    },
    "selected": false
  }, {
    "data": {
      "id": "68",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Abraham de Moivre",
      "birth_year": 1667,
      "given_name": "Abraham",
      "death_year": 1754,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Abraham_de_Moivre",
      "family_name": "de Moivre",
      "gender": "male"
    },
    "position": {
      "x": 3887.751635607394,
      "y": 2969.71953861972
    },
    "selected": false
  }, {
    "data": {
      "id": "82",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Albert Einstein",
      "birth_year": 1879,
      "given_name": "Albert",
      "death_year": 1955,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Albert_Einstein",
      "family_name": "Einstein",
      "gender": "male"
    },
    "position": {
      "x": 3537.096857450252,
      "y": 3642.4967051531794
    },
    "selected": false
  }, {
    "data": {
      "id": "130",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gotthilf Hagen",
      "birth_year": 1797,
      "given_name": "Gotthilf",
      "death_year": 1884,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gotthilf_Hagen",
      "family_name": "Hagen",
      "gender": "male"
    },
    "position": {
      "x": 1992.498668207963,
      "y": 4432.854488733672
    },
    "selected": false
  }, {
    "data": {
      "id": "125",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ronald Gurney",
      "birth_year": 1898,
      "given_name": "Ronald",
      "death_year": 1953,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ronald_Wilfred_Gurney",
      "family_name": "Gurney",
      "gender": "male"
    },
    "position": {
      "x": 3133.4060602573713,
      "y": 3100.1304957203893
    },
    "selected": false
  }, {
    "data": {
      "id": "77",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Paul Dirac",
      "birth_year": 1902,
      "given_name": "Paul",
      "death_year": 1984,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paul_Dirac",
      "family_name": "Dirac",
      "gender": "male"
    },
    "position": {
      "x": 2396.5149777846814,
      "y": 3407.3347093598873
    },
    "selected": false
  }, {
    "data": {
      "id": "172",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pascual Jordan",
      "birth_year": 1902,
      "given_name": "Pascual",
      "death_year": 1980,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pascual_Jordan",
      "family_name": "Jordan",
      "gender": "male"
    },
    "position": {
      "x": 6167.842338301678,
      "y": 3356.828679376666
    },
    "selected": false
  }, {
    "data": {
      "id": "71",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Deligne",
      "birth_year": 1944,
      "given_name": "Pierre",
      "death_year": "missing",
      "birth_country": "Belgium",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Deligne",
      "family_name": "Deligne",
      "gender": "male"
    },
    "position": {
      "x": 3399.452587664697,
      "y": 3824.7792525532095
    },
    "selected": false
  }, {
    "data": {
      "id": "339",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Frigyes Riesz",
      "birth_year": 1880,
      "given_name": "Frigyes",
      "death_year": 1956,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Frigyes_Riesz",
      "family_name": "Riesz",
      "gender": "male"
    },
    "position": {
      "x": 5031.365341524368,
      "y": 3608.9675959999568
    },
    "selected": false
  }, {
    "data": {
      "id": "66",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Michele de Franchis",
      "birth_year": 1875,
      "given_name": "Michele",
      "death_year": 1946,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Michele_de_Franchis",
      "family_name": "de Franchis",
      "gender": "male"
    },
    "position": {
      "x": 3717.135652762518,
      "y": 3661.1470410842785
    },
    "selected": false
  }, {
    "data": {
      "id": "103",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Yakov Frenkel",
      "birth_year": 1894,
      "given_name": "Yakov",
      "death_year": 1952,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Yakov_Frenkel",
      "family_name": "Frenkel",
      "gender": "male"
    },
    "position": {
      "x": 5952.215553953558,
      "y": 3720.00183298808
    },
    "selected": false
  }, {
    "data": {
      "id": "280",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Albert Mullin",
      "birth_year": 1933,
      "given_name": "Albert",
      "death_year": 2017,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Albert_A._Mullin",
      "family_name": "Mullin",
      "gender": "male"
    },
    "position": {
      "x": 5763.920343964239,
      "y": 3515.316395323182
    },
    "selected": false
  }, {
    "data": {
      "id": "59",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Harald Cramér",
      "birth_year": 1893,
      "given_name": "Harald",
      "death_year": 1985,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Harald_Cramér",
      "family_name": "Cramér",
      "gender": "male"
    },
    "position": {
      "x": 4511.023389958733,
      "y": 4349.622176477469
    },
    "selected": false
  }, {
    "data": {
      "id": "208",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Solomon Kullback",
      "birth_year": 1907,
      "given_name": "Solomon",
      "death_year": 1994,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Solomon_Kullback",
      "family_name": "Kullback",
      "gender": "male"
    },
    "position": {
      "x": 6244.638323299778,
      "y": 3972.3040497917627
    },
    "selected": false
  }, {
    "data": {
      "id": "336",
      "selected": false,
      "NodeType": "Cheese",
      "name": "A Rhys",
      "birth_year": "missing",
      "given_name": "A",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Rhys",
      "gender": "missing"
    },
    "position": {
      "x": 3235.763537122815,
      "y": 3354.6985348989947
    },
    "selected": false
  }, {
    "data": {
      "id": "26",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Bernard Bolzano",
      "birth_year": 1781,
      "given_name": "Bernard",
      "death_year": 1848,
      "birth_country": "Bohemia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Bernard_Bolzano",
      "family_name": "Bolzano",
      "gender": "male"
    },
    "position": {
      "x": 3103.8246253379293,
      "y": 3450.6386519625694
    },
    "selected": false
  }, {
    "data": {
      "id": "211",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph-Louis Lagrange",
      "birth_year": 1736,
      "given_name": "Joseph-Louis",
      "death_year": 1813,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph-Louis_Lagrange",
      "family_name": "Lagrange",
      "gender": "male"
    },
    "position": {
      "x": 3519.311445833506,
      "y": 3809.2123280926644
    },
    "selected": false
  }, {
    "data": {
      "id": "343",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Rosser",
      "birth_year": 1907,
      "given_name": "John",
      "death_year": 1989,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/J._Barkley_Rosser",
      "family_name": "Rosser",
      "gender": "male"
    },
    "position": {
      "x": 2599.9068992671737,
      "y": 3904.99847081509
    },
    "selected": false
  }, {
    "data": {
      "id": "358",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walter Schottky",
      "birth_year": 1886,
      "given_name": "Walter",
      "death_year": 1976,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walter_H._Schottky",
      "family_name": "Schottky",
      "gender": "male"
    },
    "position": {
      "x": 3035.606009598082,
      "y": 3047.2655189450224
    },
    "selected": false
  }, {
    "data": {
      "id": "366",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Sekerka",
      "birth_year": 1937,
      "given_name": "Robert",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_Sekerka",
      "family_name": "Sekerka",
      "gender": "male"
    },
    "position": {
      "x": 2466.3628768038407,
      "y": 3536.198836871069
    },
    "selected": false
  }, {
    "data": {
      "id": "127",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Haag",
      "birth_year": 1922,
      "given_name": "Rudolf",
      "death_year": 2016,
      "birth_country": "Fermany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolf_Haag",
      "family_name": "Haag",
      "gender": "male"
    },
    "position": {
      "x": 2574.68198622171,
      "y": 3473.237951822792
    },
    "selected": false
  }, {
    "data": {
      "id": "116",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walter Gordon",
      "birth_year": 1893,
      "given_name": "Walter",
      "death_year": 1939,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walter_Gordon_(physicist)",
      "family_name": "Gordon",
      "gender": "male"
    },
    "position": {
      "x": 2019.1983794547145,
      "y": 4170.791275906453
    },
    "selected": false
  }, {
    "data": {
      "id": "100",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Thomas Fox",
      "birth_year": "missing",
      "given_name": "Thomas",
      "death_year": 1978,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://physicstoday.scitation.org/doi/pdf/10.1063/1.2995006",
      "family_name": "Fox",
      "gender": "male"
    },
    "position": {
      "x": 4915.545292766853,
      "y": 2907.6247635336927
    },
    "selected": false
  }, {
    "data": {
      "id": "414",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ivan Vinogradov",
      "birth_year": 1891,
      "given_name": "Ivan",
      "death_year": 1983,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ivan_Vinogradov",
      "family_name": "Vinogradov",
      "gender": "male"
    },
    "position": {
      "x": 3949.3930373469148,
      "y": 3941.447946482688
    },
    "selected": false
  }, {
    "data": {
      "id": "79",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vladimir Drinefeld",
      "birth_year": 1954,
      "given_name": "Vladimir",
      "death_year": "missing",
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vladimir_Drinfeld",
      "family_name": "Drinefeld",
      "gender": "male"
    },
    "position": {
      "x": 3977.1735369016583,
      "y": 3591.054870769156
    },
    "selected": false
  }, {
    "data": {
      "id": "230",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ernst Lindelöf",
      "birth_year": 1870,
      "given_name": "Ernst",
      "death_year": 1946,
      "birth_country": "Finland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ernst_Leonard_Lindelöf",
      "family_name": "Lindelöf",
      "gender": "male"
    },
    "position": {
      "x": 2586.88264852242,
      "y": 3567.229296932101
    },
    "selected": false
  }, {
    "data": {
      "id": "279",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Mervin Muller",
      "birth_year": 1928,
      "given_name": "Mervin",
      "death_year": 2018,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Mervin_E._Muller",
      "family_name": "Muller",
      "gender": "male"
    },
    "position": {
      "x": 4165.263114711615,
      "y": 4652.252905219453
    },
    "selected": false
  }, {
    "data": {
      "id": "195",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ellis Kolchin",
      "birth_year": 1916,
      "given_name": "Ellis",
      "death_year": 1991,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ellis_Kolchin",
      "family_name": "Kolchin",
      "gender": "male"
    },
    "position": {
      "x": 2256.135254572114,
      "y": 4241.279890336364
    },
    "selected": false
  }, {
    "data": {
      "id": "374",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Slater",
      "birth_year": 1900,
      "given_name": "John",
      "death_year": 1976,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_C._Slater",
      "family_name": "Slater",
      "gender": "male"
    },
    "position": {
      "x": 3390.67819913404,
      "y": 3002.726580342131
    },
    "selected": false
  }, {
    "data": {
      "id": "141",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walter Heitler",
      "birth_year": 1904,
      "given_name": "Walter",
      "death_year": 1981,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walter_Heitler",
      "family_name": "Heitler",
      "gender": "male"
    },
    "position": {
      "x": 6403.897789308589,
      "y": 3712.9336429370933
    },
    "selected": false
  }, {
    "data": {
      "id": "278",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Shigeru Mukai",
      "birth_year": 1953,
      "given_name": "Shigeru",
      "death_year": "missing",
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Shigeru_Mukai",
      "family_name": "Mukai",
      "gender": "male"
    },
    "position": {
      "x": 3193.7855340524875,
      "y": 3954.863230588282
    },
    "selected": false
  }, {
    "data": {
      "id": "388",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Otto Stern",
      "birth_year": 1888,
      "given_name": "Otto",
      "death_year": 1969,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Otto_Stern",
      "family_name": "Stern",
      "gender": "male"
    },
    "position": {
      "x": 5465.666918562806,
      "y": 4200.799569288682
    },
    "selected": false
  }, {
    "data": {
      "id": "135",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Douglas Hartree",
      "birth_year": 1897,
      "given_name": "Douglas",
      "death_year": 1958,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Douglas_Hartree",
      "family_name": "Hartree",
      "gender": "male"
    },
    "position": {
      "x": 1996.5525663892647,
      "y": 3990.325069527067
    },
    "selected": false
  }, {
    "data": {
      "id": "389",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Thomas Stieltjes",
      "birth_year": 1856,
      "given_name": "Thomas",
      "death_year": 1894,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Thomas_Joannes_Stieltjes",
      "family_name": "Stieltjes",
      "gender": "male"
    },
    "position": {
      "x": 3802.562980746501,
      "y": 3674.8651108879603
    },
    "selected": false
  }, {
    "data": {
      "id": "138",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stephen Hawking",
      "birth_year": 1942,
      "given_name": "Stephen",
      "death_year": 2018,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Stephen_Hawking",
      "family_name": "Hawking",
      "gender": "male"
    },
    "position": {
      "x": 3451.8780267309216,
      "y": 4567.685104890963
    },
    "selected": false
  }, {
    "data": {
      "id": "222",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Adrien-Marie Legendre",
      "birth_year": 1752,
      "given_name": "Adrien-Marie",
      "death_year": 1833,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Adrien-Marie_Legendre",
      "family_name": "Legendre",
      "gender": "male"
    },
    "position": {
      "x": 4142.081519193099,
      "y": 3451.948403901434
    },
    "selected": false
  }, {
    "data": {
      "id": "107",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Gauss",
      "birth_year": 1777,
      "given_name": "Carl",
      "death_year": 1855,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carl_Friedrich_Gauss",
      "family_name": "Gauss",
      "gender": "male"
    },
    "position": {
      "x": 4078.1781245399907,
      "y": 3499.951391119693
    },
    "selected": false
  }, {
    "data": {
      "id": "46",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Eduard Čech",
      "birth_year": 1893,
      "given_name": "Eduard",
      "death_year": 1960,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Eduard_Čech",
      "family_name": "Čech",
      "gender": "male"
    },
    "position": {
      "x": 2807.652272982339,
      "y": 3416.6128055228646
    },
    "selected": false
  }, {
    "data": {
      "id": "276",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Nevill Mott",
      "birth_year": 1905,
      "given_name": "Nevill",
      "death_year": 1996,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Nevill_Francis_Mott",
      "family_name": "Mott",
      "gender": "male"
    },
    "position": {
      "x": 3080.918872594914,
      "y": 3032.1785988077636
    },
    "selected": false
  }, {
    "data": {
      "id": "295",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Susumu Okubo",
      "birth_year": 1930,
      "given_name": "Susumu",
      "death_year": 2015,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Susumu_Okubo",
      "family_name": "Okubo",
      "gender": "male"
    },
    "position": {
      "x": 5224.538430092593,
      "y": 2691.867933589003
    },
    "selected": false
  }, {
    "data": {
      "id": "57",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Maurice Couette",
      "birth_year": 1858,
      "given_name": "Maurice",
      "death_year": 1943,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Maurice_Couette",
      "family_name": "Couette",
      "gender": "male"
    },
    "position": {
      "x": 4593.127106507129,
      "y": 3059.6767405060123
    },
    "selected": false
  }, {
    "data": {
      "id": "381",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Arnold Sommerfeld",
      "birth_year": 1868,
      "given_name": "Arnold",
      "death_year": 1951,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Arnold_Sommerfeld",
      "family_name": "Sommerfeld",
      "gender": "male"
    },
    "position": {
      "x": 4471.637806688894,
      "y": 3652.883951101171
    },
    "selected": false
  }, {
    "data": {
      "id": "152",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Hollomon",
      "birth_year": 1919,
      "given_name": "John",
      "death_year": 1985,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Herbert_Hollomon_Jr.",
      "family_name": "Hollomon",
      "gender": "male"
    },
    "position": {
      "x": 4777.000638507506,
      "y": 3684.178516154606
    },
    "selected": false
  }, {
    "data": {
      "id": "247",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ioel Malkin",
      "birth_year": 1907,
      "given_name": "Ioel",
      "death_year": 1958,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://g.co/kgs/LQNFK9",
      "family_name": "Malkin",
      "gender": "male"
    },
    "position": {
      "x": 4108.562534631979,
      "y": 3888.6084850558473
    },
    "selected": false
  }, {
    "data": {
      "id": "170",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lowell Jones",
      "birth_year": 1945,
      "given_name": "Lowell",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lowell_E._Jones",
      "family_name": "Jones",
      "gender": "male"
    },
    "position": {
      "x": 5543.01611220485,
      "y": 4029.6703305116102
    },
    "selected": false
  }, {
    "data": {
      "id": "397",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jacques Sturm",
      "birth_year": 1803,
      "given_name": "Jacques",
      "death_year": 1855,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jacques_Charles_François_Sturm",
      "family_name": "Sturm",
      "gender": "male"
    },
    "position": {
      "x": 3754.9935279519127,
      "y": 3562.0327162350286
    },
    "selected": false
  }, {
    "data": {
      "id": "129",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jacques Hadamard",
      "birth_year": 1865,
      "given_name": "Jacques",
      "death_year": 1963,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jacques_Hadamard",
      "family_name": "Hadamard",
      "gender": "male"
    },
    "position": {
      "x": 3724.171807990997,
      "y": 3612.767190676668
    },
    "selected": false
  }, {
    "data": {
      "id": "238",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Fritz London",
      "birth_year": 1900,
      "given_name": "Fritz",
      "death_year": 1954,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Fritz_London",
      "family_name": "London",
      "gender": "male"
    },
    "position": {
      "x": 6467.402013892695,
      "y": 3716.23697642923
    },
    "selected": false
  }, {
    "data": {
      "id": "250",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Max Margules",
      "birth_year": 1856,
      "given_name": "Max",
      "death_year": 1920,
      "birth_country": "Austrian Empire",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Max_Margules",
      "family_name": "Margules",
      "gender": "male"
    },
    "position": {
      "x": 3640.929717934578,
      "y": 3193.7196574818618
    },
    "selected": false
  }, {
    "data": {
      "id": "78",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Monroe Donsker",
      "birth_year": 1924,
      "given_name": "Monroe",
      "death_year": 1991,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Monroe_D._Donsker",
      "family_name": "Donsker",
      "gender": "male"
    },
    "position": {
      "x": 5482.665803159184,
      "y": 4427.957086719488
    },
    "selected": false
  }, {
    "data": {
      "id": "438",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Erich Wohlfarth",
      "birth_year": 1924,
      "given_name": "Erich",
      "death_year": 1988,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Erich_Peter_Wohlfarth",
      "family_name": "Wohlfarth",
      "gender": "male"
    },
    "position": {
      "x": 1715.9199895415697,
      "y": 3570.179840203561
    },
    "selected": false
  }, {
    "data": {
      "id": "133",
      "selected": false,
      "NodeType": "Cheese",
      "name": "James Hartle",
      "birth_year": 1939,
      "given_name": "James",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/James_Hartle",
      "family_name": "Hartle",
      "gender": "male"
    },
    "position": {
      "x": 3424.2511130393873,
      "y": 4603.103495958696
    },
    "selected": false
  }, {
    "data": {
      "id": "72",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Arnaud Denjoy",
      "birth_year": 1884,
      "given_name": "Arnaud",
      "death_year": 1974,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Arnaud_Denjoy",
      "family_name": "Denjoy",
      "gender": "male"
    },
    "position": {
      "x": 4961.344018994817,
      "y": 3614.933984698407
    },
    "selected": false
  }, {
    "data": {
      "id": "258",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Karl Menger",
      "birth_year": 1902,
      "given_name": "Karl",
      "death_year": 1985,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Karl_Menger",
      "family_name": "Menger",
      "gender": "male"
    },
    "position": {
      "x": 4328.011972827675,
      "y": 3086.5304925527435
    },
    "selected": false
  }, {
    "data": {
      "id": "436",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Eugene Wigner",
      "birth_year": 1902,
      "given_name": "Eugene",
      "death_year": 1995,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Eugene_Wigner",
      "family_name": "Wigner",
      "gender": "male"
    },
    "position": {
      "x": 6143.673940631487,
      "y": 3380.9567118859222
    },
    "selected": false
  }, {
    "data": {
      "id": "184",
      "selected": false,
      "NodeType": "Cheese",
      "name": "PC Kendall",
      "birth_year": "missing",
      "given_name": "PC",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Kendall",
      "gender": "missing"
    },
    "position": {
      "x": 4417.441611931714,
      "y": 4444.237421089019
    },
    "selected": false
  }, {
    "data": {
      "id": "252",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gisiro Maruyama",
      "birth_year": 1916,
      "given_name": "Gisiro",
      "death_year": 1986,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Gisiro_Maruyama",
      "family_name": "Maruyama",
      "gender": "male"
    },
    "position": {
      "x": 3404.556753496606,
      "y": 3790.3442062319846
    },
    "selected": false
  }, {
    "data": {
      "id": "1",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Niels Abel",
      "birth_year": 1802,
      "given_name": "Niels",
      "death_year": 1829,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Niels_Henrik_Abel",
      "family_name": "Abel",
      "gender": "male"
    },
    "position": {
      "x": 4389.899344762265,
      "y": 3332.9902177742115
    },
    "selected": false
  }, {
    "data": {
      "id": "137",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Wilfred Hastings",
      "birth_year": 1930,
      "given_name": "Wilfred",
      "death_year": 2016,
      "birth_country": "Canada",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/W._K._Hastings",
      "family_name": "Hastings",
      "gender": "male"
    },
    "position": {
      "x": 2182.0684120444303,
      "y": 4334.225533719138
    },
    "selected": false
  }, {
    "data": {
      "id": "22",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Blackwell",
      "birth_year": 1919,
      "given_name": "David",
      "death_year": 2010,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Blackwell",
      "family_name": "Blackwell",
      "gender": "male"
    },
    "position": {
      "x": 4346.005150378704,
      "y": 4416.538779693834
    },
    "selected": false
  }, {
    "data": {
      "id": "154",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Hoover",
      "birth_year": 1936,
      "given_name": "William",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "http://williamhoover.info",
      "family_name": "Hoover",
      "gender": "male"
    },
    "position": {
      "x": 6182.683797990524,
      "y": 4142.046011226495
    },
    "selected": false
  }, {
    "data": {
      "id": "313",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Max Planck",
      "birth_year": 1858,
      "given_name": "Max",
      "death_year": 1947,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Max_Planck",
      "family_name": "Planck",
      "gender": "male"
    },
    "position": {
      "x": 3202.36452998842,
      "y": 3604.999490625491
    },
    "selected": false
  }, {
    "data": {
      "id": "435",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Norbert Wiener",
      "birth_year": 1894,
      "given_name": "Norbert",
      "death_year": 1964,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Norbert_Wiener",
      "family_name": "Wiener",
      "gender": "male"
    },
    "position": {
      "x": 3656.6983265535764,
      "y": 4247.615421274569
    },
    "selected": false
  }, {
    "data": {
      "id": "427",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Karl Weierstrass",
      "birth_year": 1815,
      "given_name": "Karl",
      "death_year": 1897,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Karl_Weierstrass",
      "family_name": "Weierstrass",
      "gender": "male"
    },
    "position": {
      "x": 3210.70557417712,
      "y": 3476.8665345528943
    },
    "selected": false
  }, {
    "data": {
      "id": "391",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Stokes",
      "birth_year": 1819,
      "given_name": "George",
      "death_year": 1903,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sir_George_Stokes,_1st_Baronet",
      "family_name": "Stokes",
      "gender": "male"
    },
    "position": {
      "x": 3579.050606200509,
      "y": 3480.9462127105608
    },
    "selected": false
  }, {
    "data": {
      "id": "237",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Greta Ljung",
      "birth_year": 1941,
      "given_name": "Greta",
      "death_year": "missing",
      "birth_country": "Finland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Greta_M._Ljung",
      "family_name": "Ljung",
      "gender": "female"
    },
    "position": {
      "x": 4108.346435521815,
      "y": 4663.6181643186865
    },
    "selected": false
  }, {
    "data": {
      "id": "206",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alexander Kronrod",
      "birth_year": 1921,
      "given_name": "Alexander",
      "death_year": 1986,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Alexander_Kronrod",
      "family_name": "Kronrod",
      "gender": "male"
    },
    "position": {
      "x": 4093.7661129816697,
      "y": 3451.874672118103
    },
    "selected": false
  }, {
    "data": {
      "id": "288",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Isaac Newton",
      "birth_year": 1642,
      "given_name": "Isaac",
      "death_year": 1727,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Isaac_Newton#cite_note-OSNS-2",
      "family_name": "Newton",
      "gender": "male"
    },
    "position": {
      "x": 3446.3573824267755,
      "y": 3715.1665259134265
    },
    "selected": false
  }, {
    "data": {
      "id": "270",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Oskar Morgenstern",
      "birth_year": 1902,
      "given_name": "Oskar",
      "death_year": 1977,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Oskar_Morgenstern",
      "family_name": "Morgenstern",
      "gender": "male"
    },
    "position": {
      "x": 2499.994341232178,
      "y": 3401.172049049442
    },
    "selected": false
  }, {
    "data": {
      "id": "354",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Félix Savart",
      "birth_year": 1791,
      "given_name": "Félix",
      "death_year": 1841,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Félix_Savart",
      "family_name": "Savart",
      "gender": "male"
    },
    "position": {
      "x": 1400.0325541832324,
      "y": 3864.421120757288
    },
    "selected": false
  }, {
    "data": {
      "id": "299",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stephen Oxford",
      "birth_year": "missing",
      "given_name": "Stephen",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Oxford",
      "gender": "missing"
    },
    "position": {
      "x": 5487.4932076032865,
      "y": 2892.417897238265
    },
    "selected": false
  }, {
    "data": {
      "id": "33",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Brunn",
      "birth_year": 1862,
      "given_name": "Hermann",
      "death_year": 1939,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Brunn",
      "family_name": "Brunn",
      "gender": "male"
    },
    "position": {
      "x": 4374.1509423499265,
      "y": 3673.099740697836
    },
    "selected": false
  }, {
    "data": {
      "id": "345",
      "selected": false,
      "NodeType": "Cheese",
      "name": "S.N. Ruddlesden",
      "birth_year": "missing",
      "given_name": "S.N.",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Ruddlesden",
      "gender": "missing"
    },
    "position": {
      "x": 4934.054172128211,
      "y": 4729.693807518202
    },
    "selected": false
  }, {
    "data": {
      "id": "40",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Élie Cartan",
      "birth_year": 1869,
      "given_name": "Élie",
      "death_year": 1951,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Élie_Cartan",
      "family_name": "Cartan",
      "gender": "male"
    },
    "position": {
      "x": 3605.7413312265135,
      "y": 3667.454322650519
    },
    "selected": false
  }, {
    "data": {
      "id": "400",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gábor Szegö",
      "birth_year": 1895,
      "given_name": "Gábor",
      "death_year": 1985,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gábor_Szegő",
      "family_name": "Szegö",
      "gender": "male"
    },
    "position": {
      "x": 3964.5993703737604,
      "y": 4036.9155567342877
    },
    "selected": false
  }, {
    "data": {
      "id": "113",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sydney Goldstein",
      "birth_year": 1903,
      "given_name": "Sydney",
      "death_year": 1989,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sydney_Goldstein",
      "family_name": "Goldstein",
      "gender": "male"
    },
    "position": {
      "x": 4625.515411117692,
      "y": 3063.8492541808837
    },
    "selected": false
  }, {
    "data": {
      "id": "231",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ferdinand Lindemann",
      "birth_year": 1852,
      "given_name": "Ferdinand",
      "death_year": 1939,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ferdinand_von_Lindemann",
      "family_name": "Lindemann",
      "gender": "male"
    },
    "position": {
      "x": 3575.959053111157,
      "y": 3523.5877360507284
    },
    "selected": false
  }, {
    "data": {
      "id": "432",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Weyl",
      "birth_year": 1885,
      "given_name": "Hermann",
      "death_year": 1955,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Weyl",
      "family_name": "Weyl",
      "gender": "male"
    },
    "position": {
      "x": 1692.371342352676,
      "y": 3006.588424517725
    },
    "selected": false
  }, {
    "data": {
      "id": "245",
      "selected": false,
      "NodeType": "Cheese",
      "name": "S. Machlup",
      "birth_year": 1927,
      "given_name": "S.",
      "death_year": 2008,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://www.bems.org/node/190",
      "family_name": "Machlup",
      "gender": "male"
    },
    "position": {
      "x": 1363.5479781592237,
      "y": 3782.6868236427013
    },
    "selected": false
  }, {
    "data": {
      "id": "254",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Varghese Mathai",
      "birth_year": "missing",
      "given_name": "Varghese",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "South Asian",
      "reference": "missing",
      "family_name": "Mathai",
      "gender": "male"
    },
    "position": {
      "x": 5412.527812238202,
      "y": 3797.243860833427
    },
    "selected": false
  }, {
    "data": {
      "id": "283",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Frank Nabarro",
      "birth_year": 1916,
      "given_name": "Frank",
      "death_year": 2006,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Frank_Nabarro",
      "family_name": "Nabarro",
      "gender": "male"
    },
    "position": {
      "x": 2124.068447017927,
      "y": 3686.311736837153
    },
    "selected": false
  }, {
    "data": {
      "id": "165",
      "selected": false,
      "NodeType": "Cheese",
      "name": "James Jeans",
      "birth_year": 1877,
      "given_name": "James",
      "death_year": 1946,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/James_Jeans",
      "family_name": "Jeans",
      "gender": "male"
    },
    "position": {
      "x": 4840.507547091546,
      "y": 3144.8835019168087
    },
    "selected": false
  }, {
    "data": {
      "id": "309",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Melba Philips",
      "birth_year": 1907,
      "given_name": "Melba",
      "death_year": 2004,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Melba_Phillips",
      "family_name": "Philips",
      "gender": "female"
    },
    "position": {
      "x": 3175.090739089742,
      "y": 3377.0544066595317
    },
    "selected": false
  }, {
    "data": {
      "id": "142",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans Hellmann",
      "birth_year": 1903,
      "given_name": "Hans",
      "death_year": 1938,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hans_Hellmann",
      "family_name": "Hellmann",
      "gender": "male"
    },
    "position": {
      "x": 2199.3614649846354,
      "y": 3099.0068245063203
    },
    "selected": false
  }, {
    "data": {
      "id": "416",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vito Volterra",
      "birth_year": 1860,
      "given_name": "Vito",
      "death_year": 1940,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vito_Volterra",
      "family_name": "Volterra",
      "gender": "male"
    },
    "position": {
      "x": 3462.6111376293925,
      "y": 3911.162761244378
    },
    "selected": false
  }, {
    "data": {
      "id": "5",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Michael Atiyah",
      "birth_year": 1929,
      "given_name": "Michael",
      "death_year": 2019,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Michael_Atiyah",
      "family_name": "Atiyah",
      "gender": "male"
    },
    "position": {
      "x": 1984.4474005909644,
      "y": 3335.6295344621394
    },
    "selected": false
  }, {
    "data": {
      "id": "55",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edward Condon",
      "birth_year": 1902,
      "given_name": "Edward",
      "death_year": 1974,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edward_Condon",
      "family_name": "Condon",
      "gender": "male"
    },
    "position": {
      "x": 3561.360710512283,
      "y": 2970.404526146242
    },
    "selected": false
  }, {
    "data": {
      "id": "114",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jeffrey Goldstone",
      "birth_year": 1933,
      "given_name": "Jeffrey",
      "death_year": "missing",
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jeffrey_Goldstone",
      "family_name": "Goldstone",
      "gender": "male"
    },
    "position": {
      "x": 2740.0933218688474,
      "y": 4621.081625748164
    },
    "selected": false
  }, {
    "data": {
      "id": "265",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Mills",
      "birth_year": 1927,
      "given_name": "Robert",
      "death_year": 1999,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_Mills_(physicist)",
      "family_name": "Mills",
      "gender": "male"
    },
    "position": {
      "x": 5238.523337204606,
      "y": 3800.5801285977022
    },
    "selected": false
  }, {
    "data": {
      "id": "325",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Proudman",
      "birth_year": 1888,
      "given_name": "Joseph",
      "death_year": 1975,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Proudman",
      "family_name": "Proudman",
      "gender": "male"
    },
    "position": {
      "x": 4604.4208517186935,
      "y": 3044.278672472058
    },
    "selected": false
  }, {
    "data": {
      "id": "136",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Helmut Hasse",
      "birth_year": 1898,
      "given_name": "Helmut",
      "death_year": 1979,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Helmut_Hasse",
      "family_name": "Hasse",
      "gender": "male"
    },
    "position": {
      "x": 4398.843997989197,
      "y": 3654.9410652954757
    },
    "selected": false
  }, {
    "data": {
      "id": "117",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Tetsuo Goto",
      "birth_year": "missing",
      "given_name": "Tetsuo",
      "death_year": "missing",
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "missing",
      "family_name": "Goto",
      "gender": "male"
    },
    "position": {
      "x": 2819.965195568172,
      "y": 4541.89336794793
    },
    "selected": false
  }, {
    "data": {
      "id": "45",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Arthur Cayley",
      "birth_year": 1821,
      "given_name": "Arthur",
      "death_year": 1895,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Arthur_Cayley",
      "family_name": "Cayley",
      "gender": "male"
    },
    "position": {
      "x": 4305.833015393377,
      "y": 3140.928972197539
    },
    "selected": false
  }, {
    "data": {
      "id": "145",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Conyers Herring",
      "birth_year": 1914,
      "given_name": "Conyers",
      "death_year": 2009,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Conyers_Herring",
      "family_name": "Herring",
      "gender": "male"
    },
    "position": {
      "x": 2199.724276521699,
      "y": 3671.0966950561356
    },
    "selected": false
  }, {
    "data": {
      "id": "418",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard von Mises",
      "birth_year": 1883,
      "given_name": "Richard",
      "death_year": 1953,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_von_Mises",
      "family_name": "von Mises",
      "gender": "male"
    },
    "position": {
      "x": 4632.003274278832,
      "y": 4384.4923324015
    },
    "selected": false
  }, {
    "data": {
      "id": "444",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stanisław Zaremba",
      "birth_year": 1863,
      "given_name": "Stanisław",
      "death_year": 1942,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Stanisław_Zaremba_(mathematician)",
      "family_name": "Zaremba",
      "gender": "male"
    },
    "position": {
      "x": 4651.046440730176,
      "y": 3662.6380151734957
    },
    "selected": false
  }, {
    "data": {
      "id": "282",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Mumford",
      "birth_year": 1937,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Mumford",
      "family_name": "Mumford",
      "gender": "male"
    },
    "position": {
      "x": 3672.0540119813218,
      "y": 3739.9359494595838
    },
    "selected": false
  }, {
    "data": {
      "id": "275",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Andrzej Mostowski",
      "birth_year": 1913,
      "given_name": "Andrzej",
      "death_year": 1975,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Andrzej_Mostowski",
      "family_name": "Mostowski",
      "gender": "male"
    },
    "position": {
      "x": 2545.417321960187,
      "y": 3890.824536726203
    },
    "selected": false
  }, {
    "data": {
      "id": "337",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Richtmyer",
      "birth_year": 1910,
      "given_name": "Robert",
      "death_year": 2003,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_D._Richtmyer",
      "family_name": "Richtmyer",
      "gender": "male"
    },
    "position": {
      "x": 2083.633192764003,
      "y": 3623.49059553178
    },
    "selected": false
  }, {
    "data": {
      "id": "342",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leonard Rogers",
      "birth_year": 1862,
      "given_name": "Leonard",
      "death_year": 1933,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Leonard_James_Rogers",
      "family_name": "Rogers",
      "gender": "male"
    },
    "position": {
      "x": 3977.651539312081,
      "y": 4157.735864188322
    },
    "selected": false
  }, {
    "data": {
      "id": "393",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edmund Stoner",
      "birth_year": 1899,
      "given_name": "Edmund",
      "death_year": 1968,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edmund_Clifton_Stoner",
      "family_name": "Stoner",
      "gender": "male"
    },
    "position": {
      "x": 1617.802366728876,
      "y": 3562.7627833584693
    },
    "selected": false
  }, {
    "data": {
      "id": "363",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Graeme Segal",
      "birth_year": 1941,
      "given_name": "Graeme",
      "death_year": "missing",
      "birth_country": "Australia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Graeme_Segal",
      "family_name": "Segal",
      "gender": "male"
    },
    "position": {
      "x": 1905.6242046742673,
      "y": 3324.4319342915164
    },
    "selected": false
  }, {
    "data": {
      "id": "378",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Marian Smoluchowski",
      "birth_year": 1872,
      "given_name": "Marian",
      "death_year": 1917,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Marian_Smoluchowski",
      "family_name": "Smoluchowski",
      "gender": "male"
    },
    "position": {
      "x": 3450.430776949642,
      "y": 3649.8765661590983
    },
    "selected": false
  }, {
    "data": {
      "id": "351",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edwin Salpeter",
      "birth_year": 1924,
      "given_name": "Edwin",
      "death_year": 2008,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edwin_Ernest_Salpeter",
      "family_name": "Salpeter",
      "gender": "male"
    },
    "position": {
      "x": 3163.012212858821,
      "y": 2917.113664573413
    },
    "selected": false
  }, {
    "data": {
      "id": "158",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Kun Huang",
      "birth_year": 1919,
      "given_name": "Kun",
      "death_year": 2005,
      "birth_country": "China",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Huang_Kun",
      "family_name": "Huang",
      "gender": "male"
    },
    "position": {
      "x": 3303.2898296566636,
      "y": 3401.5577100043174
    },
    "selected": false
  }, {
    "data": {
      "id": "218",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Irving Langmuir",
      "birth_year": 1881,
      "given_name": "Irving",
      "death_year": 1957,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Irving_Langmuir",
      "family_name": "Langmuir",
      "gender": "male"
    },
    "position": {
      "x": 4167.011420892406,
      "y": 2973.0981681986023
    },
    "selected": false
  }, {
    "data": {
      "id": "176",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Erich Kähler",
      "birth_year": 1906,
      "given_name": "Erich",
      "death_year": 2000,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Erich_Kähler",
      "family_name": "Kähler",
      "gender": "male"
    },
    "position": {
      "x": 3546.934008049736,
      "y": 3658.3580124576492
    },
    "selected": false
  }, {
    "data": {
      "id": "437",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Aurel Wintner",
      "birth_year": 1903,
      "given_name": "Aurel",
      "death_year": 1958,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Aurel_Wintner",
      "family_name": "Wintner",
      "gender": "male"
    },
    "position": {
      "x": 3585.1155640330967,
      "y": 4322.1918914795515
    },
    "selected": false
  }, {
    "data": {
      "id": "28",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Max Born",
      "birth_year": 1882,
      "given_name": "Max",
      "death_year": 1970,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Max_Born",
      "family_name": "Born",
      "gender": "male"
    },
    "position": {
      "x": 3380.5083305829985,
      "y": 3465.2663600400656
    },
    "selected": false
  }, {
    "data": {
      "id": "148",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edmund Hlawka",
      "birth_year": 1916,
      "given_name": "Edmund",
      "death_year": 2009,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Edmund_Hlawka",
      "family_name": "Hlawka",
      "gender": "male"
    },
    "position": {
      "x": 4556.875623850552,
      "y": 3651.1682462416065
    },
    "selected": false
  }, {
    "data": {
      "id": "92",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Franz Fischer",
      "birth_year": 1877,
      "given_name": "Franz",
      "death_year": 1947,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Franz_Joseph_Emil_Fischer",
      "family_name": "Fischer",
      "gender": "male"
    },
    "position": {
      "x": 6452.311520537144,
      "y": 3617.2686292609756
    },
    "selected": false
  }, {
    "data": {
      "id": "36",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Augustin Cauchy",
      "birth_year": 1789,
      "given_name": "Augustin",
      "death_year": 1857,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy",
      "family_name": "Cauchy",
      "gender": "male"
    },
    "position": {
      "x": 3537.5485968287385,
      "y": 3608.7379980539013
    },
    "selected": false
  }, {
    "data": {
      "id": "118",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Louis Gouy",
      "birth_year": 1854,
      "given_name": "Louis",
      "death_year": 1926,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Louis_Georges_Gouy",
      "family_name": "Gouy",
      "gender": "male"
    },
    "position": {
      "x": 2489.7125909036286,
      "y": 4616.416761741155
    },
    "selected": false
  }, {
    "data": {
      "id": "162",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Shikao Ikehara",
      "birth_year": 1904,
      "given_name": "Shikao",
      "death_year": 1984,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Shikao_Ikehara",
      "family_name": "Ikehara",
      "gender": "male"
    },
    "position": {
      "x": 3605.0426457793587,
      "y": 4292.961337685961
    },
    "selected": false
  }, {
    "data": {
      "id": "84",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alfred Enneper",
      "birth_year": 1830,
      "given_name": "Alfred",
      "death_year": 1885,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Alfred_Enneper",
      "family_name": "Enneper",
      "gender": "male"
    },
    "position": {
      "x": 3102.7400243672973,
      "y": 3469.7725305076956
    },
    "selected": false
  }, {
    "data": {
      "id": "7",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ernest Barnes",
      "birth_year": 1874,
      "given_name": "Ernest",
      "death_year": 1953,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ernest_Barnes",
      "family_name": "Barnes",
      "gender": "male"
    },
    "position": {
      "x": 5865.375259501818,
      "y": 3457.7819056623557
    },
    "selected": false
  }, {
    "data": {
      "id": "25",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ludwig Boltzmann",
      "birth_year": 1844,
      "given_name": "Ludwig",
      "death_year": 1906,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ludwig_Boltzmann",
      "family_name": "Boltzmann",
      "gender": "male"
    },
    "position": {
      "x": 5125.804937820076,
      "y": 4524.05141348593
    },
    "selected": false
  }, {
    "data": {
      "id": "95",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vladimir Fock",
      "birth_year": 1898,
      "given_name": "Vladimir",
      "death_year": 1974,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vladimir_Fock",
      "family_name": "Fock",
      "gender": "male"
    },
    "position": {
      "x": 1984.5176016836144,
      "y": 3969.266705194242
    },
    "selected": false
  }, {
    "data": {
      "id": "203",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans Kramers",
      "birth_year": 1894,
      "given_name": "Hans",
      "death_year": 1952,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hans_Kramers",
      "family_name": "Kramers",
      "gender": "male"
    },
    "position": {
      "x": 2805.4268935264263,
      "y": 3089.6519473439357
    },
    "selected": false
  }, {
    "data": {
      "id": "292",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Shuichi Nosé",
      "birth_year": 1951,
      "given_name": "Shuichi",
      "death_year": 2005,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Shuichi_Nosé",
      "family_name": "Nosé",
      "gender": "male"
    },
    "position": {
      "x": 6279.404635906428,
      "y": 4164.6528334515515
    },
    "selected": false
  }, {
    "data": {
      "id": "353",
      "selected": false,
      "NodeType": "Cheese",
      "name": "T Sato",
      "birth_year": "missing",
      "given_name": "T",
      "death_year": "missing",
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "missing",
      "family_name": "Sato",
      "gender": "missing"
    },
    "position": {
      "x": 4024.887965784255,
      "y": 4317.134464713278
    },
    "selected": false
  }, {
    "data": {
      "id": "232",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Anders Lindstedt",
      "birth_year": 1854,
      "given_name": "Anders",
      "death_year": 1939,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Anders_Lindstedt",
      "family_name": "Lindstedt",
      "gender": "male"
    },
    "position": {
      "x": 3813.9660207093484,
      "y": 3956.7251797561703
    },
    "selected": false
  }, {
    "data": {
      "id": "93",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ronald Fisher",
      "birth_year": 1890,
      "given_name": "Ronald",
      "death_year": 1962,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ronald_Fisher",
      "family_name": "Fisher",
      "gender": "male"
    },
    "position": {
      "x": 4694.155808378908,
      "y": 4413.025981411467
    },
    "selected": false
  }, {
    "data": {
      "id": "296",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lars Onsager",
      "birth_year": 1903,
      "given_name": "Lars",
      "death_year": 1976,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lars_Onsager",
      "family_name": "Onsager",
      "gender": "male"
    },
    "position": {
      "x": 1314.6606974489332,
      "y": 3791.2428606737053
    },
    "selected": false
  }, {
    "data": {
      "id": "304",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Peierls",
      "birth_year": 1907,
      "given_name": "Rudolf",
      "death_year": 1995,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolf_Peierls",
      "family_name": "Peierls",
      "gender": "male"
    },
    "position": {
      "x": 2044.4462507543778,
      "y": 3695.276159698179
    },
    "selected": false
  }, {
    "data": {
      "id": "18",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Friedrich Bessel",
      "birth_year": 1784,
      "given_name": "Friedrich",
      "death_year": 1846,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Friedrich_Bessel",
      "family_name": "Bessel",
      "gender": "male"
    },
    "position": {
      "x": 3159.844001679983,
      "y": 3945.0816233104038
    },
    "selected": false
  }, {
    "data": {
      "id": "240",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ludvig Lorenz",
      "birth_year": 1829,
      "given_name": "Ludvig",
      "death_year": 1891,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ludvig_Lorenz",
      "family_name": "Lorenz",
      "gender": "male"
    },
    "position": {
      "x": 4780.697390836911,
      "y": 3334.8727146890287
    },
    "selected": false
  }, {
    "data": {
      "id": "147",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Hilbert",
      "birth_year": 1862,
      "given_name": "David",
      "death_year": 1943,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Hilbert",
      "family_name": "Hilbert",
      "gender": "male"
    },
    "position": {
      "x": 3722.8565491971635,
      "y": 3803.1365010291092
    },
    "selected": false
  }, {
    "data": {
      "id": "157",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leslie Howarth",
      "birth_year": 1911,
      "given_name": "Leslie",
      "death_year": 2001,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Leslie_Howarth",
      "family_name": "Howarth",
      "gender": "male"
    },
    "position": {
      "x": 3351.951190710754,
      "y": 3335.4699521633684
    },
    "selected": false
  }, {
    "data": {
      "id": "16",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Bernstein",
      "birth_year": 1945,
      "given_name": "Joseph",
      "death_year": "missing",
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Bernstein",
      "family_name": "Bernstein",
      "gender": "male"
    },
    "position": {
      "x": 5501.894530831574,
      "y": 3944.5612897861174
    },
    "selected": false
  }, {
    "data": {
      "id": "370",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Claude Shannon",
      "birth_year": 1916,
      "given_name": "Claude",
      "death_year": 2001,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Claude_Shannon",
      "family_name": "Shannon",
      "gender": "male"
    },
    "position": {
      "x": 2761.082862344558,
      "y": 4145.846077526849
    },
    "selected": false
  }, {
    "data": {
      "id": "392",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Marshall Stone",
      "birth_year": 1903,
      "given_name": "Marshall",
      "death_year": 1989,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Marshall_Harvey_Stone",
      "family_name": "Stone",
      "gender": "male"
    },
    "position": {
      "x": 2889.7718653425036,
      "y": 3450.141967982963
    },
    "selected": false
  }, {
    "data": {
      "id": "341",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gustav Roch",
      "birth_year": 1839,
      "given_name": "Gustav",
      "death_year": 1866,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gustav_Roch",
      "family_name": "Roch",
      "gender": "male"
    },
    "position": {
      "x": 3812.924268939049,
      "y": 3694.3998054624726
    },
    "selected": false
  }, {
    "data": {
      "id": "415",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Max Volmer",
      "birth_year": 1885,
      "given_name": "Max",
      "death_year": 1965,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Max_Volmer",
      "family_name": "Volmer",
      "gender": "male"
    },
    "position": {
      "x": 5439.780986381334,
      "y": 4229.264217470753
    },
    "selected": false
  }, {
    "data": {
      "id": "287",
      "selected": false,
      "NodeType": "Cheese",
      "name": "André Néron",
      "birth_year": 1922,
      "given_name": "André",
      "death_year": 1985,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/André_Néron",
      "family_name": "Néron",
      "gender": "male"
    },
    "position": {
      "x": 5370.497218354671,
      "y": 3994.928769590383
    },
    "selected": false
  }, {
    "data": {
      "id": "349",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Otto Sackur",
      "birth_year": 1880,
      "given_name": "Otto",
      "death_year": 1914,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Otto_Sackur",
      "family_name": "Sackur",
      "gender": "male"
    },
    "position": {
      "x": 4015.7485532793144,
      "y": 4972.762681156161
    },
    "selected": false
  }, {
    "data": {
      "id": "19",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans Bethe",
      "birth_year": 1906,
      "given_name": "Hans",
      "death_year": 2005,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hans_Bethe",
      "family_name": "Bethe",
      "gender": "male"
    },
    "position": {
      "x": 3211.775676893018,
      "y": 2977.01494378777
    },
    "selected": false
  }, {
    "data": {
      "id": "44",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Guido Castelnuovo",
      "birth_year": 1865,
      "given_name": "Guido",
      "death_year": 1952,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Guido_Castelnuovo",
      "family_name": "Castelnuovo",
      "gender": "male"
    },
    "position": {
      "x": 3715.8841554716573,
      "y": 3706.5455453150125
    },
    "selected": false
  }, {
    "data": {
      "id": "266",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Minkowski",
      "birth_year": 1864,
      "given_name": "Hermann",
      "death_year": 1909,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Minkowski#See_also",
      "family_name": "Minkowski",
      "gender": "male"
    },
    "position": {
      "x": 4299.773972750563,
      "y": 3658.304376840775
    },
    "selected": false
  }, {
    "data": {
      "id": "31",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Box",
      "birth_year": 1919,
      "given_name": "George",
      "death_year": 2013,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_E._P._Box",
      "family_name": "Box",
      "gender": "male"
    },
    "position": {
      "x": 4124.512501776215,
      "y": 4609.853649016758
    },
    "selected": false
  }, {
    "data": {
      "id": "217",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Langlands",
      "birth_year": 1936,
      "given_name": "Robert",
      "death_year": "missing",
      "birth_country": "Canada",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_Langlands",
      "family_name": "Langlands",
      "gender": "male"
    },
    "position": {
      "x": 3309.1493185411846,
      "y": 3854.9073838795475
    },
    "selected": false
  }, {
    "data": {
      "id": "146",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Heinrich Hertz",
      "birth_year": 1857,
      "given_name": "Heinrich",
      "death_year": 1894,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Heinrich_Hertz",
      "family_name": "Hertz",
      "gender": "male"
    },
    "position": {
      "x": 3918.507554044551,
      "y": 2968.1430062203794
    },
    "selected": false
  }, {
    "data": {
      "id": "368",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jayant Shah",
      "birth_year": "missing",
      "given_name": "Jayant",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Shah",
      "gender": "missing"
    },
    "position": {
      "x": 3742.59301374368,
      "y": 3774.7602059994565
    },
    "selected": false
  }, {
    "data": {
      "id": "74",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leonard Dickson",
      "birth_year": 1874,
      "given_name": "Leonard",
      "death_year": 1954,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Leonard_Eugene_Dickson",
      "family_name": "Dickson",
      "gender": "male"
    },
    "position": {
      "x": 4364.48642120865,
      "y": 3091.1888274381304
    },
    "selected": false
  }, {
    "data": {
      "id": "61",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Curie",
      "birth_year": 1859,
      "given_name": "Pierre",
      "death_year": 1906,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Curie",
      "family_name": "Curie",
      "gender": "male"
    },
    "position": {
      "x": 6308.013322830268,
      "y": 3166.5477683152712
    },
    "selected": false
  }, {
    "data": {
      "id": "29",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Bosch",
      "birth_year": 1874,
      "given_name": "Carl",
      "death_year": 1940,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carl_Bosch",
      "family_name": "Bosch",
      "gender": "male"
    },
    "position": {
      "x": 3220.1399555407124,
      "y": 3325.649149528621
    },
    "selected": false
  }, {
    "data": {
      "id": "412",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sathamangalam Varadhan",
      "birth_year": 1940,
      "given_name": "Sathamangalam",
      "death_year": "missing",
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/S._R._Srinivasa_Varadhan",
      "family_name": "Varadhan",
      "gender": "male"
    },
    "position": {
      "x": 5523.817142695166,
      "y": 4419.479918145298
    },
    "selected": false
  }, {
    "data": {
      "id": "390",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walter Stockmayer",
      "birth_year": 1914,
      "given_name": "Walter",
      "death_year": 2004,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walter_H._Stockmayer",
      "family_name": "Stockmayer",
      "gender": "male"
    },
    "position": {
      "x": 5022.528728204277,
      "y": 2907.0925947805463
    },
    "selected": false
  }, {
    "data": {
      "id": "380",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Johann Soldner",
      "birth_year": 1776,
      "given_name": "Johann",
      "death_year": 1833,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Johann_Georg_von_Soldner",
      "family_name": "Soldner",
      "gender": "male"
    },
    "position": {
      "x": 3986.076353284974,
      "y": 4327.796563874181
    },
    "selected": false
  }, {
    "data": {
      "id": "212",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Willis Lamb",
      "birth_year": 1913,
      "given_name": "Willis",
      "death_year": 2008,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Willis_Lamb",
      "family_name": "Lamb",
      "gender": "male"
    },
    "position": {
      "x": 1801.7837684677725,
      "y": 3850.2094633859388
    },
    "selected": false
  }, {
    "data": {
      "id": "303",
      "selected": false,
      "NodeType": "Cheese",
      "name": "missing Peach",
      "birth_year": "missing",
      "given_name": "missing",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Peach",
      "gender": "missing"
    },
    "position": {
      "x": 6183.218033123999,
      "y": 3814.627821271426
    },
    "selected": false
  }, {
    "data": {
      "id": "424",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Duncan Watts",
      "birth_year": 1971,
      "given_name": "Duncan",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Duncan_J._Watts",
      "family_name": "Watts",
      "gender": "male"
    },
    "position": {
      "x": 3664.718820346108,
      "y": 2964.29968463368
    },
    "selected": false
  }, {
    "data": {
      "id": "228",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Elliott Lieb",
      "birth_year": 1932,
      "given_name": "Elliott",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Elliott_H._Lieb",
      "family_name": "Lieb",
      "gender": "male"
    },
    "position": {
      "x": 5469.270002018144,
      "y": 2923.9723089191016
    },
    "selected": false
  }, {
    "data": {
      "id": "159",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Erich Hückel",
      "birth_year": 1896,
      "given_name": "Erich",
      "death_year": 1980,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Erich_Hückel",
      "family_name": "Hückel",
      "gender": "male"
    },
    "position": {
      "x": 4210.560414529326,
      "y": 2587.8073283150875
    },
    "selected": false
  }, {
    "data": {
      "id": "193",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walter Kohn",
      "birth_year": 1923,
      "given_name": "Walter",
      "death_year": 1916,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walter_Kohn",
      "family_name": "Kohn",
      "gender": "male"
    },
    "position": {
      "x": 1507.9890634487767,
      "y": 3851.4540085024655
    },
    "selected": false
  }, {
    "data": {
      "id": "226",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Mel Levy",
      "birth_year": 1941,
      "given_name": "Mel",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://www.iaqms.org/members/levy.php",
      "family_name": "Levy",
      "gender": "male"
    },
    "position": {
      "x": 5529.668457748511,
      "y": 2925.660302819634
    },
    "selected": false
  }, {
    "data": {
      "id": "101",
      "selected": false,
      "NodeType": "Cheese",
      "name": "James Franck",
      "birth_year": 1882,
      "given_name": "James",
      "death_year": 1964,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/James_Franck",
      "family_name": "Franck",
      "gender": "male"
    },
    "position": {
      "x": 3743.8100553791296,
      "y": 2960.3090424443844
    },
    "selected": false
  }, {
    "data": {
      "id": "360",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Günter Schulz",
      "birth_year": 1905,
      "given_name": "Günter",
      "death_year": 1999,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://de.wikipedia.org/wiki/Günter_Victor_Schulz",
      "family_name": "Schulz",
      "gender": "male"
    },
    "position": {
      "x": 4991.957476048186,
      "y": 2879.933828895127
    },
    "selected": false
  }, {
    "data": {
      "id": "105",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Gamow",
      "birth_year": 1904,
      "given_name": "George",
      "death_year": 1968,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Gamow",
      "family_name": "Gamow",
      "gender": "male"
    },
    "position": {
      "x": 5738.40735209666,
      "y": 4336.705504131022
    },
    "selected": false
  }, {
    "data": {
      "id": "223",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Daniel Lehmus",
      "birth_year": 1780,
      "given_name": "Daniel",
      "death_year": 1863,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/C._L._Lehmus",
      "family_name": "Lehmus",
      "gender": "male"
    },
    "position": {
      "x": 4594.407035294007,
      "y": 3801.261124457153
    },
    "selected": false
  }, {
    "data": {
      "id": "399",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Swan",
      "birth_year": 1933,
      "given_name": "Richard",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Swan",
      "family_name": "Swan",
      "gender": "male"
    },
    "position": {
      "x": 4764.600581187444,
      "y": 3868.510579554858
    },
    "selected": false
  }, {
    "data": {
      "id": "285",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Claude-Louis Navier",
      "birth_year": 1785,
      "given_name": "Claude-Louis",
      "death_year": 1836,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Claude-Louis_Navier",
      "family_name": "Navier",
      "gender": "male"
    },
    "position": {
      "x": 3579.7427857447665,
      "y": 3432.060665600833
    },
    "selected": false
  }, {
    "data": {
      "id": "17",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sergei Bernstein",
      "birth_year": 1880,
      "given_name": "Sergei",
      "death_year": 1968,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sergei_Natanovich_Bernstein",
      "family_name": "Bernstein",
      "gender": "male"
    },
    "position": {
      "x": 4711.938257393736,
      "y": 4386.246690554625
    },
    "selected": false
  }, {
    "data": {
      "id": "421",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ivar Waller",
      "birth_year": 1898,
      "given_name": "Ivar",
      "death_year": 1991,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ivar_Waller",
      "family_name": "Waller",
      "gender": "male"
    },
    "position": {
      "x": 4298.89616686105,
      "y": 2609.725348622189
    },
    "selected": false
  }, {
    "data": {
      "id": "271",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Marston Morse",
      "birth_year": 1892,
      "given_name": "Marston",
      "death_year": 1977,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Marston_Morse",
      "family_name": "Morse",
      "gender": "male"
    },
    "position": {
      "x": 2291.961762295008,
      "y": 4092.778441551244
    },
    "selected": false
  }, {
    "data": {
      "id": "335",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Renner",
      "birth_year": 1909,
      "given_name": "Rudolf",
      "death_year": 1991,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://link.springer.com/article/10.1007/s11224-009-9479-z",
      "family_name": "Renner",
      "gender": "male"
    },
    "position": {
      "x": 5716.587758425061,
      "y": 4349.083478316502
    },
    "selected": false
  }, {
    "data": {
      "id": "426",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Heinrich Weber",
      "birth_year": 1842,
      "given_name": "Heinrich",
      "death_year": 1913,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Heinrich_Martin_Weber",
      "family_name": "Weber",
      "gender": "male"
    },
    "position": {
      "x": 5406.473229160955,
      "y": 4696.795608548369
    },
    "selected": false
  }, {
    "data": {
      "id": "166",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Oleg Jefimenko",
      "birth_year": 1922,
      "given_name": "Oleg",
      "death_year": 2009,
      "birth_country": "Ukraine",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Oleg_D._Jefimenko",
      "family_name": "Jefimenko",
      "gender": "male"
    },
    "position": {
      "x": 2226.941519147458,
      "y": 3085.2153782547275
    },
    "selected": false
  }, {
    "data": {
      "id": "89",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Michael Fekete",
      "birth_year": 1886,
      "given_name": "Michael",
      "death_year": 1957,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Michael_Fekete",
      "family_name": "Fekete",
      "gender": "male"
    },
    "position": {
      "x": 4089.529121382235,
      "y": 4007.6500108423247
    },
    "selected": false
  }, {
    "data": {
      "id": "198",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Bernard Koopman",
      "birth_year": 1900,
      "given_name": "Bernard",
      "death_year": 1981,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Bernard_Koopman",
      "family_name": "Koopman",
      "gender": "male"
    },
    "position": {
      "x": 2485.482270057106,
      "y": 3423.9096368322826
    },
    "selected": false
  }, {
    "data": {
      "id": "214",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Landau",
      "birth_year": 1941,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_P._Landau",
      "family_name": "Landau",
      "gender": "male"
    },
    "position": {
      "x": 5305.864837224382,
      "y": 2937.1370291547755
    },
    "selected": false
  }, {
    "data": {
      "id": "80",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Paul Drude",
      "birth_year": 1863,
      "given_name": "Paul",
      "death_year": 1906,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paul_Drude",
      "family_name": "Drude",
      "gender": "male"
    },
    "position": {
      "x": 4578.49854072625,
      "y": 3504.618316596889
    },
    "selected": false
  }, {
    "data": {
      "id": "331",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Raphson",
      "birth_year": 1648,
      "given_name": "Joseph",
      "death_year": 1715,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Raphson",
      "family_name": "Raphson",
      "gender": "male"
    },
    "position": {
      "x": 3342.6850631511024,
      "y": 3732.8505134160314
    },
    "selected": false
  }, {
    "data": {
      "id": "51",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alonzo Church",
      "birth_year": 1903,
      "given_name": "Alonzo",
      "death_year": 1995,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Alonzo_Church",
      "family_name": "Church",
      "gender": "male"
    },
    "position": {
      "x": 2644.4613494657233,
      "y": 3922.766967283488
    },
    "selected": false
  }, {
    "data": {
      "id": "274",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Mostow",
      "birth_year": 1923,
      "given_name": "George",
      "death_year": 1917,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Mostow#See_also",
      "family_name": "Mostow",
      "gender": "male"
    },
    "position": {
      "x": 2276.4255100685873,
      "y": 4152.741116263694
    },
    "selected": false
  }, {
    "data": {
      "id": "246",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Colin Maclaurin",
      "birth_year": 1698,
      "given_name": "Colin",
      "death_year": 1746,
      "birth_country": "Scotland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Colin_Maclaurin",
      "family_name": "Maclaurin",
      "gender": "male"
    },
    "position": {
      "x": 3425.1930253289875,
      "y": 3810.004198483126
    },
    "selected": false
  }, {
    "data": {
      "id": "143",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Helmholtz",
      "birth_year": 1821,
      "given_name": "Hermann",
      "death_year": 1894,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_von_Helmholtz",
      "family_name": "Helmholtz",
      "gender": "male"
    },
    "position": {
      "x": 3669.7511999855633,
      "y": 3197.1251504612046
    },
    "selected": false
  }, {
    "data": {
      "id": "48",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Chapman",
      "birth_year": 1869,
      "given_name": "David",
      "death_year": 1958,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Chapman_(chemist)",
      "family_name": "Chapman",
      "gender": "male"
    },
    "position": {
      "x": 2478.112465013389,
      "y": 4588.905493538718
    },
    "selected": false
  }, {
    "data": {
      "id": "15",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Daniel Bernoulli",
      "birth_year": 1700,
      "given_name": "Daniel",
      "death_year": 1782,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Daniel_Bernoulli",
      "family_name": "Bernoulli",
      "gender": "male"
    },
    "position": {
      "x": 3456.771804356306,
      "y": 3802.537348628932
    },
    "selected": false
  }, {
    "data": {
      "id": "97",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Kent Ford",
      "birth_year": 1931,
      "given_name": "Kent",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Kent_Ford_(astronomer)",
      "family_name": "Ford",
      "gender": "male"
    },
    "position": {
      "x": 3598.073849739421,
      "y": 2618.346825409135
    },
    "selected": false
  }, {
    "data": {
      "id": "330",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Calyampudi Rao",
      "birth_year": 1920,
      "given_name": "Calyampudi",
      "death_year": "missing",
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/C._R._Rao",
      "family_name": "Rao",
      "gender": "male"
    },
    "position": {
      "x": 4388.093554615096,
      "y": 4386.818436582196
    },
    "selected": false
  }, {
    "data": {
      "id": "284",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Yoichiro Nambu",
      "birth_year": 1921,
      "given_name": "Yoichiro",
      "death_year": 2015,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Yoichiro_Nambu",
      "family_name": "Nambu",
      "gender": "male"
    },
    "position": {
      "x": 2780.781494752807,
      "y": 4580.7849627770665
    },
    "selected": false
  }, {
    "data": {
      "id": "134",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ralph Hartley",
      "birth_year": 1888,
      "given_name": "Ralph",
      "death_year": 1970,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ralph_Hartley",
      "family_name": "Hartley",
      "gender": "male"
    },
    "position": {
      "x": 2693.7188538077244,
      "y": 4140.255668517795
    },
    "selected": false
  }, {
    "data": {
      "id": "402",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Tate",
      "birth_year": 1925,
      "given_name": "John",
      "death_year": 2019,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Tate",
      "family_name": "Tate",
      "gender": "male"
    },
    "position": {
      "x": 5285.995458255802,
      "y": 3957.86314723147
    },
    "selected": false
  }, {
    "data": {
      "id": "413",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ernest Vessiot",
      "birth_year": 1865,
      "given_name": "Ernest",
      "death_year": 1952,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ernest_Vessiot",
      "family_name": "Vessiot",
      "gender": "male"
    },
    "position": {
      "x": 2574.80233837258,
      "y": 3417.2987983088874
    },
    "selected": false
  }, {
    "data": {
      "id": "110",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gary Gibbons",
      "birth_year": 1946,
      "given_name": "Gary",
      "death_year": "missing",
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gary_Gibbons",
      "family_name": "Gibbons",
      "gender": "male"
    },
    "position": {
      "x": 3423.2782379753558,
      "y": 4629.249520350789
    },
    "selected": false
  }, {
    "data": {
      "id": "30",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Satyendra Bose",
      "birth_year": 1894,
      "given_name": "Satyendra",
      "death_year": 1974,
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/Satyendra_Nath_Bose",
      "family_name": "Bose",
      "gender": "male"
    },
    "position": {
      "x": 3474.3175316234633,
      "y": 3610.5200310021237
    },
    "selected": false
  }, {
    "data": {
      "id": "419",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John von Neumann",
      "birth_year": 1903,
      "given_name": "John",
      "death_year": 1957,
      "birth_country": "Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_von_Neumann",
      "family_name": "von Neumann",
      "gender": "male"
    },
    "position": {
      "x": 2598.8945969032284,
      "y": 3434.2635788709395
    },
    "selected": false
  }, {
    "data": {
      "id": "6",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Isaak Bacharach",
      "birth_year": 1854,
      "given_name": "Isaak",
      "death_year": 1942,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Isaak_Bacharach",
      "family_name": "Bacharach",
      "gender": "male"
    },
    "position": {
      "x": 4305.325901467476,
      "y": 3118.5500051271047
    },
    "selected": false
  }, {
    "data": {
      "id": "234",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Bernard Lippmann",
      "birth_year": 1914,
      "given_name": "Bernard",
      "death_year": 1988,
      "birth_country": "American",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Bernard_Lippmann",
      "family_name": "Lippmann",
      "gender": "male"
    },
    "position": {
      "x": 4582.330715898073,
      "y": 2609.84734594588
    },
    "selected": false
  }, {
    "data": {
      "id": "219",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre-Simon Laplace",
      "birth_year": 1749,
      "given_name": "Pierre-Simon",
      "death_year": 1827,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre-Simon_Laplace",
      "family_name": "Laplace",
      "gender": "male"
    },
    "position": {
      "x": 3899.177199927225,
      "y": 3033.3994301545245
    },
    "selected": false
  }, {
    "data": {
      "id": "367",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean-Pierre Serre",
      "birth_year": 1926,
      "given_name": "Jean-Pierre",
      "death_year": "missing",
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean-Pierre_Serre",
      "family_name": "Serre",
      "gender": "male"
    },
    "position": {
      "x": 5034.019949068831,
      "y": 3892.0496577549793
    },
    "selected": false
  }, {
    "data": {
      "id": "272",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Mössbauer",
      "birth_year": 1929,
      "given_name": "Rudolf",
      "death_year": 2011,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolf_Mössbauer",
      "family_name": "Mössbauer",
      "gender": "male"
    },
    "position": {
      "x": 1814.0105050985317,
      "y": 3871.591780867546
    },
    "selected": false
  }, {
    "data": {
      "id": "182",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Kazhdan",
      "birth_year": 1946,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Kazhdan",
      "family_name": "Kazhdan",
      "gender": "male"
    },
    "position": {
      "x": 3073.5716991219774,
      "y": 3876.0861637447742
    },
    "selected": false
  }, {
    "data": {
      "id": "164",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Jahn",
      "birth_year": 1907,
      "given_name": "Hermann",
      "death_year": 1979,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Arthur_Jahn",
      "family_name": "Jahn",
      "gender": "male"
    },
    "position": {
      "x": 5592.97200450521,
      "y": 4291.04856354147
    },
    "selected": false
  }, {
    "data": {
      "id": "153",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Theodore Holstein",
      "birth_year": 1915,
      "given_name": "Theodore",
      "death_year": 1985,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Theodore_Holstein",
      "family_name": "Holstein",
      "gender": "male"
    },
    "position": {
      "x": 2304.024176164859,
      "y": 3659.828327129814
    },
    "selected": false
  }, {
    "data": {
      "id": "186",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Aleksandr Khinchin",
      "birth_year": 1894,
      "given_name": "Aleksandr",
      "death_year": 1959,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Aleksandr_Khinchin",
      "family_name": "Khinchin",
      "gender": "male"
    },
    "position": {
      "x": 3717.2375788499658,
      "y": 4292.924598384721
    },
    "selected": false
  }, {
    "data": {
      "id": "253",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lorenzo Mascheroni",
      "birth_year": 1750,
      "given_name": "Lorenzo",
      "death_year": 1800,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lorenzo_Mascheroni",
      "family_name": "Mascheroni",
      "gender": "male"
    },
    "position": {
      "x": 3422.7037942083407,
      "y": 3846.0688966878483
    },
    "selected": false
  }, {
    "data": {
      "id": "64",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Charles G Darwin",
      "birth_year": 1887,
      "given_name": "Charles G",
      "death_year": 1962,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Charles_Galton_Darwin",
      "family_name": "Darwin",
      "gender": "male"
    },
    "position": {
      "x": 4638.647072306978,
      "y": 2798.2314828798076
    },
    "selected": false
  }, {
    "data": {
      "id": "267",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Adriaan Moens",
      "birth_year": 1846,
      "given_name": "Adriaan",
      "death_year": 1891,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Adriaan_Isebree_Moens",
      "family_name": "Moens",
      "gender": "male"
    },
    "position": {
      "x": 6078.154660506435,
      "y": 4057.6455154287833
    },
    "selected": false
  }, {
    "data": {
      "id": "394",
      "selected": false,
      "NodeType": "Cheese",
      "name": "H. W. Streeter",
      "birth_year": "missing",
      "given_name": "H. W.",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "missing",
      "family_name": "Streeter",
      "gender": "male"
    },
    "position": {
      "x": 1607.2252220424425,
      "y": 3258.745478405275
    },
    "selected": false
  }, {
    "data": {
      "id": "90",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Enrico Fermi",
      "birth_year": 1901,
      "given_name": "Enrico",
      "death_year": 1954,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Enrico_Fermi",
      "family_name": "Fermi",
      "gender": "male"
    },
    "position": {
      "x": 2275.17102909784,
      "y": 3400.405282451114
    },
    "selected": false
  }, {
    "data": {
      "id": "139",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Oliver Heaviside",
      "birth_year": 1850,
      "given_name": "Oliver",
      "death_year": 1925,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Oliver_Heaviside",
      "family_name": "Heaviside",
      "gender": "male"
    },
    "position": {
      "x": 2437.7107192550325,
      "y": 3201.9883385036683
    },
    "selected": false
  }, {
    "data": {
      "id": "4",
      "selected": false,
      "NodeType": "Cheese",
      "name": "François Arago",
      "birth_year": 1786,
      "given_name": "François",
      "death_year": 1853,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/François_Arago",
      "family_name": "Arago",
      "gender": "male"
    },
    "position": {
      "x": 4819.453174894956,
      "y": 3960.1199973111115
    },
    "selected": false
  }, {
    "data": {
      "id": "13",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Henri Bénard",
      "birth_year": 1874,
      "given_name": "Henri",
      "death_year": 1939,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Henri_Bénard",
      "family_name": "Bénard",
      "gender": "male"
    },
    "position": {
      "x": 4874.140497438115,
      "y": 3142.03551457858
    },
    "selected": false
  }, {
    "data": {
      "id": "359",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Erwin Schrödinger",
      "birth_year": 1887,
      "given_name": "Erwin",
      "death_year": 1961,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Erwin_Schrödinger",
      "family_name": "Schrödinger",
      "gender": "male"
    },
    "position": {
      "x": 4915.205424797347,
      "y": 3192.078893885204
    },
    "selected": false
  }, {
    "data": {
      "id": "405",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hugo Tetrode",
      "birth_year": 1895,
      "given_name": "Hugo",
      "death_year": 1931,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hugo_Tetrode",
      "family_name": "Tetrode",
      "gender": "male"
    },
    "position": {
      "x": 3971.7456641780395,
      "y": 4968.311619044721
    },
    "selected": false
  }, {
    "data": {
      "id": "104",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Augustin-Jean Fresnel",
      "birth_year": 1788,
      "given_name": "Augustin-Jean",
      "death_year": 1827,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Augustin-Jean_Fresnel",
      "family_name": "Fresnel",
      "gender": "male"
    },
    "position": {
      "x": 4741.215666505648,
      "y": 3910.335474565194
    },
    "selected": false
  }, {
    "data": {
      "id": "316",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Henri Poincaré",
      "birth_year": 1854,
      "given_name": "Henri",
      "death_year": 1912,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Henri_Poincaré",
      "family_name": "Poincaré",
      "gender": "male"
    },
    "position": {
      "x": 3720.817703126585,
      "y": 3957.5062290681117
    },
    "selected": false
  }, {
    "data": {
      "id": "328",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Daniel Quillen",
      "birth_year": 1940,
      "given_name": "Daniel",
      "death_year": 2011,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Daniel_Quillen",
      "family_name": "Quillen",
      "gender": "male"
    },
    "position": {
      "x": 5303.2751644366745,
      "y": 3799.4628618772485
    },
    "selected": false
  }, {
    "data": {
      "id": "52",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Benoît Clapeyron",
      "birth_year": 1799,
      "given_name": "Benoît",
      "death_year": 1864,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Benoît_Paul_Émile_Clapeyron",
      "family_name": "Clapeyron",
      "gender": "male"
    },
    "position": {
      "x": 3768.6014723958133,
      "y": 3118.364162537858
    },
    "selected": false
  }, {
    "data": {
      "id": "179",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Irving Kaplansky",
      "birth_year": 1917,
      "given_name": "Irving",
      "death_year": 2006,
      "birth_country": "Canada",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Irving_Kaplansky",
      "family_name": "Kaplansky",
      "gender": "male"
    },
    "position": {
      "x": 2141.129708318057,
      "y": 3339.40886655198
    },
    "selected": false
  }, {
    "data": {
      "id": "369",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lu Sham",
      "birth_year": 1938,
      "given_name": "Lu",
      "death_year": "missing",
      "birth_country": "Hong Kong",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Lu_Jeu_Sham",
      "family_name": "Sham",
      "gender": "male"
    },
    "position": {
      "x": 1463.0213361365707,
      "y": 3831.1081855097864
    },
    "selected": false
  }, {
    "data": {
      "id": "410",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pieter van Alphen",
      "birth_year": "missing",
      "given_name": "Pieter",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "van Alphen",
      "gender": "missing"
    },
    "position": {
      "x": 3244.6830504398895,
      "y": 3638.197329370675
    },
    "selected": false
  }, {
    "data": {
      "id": "356",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Mario Schönberg",
      "birth_year": 1914,
      "given_name": "Mario",
      "death_year": 1990,
      "birth_country": "Brazil",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Mário_Schenberg",
      "family_name": "Schönberg",
      "gender": "male"
    },
    "position": {
      "x": 4439.134107520388,
      "y": 4367.448018862728
    },
    "selected": false
  }, {
    "data": {
      "id": "300",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Don Page",
      "birth_year": 1948,
      "given_name": "Don",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "missing",
      "family_name": "Page",
      "gender": "male"
    },
    "position": {
      "x": 4437.865407626621,
      "y": 4426.5998084626035
    },
    "selected": false
  }, {
    "data": {
      "id": "43",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Felice Casorati",
      "birth_year": 1835,
      "given_name": "Felice",
      "death_year": 1890,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Felice_Casorati_(mathematician)",
      "family_name": "Casorati",
      "gender": "male"
    },
    "position": {
      "x": 3131.1164283774733,
      "y": 3438.095540455568
    },
    "selected": false
  }, {
    "data": {
      "id": "11",
      "selected": false,
      "NodeType": "Cheese",
      "name": "August Beer",
      "birth_year": 1825,
      "given_name": "August",
      "death_year": 1863,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/August_Beer",
      "family_name": "Beer",
      "gender": "male"
    },
    "position": {
      "x": 5340.656327741004,
      "y": 4397.61929856228
    },
    "selected": false
  }, {
    "data": {
      "id": "69",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gustav de Vries",
      "birth_year": 1866,
      "given_name": "Gustav",
      "death_year": 1934,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gustav_de_Vries",
      "family_name": "de Vries",
      "gender": "male"
    },
    "position": {
      "x": 5961.5384761338555,
      "y": 4011.672439122393
    },
    "selected": false
  }, {
    "data": {
      "id": "171",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Camille Jordan",
      "birth_year": 1838,
      "given_name": "Camille",
      "death_year": 1922,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Camille_Jordan",
      "family_name": "Jordan",
      "gender": "male"
    },
    "position": {
      "x": 2405.0090967582623,
      "y": 3787.02094581466
    },
    "selected": false
  }, {
    "data": {
      "id": "302",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Raymond Paley",
      "birth_year": 1907,
      "given_name": "Raymond",
      "death_year": 1933,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Raymond_Paley",
      "family_name": "Paley",
      "gender": "male"
    },
    "position": {
      "x": 3694.302039215436,
      "y": 4340.472644339916
    },
    "selected": false
  }, {
    "data": {
      "id": "85",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Enskog",
      "birth_year": 1884,
      "given_name": "David",
      "death_year": 1947,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Enskog",
      "family_name": "Enskog",
      "gender": "male"
    },
    "position": {
      "x": 6169.749231808387,
      "y": 3836.980069289803
    },
    "selected": false
  }, {
    "data": {
      "id": "119",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jørgen Gram",
      "birth_year": 1850,
      "given_name": "Jørgen",
      "death_year": 1916,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jørgen_Pedersen_Gram",
      "family_name": "Gram",
      "gender": "male"
    },
    "position": {
      "x": 3977.004036088792,
      "y": 3912.411024293828
    },
    "selected": false
  }, {
    "data": {
      "id": "39",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Norman Carnahan",
      "birth_year": 1942,
      "given_name": "Norman",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Norman_F._Carnahan",
      "family_name": "Carnahan",
      "gender": "male"
    },
    "position": {
      "x": 6110.687415712293,
      "y": 3174.6395876108454
    },
    "selected": false
  }, {
    "data": {
      "id": "406",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Axel Thue",
      "birth_year": 1863,
      "given_name": "Axel",
      "death_year": 1922,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Axel_Thue",
      "family_name": "Thue",
      "gender": "male"
    },
    "position": {
      "x": 2273.8356597492543,
      "y": 4056.986535644716
    },
    "selected": false
  }, {
    "data": {
      "id": "216",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lev Landau",
      "birth_year": 1908,
      "given_name": "Lev",
      "death_year": 1968,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lev_Landau",
      "family_name": "Landau",
      "gender": "male"
    },
    "position": {
      "x": 5191.936655746049,
      "y": 3708.488149955064
    },
    "selected": false
  }, {
    "data": {
      "id": "126",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Gutmann",
      "birth_year": "missing",
      "given_name": "Carl",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Gutmann",
      "gender": "missing"
    },
    "position": {
      "x": 1731.2146565123232,
      "y": 3741.0711771795386
    },
    "selected": false
  }, {
    "data": {
      "id": "108",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Murray Gell-Mann",
      "birth_year": 1929,
      "given_name": "Murray",
      "death_year": 2019,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Murray_Gell-Mann",
      "family_name": "Gell-Mann",
      "gender": "male"
    },
    "position": {
      "x": 5250.992153081961,
      "y": 2715.688296303971
    },
    "selected": false
  }, {
    "data": {
      "id": "441",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Julius Wolff",
      "birth_year": 1882,
      "given_name": "Julius",
      "death_year": 1945,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Julius_Wolff_(mathematician)",
      "family_name": "Wolff",
      "gender": "male"
    },
    "position": {
      "x": 5051.544983034806,
      "y": 3630.2437016675212
    },
    "selected": false
  }, {
    "data": {
      "id": "443",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Thomas Young",
      "birth_year": 1773,
      "given_name": "Thomas",
      "death_year": 1829,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Thomas_Young_(scientist)",
      "family_name": "Young",
      "gender": "male"
    },
    "position": {
      "x": 3781.0430341579213,
      "y": 3102.419688061459
    },
    "selected": false
  }, {
    "data": {
      "id": "382",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Herbert Squire",
      "birth_year": 1909,
      "given_name": "Herbert",
      "death_year": 1961,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Herbert_Squire",
      "family_name": "Squire",
      "gender": "male"
    },
    "position": {
      "x": 5293.435625333043,
      "y": 3722.965833930005
    },
    "selected": false
  }, {
    "data": {
      "id": "156",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Geoffrey Horrocks",
      "birth_year": 1932,
      "given_name": "Geoffrey",
      "death_year": 2012,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Geoffrey_Horrocks",
      "family_name": "Horrocks",
      "gender": "male"
    },
    "position": {
      "x": 3689.0535890122255,
      "y": 3763.5089981022156
    },
    "selected": false
  }, {
    "data": {
      "id": "439",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Herman Wold",
      "birth_year": 1908,
      "given_name": "Herman",
      "death_year": 1992,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Herman_Wold",
      "family_name": "Wold",
      "gender": "male"
    },
    "position": {
      "x": 4580.732857936648,
      "y": 4339.128368895623
    },
    "selected": false
  }, {
    "data": {
      "id": "2",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Philip Anderson",
      "birth_year": 1923,
      "given_name": "Philip",
      "death_year": 2020,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Philip_W._Anderson",
      "family_name": "Anderson",
      "gender": "male"
    },
    "position": {
      "x": 2725.5770337115555,
      "y": 3063.4648262291125
    },
    "selected": false
  }, {
    "data": {
      "id": "10",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Batchelor",
      "birth_year": 1920,
      "given_name": "George",
      "death_year": 2000,
      "birth_country": "Australia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Batchelor",
      "family_name": "Batchelor",
      "gender": "male"
    },
    "position": {
      "x": 4255.957151948979,
      "y": 4385.255971912606
    },
    "selected": false
  }, {
    "data": {
      "id": "27",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Bonnet",
      "birth_year": 1819,
      "given_name": "Pierre",
      "death_year": 1892,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Ossian_Bonnet",
      "family_name": "Bonnet",
      "gender": "male"
    },
    "position": {
      "x": 4172.9444737918175,
      "y": 3493.977948788399
    },
    "selected": false
  }, {
    "data": {
      "id": "124",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans Grimm",
      "birth_year": 1887,
      "given_name": "Hans",
      "death_year": 1958,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://de.zxc.wiki/wiki/Hans_G._Grimm",
      "family_name": "Grimm",
      "gender": "male"
    },
    "position": {
      "x": 4458.335263359208,
      "y": 3726.0178383509847
    },
    "selected": false
  }, {
    "data": {
      "id": "261",
      "selected": false,
      "NodeType": "Cheese",
      "name": "E Meshkov",
      "birth_year": "missing",
      "given_name": "E",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Meshkov",
      "gender": "missing"
    },
    "position": {
      "x": 2089.6957608155294,
      "y": 3601.624600948848
    },
    "selected": false
  }, {
    "data": {
      "id": "307",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Fritz Peter",
      "birth_year": 1899,
      "given_name": "Fritz",
      "death_year": 1949,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Fritz_Peter",
      "family_name": "Peter",
      "gender": "male"
    },
    "position": {
      "x": 1648.4922748445542,
      "y": 2999.387624136678
    },
    "selected": false
  }, {
    "data": {
      "id": "144",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Charles Hermite",
      "birth_year": 1822,
      "given_name": "Charles",
      "death_year": 1901,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Charles_Hermite",
      "family_name": "Hermite",
      "gender": "male"
    },
    "position": {
      "x": 3939.415511090972,
      "y": 3578.2456045352383
    },
    "selected": false
  }, {
    "data": {
      "id": "273",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ottaviano-Fabrizio Mossotti",
      "birth_year": 1791,
      "given_name": "Ottaviano-Fabrizio",
      "death_year": 1863,
      "birth_country": "italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ottaviano-Fabrizio_Mossotti",
      "family_name": "Mossotti",
      "gender": "male"
    },
    "position": {
      "x": 3814.776530118362,
      "y": 3127.6702071615296
    },
    "selected": false
  }, {
    "data": {
      "id": "257",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hjalmar Mellin",
      "birth_year": 1854,
      "given_name": "Hjalmar",
      "death_year": 1933,
      "birth_country": "Finland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hjalmar_Mellin",
      "family_name": "Mellin",
      "gender": "male"
    },
    "position": {
      "x": 5909.731575171919,
      "y": 3471.439958065298
    },
    "selected": false
  }, {
    "data": {
      "id": "352",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Mikio Sato",
      "birth_year": 1928,
      "given_name": "Mikio",
      "death_year": "missing",
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Mikio_Sato",
      "family_name": "Sato",
      "gender": "male"
    },
    "position": {
      "x": 5409.236543850529,
      "y": 3949.4193483161243
    },
    "selected": false
  }, {
    "data": {
      "id": "200",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walther Kossel",
      "birth_year": 1888,
      "given_name": "Walther",
      "death_year": 1956,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walther_Kossel",
      "family_name": "Kossel",
      "gender": "male"
    },
    "position": {
      "x": 4400.28535265769,
      "y": 3721.231086571692
    },
    "selected": false
  }, {
    "data": {
      "id": "290",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Kazuhiko Nishijima",
      "birth_year": 1926,
      "given_name": "Kazuhiko",
      "death_year": 2009,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Kazuhiko_Nishijima",
      "family_name": "Nishijima",
      "gender": "male"
    },
    "position": {
      "x": 5306.959257012005,
      "y": 2713.2028000792343
    },
    "selected": false
  }, {
    "data": {
      "id": "20",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean-Baptiste Biot",
      "birth_year": 1774,
      "given_name": "Jean-Baptiste",
      "death_year": 1862,
      "birth_country": "Frane",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean-Baptiste_Biot",
      "family_name": "Biot",
      "gender": "male"
    },
    "position": {
      "x": 1300.0,
      "y": 3875.895269821694
    },
    "selected": false
  }, {
    "data": {
      "id": "81",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Duhem",
      "birth_year": 1861,
      "given_name": "Pierre",
      "death_year": 1916,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paul_Drude",
      "family_name": "Duhem",
      "gender": "male"
    },
    "position": {
      "x": 3665.983906529955,
      "y": 3144.4308274238415
    },
    "selected": false
  }, {
    "data": {
      "id": "312",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Giovanni Plana",
      "birth_year": 1781,
      "given_name": "Giovanni",
      "death_year": 1864,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Giovanni_Antonio_Amedeo_Plana",
      "family_name": "Plana",
      "gender": "male"
    },
    "position": {
      "x": 4490.6685524398645,
      "y": 3317.8706218252178
    },
    "selected": false
  }, {
    "data": {
      "id": "340",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walther Ritz",
      "birth_year": 1878,
      "given_name": "Walther",
      "death_year": 1909,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walther_Ritz",
      "family_name": "Ritz",
      "gender": "male"
    },
    "position": {
      "x": 4886.194101925168,
      "y": 3171.225524782966
    },
    "selected": false
  }, {
    "data": {
      "id": "187",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stephen Kleene",
      "birth_year": 1909,
      "given_name": "Stephen",
      "death_year": 1994,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Stephen_Cole_Kleene",
      "family_name": "Kleene",
      "gender": "male"
    },
    "position": {
      "x": 2604.8833710007043,
      "y": 3859.5340294434595
    },
    "selected": false
  }, {
    "data": {
      "id": "213",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Johann Lambert",
      "birth_year": 1728,
      "given_name": "Johann",
      "death_year": 1777,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Johann_Heinrich_Lambert",
      "family_name": "Lambert",
      "gender": "male"
    },
    "position": {
      "x": 5282.03312628252,
      "y": 4358.898589792437
    },
    "selected": false
  }, {
    "data": {
      "id": "329",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Srinivasa Ramanujan",
      "birth_year": 1887,
      "given_name": "Srinivasa",
      "death_year": 1920,
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/Srinivasa_Ramanujan",
      "family_name": "Ramanujan",
      "gender": "male"
    },
    "position": {
      "x": 3965.775445757369,
      "y": 4275.064840378103
    },
    "selected": false
  }, {
    "data": {
      "id": "398",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Andrei Suslin",
      "birth_year": 1950,
      "given_name": "Andrei",
      "death_year": 2018,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Andrei_Suslin",
      "family_name": "Suslin",
      "gender": "male"
    },
    "position": {
      "x": 5397.86560720149,
      "y": 3772.5371276577584
    },
    "selected": false
  }, {
    "data": {
      "id": "9",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hyman Bass",
      "birth_year": 1932,
      "given_name": "Hyman",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hyman_Bass",
      "family_name": "Bass",
      "gender": "male"
    },
    "position": {
      "x": 5165.033254123893,
      "y": 3843.530431997457
    },
    "selected": false
  }, {
    "data": {
      "id": "344",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vera Rubin",
      "birth_year": 1928,
      "given_name": "Vera",
      "death_year": 2016,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vera_Rubin",
      "family_name": "Rubin",
      "gender": "female"
    },
    "position": {
      "x": 3568.24831248065,
      "y": 2600.4262206494227
    },
    "selected": false
  }, {
    "data": {
      "id": "189",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Oskar Klein",
      "birth_year": 1894,
      "given_name": "Oskar",
      "death_year": 1977,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Oskar_Klein",
      "family_name": "Klein",
      "gender": "male"
    },
    "position": {
      "x": 1973.8243608079738,
      "y": 4156.2725051779935
    },
    "selected": false
  }, {
    "data": {
      "id": "346",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Ruelle",
      "birth_year": 1935,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "Belgium",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Ruelle#See_also",
      "family_name": "Ruelle",
      "gender": "male"
    },
    "position": {
      "x": 2708.384917589201,
      "y": 3505.3543527256647
    },
    "selected": false
  }, {
    "data": {
      "id": "227",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sophus Lie",
      "birth_year": 1842,
      "given_name": "Sophus",
      "death_year": 1899,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sophus_Lie",
      "family_name": "Lie",
      "gender": "male"
    },
    "position": {
      "x": 2272.9198895797917,
      "y": 4193.342189703701
    },
    "selected": false
  }, {
    "data": {
      "id": "294",
      "selected": false,
      "NodeType": "Cheese",
      "name": "A Okubo",
      "birth_year": "missing",
      "given_name": "A",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Okubo",
      "gender": "missing"
    },
    "position": {
      "x": 3689.842234478684,
      "y": 5000.0
    },
    "selected": false
  }, {
    "data": {
      "id": "109",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walther Gerlach",
      "birth_year": 1889,
      "given_name": "Walther",
      "death_year": 1979,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walther_Gerlach",
      "family_name": "Gerlach",
      "gender": "male"
    },
    "position": {
      "x": 5525.261212406472,
      "y": 4192.445510184362
    },
    "selected": false
  }, {
    "data": {
      "id": "409",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Stanisław Ulam",
      "birth_year": 1909,
      "given_name": "Stanisław",
      "death_year": 1984,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Stanislaw_Ulam",
      "family_name": "Ulam",
      "gender": "male"
    },
    "position": {
      "x": 5698.38338669042,
      "y": 4362.711490733836
    },
    "selected": false
  }, {
    "data": {
      "id": "161",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Christiaan Huygens",
      "birth_year": 1629,
      "given_name": "Christiaan",
      "death_year": 1695,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Christiaan_Huygens",
      "family_name": "Huygens",
      "gender": "male"
    },
    "position": {
      "x": 4633.358825811512,
      "y": 3842.9805557792715
    },
    "selected": false
  }, {
    "data": {
      "id": "445",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Clarence Zener",
      "birth_year": 1905,
      "given_name": "Clarence",
      "death_year": 1993,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Clarence_Zener",
      "family_name": "Zener",
      "gender": "male"
    },
    "position": {
      "x": 4979.2150759209035,
      "y": 3697.8464373661827
    },
    "selected": false
  }, {
    "data": {
      "id": "249",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carlo Marangoni",
      "birth_year": 1840,
      "given_name": "Carlo",
      "death_year": 1925,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carlo_Marangoni",
      "family_name": "Marangoni",
      "gender": "male"
    },
    "position": {
      "x": 3587.831417305001,
      "y": 3064.7694657822653
    },
    "selected": false
  }, {
    "data": {
      "id": "383",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Stallings",
      "birth_year": 1935,
      "given_name": "John",
      "death_year": 2008,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_R._Stallings",
      "family_name": "Stallings",
      "gender": "male"
    },
    "position": {
      "x": 4559.577754647242,
      "y": 3860.298776256015
    },
    "selected": false
  }, {
    "data": {
      "id": "395",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Steven Strogatz",
      "birth_year": 1959,
      "given_name": "Steven",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Steven_Strogatz",
      "family_name": "Strogatz",
      "gender": "male"
    },
    "position": {
      "x": 3649.903578364284,
      "y": 2926.2808203438904
    },
    "selected": false
  }, {
    "data": {
      "id": "372",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lev Shubnikov",
      "birth_year": 1901,
      "given_name": "Lev",
      "death_year": 1937,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lev_Shubnikov",
      "family_name": "Shubnikov",
      "gender": "male"
    },
    "position": {
      "x": 3245.7623053765965,
      "y": 3659.240929856336
    },
    "selected": false
  }, {
    "data": {
      "id": "241",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alfred Lotka",
      "birth_year": 1880,
      "given_name": "Alfred",
      "death_year": 1949,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ludvig_Lorenz",
      "family_name": "Lotka",
      "gender": "male"
    },
    "position": {
      "x": 3478.035706310606,
      "y": 3850.953275012559
    },
    "selected": false
  }, {
    "data": {
      "id": "401",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Niccolò Tartaglia",
      "birth_year": 1500,
      "given_name": "Niccolò",
      "death_year": 1557,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Niccolò_Fontana_Tartaglia",
      "family_name": "Tartaglia",
      "gender": "male"
    },
    "position": {
      "x": 3555.6089552051485,
      "y": 4914.397766844848
    },
    "selected": false
  }, {
    "data": {
      "id": "88",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Thomas Farrell",
      "birth_year": 1941,
      "given_name": "Thomas",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/F._Thomas_Farrell",
      "family_name": "Farrell",
      "gender": "male"
    },
    "position": {
      "x": 5434.430906488048,
      "y": 4001.5256048882043
    },
    "selected": false
  }, {
    "data": {
      "id": "209",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Masatake Kuranishi",
      "birth_year": 1924,
      "given_name": "Masatake",
      "death_year": "missing",
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Masatake_Kuranishi",
      "family_name": "Kuranishi",
      "gender": "male"
    },
    "position": {
      "x": 3524.0965977249502,
      "y": 3685.2142209294298
    },
    "selected": false
  }, {
    "data": {
      "id": "236",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Littlewood",
      "birth_year": 1885,
      "given_name": "John",
      "death_year": 1977,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Edensor_Littlewood",
      "family_name": "Littlewood",
      "gender": "male"
    },
    "position": {
      "x": 3792.5405416044578,
      "y": 4375.159588423295
    },
    "selected": false
  }, {
    "data": {
      "id": "120",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Grassmann",
      "birth_year": 1809,
      "given_name": "Hermann",
      "death_year": 1877,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Grassmann",
      "family_name": "Grassmann",
      "gender": "male"
    },
    "position": {
      "x": 4365.517747807491,
      "y": 3160.8340400162306
    },
    "selected": false
  }, {
    "data": {
      "id": "323",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Laurent Pothenot",
      "birth_year": 1650,
      "given_name": "Laurent",
      "death_year": 1732,
      "birth_country": "France",
      "race": "white",
      "reference": "https://fr.wikipedia.org/wiki/Laurent_Pothenot",
      "family_name": "Pothenot",
      "gender": "male"
    },
    "position": {
      "x": 1387.971004009623,
      "y": 3335.8601457628934
    },
    "selected": false
  }, {
    "data": {
      "id": "260",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Mermin",
      "birth_year": 1935,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/N._David_Mermin",
      "family_name": "Mermin",
      "gender": "male"
    },
    "position": {
      "x": 4282.101773048429,
      "y": 4923.015338861043
    },
    "selected": false
  }, {
    "data": {
      "id": "297",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Oppenheimer",
      "birth_year": 1904,
      "given_name": "Robert",
      "death_year": 1967,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/J._Robert_Oppenheimer",
      "family_name": "Oppenheimer",
      "gender": "male"
    },
    "position": {
      "x": 3262.932821438151,
      "y": 3415.124751155265
    },
    "selected": false
  }, {
    "data": {
      "id": "24",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Niels Bohr",
      "birth_year": 1885,
      "given_name": "Niels",
      "death_year": 1962,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Niels_Bohr",
      "family_name": "Bohr",
      "gender": "male"
    },
    "position": {
      "x": 4468.675306031488,
      "y": 2527.188700582837
    },
    "selected": false
  }, {
    "data": {
      "id": "8",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Iacopo Barsotti",
      "birth_year": 1921,
      "given_name": "Iacopo",
      "death_year": 1987,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Iacopo_Barsotti",
      "family_name": "Barsotti",
      "gender": "male"
    },
    "position": {
      "x": 5338.648134290883,
      "y": 4004.372034731101
    },
    "selected": false
  }, {
    "data": {
      "id": "37",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gerolamo Cardano",
      "birth_year": 1501,
      "given_name": "Gerolamo",
      "death_year": 1576,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gerolamo_Cardano",
      "family_name": "Cardano",
      "gender": "male"
    },
    "position": {
      "x": 3569.276416115534,
      "y": 4889.523929211184
    },
    "selected": false
  }, {
    "data": {
      "id": "83",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Robert Emden",
      "birth_year": 1862,
      "given_name": "Robert",
      "death_year": 1940,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_Emden",
      "family_name": "Emden",
      "gender": "male"
    },
    "position": {
      "x": 4455.051575799551,
      "y": 4399.13404635824
    },
    "selected": false
  }, {
    "data": {
      "id": "190",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Martin Knudsen",
      "birth_year": 1871,
      "given_name": "Martin",
      "death_year": 1949,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Martin_Knudsen",
      "family_name": "Knudsen",
      "gender": "male"
    },
    "position": {
      "x": 4064.7957375243755,
      "y": 2979.7334028844552
    },
    "selected": false
  }, {
    "data": {
      "id": "201",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Koster",
      "birth_year": 1927,
      "given_name": "George",
      "death_year": 2012,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://www.google.com/search?client=safari&rls=en&q=george+fred+koster&ie=UTF-8&oe=UTF-8",
      "family_name": "Koster",
      "gender": "male"
    },
    "position": {
      "x": 3421.2934473309383,
      "y": 3085.914065192044
    },
    "selected": false
  }, {
    "data": {
      "id": "99",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ralph Fowler",
      "birth_year": 1889,
      "given_name": "Ralph",
      "death_year": 1944,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ralph_H._Fowler",
      "family_name": "Fowler",
      "gender": "male"
    },
    "position": {
      "x": 4686.310964168293,
      "y": 2789.182977752134
    },
    "selected": false
  }, {
    "data": {
      "id": "121",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Albert Green",
      "birth_year": 1912,
      "given_name": "Albert",
      "death_year": 1999,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Albert_E._Green",
      "family_name": "Green",
      "gender": "male"
    },
    "position": {
      "x": 4558.147440917258,
      "y": 3059.7234736044243
    },
    "selected": false
  }, {
    "data": {
      "id": "311",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Émile Picard",
      "birth_year": 1856,
      "given_name": "Émile",
      "death_year": 1941,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Émile_Picard",
      "family_name": "Picard",
      "gender": "male"
    },
    "position": {
      "x": 2577.45422792405,
      "y": 3470.1255016693103
    },
    "selected": false
  }, {
    "data": {
      "id": "281",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Mullins",
      "birth_year": 1927,
      "given_name": "William",
      "death_year": 2001,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_W._Mullins",
      "family_name": "Mullins",
      "gender": "male"
    },
    "position": {
      "x": 2487.5489697289277,
      "y": 3480.8183999311477
    },
    "selected": false
  }, {
    "data": {
      "id": "14",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Bernal",
      "birth_year": 1901,
      "given_name": "John",
      "death_year": 1971,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/J._D._Bernal",
      "family_name": "Bernal",
      "gender": "male"
    },
    "position": {
      "x": 4722.413132303684,
      "y": 2750.358259855045
    },
    "selected": false
  }, {
    "data": {
      "id": "386",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Josef Stefan",
      "birth_year": 1835,
      "given_name": "Josef",
      "death_year": 1893,
      "birth_country": "Austria",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Josef_Stefan",
      "family_name": "Stefan",
      "gender": "male"
    },
    "position": {
      "x": 5134.077915552257,
      "y": 4555.364931507326
    },
    "selected": false
  }, {
    "data": {
      "id": "433",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Edmund Whittaker",
      "birth_year": 1873,
      "given_name": "Edmund",
      "death_year": 1956,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/E._T._Whittaker",
      "family_name": "Whittaker",
      "gender": "male"
    },
    "position": {
      "x": 2695.656609313217,
      "y": 4170.080629766675
    },
    "selected": false
  }, {
    "data": {
      "id": "314",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Plateau",
      "birth_year": 1801,
      "given_name": "Joseph",
      "death_year": 1883,
      "birth_country": "Belgium",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Plateau",
      "family_name": "Plateau",
      "gender": "male"
    },
    "position": {
      "x": 4928.546478723463,
      "y": 3174.0122135971123
    },
    "selected": false
  }, {
    "data": {
      "id": "357",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Friedrich Schottky",
      "birth_year": 1851,
      "given_name": "Friedrich",
      "death_year": 1935,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Friedrich_Schottky",
      "family_name": "Schottky",
      "gender": "male"
    },
    "position": {
      "x": 4242.213183594875,
      "y": 3090.971371685113
    },
    "selected": false
  }, {
    "data": {
      "id": "334",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Rehner",
      "birth_year": "missing",
      "given_name": "John",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Rehner",
      "gender": "missing"
    },
    "position": {
      "x": 5029.062714949023,
      "y": 2929.2307949806764
    },
    "selected": false
  }, {
    "data": {
      "id": "403",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Geoffrey Taylor",
      "birth_year": 1886,
      "given_name": "Geoffrey",
      "death_year": 1975,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/G._I._Taylor",
      "family_name": "Taylor",
      "gender": "male"
    },
    "position": {
      "x": 4625.107093509172,
      "y": 3105.0559586361296
    },
    "selected": false
  }, {
    "data": {
      "id": "174",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Émile Jouguet",
      "birth_year": 1871,
      "given_name": "Émile",
      "death_year": 1943,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Émile_Jouguet",
      "family_name": "Jouguet",
      "gender": "male"
    },
    "position": {
      "x": 2421.007469191898,
      "y": 4612.992732131781
    },
    "selected": false
  }, {
    "data": {
      "id": "322",
      "selected": false,
      "NodeType": "Cheese",
      "name": "P. Popper",
      "birth_year": "missing",
      "given_name": "P.",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Popper",
      "gender": "missing"
    },
    "position": {
      "x": 4977.594500652922,
      "y": 4723.531161456632
    },
    "selected": false
  }, {
    "data": {
      "id": "269",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Christian Møller",
      "birth_year": 1904,
      "given_name": "Christian",
      "death_year": 1980,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Christian_Møller",
      "family_name": "Møller",
      "gender": "male"
    },
    "position": {
      "x": 5054.712012822714,
      "y": 3103.4387666196144
    },
    "selected": false
  }, {
    "data": {
      "id": "315",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Milton Plesset",
      "birth_year": 1908,
      "given_name": "Milton",
      "death_year": 1991,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Milton_S._Plesset",
      "family_name": "Plesset",
      "gender": "male"
    },
    "position": {
      "x": 4952.777063444386,
      "y": 3139.4615955151576
    },
    "selected": false
  }, {
    "data": {
      "id": "123",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Melville Green",
      "birth_year": 1922,
      "given_name": "Melville",
      "death_year": 1979,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Melville_S._Green",
      "family_name": "Green",
      "gender": "male"
    },
    "position": {
      "x": 1965.5095506061466,
      "y": 2942.8532202002825
    },
    "selected": false
  }, {
    "data": {
      "id": "305",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Penney",
      "birth_year": 1909,
      "given_name": "William",
      "death_year": 1991,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_Penney,_Baron_Penney",
      "family_name": "Penney",
      "gender": "male"
    },
    "position": {
      "x": 2724.947343016367,
      "y": 3186.7274320509096
    },
    "selected": false
  }, {
    "data": {
      "id": "268",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Georg Mohr",
      "birth_year": 1640,
      "given_name": "Georg",
      "death_year": 1697,
      "birth_country": "Denmark",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Georg_Mohr",
      "family_name": "Mohr",
      "gender": "male"
    },
    "position": {
      "x": 3376.926082574367,
      "y": 3902.929570713506
    },
    "selected": false
  }, {
    "data": {
      "id": "423",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gregory Wannier",
      "birth_year": 1911,
      "given_name": "Gregory",
      "death_year": 1983,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gregory_Wannier",
      "family_name": "Wannier",
      "gender": "male"
    },
    "position": {
      "x": 2922.100018141966,
      "y": 3040.393889542144
    },
    "selected": false
  }, {
    "data": {
      "id": "32",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Luitzen Brouwer",
      "birth_year": 1881,
      "given_name": "Luitzen",
      "death_year": 1966,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/L._E._J._Brouwer",
      "family_name": "Brouwer",
      "gender": "male"
    },
    "position": {
      "x": 2556.7056603792744,
      "y": 3768.5055265676983
    },
    "selected": false
  }, {
    "data": {
      "id": "197",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Tatiana Kontorova",
      "birth_year": "missing",
      "given_name": "Tatiana",
      "death_year": "missing",
      "birth_country": "Russia",
      "race": "white",
      "reference": "missing",
      "family_name": "Kontorova",
      "gender": "female"
    },
    "position": {
      "x": 5978.28820117135,
      "y": 3696.297351347922
    },
    "selected": false
  }, {
    "data": {
      "id": "233",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Liouville",
      "birth_year": 1809,
      "given_name": "Joseph",
      "death_year": 1882,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Liouville",
      "family_name": "Liouville",
      "gender": "male"
    },
    "position": {
      "x": 3709.492222763658,
      "y": 3608.6564771667363
    },
    "selected": false
  }, {
    "data": {
      "id": "196",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Andrey Kolmogorov",
      "birth_year": 1903,
      "given_name": "Andrey",
      "death_year": 1987,
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Andrey_Kolmogorov",
      "family_name": "Kolmogorov",
      "gender": "male"
    },
    "position": {
      "x": 3812.008540897075,
      "y": 4292.2799340827205
    },
    "selected": false
  }, {
    "data": {
      "id": "262",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Nicholas Metropolis",
      "birth_year": 1915,
      "given_name": "Nicholas",
      "death_year": 1999,
      "birth_country": "Greece",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Nicholas_Metropolis",
      "family_name": "Metropolis",
      "gender": "male"
    },
    "position": {
      "x": 2079.0452274833515,
      "y": 4359.132440239816
    },
    "selected": false
  }, {
    "data": {
      "id": "320",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean-Victor Poncelet",
      "birth_year": 1788,
      "given_name": "Jean-Victor",
      "death_year": 1867,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean-Victor_Poncelet",
      "family_name": "Poncelet",
      "gender": "male"
    },
    "position": {
      "x": 4558.523969981074,
      "y": 3807.907146898516
    },
    "selected": false
  }, {
    "data": {
      "id": "408",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alan Turing",
      "birth_year": 1912,
      "given_name": "Alan",
      "death_year": 1954,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Alan_Turing",
      "family_name": "Turing",
      "gender": "male"
    },
    "position": {
      "x": 2675.7165733229067,
      "y": 3972.0589842379272
    },
    "selected": false
  }, {
    "data": {
      "id": "324",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ludwig Prandtl",
      "birth_year": 1875,
      "given_name": "Ludwig",
      "death_year": 1953,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ludwig_Prandtl",
      "family_name": "Prandtl",
      "gender": "male"
    },
    "position": {
      "x": 4149.587157662658,
      "y": 4405.611378246817
    },
    "selected": false
  }, {
    "data": {
      "id": "210",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Wilhelm Kutta",
      "birth_year": 1867,
      "given_name": "Wilhelm",
      "death_year": 1944,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Martin_Kutta",
      "family_name": "Kutta",
      "gender": "male"
    },
    "position": {
      "x": 3164.0816576111893,
      "y": 4883.37695243682
    },
    "selected": false
  }, {
    "data": {
      "id": "151",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Otto Hölder",
      "birth_year": 1859,
      "given_name": "Otto",
      "death_year": 1937,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Otto_Hölder",
      "family_name": "Hölder",
      "gender": "male"
    },
    "position": {
      "x": 2293.6608312179214,
      "y": 3801.8399043682666
    },
    "selected": false
  }, {
    "data": {
      "id": "239",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hendrik Lorentz",
      "birth_year": 1853,
      "given_name": "Hendrik",
      "death_year": 1928,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hendrik_Lorentz",
      "family_name": "Lorentz",
      "gender": "male"
    },
    "position": {
      "x": 4692.661656418689,
      "y": 3350.926878580205
    },
    "selected": false
  }, {
    "data": {
      "id": "54",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Alfred Clebsch",
      "birth_year": 1833,
      "given_name": "Alfred",
      "death_year": 1872,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Clebsch–Gordan_coefficients",
      "family_name": "Clebsch",
      "gender": "male"
    },
    "position": {
      "x": 5829.252125653523,
      "y": 3856.761272043217
    },
    "selected": false
  }, {
    "data": {
      "id": "63",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Georges Darrieus",
      "birth_year": 188,
      "given_name": "Georges",
      "death_year": 1979,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Georges_Jean_Marie_Darrieus",
      "family_name": "Darrieus",
      "gender": "male"
    },
    "position": {
      "x": 5312.910456194937,
      "y": 3709.496656935864
    },
    "selected": false
  }, {
    "data": {
      "id": "191",
      "selected": false,
      "NodeType": "Cheese",
      "name": "James Koehler",
      "birth_year": 1914,
      "given_name": "James",
      "death_year": 2006,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/James_Stark_Koehler",
      "family_name": "Koehler",
      "gender": "male"
    },
    "position": {
      "x": 6190.314436167639,
      "y": 3782.3661273730313
    },
    "selected": false
  }, {
    "data": {
      "id": "91",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Feynman",
      "birth_year": 1918,
      "given_name": "Richard",
      "death_year": 1988,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Feynman",
      "family_name": "Feynman",
      "gender": "male"
    },
    "position": {
      "x": 2301.4805370990844,
      "y": 3135.599476379898
    },
    "selected": false
  }, {
    "data": {
      "id": "62",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean d’Alembert",
      "birth_year": 1717,
      "given_name": "Jean",
      "death_year": 1783,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean_le_Rond_d%27Alembert",
      "family_name": "d’Alembert",
      "gender": "male"
    },
    "position": {
      "x": 3485.2051326388632,
      "y": 3819.613492263141
    },
    "selected": false
  }, {
    "data": {
      "id": "205",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ralph Kronig",
      "birth_year": 1904,
      "given_name": "Ralph",
      "death_year": 1995,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ralph_Kronig",
      "family_name": "Kronig",
      "gender": "male"
    },
    "position": {
      "x": 2774.95410608729,
      "y": 3153.7709530895486
    },
    "selected": false
  }, {
    "data": {
      "id": "244",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Aleksandr Lyapunov",
      "birth_year": 1857,
      "given_name": "Aleksandr",
      "death_year": 1918,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Aleksandr_Lyapunov",
      "family_name": "Lyapunov",
      "gender": "male"
    },
    "position": {
      "x": 4013.8083734649667,
      "y": 3879.514467870301
    },
    "selected": false
  }, {
    "data": {
      "id": "327",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans-Joachim Queisser",
      "birth_year": 1931,
      "given_name": "Hans-Joachim",
      "death_year": "missing",
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hans-Joachim_Queisser",
      "family_name": "Queisser",
      "gender": "male"
    },
    "position": {
      "x": 1719.1921777071589,
      "y": 3337.172370156104
    },
    "selected": false
  }, {
    "data": {
      "id": "150",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Pierre Hohenberg",
      "birth_year": 1934,
      "given_name": "Pierre",
      "death_year": 2017,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pierre_Hohenberg",
      "family_name": "Hohenberg",
      "gender": "male"
    },
    "position": {
      "x": 1477.839347243434,
      "y": 3878.921523539273
    },
    "selected": false
  }, {
    "data": {
      "id": "122",
      "selected": false,
      "NodeType": "Cheese",
      "name": "George Green",
      "birth_year": 1793,
      "given_name": "George",
      "death_year": 1841,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/George_Green_(mathematician)",
      "family_name": "Green",
      "gender": "male"
    },
    "position": {
      "x": 3628.980755124999,
      "y": 3587.826630390604
    },
    "selected": false
  }, {
    "data": {
      "id": "58",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Cox",
      "birth_year": 1924,
      "given_name": "David",
      "death_year": "missing",
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Cox_(statistician)",
      "family_name": "Cox",
      "gender": "male"
    },
    "position": {
      "x": 4104.153742432886,
      "y": 4537.122627465969
    },
    "selected": false
  }, {
    "data": {
      "id": "199",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Diederik Korteweg",
      "birth_year": 1848,
      "given_name": "Diederik",
      "death_year": 1941,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Bernard_Koopman",
      "family_name": "Korteweg",
      "gender": "male"
    },
    "position": {
      "x": 5971.935625951349,
      "y": 4034.544337701751
    },
    "selected": false
  }, {
    "data": {
      "id": "434",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gustav Wiedemann",
      "birth_year": 1826,
      "given_name": "Gustav",
      "death_year": 1899,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gustav_Heinrich_Wiedemann",
      "family_name": "Wiedemann",
      "gender": "male"
    },
    "position": {
      "x": 3764.6187888461577,
      "y": 2538.628147798608
    },
    "selected": false
  }, {
    "data": {
      "id": "173",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Wilhelm Jordan",
      "birth_year": 1842,
      "given_name": "Wilhelm",
      "death_year": 1899,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Wilhelm_Jordan_(geodesist)",
      "family_name": "Jordan",
      "gender": "male"
    },
    "position": {
      "x": 4179.95506953682,
      "y": 3472.5482517679907
    },
    "selected": false
  }, {
    "data": {
      "id": "256",
      "selected": false,
      "NodeType": "Cheese",
      "name": "James Maxwell",
      "birth_year": 1831,
      "given_name": "James",
      "death_year": 1879,
      "birth_country": "Scotland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/James_Clerk_Maxwell",
      "family_name": "Maxwell",
      "gender": "male"
    },
    "position": {
      "x": 5180.569327455565,
      "y": 4524.569823304354
    },
    "selected": false
  }, {
    "data": {
      "id": "188",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Felix Klein",
      "birth_year": 1849,
      "given_name": "Felix",
      "death_year": 1925,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Felix_Klein",
      "family_name": "Klein",
      "gender": "male"
    },
    "position": {
      "x": 4193.762812901194,
      "y": 3076.791501782885
    },
    "selected": false
  }, {
    "data": {
      "id": "277",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Theodore Motzkin",
      "birth_year": 1908,
      "given_name": "Theodore",
      "death_year": 1970,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Theodore_Motzkin",
      "family_name": "Motzkin",
      "gender": "male"
    },
    "position": {
      "x": 3142.058363277522,
      "y": 3927.9897372572905
    },
    "selected": false
  }, {
    "data": {
      "id": "361",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hermann Schwarz",
      "birth_year": 1843,
      "given_name": "Hermann",
      "death_year": 1921,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hermann_Schwarz",
      "family_name": "Schwarz",
      "gender": "male"
    },
    "position": {
      "x": 3532.7046423718325,
      "y": 3564.559093562896
    },
    "selected": false
  }, {
    "data": {
      "id": "98",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Joseph Fourier",
      "birth_year": 1768,
      "given_name": "Joseph",
      "death_year": 1830,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Joseph_Fourier",
      "family_name": "Fourier",
      "gender": "male"
    },
    "position": {
      "x": 3241.400253902698,
      "y": 3902.096799631926
    },
    "selected": false
  }, {
    "data": {
      "id": "355",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Erhard Schmidt",
      "birth_year": 1876,
      "given_name": "Erhard",
      "death_year": 1959,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Erhard_Schmidt#See_also",
      "family_name": "Schmidt",
      "gender": "male"
    },
    "position": {
      "x": 3885.944294298332,
      "y": 3859.010904530517
    },
    "selected": false
  }, {
    "data": {
      "id": "235",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Lipschitz",
      "birth_year": 1832,
      "given_name": "Rudolf",
      "death_year": 1903,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolf_Lipschitz",
      "family_name": "Lipschitz",
      "gender": "male"
    },
    "position": {
      "x": 3457.330949935139,
      "y": 3552.3689064130767
    },
    "selected": false
  }, {
    "data": {
      "id": "204",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leopold Kronecker",
      "birth_year": 1823,
      "given_name": "Leopold",
      "death_year": 1891,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Leopold_Kronecker",
      "family_name": "Kronecker",
      "gender": "male"
    },
    "position": {
      "x": 5373.674386108167,
      "y": 4712.449635366966
    },
    "selected": false
  }, {
    "data": {
      "id": "385",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Kenneth Starling",
      "birth_year": 1935,
      "given_name": "Kenneth",
      "death_year": 2019,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://cen.acs.org/people/obituaries/Obituary-Kenneth-E-Starling/98/i8",
      "family_name": "Starling",
      "gender": "male"
    },
    "position": {
      "x": 6107.85551339627,
      "y": 3197.1402122156196
    },
    "selected": false
  }, {
    "data": {
      "id": "377",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Nikolai Smirnov",
      "birth_year": 1900,
      "given_name": "Nikolai",
      "death_year": 1966,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Nikolai_Smirnov_(mathematician)",
      "family_name": "Smirnov",
      "gender": "male"
    },
    "position": {
      "x": 3779.2578821875627,
      "y": 4279.143445180927
    },
    "selected": false
  }, {
    "data": {
      "id": "411",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hendrika van Leeuwen",
      "birth_year": 1887,
      "given_name": "Hendrika",
      "death_year": 1974,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hendrika_Johanna_van_Leeuwen",
      "family_name": "van Leeuwen",
      "gender": "female"
    },
    "position": {
      "x": 4424.0902026931635,
      "y": 2522.222891983315
    },
    "selected": false
  }, {
    "data": {
      "id": "310",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Lars Phragmén",
      "birth_year": 1863,
      "given_name": "Lars",
      "death_year": 1937,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Lars_Edvard_Phragmén",
      "family_name": "Phragmén",
      "gender": "male"
    },
    "position": {
      "x": 2579.455166599922,
      "y": 3667.313219968948
    },
    "selected": false
  }, {
    "data": {
      "id": "321",
      "selected": false,
      "NodeType": "Cheese",
      "name": "HH Poole",
      "birth_year": "missing",
      "given_name": "HH",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Poole",
      "gender": "missing"
    },
    "position": {
      "x": 5966.713006336011,
      "y": 3745.2904925350595
    },
    "selected": false
  }, {
    "data": {
      "id": "371",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Shockley",
      "birth_year": 1910,
      "given_name": "William",
      "death_year": 1989,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_Shockley",
      "family_name": "Shockley",
      "gender": "male"
    },
    "position": {
      "x": 1740.6686422107566,
      "y": 3316.509204527491
    },
    "selected": false
  }, {
    "data": {
      "id": "384",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Johannes Stark",
      "birth_year": 1875,
      "given_name": "Johannes",
      "death_year": 1957,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Johannes_Stark",
      "family_name": "Stark",
      "gender": "male"
    },
    "position": {
      "x": 3451.796783276245,
      "y": 3627.830079348054
    },
    "selected": false
  }, {
    "data": {
      "id": "76",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ulisse Dini",
      "birth_year": 1845,
      "given_name": "Ulisse",
      "death_year": 1918,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ulisse_Dini#See_also",
      "family_name": "Dini",
      "gender": "male"
    },
    "position": {
      "x": 3398.5791473072377,
      "y": 3512.173254714366
    },
    "selected": false
  }, {
    "data": {
      "id": "34",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Butler",
      "birth_year": 1899,
      "given_name": "John",
      "death_year": 1977,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Alfred_Valentine_Butler",
      "family_name": "Butler",
      "gender": "male"
    },
    "position": {
      "x": 5473.035219680462,
      "y": 4259.619611287672
    },
    "selected": false
  }, {
    "data": {
      "id": "50",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Charlier",
      "birth_year": 1862,
      "given_name": "Carl",
      "death_year": 1934,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carl_Charlier",
      "family_name": "Charlier",
      "gender": "male"
    },
    "position": {
      "x": 4036.943915412493,
      "y": 3953.9450901764326
    },
    "selected": false
  }, {
    "data": {
      "id": "243",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Nikolai Luzin",
      "birth_year": 1883,
      "given_name": "Nikolai",
      "death_year": 1950,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Nikolai_Luzin",
      "family_name": "Luzin",
      "gender": "male"
    },
    "position": {
      "x": 5070.057868028938,
      "y": 3602.6801489011787
    },
    "selected": false
  }, {
    "data": {
      "id": "318",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Siméon Poisson",
      "birth_year": 1781,
      "given_name": "Siméon",
      "death_year": 1840,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Siméon_Denis_Poisson",
      "family_name": "Poisson",
      "gender": "male"
    },
    "position": {
      "x": 2190.663737840633,
      "y": 4222.818944554613
    },
    "selected": false
  }, {
    "data": {
      "id": "194",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jurjen Koksma",
      "birth_year": 1904,
      "given_name": "Jurjen",
      "death_year": 1964,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jurjen_Ferdinand_Koksma",
      "family_name": "Koksma",
      "gender": "male"
    },
    "position": {
      "x": 4766.923727533714,
      "y": 3632.8967439351504
    },
    "selected": false
  }, {
    "data": {
      "id": "167",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Gwilym Jenkins",
      "birth_year": 1932,
      "given_name": "Gwilym",
      "death_year": 1982,
      "birth_country": "Wales",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Gwilym_Jenkins",
      "family_name": "Jenkins",
      "gender": "male"
    },
    "position": {
      "x": 4149.342754747101,
      "y": 4674.9228599774415
    },
    "selected": false
  }, {
    "data": {
      "id": "42",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Aharon Casher",
      "birth_year": 1941,
      "given_name": "Aharon",
      "death_year": 2018,
      "birth_country": "Palestine",
      "race": "white",
      "reference": "https://physics.tau.ac.il/in_memoriam_casher",
      "family_name": "Casher",
      "gender": "male"
    },
    "position": {
      "x": 2097.236766519904,
      "y": 4362.941282454454
    },
    "selected": false
  }, {
    "data": {
      "id": "87",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Leonhard Euler",
      "birth_year": 1707,
      "given_name": "Leonhard",
      "death_year": 1783,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Robert_Emden",
      "family_name": "Euler",
      "gender": "male"
    },
    "position": {
      "x": 3480.6096906974285,
      "y": 3767.7232509434075
    },
    "selected": false
  }, {
    "data": {
      "id": "132",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Godfrey Hardy",
      "birth_year": 1877,
      "given_name": "Godfrey",
      "death_year": 1947,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/G._H._Hardy",
      "family_name": "Hardy",
      "gender": "male"
    },
    "position": {
      "x": 3905.453241825198,
      "y": 4357.5371712586475
    },
    "selected": false
  }, {
    "data": {
      "id": "140",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Werner Heisenberg",
      "birth_year": 1901,
      "given_name": "Werner",
      "death_year": 1976,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Werner_Heisenberg",
      "family_name": "Heisenberg",
      "gender": "male"
    },
    "position": {
      "x": 2735.6045104369514,
      "y": 3033.176568573055
    },
    "selected": false
  }, {
    "data": {
      "id": "202",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sofya Kovalevskaya",
      "birth_year": 1850,
      "given_name": "Sofya",
      "death_year": 1891,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sofya_Kovalevskaya",
      "family_name": "Kovalevskaya",
      "gender": "female"
    },
    "position": {
      "x": 3478.562787426357,
      "y": 3574.7021453369507
    },
    "selected": false
  }, {
    "data": {
      "id": "248",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Yuri Manin",
      "birth_year": 1937,
      "given_name": "Yuri",
      "death_year": "missing",
      "birth_country": "Soviet Union",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Yuri_Manin",
      "family_name": "Manin",
      "gender": "male"
    },
    "position": {
      "x": 3893.156926995087,
      "y": 3618.3474599244705
    },
    "selected": false
  }, {
    "data": {
      "id": "169",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Johnson",
      "birth_year": 1887,
      "given_name": "John",
      "death_year": 1970,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Bertrand_Johnson",
      "family_name": "Johnson",
      "gender": "male"
    },
    "position": {
      "x": 2892.9586285539976,
      "y": 4157.064635545528
    },
    "selected": false
  }, {
    "data": {
      "id": "301",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Palais",
      "birth_year": 1931,
      "given_name": "Richard",
      "death_year": "missing",
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Palais",
      "family_name": "Palais",
      "gender": "male"
    },
    "position": {
      "x": 2319.4750858419616,
      "y": 4132.102076576627
    },
    "selected": false
  }, {
    "data": {
      "id": "317",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jean Poiseuille",
      "birth_year": 1797,
      "given_name": "Jean",
      "death_year": 1869,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jean_Léonard_Marie_Poiseuille",
      "family_name": "Poiseuille",
      "gender": "male"
    },
    "position": {
      "x": 2000.8986836447823,
      "y": 4455.218857401282
    },
    "selected": false
  }, {
    "data": {
      "id": "442",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Chen-Ning Yang",
      "birth_year": 1922,
      "given_name": "Chen-Ning",
      "death_year": "missing",
      "birth_country": "China",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Yang_Chen-Ning",
      "family_name": "Yang",
      "gender": "male"
    },
    "position": {
      "x": 5174.731666510937,
      "y": 3766.5648840500317
    },
    "selected": false
  }, {
    "data": {
      "id": "180",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Anders Karlhede",
      "birth_year": "missing",
      "given_name": "Anders",
      "death_year": "missing",
      "birth_country": "Sweden",
      "race": "white",
      "reference": "missing",
      "family_name": "Karlhede",
      "gender": "male"
    },
    "position": {
      "x": 3561.5362341623672,
      "y": 3703.176641912176
    },
    "selected": false
  }, {
    "data": {
      "id": "255",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Ludwig Maurer",
      "birth_year": 1859,
      "given_name": "Ludwig",
      "death_year": 1927,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Ludwig_Maurer",
      "family_name": "Maurer",
      "gender": "male"
    },
    "position": {
      "x": 3612.9713980674583,
      "y": 3700.871858862616
    },
    "selected": false
  }, {
    "data": {
      "id": "160",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Maurice Huggins",
      "birth_year": 1897,
      "given_name": "Maurice",
      "death_year": 1981,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Maurice_Loyal_Huggins",
      "family_name": "Huggins",
      "gender": "male"
    },
    "position": {
      "x": 4915.721497465227,
      "y": 2888.477519721348
    },
    "selected": false
  }, {
    "data": {
      "id": "289",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Phyllis Nicolson",
      "birth_year": 1917,
      "given_name": "Phyllis",
      "death_year": 1968,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Phyllis_Nicolson",
      "family_name": "Nicolson",
      "gender": "female"
    },
    "position": {
      "x": 2899.233598153258,
      "y": 4733.519448950763
    },
    "selected": false
  }, {
    "data": {
      "id": "49",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Sydney Chapman",
      "birth_year": 1888,
      "given_name": "Sydney",
      "death_year": 1970,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Sydney_Chapman_(mathematician)",
      "family_name": "Chapman",
      "gender": "male"
    },
    "position": {
      "x": 6182.688287676035,
      "y": 3805.373644426224
    },
    "selected": false
  }, {
    "data": {
      "id": "291",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Yoshio Nishina",
      "birth_year": 1890,
      "given_name": "Yoshio",
      "death_year": 1951,
      "birth_country": "Japan",
      "race": "East Asian",
      "reference": "https://en.wikipedia.org/wiki/Yoshio_Nishina",
      "family_name": "Nishina",
      "gender": "male"
    },
    "position": {
      "x": 1901.545937417257,
      "y": 4176.409765340931
    },
    "selected": false
  }, {
    "data": {
      "id": "106",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Gans",
      "birth_year": 1880,
      "given_name": "Richard",
      "death_year": 1954,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Gans",
      "family_name": "Gans",
      "gender": "male"
    },
    "position": {
      "x": 4902.9455447322025,
      "y": 3154.469947659798
    },
    "selected": false
  }, {
    "data": {
      "id": "94",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Paul Flory",
      "birth_year": 1910,
      "given_name": "Paul",
      "death_year": 1985,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paul_Flory",
      "family_name": "Flory",
      "gender": "male"
    },
    "position": {
      "x": 4962.666776682541,
      "y": 2915.540626122042
    },
    "selected": false
  }, {
    "data": {
      "id": "225",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Veniamin Levich",
      "birth_year": 1917,
      "given_name": "Veniamin",
      "death_year": 1987,
      "birth_country": "Ukraine",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Veniamin_Levich",
      "family_name": "Levich",
      "gender": "male"
    },
    "position": {
      "x": 5247.705662981263,
      "y": 3730.922004401372
    },
    "selected": false
  }, {
    "data": {
      "id": "428",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Wilhelm Weinberg",
      "birth_year": 1862,
      "given_name": "Wilhelm",
      "death_year": 1937,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Wilhelm_Weinberg",
      "family_name": "Weinberg",
      "gender": "male"
    },
    "position": {
      "x": 3909.597485853522,
      "y": 4416.147535154729
    },
    "selected": false
  }, {
    "data": {
      "id": "102",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolph Franz",
      "birth_year": 1826,
      "given_name": "Rudolph",
      "death_year": 1902,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolph_Franz",
      "family_name": "Franz",
      "gender": "male"
    },
    "position": {
      "x": 3756.2214579624106,
      "y": 2500.0
    },
    "selected": false
  }, {
    "data": {
      "id": "128",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Fritz Haber",
      "birth_year": 1868,
      "given_name": "Fritz",
      "death_year": 1934,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Fritz_Haber",
      "family_name": "Haber",
      "gender": "male"
    },
    "position": {
      "x": 3295.796864224483,
      "y": 3373.6839346845386
    },
    "selected": false
  }, {
    "data": {
      "id": "259",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Maud Menten",
      "birth_year": 1879,
      "given_name": "Maud",
      "death_year": 1960,
      "birth_country": "Canada",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Maud_Menten",
      "family_name": "Menten",
      "gender": "female"
    },
    "position": {
      "x": 1638.4281021725326,
      "y": 3715.18867425005
    },
    "selected": false
  }, {
    "data": {
      "id": "70",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Peter Debye",
      "birth_year": 1884,
      "given_name": "Peter",
      "death_year": 1966,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Peter_Debye",
      "family_name": "Debye",
      "gender": "male"
    },
    "position": {
      "x": 4246.785190618348,
      "y": 2608.476243872932
    },
    "selected": false
  }, {
    "data": {
      "id": "347",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Paolo Ruffini",
      "birth_year": 1765,
      "given_name": "Paolo",
      "death_year": 1822,
      "birth_country": "Italy",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Paolo_Ruffini",
      "family_name": "Ruffini",
      "gender": "male"
    },
    "position": {
      "x": 4473.050249583972,
      "y": 3299.6570279686202
    },
    "selected": false
  }, {
    "data": {
      "id": "332",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Amal Raychaudhuri",
      "birth_year": 1923,
      "given_name": "Amal",
      "death_year": 2005,
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/Amal_Kumar_Raychaudhuri",
      "family_name": "Raychaudhuri",
      "gender": "male"
    },
    "position": {
      "x": 5183.1645614036315,
      "y": 3734.841848160291
    },
    "selected": false
  }, {
    "data": {
      "id": "21",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Vilhelm Bjerknes",
      "birth_year": 1862,
      "given_name": "Vilhelm",
      "death_year": 1951,
      "birth_country": "Norway",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Vilhelm_Bjerknes",
      "family_name": "Bjerknes",
      "gender": "male"
    },
    "position": {
      "x": 3784.9211555034935,
      "y": 3962.10282633373
    },
    "selected": false
  }, {
    "data": {
      "id": "350",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Philip Saffman",
      "birth_year": 1931,
      "given_name": "Philip",
      "death_year": 2008,
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Philip_Saffman",
      "family_name": "Saffman",
      "gender": "male"
    },
    "position": {
      "x": 4513.917291870215,
      "y": 3081.7219994779443
    },
    "selected": false
  }, {
    "data": {
      "id": "229",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Evgeny Lifshitz",
      "birth_year": 1915,
      "given_name": "Evgeny",
      "death_year": 1985,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Evgeny_Lifshitz",
      "family_name": "Lifshitz",
      "gender": "male"
    },
    "position": {
      "x": 5276.985680752983,
      "y": 3670.8911031791977
    },
    "selected": false
  }, {
    "data": {
      "id": "38",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Torsten Carleman",
      "birth_year": 1892,
      "given_name": "Torsten",
      "death_year": 1949,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Torsten_Carleman",
      "family_name": "Carleman",
      "gender": "male"
    },
    "position": {
      "x": 5029.604178975017,
      "y": 3584.1606100265917
    },
    "selected": false
  }, {
    "data": {
      "id": "163",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Carl Jacobi",
      "birth_year": 1804,
      "given_name": "Carl",
      "death_year": 1851,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Carl_Gustav_Jacob_Jacobi",
      "family_name": "Jacobi",
      "gender": "male"
    },
    "position": {
      "x": 4235.949694083934,
      "y": 3372.2637709704018
    },
    "selected": false
  }, {
    "data": {
      "id": "375",
      "selected": false,
      "NodeType": "Cheese",
      "name": "David Slepian",
      "birth_year": 1923,
      "given_name": "David",
      "death_year": 2007,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/David_Slepian",
      "family_name": "Slepian",
      "gender": "male"
    },
    "position": {
      "x": 5689.562270674449,
      "y": 2868.8453047413527
    },
    "selected": false
  }, {
    "data": {
      "id": "379",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Willebrord Snell",
      "birth_year": 1580,
      "given_name": "Willebrord",
      "death_year": 1626,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Willebrord_Snellius",
      "family_name": "Snell",
      "gender": "male"
    },
    "position": {
      "x": 1408.0720958672912,
      "y": 3362.093507878265
    },
    "selected": false
  }, {
    "data": {
      "id": "131",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Hamilton",
      "birth_year": 1805,
      "given_name": "William",
      "death_year": 1865,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_Rowan_Hamilton",
      "family_name": "Hamilton",
      "gender": "male"
    },
    "position": {
      "x": 4277.331939401317,
      "y": 3254.7692389617
    },
    "selected": false
  }, {
    "data": {
      "id": "396",
      "selected": false,
      "NodeType": "Cheese",
      "name": "John Stuart",
      "birth_year": 1929,
      "given_name": "John",
      "death_year": "missing",
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/John_Trevor_Stuart",
      "family_name": "Stuart",
      "gender": "male"
    },
    "position": {
      "x": 5305.171201107995,
      "y": 3694.769602965751
    },
    "selected": false
  }, {
    "data": {
      "id": "440",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jack Wolf",
      "birth_year": 1935,
      "given_name": "Jack",
      "death_year": 2011,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jack_Wolf",
      "family_name": "Wolf",
      "gender": "male"
    },
    "position": {
      "x": 5648.637142341708,
      "y": 2878.1344792622317
    },
    "selected": false
  }, {
    "data": {
      "id": "192",
      "selected": false,
      "NodeType": "Cheese",
      "name": "V. A. Kohlrausch",
      "birth_year": "missing",
      "given_name": "V. A.",
      "death_year": "missing",
      "birth_country": "missing",
      "race": "missing",
      "reference": "missing",
      "family_name": "Kohlrausch",
      "gender": "missing"
    },
    "position": {
      "x": 3614.1478583513913,
      "y": 3152.4529494593867
    },
    "selected": false
  }, {
    "data": {
      "id": "326",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Michael Purser",
      "birth_year": "missing",
      "given_name": "Michael",
      "death_year": "missing",
      "birth_country": "Ireland",
      "race": "white",
      "reference": "missing",
      "family_name": "Purser",
      "gender": "male"
    },
    "position": {
      "x": 4388.125045189605,
      "y": 3116.9568050225844
    },
    "selected": false
  }, {
    "data": {
      "id": "221",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Solomon Lefschetz",
      "birth_year": 1884,
      "given_name": "Solomon",
      "death_year": 1972,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Solomon_Lefschetz",
      "family_name": "Lefschetz",
      "gender": "male"
    },
    "position": {
      "x": 2544.301596504386,
      "y": 3415.149269641863
    },
    "selected": false
  }, {
    "data": {
      "id": "373",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Isadore Singer",
      "birth_year": 1924,
      "given_name": "Isadore",
      "death_year": 2021,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Isadore_Singer",
      "family_name": "Singer",
      "gender": "male"
    },
    "position": {
      "x": 2089.009316583536,
      "y": 3351.546961239712
    },
    "selected": false
  }, {
    "data": {
      "id": "53",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Rudolf Clausius",
      "birth_year": 1822,
      "given_name": "Rudolf",
      "death_year": 1888,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Rudolf_Clausius",
      "family_name": "Clausius",
      "gender": "male"
    },
    "position": {
      "x": 3746.960472150894,
      "y": 3141.914952551856
    },
    "selected": false
  }, {
    "data": {
      "id": "362",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Julian Schwinger",
      "birth_year": 1918,
      "given_name": "Julian",
      "death_year": 1994,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Julian_Schwinger",
      "family_name": "Schwinger",
      "gender": "male"
    },
    "position": {
      "x": 4623.432876764067,
      "y": 2618.907588847877
    },
    "selected": false
  }, {
    "data": {
      "id": "47",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Subrahmanyan Chandrasekhar",
      "birth_year": 1910,
      "given_name": "Subrahmanyan",
      "death_year": 1995,
      "birth_country": "India",
      "race": "South Asian",
      "reference": "https://en.wikipedia.org/wiki/Subrahmanyan_Chandrasekhar",
      "family_name": "Chandrasekhar",
      "gender": "male"
    },
    "position": {
      "x": 4391.881784768488,
      "y": 4384.736029761142
    },
    "selected": false
  }, {
    "data": {
      "id": "175",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Richard Kadison",
      "birth_year": 1925,
      "given_name": "Richard",
      "death_year": 2018,
      "birth_country": "United States",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Richard_Kadison",
      "family_name": "Kadison",
      "gender": "male"
    },
    "position": {
      "x": 2223.0511601681046,
      "y": 3373.879866629137
    },
    "selected": false
  }, {
    "data": {
      "id": "407",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Hans Tropsch",
      "birth_year": 1889,
      "given_name": "Hans",
      "death_year": 1935,
      "birth_country": "Austria-Hungary",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Hans_Tropsch",
      "family_name": "Tropsch",
      "gender": "male"
    },
    "position": {
      "x": 6500.0,
      "y": 3622.059968868313
    },
    "selected": false
  }, {
    "data": {
      "id": "286",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Walther Nernst",
      "birth_year": 1864,
      "given_name": "Walther",
      "death_year": 1941,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Walther_Nernst",
      "family_name": "Nernst",
      "gender": "male"
    },
    "position": {
      "x": 3361.2031300746876,
      "y": 3619.716348582064
    },
    "selected": false
  }, {
    "data": {
      "id": "338",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Bernhard Riemann",
      "birth_year": 1826,
      "given_name": "Bernhard",
      "death_year": 1866,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Bernhard_Riemann",
      "family_name": "Riemann",
      "gender": "male"
    },
    "position": {
      "x": 3705.768553360483,
      "y": 3685.403040325699
    },
    "selected": false
  }, {
    "data": {
      "id": "3",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Yakir Aharonov",
      "birth_year": 1932,
      "given_name": "Yakir",
      "death_year": "missing",
      "birth_country": "Palestine",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Yakir_Aharonov",
      "family_name": "Aharonov",
      "gender": "male"
    },
    "position": {
      "x": 2124.454908259998,
      "y": 4316.328119834221
    },
    "selected": false
  }, {
    "data": {
      "id": "178",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Peter Kapitza",
      "birth_year": 1894,
      "given_name": "Peter",
      "death_year": 1984,
      "birth_country": "Russia",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Pyotr_Kapitsa",
      "family_name": "Kapitza",
      "gender": "male"
    },
    "position": {
      "x": 2293.016588805421,
      "y": 3379.789686955086
    },
    "selected": false
  }, {
    "data": {
      "id": "96",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Adriaan Fokker",
      "birth_year": 1887,
      "given_name": "Adriaan",
      "death_year": 1972,
      "birth_country": "Netherlands",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Adriaan_Fokker",
      "family_name": "Fokker",
      "gender": "male"
    },
    "position": {
      "x": 3093.5077964761786,
      "y": 3599.2253513177093
    },
    "selected": false
  }, {
    "data": {
      "id": "306",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Roger Penrose",
      "birth_year": 1931,
      "given_name": "Roger",
      "death_year": "missing",
      "birth_country": "England",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Roger_Penrose",
      "family_name": "Penrose",
      "gender": "male"
    },
    "position": {
      "x": 3496.23672910811,
      "y": 4558.477336834078
    },
    "selected": false
  }, {
    "data": {
      "id": "387",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Jakob Steiner",
      "birth_year": 1796,
      "given_name": "Jakob",
      "death_year": 1863,
      "birth_country": "Switzerland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Jakob_Steiner",
      "family_name": "Steiner",
      "gender": "male"
    },
    "position": {
      "x": 4497.763057419342,
      "y": 3762.771378126255
    },
    "selected": false
  }, {
    "data": {
      "id": "149",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Hodge",
      "birth_year": 1903,
      "given_name": "William",
      "death_year": 1975,
      "birth_country": "Scotland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/W._V._D._Hodge",
      "family_name": "Hodge",
      "gender": "male"
    },
    "position": {
      "x": 5384.901682818782,
      "y": 3976.532189665705
    },
    "selected": false
  }, {
    "data": {
      "id": "155",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Heinz Hopf",
      "birth_year": 1894,
      "given_name": "Heinz",
      "death_year": 1971,
      "birth_country": "Germany",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Heinz_Hopf",
      "family_name": "Hopf",
      "gender": "male"
    },
    "position": {
      "x": 3689.837867957153,
      "y": 4106.9141121065295
    },
    "selected": false
  }, {
    "data": {
      "id": "181",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Daniel Kastler",
      "birth_year": 1926,
      "given_name": "Daniel",
      "death_year": 2015,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Daniel_Kastler",
      "family_name": "Kastler",
      "gender": "male"
    },
    "position": {
      "x": 2405.1265173037923,
      "y": 3421.858957236859
    },
    "selected": false
  }, {
    "data": {
      "id": "65",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Louis de Broglie",
      "birth_year": 1892,
      "given_name": "Louis",
      "death_year": 1987,
      "birth_country": "France",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Louis_de_Broglie",
      "family_name": "de Broglie",
      "gender": "male"
    },
    "position": {
      "x": 2237.1088880822244,
      "y": 4226.436146546544
    },
    "selected": false
  }, {
    "data": {
      "id": "446",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Antoni Zygmund",
      "birth_year": 1900,
      "given_name": "Antoni",
      "death_year": 1992,
      "birth_country": "Poland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Antoni_Zygmund",
      "family_name": "Zygmund",
      "gender": "male"
    },
    "position": {
      "x": 3663.6250459785497,
      "y": 4398.490776358492
    },
    "selected": false
  }, {
    "data": {
      "id": "293",
      "selected": false,
      "NodeType": "Cheese",
      "name": "Harry Nyquist",
      "birth_year": 1889,
      "given_name": "Harry",
      "death_year": 1976,
      "birth_country": "Sweden",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/Harry_Nyquist",
      "family_name": "Nyquist",
      "gender": "male"
    },
    "position": {
      "x": 2841.9508873632403,
      "y": 4138.990753138805
    },
    "selected": false
  }, {
    "data": {
      "id": "298",
      "selected": false,
      "NodeType": "Cheese",
      "name": "William Orr",
      "birth_year": 1866,
      "given_name": "William",
      "death_year": 1934,
      "birth_country": "Ireland",
      "race": "white",
      "reference": "https://en.wikipedia.org/wiki/William_McFadden_Orr",
      "family_name": "Orr",
      "gender": "male"
    },
    "position": {
      "x": 4427.902557591189,
      "y": 3727.7795200665464
    },
    "selected": false
  }],
  "edges": [{
    "data": {
      "id": "Edge 107 => 364",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "364",
      "year": 1823,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gauss–Seidel_method",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 388 => 415",
      "selected": false,
      "interaction": "cc",
      "source": "388",
      "target": "415",
      "year": "missing",
      "field": "Chemistry",
      "type": "relationship",
      "reference": "https://en.wikipedia.org/wiki/Stern–Volmer_relationship",
      "unrecognized?": "missing",
      "subfield": "Photochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 63 => 216",
      "selected": false,
      "interaction": "cc",
      "source": "63",
      "target": "216",
      "year": 1938,
      "field": "missing",
      "type": "instability",
      "reference": "https://en.wikipedia.org/wiki/Darrieus–Landau_instability",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 119 => 50",
      "selected": false,
      "interaction": "cc",
      "source": "119",
      "target": "50",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Edgeworth_series",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 303 => 191",
      "selected": false,
      "interaction": "cc",
      "source": "303",
      "target": "191",
      "year": 1950,
      "field": "Engineering",
      "type": "force",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 40 => 75",
      "selected": false,
      "interaction": "cc",
      "source": "40",
      "target": "75",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cartan–Dieudonné_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 374 => 201",
      "selected": false,
      "interaction": "cc",
      "source": "374",
      "target": "201",
      "year": 1954,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Tight_binding",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 237 => 31",
      "selected": false,
      "interaction": "cc",
      "source": "237",
      "target": "31",
      "year": 1978,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Ljung–Box_test",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 31 => 279",
      "selected": false,
      "interaction": "cc",
      "source": "31",
      "target": "279",
      "year": 1958,
      "field": "Mathematics",
      "type": "transform",
      "reference": "https://en.wikipedia.org/wiki/Box–Muller_transform",
      "unrecognized?": "Raymond Paley, Norbert Weiner",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 367 => 402",
      "selected": false,
      "interaction": "cc",
      "source": "367",
      "target": "402",
      "year": 1964,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Serre–Tate_theorem",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 175 => 181",
      "selected": false,
      "interaction": "cc",
      "source": "175",
      "target": "181",
      "year": 1972,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kadison–Kastler_metric",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 403 => 113",
      "selected": false,
      "interaction": "cc",
      "source": "403",
      "target": "113",
      "year": 1931,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Taylor–Goldstein_equation",
      "unrecognized?": "B. Haurwitz",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 82 => 67",
      "selected": false,
      "interaction": "cc",
      "source": "82",
      "target": "67",
      "year": 1908,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Einstein–de_Haas_effect",
      "unrecognized?": "Owen Richardson",
      "subfield": "Magnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 33 => 266",
      "selected": false,
      "interaction": "cc",
      "source": "33",
      "target": "266",
      "year": 1887,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Brunn–Minkowski_theorem",
      "unrecognized?": "missing",
      "subfield": "Germany"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 443 => 219",
      "selected": false,
      "interaction": "cc",
      "source": "443",
      "target": "219",
      "year": 1830,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Young–Laplace_equation",
      "unrecognized?": "Gauss",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 110 => 138",
      "selected": false,
      "interaction": "cc",
      "source": "110",
      "target": "138",
      "year": 1978,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gibbons–Hawking_ansatz",
      "unrecognized?": "missing",
      "subfield": "Relativity"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 166 => 91",
      "selected": false,
      "interaction": "cc",
      "source": "166",
      "target": "91",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jefimenko%27s_equations#Heaviside–Feynman_formula",
      "unrecognized?": "missing",
      "subfield": "Electromagnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 227 => 301",
      "selected": false,
      "interaction": "cc",
      "source": "227",
      "target": "301",
      "year": 1957,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lie–Palais_theorem",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 248 => 282",
      "selected": false,
      "interaction": "cc",
      "source": "248",
      "target": "282",
      "year": 1972,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Arithmetic_of_abelian_varieties#Manin–Mumford_conjecture",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 176 => 82",
      "selected": false,
      "interaction": "cc",
      "source": "176",
      "target": "82",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kähler–Einstein_metric",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 404 => 409",
      "selected": false,
      "interaction": "cc",
      "source": "404",
      "target": "409",
      "year": 1951,
      "field": "Engineering",
      "type": "design",
      "reference": "https://en.wikipedia.org/wiki/History_of_the_Teller–Ulam_design",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 203 => 423",
      "selected": false,
      "interaction": "cc",
      "source": "203",
      "target": "423",
      "year": 1941,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kramers–Wannier_duality",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 434 => 102",
      "selected": false,
      "interaction": "cc",
      "source": "434",
      "target": "102",
      "year": 1853,
      "field": "Physics",
      "type": "law",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 436 => 365",
      "selected": false,
      "interaction": "cc",
      "source": "436",
      "target": "365",
      "year": 1933,
      "field": "Physics",
      "type": "cell",
      "reference": "https://en.wikipedia.org/wiki/Wigner–Seitz_cell",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 74",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "74",
      "year": "missing",
      "field": "Mathematics",
      "type": "construction",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Dickson_construction",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 53 => 81",
      "selected": false,
      "interaction": "cc",
      "source": "53",
      "target": "81",
      "year": "missing",
      "field": "Physics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Clausius–Duhem_inequality",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 39 => 385",
      "selected": false,
      "interaction": "cc",
      "source": "39",
      "target": "385",
      "year": 1969,
      "field": "Physics",
      "type": "equation of state",
      "reference": "http://www.sklogwiki.org/SklogWiki/index.php/Carnahan-Starling_equation_of_state",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 199 => 69",
      "selected": false,
      "interaction": "cc",
      "source": "199",
      "target": "69",
      "year": 1877,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Korteweg–de_Vries_equation",
      "unrecognized?": "Boussinesq",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 111 => 249",
      "selected": false,
      "interaction": "cc",
      "source": "111",
      "target": "249",
      "year": 1855,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Marangoni_effect",
      "unrecognized?": "James Thomson",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 9 => 367",
      "selected": false,
      "interaction": "cc",
      "source": "9",
      "target": "367",
      "year": "missing",
      "field": "Mathematics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Bass–Serre_theory",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 136 => 266",
      "selected": false,
      "interaction": "cc",
      "source": "136",
      "target": "266",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hasse–Minkowski_theorem",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 267 => 199",
      "selected": false,
      "interaction": "cc",
      "source": "267",
      "target": "199",
      "year": 1877,
      "field": "Biology",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Moens–Korteweg_equation",
      "unrecognized?": "missing",
      "subfield": "Biomechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 81 => 250",
      "selected": false,
      "interaction": "cc",
      "source": "81",
      "target": "250",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Duhem–Margules_equation",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 53 => 273",
      "selected": false,
      "interaction": "cc",
      "source": "53",
      "target": "273",
      "year": "missing",
      "field": "Physics",
      "type": "relation",
      "reference": "https://en.wikipedia.org/wiki/Clausius–Mossotti_relation",
      "unrecognized?": "missing",
      "subfield": "Electromagnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 119 => 355",
      "selected": false,
      "interaction": "cc",
      "source": "119",
      "target": "355",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gram–Schmidt_process",
      "unrecognized?": "Pierre-Simon Laplace",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 44 => 66",
      "selected": false,
      "interaction": "cc",
      "source": "44",
      "target": "66",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Castelnuovo–de_Franchis_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 144 => 129",
      "selected": false,
      "interaction": "cc",
      "source": "144",
      "target": "129",
      "year": "missing",
      "field": "Mathematics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Hermite–Hadamard_inequality",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 282 => 368",
      "selected": false,
      "interaction": "cc",
      "source": "282",
      "target": "368",
      "year": 1989,
      "field": "Mathematics",
      "type": "functional",
      "reference": "https://en.wikipedia.org/wiki/Mumford–Shah_functional",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 80 => 239",
      "selected": false,
      "interaction": "cc",
      "source": "80",
      "target": "239",
      "year": "missing",
      "field": "missing",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 217 => 71",
      "selected": false,
      "interaction": "cc",
      "source": "217",
      "target": "71",
      "year": 1970,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Langlands–Deligne_local_constant",
      "unrecognized?": "missing",
      "subfield": "Representation Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 215 => 329",
      "selected": false,
      "interaction": "cc",
      "source": "215",
      "target": "329",
      "year": 1908,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Ramanujan_constant",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 108 => 295",
      "selected": false,
      "interaction": "cc",
      "source": "108",
      "target": "295",
      "year": 1961,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gell-Mann–Okubo_mass_formula",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 124 => 381",
      "selected": false,
      "interaction": "cc",
      "source": "124",
      "target": "381",
      "year": 1926,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Grimm–Sommerfeld_rule",
      "unrecognized?": "missing",
      "subfield": "Solid-State Chemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 175 => 373",
      "selected": false,
      "interaction": "cc",
      "source": "175",
      "target": "373",
      "year": 1959,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kadison–Singer_problem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 135 => 95",
      "selected": false,
      "interaction": "cc",
      "source": "135",
      "target": "95",
      "year": 1935,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 442 => 265",
      "selected": false,
      "interaction": "cc",
      "source": "442",
      "target": "265",
      "year": 1954,
      "field": "Physics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Yang–Mills_theory#History_and_theoretical_description",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 51 => 343",
      "selected": false,
      "interaction": "cc",
      "source": "51",
      "target": "343",
      "year": 1936,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Church–Rosser_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 168 => 437",
      "selected": false,
      "interaction": "cc",
      "source": "168",
      "target": "437",
      "year": 1935,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jessen–Wintner_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 132 => 428",
      "selected": false,
      "interaction": "cc",
      "source": "132",
      "target": "428",
      "year": 1908,
      "field": "Biology",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hardy–Weinberg_principle",
      "unrecognized?": "missing",
      "subfield": "Genetics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 177 => 189",
      "selected": false,
      "interaction": "cc",
      "source": "177",
      "target": "189",
      "year": 1919,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kaluza–Klein_theory",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 139 => 91",
      "selected": false,
      "interaction": "cc",
      "source": "139",
      "target": "91",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jefimenko%27s_equations#Heaviside–Feynman_formula",
      "unrecognized?": "missing",
      "subfield": "Electromagnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 352 => 402",
      "selected": false,
      "interaction": "cc",
      "source": "352",
      "target": "402",
      "year": 1960,
      "field": "Mathematics",
      "type": "conjecture",
      "reference": "https://en.wikipedia.org/wiki/Sato–Tate_conjecture",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 35 => 257",
      "selected": false,
      "interaction": "cc",
      "source": "35",
      "target": "257",
      "year": 1894,
      "field": "Mathematics",
      "type": "integral",
      "reference": "https://en.wikipedia.org/wiki/Mellin_transform#Cahen–Mellin_integral",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 49 => 85",
      "selected": false,
      "interaction": "cc",
      "source": "49",
      "target": "85",
      "year": 1916,
      "field": "Physics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Chapman–Enskog_theory",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 340",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "340",
      "year": 1908,
      "field": "Mathematics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Ritz_method",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 51 => 408",
      "selected": false,
      "interaction": "cc",
      "source": "51",
      "target": "408",
      "year": 1936,
      "field": "Mathematics",
      "type": "thesis",
      "reference": "https://en.wikipedia.org/wiki/Church–Turing_thesis",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 375 => 440",
      "selected": false,
      "interaction": "cc",
      "source": "375",
      "target": "440",
      "year": 1973,
      "field": "Mathematics",
      "type": "coding",
      "reference": "https://en.wikipedia.org/wiki/Slepian–Wolf_coding",
      "unrecognized?": "missing",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 396 => 216",
      "selected": false,
      "interaction": "cc",
      "source": "396",
      "target": "216",
      "year": 1944,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Stuart–Landau_equation",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 131 => 163",
      "selected": false,
      "interaction": "cc",
      "source": "131",
      "target": "163",
      "year": 1842,
      "field": "missing",
      "type": "missing",
      "reference": "http://www.scholarpedia.org/article/Hamilton-Jacobi_equation#History",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 445 => 152",
      "selected": false,
      "interaction": "cc",
      "source": "445",
      "target": "152",
      "year": "missing",
      "field": "Engineering",
      "type": "parameter",
      "reference": "https://en.wikipedia.org/wiki/Zener–Hollomon_parameter",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 88 => 170",
      "selected": false,
      "interaction": "cc",
      "source": "88",
      "target": "170",
      "year": 1993,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Farrell–Jones_conjecture",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 24 => 411",
      "selected": false,
      "interaction": "cc",
      "source": "24",
      "target": "411",
      "year": 1911,
      "field": "Physics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Bohr–van_Leeuwen_theorem",
      "unrecognized?": "missing",
      "subfield": "Magnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 443 => 143",
      "selected": false,
      "interaction": "cc",
      "source": "443",
      "target": "143",
      "year": 1850,
      "field": "Biology",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Young–Helmholtz_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 262 => 137",
      "selected": false,
      "interaction": "cc",
      "source": "262",
      "target": "137",
      "year": 1953,
      "field": "Mathematics",
      "type": "algorithm",
      "reference": "missing",
      "unrecognized?": "Arianna W. Rosenbluth, Marshall Rosenbluth, Augusta H. Teller and Edward Teller",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 435 => 162",
      "selected": false,
      "interaction": "cc",
      "source": "435",
      "target": "162",
      "year": 1931,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Wiener–Ikehara_theorem",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 427 => 84",
      "selected": false,
      "interaction": "cc",
      "source": "427",
      "target": "84",
      "year": 1863,
      "field": "Mathematics",
      "type": "parameterization",
      "reference": "https://en.wikipedia.org/wiki/Weierstrass–Enneper_parameterization",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 388 => 109",
      "selected": false,
      "interaction": "cc",
      "source": "388",
      "target": "109",
      "year": 1921,
      "field": "Physics",
      "type": "experiment",
      "reference": "https://en.wikipedia.org/wiki/Stern–Gerlach_experiment",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 127 => 346",
      "selected": false,
      "interaction": "cc",
      "source": "127",
      "target": "346",
      "year": 1958,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Wightman_axioms",
      "unrecognized?": "missing",
      "subfield": "Quantum Field Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 226 => 228",
      "selected": false,
      "interaction": "cc",
      "source": "226",
      "target": "228",
      "year": 1979,
      "field": "missing",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 268 => 253",
      "selected": false,
      "interaction": "cc",
      "source": "268",
      "target": "253",
      "year": 1672,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Mohr–Mascheroni_theorem#History",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 344 => 97",
      "selected": false,
      "interaction": "cc",
      "source": "344",
      "target": "97",
      "year": 1976,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Rubin–Ford_effect",
      "unrecognized?": "Norbert Thonnard, Morton Roberts, John Graham",
      "subfield": "Astrophysics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 82 => 378",
      "selected": false,
      "interaction": "cc",
      "source": "82",
      "target": "378",
      "year": "missing",
      "field": "missing",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 255 => 40",
      "selected": false,
      "interaction": "cc",
      "source": "255",
      "target": "40",
      "year": 1904,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Maurer–Cartan_form",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 28 => 417",
      "selected": false,
      "interaction": "cc",
      "source": "28",
      "target": "417",
      "year": 1912,
      "field": "Physics",
      "type": "boundary condition",
      "reference": "https://en.wikipedia.org/wiki/Born–von_Karman_boundary_condition",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 127 => 181",
      "selected": false,
      "interaction": "cc",
      "source": "127",
      "target": "181",
      "year": 1964,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Local_quantum_field_theory",
      "unrecognized?": "missing",
      "subfield": "Quantum Field Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 111 => 81",
      "selected": false,
      "interaction": "cc",
      "source": "111",
      "target": "81",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 367 => 399",
      "selected": false,
      "interaction": "cc",
      "source": "367",
      "target": "399",
      "year": 1955,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Serre–Swan_theorem",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 418 => 93",
      "selected": false,
      "interaction": "cc",
      "source": "418",
      "target": "93",
      "year": 1953,
      "field": "Mathematics",
      "type": "distribution",
      "reference": "https://en.wikipedia.org/wiki/von_Mises–Fisher_distribution",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 40 => 209",
      "selected": false,
      "interaction": "cc",
      "source": "40",
      "target": "209",
      "year": 1957,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cartan–Kuranishi_prolongation_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 8 => 402",
      "selected": false,
      "interaction": "cc",
      "source": "8",
      "target": "402",
      "year": 1962,
      "field": "Mathematics",
      "type": "group",
      "reference": "https://en.wikipedia.org/wiki/Barsotti–Tate_group",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 62 => 87",
      "selected": false,
      "interaction": "cc",
      "source": "62",
      "target": "87",
      "year": 1752,
      "field": "Mathematics",
      "type": "equation",
      "reference": "https://encyclopediaofmath.org/wiki/Cauchy-Riemann_equations",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 186 => 196",
      "selected": false,
      "interaction": "cc",
      "source": "186",
      "target": "196",
      "year": 1930,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Wiener–Khinchin_theorem",
      "unrecognized?": "Norbert Wiener",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 311 => 413",
      "selected": false,
      "interaction": "cc",
      "source": "311",
      "target": "413",
      "year": 1898,
      "field": "Mathematics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Picard–Vessiot_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 288 => 56",
      "selected": false,
      "interaction": "cc",
      "source": "288",
      "target": "56",
      "year": "missing",
      "field": "Mathematics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Newton–Cotes_formulas",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 47 => 300",
      "selected": false,
      "interaction": "cc",
      "source": "47",
      "target": "300",
      "year": 1976,
      "field": "Physics",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Chandrasekhar–Page_equations",
      "unrecognized?": "N. Toop",
      "subfield": "Astrophysics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 171 => 151",
      "selected": false,
      "interaction": "cc",
      "source": "171",
      "target": "151",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Composition_series#Uniqueness:_Jordan–Hölder_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 403 => 57",
      "selected": false,
      "interaction": "cc",
      "source": "403",
      "target": "57",
      "year": "missing",
      "field": "Engineering",
      "type": "flow",
      "reference": "https://en.wikipedia.org/wiki/Taylor–Couette_flow",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 101 => 146",
      "selected": false,
      "interaction": "cc",
      "source": "101",
      "target": "146",
      "year": 1914,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Franck–Hertz_experiment",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 406 => 271",
      "selected": false,
      "interaction": "cc",
      "source": "406",
      "target": "271",
      "year": 1906,
      "field": "Mathematics",
      "type": "sequence",
      "reference": "https://en.wikipedia.org/wiki/Thue–Morse_sequence#History",
      "unrecognized?": "Eugène Prouhet",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 94 => 160",
      "selected": false,
      "interaction": "cc",
      "source": "94",
      "target": "160",
      "year": "missing",
      "field": "Chemistry",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Polymers"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 196 => 377",
      "selected": false,
      "interaction": "cc",
      "source": "196",
      "target": "377",
      "year": 1933,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kolmogorov–Smirnov_test",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 357 => 188",
      "selected": false,
      "interaction": "cc",
      "source": "357",
      "target": "188",
      "year": "missing",
      "field": "Mathematics",
      "type": "form",
      "reference": "https://en.wikipedia.org/wiki/Prime_form",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 53 => 52",
      "selected": false,
      "interaction": "cc",
      "source": "53",
      "target": "52",
      "year": "missing",
      "field": "Physics",
      "type": "relation",
      "reference": "https://en.wikipedia.org/wiki/Clausius–Clapeyron_relation",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 30 => 82",
      "selected": false,
      "interaction": "cc",
      "source": "30",
      "target": "82",
      "year": 1924,
      "field": "Physics",
      "type": "state of matter",
      "reference": "https://en.wikipedia.org/wiki/Bose–Einstein_condensate",
      "unrecognized?": "missing",
      "subfield": "Condensed Matter"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 175 => 179",
      "selected": false,
      "interaction": "cc",
      "source": "175",
      "target": "179",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kaplansky%27s_conjectures",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 61 => 431",
      "selected": false,
      "interaction": "cc",
      "source": "61",
      "target": "431",
      "year": 1940,
      "field": "Physics",
      "type": "Law",
      "reference": "https://www.merriam-webster.com/dictionary/Curie-Weiss%20law",
      "unrecognized?": "missing",
      "subfield": "Magnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 90 => 77",
      "selected": false,
      "interaction": "cc",
      "source": "90",
      "target": "77",
      "year": 1926,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fermi–Dirac_statistics#History",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 28 => 297",
      "selected": false,
      "interaction": "cc",
      "source": "28",
      "target": "297",
      "year": 1927,
      "field": "Physics",
      "type": "approximation",
      "reference": "https://en.wikipedia.org/wiki/Born–Oppenheimer_approximation",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 227 => 195",
      "selected": false,
      "interaction": "cc",
      "source": "227",
      "target": "195",
      "year": 1948,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lie–Kolchin_theorem",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 48 => 174",
      "selected": false,
      "interaction": "cc",
      "source": "48",
      "target": "174",
      "year": 1905,
      "field": "Engineering",
      "type": "condition",
      "reference": "https://en.wikipedia.org/wiki/Chapman–Jouguet_condition",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 435 => 437",
      "selected": false,
      "interaction": "cc",
      "source": "435",
      "target": "437",
      "year": 1941,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Wiener–Wintner_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 252",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "252",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 423 => 276",
      "selected": false,
      "interaction": "cc",
      "source": "423",
      "target": "276",
      "year": 1937,
      "field": "Physics",
      "type": "exciton",
      "reference": "https://en.wikipedia.org/wiki/Exciton#Wannier–Mott_exciton",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 271 => 376",
      "selected": false,
      "interaction": "cc",
      "source": "271",
      "target": "376",
      "year": "missing",
      "field": "Mathematics",
      "type": "system",
      "reference": "https://en.wikipedia.org/wiki/Morse–Smale_system",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 435 => 155",
      "selected": false,
      "interaction": "cc",
      "source": "435",
      "target": "155",
      "year": 1931,
      "field": "Mathematics",
      "type": "method",
      "reference": "https://encyclopediaofmath.org/index.php?title=Wiener-Hopf_method",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 264 => 126",
      "selected": false,
      "interaction": "cc",
      "source": "264",
      "target": "126",
      "year": 1902,
      "field": "Biology",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Michaelis–Gutmann_bodies",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 71 => 282",
      "selected": false,
      "interaction": "cc",
      "source": "71",
      "target": "282",
      "year": 1969,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Moduli_of_algebraic_curves#cite_note-:0-1",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 146 => 190",
      "selected": false,
      "interaction": "cc",
      "source": "146",
      "target": "190",
      "year": "missing",
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hertz–Knudsen_equation",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 189 => 116",
      "selected": false,
      "interaction": "cc",
      "source": "189",
      "target": "116",
      "year": 1926,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Klein–Gordon_equation",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 171 => 32",
      "selected": false,
      "interaction": "cc",
      "source": "171",
      "target": "32",
      "year": 1911,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jordan_curve_theorem#Proof_and_generalizations",
      "unrecognized?": "Henri Lebesgue",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 59 => 439",
      "selected": false,
      "interaction": "cc",
      "source": "59",
      "target": "439",
      "year": 1936,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cramér–Wold_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 187 => 343",
      "selected": false,
      "interaction": "cc",
      "source": "187",
      "target": "343",
      "year": 1935,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kleene–Rosser_paradox",
      "unrecognized?": "missing",
      "subfield": "Logic"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 253",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "253",
      "year": 1734,
      "field": "Mathematics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 244 => 247",
      "selected": false,
      "interaction": "cc",
      "source": "244",
      "target": "247",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lyapunov–Malkin_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 381 => 200",
      "selected": false,
      "interaction": "cc",
      "source": "381",
      "target": "200",
      "year": 1919,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Sommerfeld–Kossel_displacement_law",
      "unrecognized?": "missing",
      "subfield": "AMO"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 40 => 176",
      "selected": false,
      "interaction": "cc",
      "source": "40",
      "target": "176",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cartan–Kähler_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 59 => 418",
      "selected": false,
      "interaction": "cc",
      "source": "59",
      "target": "418",
      "year": 1930,
      "field": "Mathematics",
      "type": "criterion",
      "reference": "https://en.wikipedia.org/wiki/Cramér–von_Mises_criterion",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 147 => 319",
      "selected": false,
      "interaction": "cc",
      "source": "147",
      "target": "319",
      "year": 1982,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hilbert–Pólya_conjecture",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 244 => 355",
      "selected": false,
      "interaction": "cc",
      "source": "244",
      "target": "355",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lyapunov–Schmidt_reduction",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 144",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "144",
      "year": "missing",
      "field": "missing",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 67 => 410",
      "selected": false,
      "interaction": "cc",
      "source": "67",
      "target": "410",
      "year": 1930,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/de_Haas–van_Alphen_effect#History",
      "unrecognized?": "missing",
      "subfield": "Magnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 219 => 12",
      "selected": false,
      "interaction": "cc",
      "source": "219",
      "target": "12",
      "year": "missing",
      "field": "Mathematics",
      "type": "operator",
      "reference": "https://en.wikipedia.org/wiki/Laplace–Beltrami_operator",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 165",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "165",
      "year": 1905,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Jeans_law",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 264 => 259",
      "selected": false,
      "interaction": "cc",
      "source": "264",
      "target": "259",
      "year": "missing",
      "field": "Biology",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Michaelis–Menten_kinetics",
      "unrecognized?": "missing",
      "subfield": "Biochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 27",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "27",
      "year": 1900,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://encyclopediaofmath.org/wiki/Gauss-Bonnet_theorem",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 1 => 312",
      "selected": false,
      "interaction": "cc",
      "source": "1",
      "target": "312",
      "year": 1820,
      "field": "Mathematics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Abel–Plana_formula",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 319 => 400",
      "selected": false,
      "interaction": "cc",
      "source": "319",
      "target": "400",
      "year": 1951,
      "field": "Mathematics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Pólya–Szegő_inequality",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 233 => 122",
      "selected": false,
      "interaction": "cc",
      "source": "233",
      "target": "122",
      "year": 1837,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/WKB_approximation",
      "unrecognized?": "Francesco Carlini",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 311 => 230",
      "selected": false,
      "interaction": "cc",
      "source": "311",
      "target": "230",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Picard–Lindelöf_theorem",
      "unrecognized?": "missing",
      "subfield": "Differential Equations"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 60 => 289",
      "selected": false,
      "interaction": "cc",
      "source": "60",
      "target": "289",
      "year": 1947,
      "field": "Mathematics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Crank–Nicolson_method",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 105 => 404",
      "selected": false,
      "interaction": "cc",
      "source": "105",
      "target": "404",
      "year": 1936,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Beta_decay_transition",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 106",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "106",
      "year": 1881,
      "field": "Physics",
      "type": "approximation",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Gans_approximation",
      "unrecognized?": "missing",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 383 => 399",
      "selected": false,
      "interaction": "cc",
      "source": "383",
      "target": "399",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cohomological_dimension#Examples",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 187 => 32",
      "selected": false,
      "interaction": "cc",
      "source": "187",
      "target": "32",
      "year": 1923,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kleene–Brouwer_order#History",
      "unrecognized?": "Nikolai Luzin, Wacław Sierpiński",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 76 => 235",
      "selected": false,
      "interaction": "cc",
      "source": "76",
      "target": "235",
      "year": 1872,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Dini–Lipschitz_criterion",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 286 => 313",
      "selected": false,
      "interaction": "cc",
      "source": "286",
      "target": "313",
      "year": "missing",
      "field": "Chemistry",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Nernst–Planck_equation",
      "unrecognized?": "missing",
      "subfield": "Electrochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 98 => 277",
      "selected": false,
      "interaction": "cc",
      "source": "98",
      "target": "277",
      "year": 1827,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fourier–Motzkin_elimination",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 335 => 404",
      "selected": false,
      "interaction": "cc",
      "source": "335",
      "target": "404",
      "year": 1934,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Renner–Teller_effect",
      "unrecognized?": "missing",
      "subfield": "AMO"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 96 => 313",
      "selected": false,
      "interaction": "cc",
      "source": "96",
      "target": "313",
      "year": 1914,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fokker–Planck_equation",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 342 => 329",
      "selected": false,
      "interaction": "cc",
      "source": "342",
      "target": "329",
      "year": 1894,
      "field": "Mathematics",
      "type": "identity",
      "reference": "https://en.wikipedia.org/wiki/Rogers–Ramanujan_identities",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 182 => 242",
      "selected": false,
      "interaction": "cc",
      "source": "182",
      "target": "242",
      "year": 1979,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kazhdan–Lusztig_polynomial",
      "unrecognized?": "missing",
      "subfield": "Representation Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 5 => 363",
      "selected": false,
      "interaction": "cc",
      "source": "5",
      "target": "363",
      "year": 1969,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Atiyah–Segal_completion_theorem",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 3 => 42",
      "selected": false,
      "interaction": "cc",
      "source": "3",
      "target": "42",
      "year": 1984,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Aharonov–Casher_effect",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 47 => 184",
      "selected": false,
      "interaction": "cc",
      "source": "47",
      "target": "184",
      "year": 1957,
      "field": "Mathematics",
      "type": "function",
      "reference": "https://en.wikipedia.org/wiki/Chandrasekhar–Kendall_function",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 281 => 366",
      "selected": false,
      "interaction": "cc",
      "source": "281",
      "target": "366",
      "year": "missing",
      "field": "Engineering",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 28",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "28",
      "year": "missing",
      "field": "Engineering",
      "type": "rule",
      "reference": "https://en.wikipedia.org/wiki/Cauchy–Born_rule",
      "unrecognized?": "missing",
      "subfield": "Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 370 => 425",
      "selected": false,
      "interaction": "cc",
      "source": "370",
      "target": "425",
      "year": 1948,
      "field": "Mathematics",
      "type": "model",
      "reference": "https://en.wikipedia.org/wiki/Shannon–Weaver_model",
      "unrecognized?": "missing",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 419 => 281",
      "selected": false,
      "interaction": "cc",
      "source": "419",
      "target": "281",
      "year": 1956,
      "field": "Engineering",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 163",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "163",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gauss–Jacobi_quadrature",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 374 => 55",
      "selected": false,
      "interaction": "cc",
      "source": "374",
      "target": "55",
      "year": 1930,
      "field": "Chemistry",
      "type": "rule",
      "reference": "https://en.wikipedia.org/wiki/Slater–Condon_rules",
      "unrecognized?": "missing",
      "subfield": "Quantum Chemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 82 => 40",
      "selected": false,
      "interaction": "cc",
      "source": "82",
      "target": "40",
      "year": 1922,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Einstein–Cartan_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 28 => 158",
      "selected": false,
      "interaction": "cc",
      "source": "28",
      "target": "158",
      "year": 1954,
      "field": "Physics",
      "type": "approximation",
      "reference": "https://en.wikipedia.org/wiki/Born–Huang_approximation",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 72 => 441",
      "selected": false,
      "interaction": "cc",
      "source": "72",
      "target": "441",
      "year": 1926,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Denjoy–Wolff_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 5 => 373",
      "selected": false,
      "interaction": "cc",
      "source": "5",
      "target": "373",
      "year": 1963,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Atiyah–Singer_index_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 329 => 380",
      "selected": false,
      "interaction": "cc",
      "source": "329",
      "target": "380",
      "year": "missing",
      "field": "Mathematics",
      "type": "constant",
      "reference": "https://en.wikipedia.org/wiki/Ramanujan–Soldner_constant",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 13",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "13",
      "year": 1916,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Bénard_convection#Rayleigh–Bénard_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 64 => 99",
      "selected": false,
      "interaction": "cc",
      "source": "64",
      "target": "99",
      "year": 1922,
      "field": "Physics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Darwin–Fowler_method",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 359",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "359",
      "year": 1926,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Perturbation_theory_(quantum_mechanics)",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 185 => 139",
      "selected": false,
      "interaction": "cc",
      "source": "185",
      "target": "139",
      "year": 1902,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kennelly–Heaviside_layer",
      "unrecognized?": "missing",
      "subfield": "Atmospheric Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 15",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "15",
      "year": 1750,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Euler–Bernoulli_beam_theory",
      "unrecognized?": "missing",
      "subfield": "Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 72 => 38",
      "selected": false,
      "interaction": "cc",
      "source": "72",
      "target": "38",
      "year": 1926,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Quasi-analytic_function#The_Denjoy–Carleman_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 424 => 395",
      "selected": false,
      "interaction": "cc",
      "source": "424",
      "target": "395",
      "year": 1998,
      "field": "Mathematics",
      "type": "model",
      "reference": "https://en.wikipedia.org/wiki/Watts–Strogatz_model",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 1 => 163",
      "selected": false,
      "interaction": "cc",
      "source": "1",
      "target": "163",
      "year": "missing",
      "field": "Mathematics",
      "type": "map",
      "reference": "https://en.wikipedia.org/wiki/Abel–Jacobi_map",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 266 => 148",
      "selected": false,
      "interaction": "cc",
      "source": "266",
      "target": "148",
      "year": 1911,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Minkowski–Hlawka_theorem",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 164 => 404",
      "selected": false,
      "interaction": "cc",
      "source": "164",
      "target": "404",
      "year": 1937,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jahn–Teller_effect",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 98 => 278",
      "selected": false,
      "interaction": "cc",
      "source": "98",
      "target": "278",
      "year": 1981,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fourier–Mukai_transform",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 337 => 261",
      "selected": false,
      "interaction": "cc",
      "source": "337",
      "target": "261",
      "year": 1969,
      "field": "Engineering",
      "type": "instability",
      "reference": "https://en.wikipedia.org/wiki/Richtmyer–Meshkov_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 144 => 266",
      "selected": false,
      "interaction": "cc",
      "source": "144",
      "target": "266",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hermite–Minkowski_theorem",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 183 => 391",
      "selected": false,
      "interaction": "cc",
      "source": "183",
      "target": "391",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Stokes%27_theorem",
      "unrecognized?": "missing",
      "subfield": "Calculus"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 283 => 145",
      "selected": false,
      "interaction": "cc",
      "source": "283",
      "target": "145",
      "year": 1950,
      "field": "Engineering",
      "type": "creep",
      "reference": "https://en.wikipedia.org/wiki/Nabarro–Herring_creep",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 371 => 327",
      "selected": false,
      "interaction": "cc",
      "source": "371",
      "target": "327",
      "year": 1961,
      "field": "Engineering",
      "type": "limit",
      "reference": "https://en.wikipedia.org/wiki/Shockley–Queisser_limit",
      "unrecognized?": "missing",
      "subfield": "Electronics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 246",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "246",
      "year": 1735,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Euler–Maclaurin_formula",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 1 => 347",
      "selected": false,
      "interaction": "cc",
      "source": "1",
      "target": "347",
      "year": 1824,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Abel–Ruffini_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 338",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "338",
      "year": 1752,
      "field": "Mathematics",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Cauchy–Riemann_equations",
      "unrecognized?": "d’Alembert",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 326",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "326",
      "year": 1999,
      "field": "Mathematics",
      "type": "algorithm",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Purser_algorithm",
      "unrecognized?": "Sarah Flannery",
      "subfield": "Cryptography"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 182 => 251",
      "selected": false,
      "interaction": "cc",
      "source": "182",
      "target": "251",
      "year": 1968,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kazhdan–Margulis_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 75 => 248",
      "selected": false,
      "interaction": "cc",
      "source": "75",
      "target": "248",
      "year": 1955,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Dieudonné_module#Dieudonné–Manin_classification_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 92 => 407",
      "selected": false,
      "interaction": "cc",
      "source": "92",
      "target": "407",
      "year": 1925,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fischer–Tropsch_process",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 41 => 248",
      "selected": false,
      "interaction": "cc",
      "source": "41",
      "target": "248",
      "year": "missing",
      "field": "Mathematics",
      "type": "operator",
      "reference": "https://en.wikipedia.org/wiki/Hasse–Witt_matrix#Cohomology",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 204 => 426",
      "selected": false,
      "interaction": "cc",
      "source": "204",
      "target": "426",
      "year": 1853,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kronecker–Weber_theorem#History",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 402 => 88",
      "selected": false,
      "interaction": "cc",
      "source": "402",
      "target": "88",
      "year": 1977,
      "field": "Mathematics",
      "type": "cohomology",
      "reference": "https://en.wikipedia.org/wiki/Tate_cohomology_group#Tate-Farrell_cohomology",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 19 => 351",
      "selected": false,
      "interaction": "cc",
      "source": "19",
      "target": "351",
      "year": 1950,
      "field": "Physics",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Bethe–Salpeter_equation",
      "unrecognized?": "Nambu",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 310 => 230",
      "selected": false,
      "interaction": "cc",
      "source": "310",
      "target": "230",
      "year": 1908,
      "field": "Mathematics",
      "type": "principle",
      "reference": "https://en.wikipedia.org/wiki/Phragmén–Lindelöf_principle",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 131",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "131",
      "year": 1853,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Hamilton_theorem",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 149 => 402",
      "selected": false,
      "interaction": "cc",
      "source": "149",
      "target": "402",
      "year": 1967,
      "field": "Mathematics",
      "type": "module",
      "reference": "https://en.wikipedia.org/wiki/Hodge–Tate_module",
      "unrecognized?": "Jean-Pierre Serre",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 130 => 317",
      "selected": false,
      "interaction": "cc",
      "source": "130",
      "target": "317",
      "year": 1838,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hagen–Poiseuille_equation",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 298 => 381",
      "selected": false,
      "interaction": "cc",
      "source": "298",
      "target": "381",
      "year": 1907,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Orr–Sommerfeld_equation",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 316 => 232",
      "selected": false,
      "interaction": "cc",
      "source": "316",
      "target": "232",
      "year": "missing",
      "field": "Mathematics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Poincaré–Lindstedt_method",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 248 => 79",
      "selected": false,
      "interaction": "cc",
      "source": "248",
      "target": "79",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Manin–Drinfeld_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 26 => 427",
      "selected": false,
      "interaction": "cc",
      "source": "26",
      "target": "427",
      "year": 1817,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Bolzano–Weierstrass_theorem",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 266 => 387",
      "selected": false,
      "interaction": "cc",
      "source": "266",
      "target": "387",
      "year": "missing",
      "field": "Mathematics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Minkowski–Steiner_formula",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 269 => 315",
      "selected": false,
      "interaction": "cc",
      "source": "269",
      "target": "315",
      "year": 1934,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Møller–Plesset_perturbation_theory",
      "unrecognized?": "missing",
      "subfield": "Quantum Chemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 16 => 352",
      "selected": false,
      "interaction": "cc",
      "source": "16",
      "target": "352",
      "year": 1971,
      "field": "Mathematics",
      "type": "polynomial",
      "reference": "https://en.wikipedia.org/wiki/Bernstein–Sato_polynomial",
      "unrecognized?": "Takuro Shintani",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 203 => 2",
      "selected": false,
      "interaction": "cc",
      "source": "203",
      "target": "2",
      "year": 1934,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Superexchange",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 112",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "112",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Ginzburg–Landau_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 306 => 138",
      "selected": false,
      "interaction": "cc",
      "source": "306",
      "target": "138",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Penrose–Hawking_singularity_theorems",
      "unrecognized?": "missing",
      "subfield": "Cosmology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 338 => 389",
      "selected": false,
      "interaction": "cc",
      "source": "338",
      "target": "389",
      "year": 1884,
      "field": "Mathematics",
      "type": "integral",
      "reference": "https://en.wikipedia.org/wiki/Riemann–Stieltjes_integral",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 148 => 444",
      "selected": false,
      "interaction": "cc",
      "source": "148",
      "target": "444",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Low-discrepancy_sequence#The_formula_of_Hlawka–Zaremba",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 394 => 308",
      "selected": false,
      "interaction": "cc",
      "source": "394",
      "target": "308",
      "year": 1925,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Streeter–Phelps_equation",
      "unrecognized?": "missing",
      "subfield": "Civil/Environmental Engineering"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 288 => 40",
      "selected": false,
      "interaction": "cc",
      "source": "288",
      "target": "40",
      "year": 1923,
      "field": "Physics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Newton–Cartan_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 172 => 436",
      "selected": false,
      "interaction": "cc",
      "source": "172",
      "target": "436",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Jordan–Wigner_transformation",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 68 => 219",
      "selected": false,
      "interaction": "cc",
      "source": "68",
      "target": "219",
      "year": 1738,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/de_Moivre–Laplace_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 211",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "211",
      "year": 1755,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Euler–Lagrange_equation",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 98 => 71",
      "selected": false,
      "interaction": "cc",
      "source": "98",
      "target": "71",
      "year": 1976,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fourier–Deligne_transform",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 206",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "206",
      "year": 1964,
      "field": "Mathematics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 150 => 193",
      "selected": false,
      "interaction": "cc",
      "source": "150",
      "target": "193",
      "year": 1964,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 321 => 103",
      "selected": false,
      "interaction": "cc",
      "source": "321",
      "target": "103",
      "year": 1938,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Poole–Frenkel_effect",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 94 => 100",
      "selected": false,
      "interaction": "cc",
      "source": "94",
      "target": "100",
      "year": 1950,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Flory–Fox_equation",
      "unrecognized?": "missing",
      "subfield": "Polymers"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 147 => 282",
      "selected": false,
      "interaction": "cc",
      "source": "147",
      "target": "282",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hilbert–Mumford_criterion",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 205 => 305",
      "selected": false,
      "interaction": "cc",
      "source": "205",
      "target": "305",
      "year": 1931,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 51 => 187",
      "selected": false,
      "interaction": "cc",
      "source": "51",
      "target": "187",
      "year": 1937,
      "field": "Mathematics",
      "type": "ordinal",
      "reference": "https://en.wikipedia.org/wiki/Church–Kleene_ordinal",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 248",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "248",
      "year": 1958,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gauss–Manin_connection",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 254 => 328",
      "selected": false,
      "interaction": "cc",
      "source": "254",
      "target": "328",
      "year": 1986,
      "field": "Physics",
      "type": "form",
      "reference": "https://en.wikipedia.org/wiki/Mathai–Quillen_formalism",
      "unrecognized?": "missing",
      "subfield": "Quantum Field Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 310 => 32",
      "selected": false,
      "interaction": "cc",
      "source": "310",
      "target": "32",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Phragmen–Brouwer_theorem",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 77 => 419",
      "selected": false,
      "interaction": "cc",
      "source": "77",
      "target": "419",
      "year": 1930,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Dirac–von_Neumann_axioms",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 28 => 128",
      "selected": false,
      "interaction": "cc",
      "source": "28",
      "target": "128",
      "year": 1919,
      "field": "Chemistry",
      "type": "thermodynamic cycle",
      "reference": "https://en.wikipedia.org/wiki/Born–Haber_cycle",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 70 => 421",
      "selected": false,
      "interaction": "cc",
      "source": "70",
      "target": "421",
      "year": 1913,
      "field": "Physics",
      "type": "factor",
      "reference": "https://www.oxfordreference.com/view/10.1093/oi/authority.20110803095705269",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 44 => 282",
      "selected": false,
      "interaction": "cc",
      "source": "44",
      "target": "282",
      "year": 1893,
      "field": "Mathematics",
      "type": "regularity",
      "reference": "https://en.wikipedia.org/wiki/Castelnuovo–Mumford_regularity",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 329 => 353",
      "selected": false,
      "interaction": "cc",
      "source": "329",
      "target": "353",
      "year": 2002,
      "field": "Mathematics",
      "type": "series",
      "reference": "https://en.wikipedia.org/wiki/Ramanujan–Sato_series#cite_note-Sato-7",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 40 => 180",
      "selected": false,
      "interaction": "cc",
      "source": "40",
      "target": "180",
      "year": "missing",
      "field": "Mathematics",
      "type": "algorithm",
      "reference": "https://en.wikipedia.org/wiki/Cartan–Karlhede_algorithm",
      "unrecognized?": "Carl Brans",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 342 => 400",
      "selected": false,
      "interaction": "cc",
      "source": "342",
      "target": "400",
      "year": 1926,
      "field": "Mathematics",
      "type": "polynomial",
      "reference": "https://en.wikipedia.org/wiki/Rogers–Szegő_polynomials",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 257 => 7",
      "selected": false,
      "interaction": "cc",
      "source": "257",
      "target": "7",
      "year": 1908,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Barnes_integral",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 433 => 370",
      "selected": false,
      "interaction": "cc",
      "source": "433",
      "target": "370",
      "year": 1898,
      "field": "Mathematics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Whittaker–Shannon_interpolation_formula",
      "unrecognized?": "Borel",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 12 => 188",
      "selected": false,
      "interaction": "cc",
      "source": "12",
      "target": "188",
      "year": 1868,
      "field": "Mathematics",
      "type": "model",
      "reference": "https://en.wikipedia.org/wiki/Beltrami–Klein_model",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 14 => 99",
      "selected": false,
      "interaction": "cc",
      "source": "14",
      "target": "99",
      "year": 1933,
      "field": "Chemistry",
      "type": "rule",
      "reference": "https://en.wikipedia.org/wiki/Ice_rules",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 260 => 420",
      "selected": false,
      "interaction": "cc",
      "source": "260",
      "target": "420",
      "year": 1966,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Mermin–Wagner_theorem",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 141 => 238",
      "selected": false,
      "interaction": "cc",
      "source": "141",
      "target": "238",
      "year": 1927,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Valence_bond_theory",
      "unrecognized?": "missing",
      "subfield": "Quantum Chemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 314 => 333",
      "selected": false,
      "interaction": "cc",
      "source": "314",
      "target": "333",
      "year": 1873,
      "field": "Engineering",
      "type": "instability",
      "reference": "https://en.wikipedia.org/wiki/Plateau–Rayleigh_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 384 => 82",
      "selected": false,
      "interaction": "cc",
      "source": "384",
      "target": "82",
      "year": 1908,
      "field": "Chemistry",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Photoelectrochemical_process#Stark–Einstein_law",
      "unrecognized?": "missing",
      "subfield": "Photochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 123 => 207",
      "selected": false,
      "interaction": "cc",
      "source": "123",
      "target": "207",
      "year": 1954,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Green–Kubo_relations",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 72 => 194",
      "selected": false,
      "interaction": "cc",
      "source": "72",
      "target": "194",
      "year": 1979,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Denjoy–Koksma_inequality",
      "unrecognized?": "Michael-Robert Herman",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 94 => 360",
      "selected": false,
      "interaction": "cc",
      "source": "94",
      "target": "360",
      "year": 1936,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Flory–Schulz_distribution",
      "unrecognized?": "missing",
      "subfield": "Polymers"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 403 => 121",
      "selected": false,
      "interaction": "cc",
      "source": "403",
      "target": "121",
      "year": 1937,
      "field": "Engineering",
      "type": "vortex",
      "reference": "https://en.wikipedia.org/wiki/Taylor–Green_vortex",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 72 => 243",
      "selected": false,
      "interaction": "cc",
      "source": "72",
      "target": "243",
      "year": 1912,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Denjoy–Luzin_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 445",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "445",
      "year": 1932,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Zener_formula",
      "unrecognized?": "Ernst Stueckelberg, Ettore Majorana",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 302 => 446",
      "selected": false,
      "interaction": "cc",
      "source": "302",
      "target": "446",
      "year": 1932,
      "field": "Mathematics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Paley–Zygmund_inequality",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 231 => 427",
      "selected": false,
      "interaction": "cc",
      "source": "231",
      "target": "427",
      "year": 1882,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Lindemann–Weierstrass_theorem",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 372 => 67",
      "selected": false,
      "interaction": "cc",
      "source": "372",
      "target": "67",
      "year": 1930,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Shubnikov–de_Haas_effect",
      "unrecognized?": "missing",
      "subfield": "Magnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 183 => 143",
      "selected": false,
      "interaction": "cc",
      "source": "183",
      "target": "143",
      "year": 1868,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kelvin–Helmholtz_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 435 => 186",
      "selected": false,
      "interaction": "cc",
      "source": "435",
      "target": "186",
      "year": 1930,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Wiener–Khinchin_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 324 => 263",
      "selected": false,
      "interaction": "cc",
      "source": "324",
      "target": "263",
      "year": 1908,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Prandtl–Meyer_expansion_fan",
      "unrecognized?": "missing",
      "subfield": "Supersonics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 358 => 276",
      "selected": false,
      "interaction": "cc",
      "source": "358",
      "target": "276",
      "year": "missing",
      "field": "Engineering",
      "type": "rule",
      "reference": "https://en.wikipedia.org/wiki/Metal–semiconductor_junction#Schottky–Mott_rule_and_Fermi_level_pinning",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 316 => 155",
      "selected": false,
      "interaction": "cc",
      "source": "316",
      "target": "155",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Poincaré–Hopf_theorem",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 17 => 418",
      "selected": false,
      "interaction": "cc",
      "source": "17",
      "target": "418",
      "year": 1949,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Bernstein–von_Mises_theorem",
      "unrecognized?": "Joseph Doob",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 111 => 143",
      "selected": false,
      "interaction": "cc",
      "source": "111",
      "target": "143",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 304 => 283",
      "selected": false,
      "interaction": "cc",
      "source": "304",
      "target": "283",
      "year": "missing",
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Peierls_stress",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 338 => 233",
      "selected": false,
      "interaction": "cc",
      "source": "338",
      "target": "233",
      "year": "missing",
      "field": "Mathematics",
      "type": "integral",
      "reference": "https://en.wikipedia.org/wiki/Riemann–Liouville_integral",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 294 => 429",
      "selected": false,
      "interaction": "cc",
      "source": "294",
      "target": "429",
      "year": 1970,
      "field": "Engineering",
      "type": "parameter",
      "reference": "https://en.wikipedia.org/wiki/Okubo-Weiss_parameter",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 59 => 330",
      "selected": false,
      "interaction": "cc",
      "source": "59",
      "target": "330",
      "year": 1946,
      "field": "Mathematics",
      "type": "bound",
      "reference": "https://en.wikipedia.org/wiki/Cramér–Rao_bound#cite_note-Cramér-1",
      "unrecognized?": "Maurice Fréchet, Georges Darmois, Alexander Aitken and Harold Silverstone",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 387 => 223",
      "selected": false,
      "interaction": "cc",
      "source": "387",
      "target": "223",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Steiner–Lehmus_theorem",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 328 => 398",
      "selected": false,
      "interaction": "cc",
      "source": "328",
      "target": "398",
      "year": 1976,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Quillen–Suslin_theorem",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 296 => 245",
      "selected": false,
      "interaction": "cc",
      "source": "296",
      "target": "245",
      "year": 1953,
      "field": "Mathematics",
      "type": "function",
      "reference": "https://en.wikipedia.org/wiki/Onsager–Machlup_function",
      "unrecognized?": "missing",
      "subfield": "Differential Equations"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 234 => 362",
      "selected": false,
      "interaction": "cc",
      "source": "234",
      "target": "362",
      "year": 1950,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lippmann–Schwinger_equation",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 11 => 213",
      "selected": false,
      "interaction": "cc",
      "source": "11",
      "target": "213",
      "year": 1729,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Beer–Lambert_law",
      "unrecognized?": "Pierre Bouguer",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 422 => 214",
      "selected": false,
      "interaction": "cc",
      "source": "422",
      "target": "214",
      "year": 2001,
      "field": "Mathematics",
      "type": "algorithm",
      "reference": "https://en.wikipedia.org/wiki/Wang_and_Landau_algorithm",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 70 => 159",
      "selected": false,
      "interaction": "cc",
      "source": "70",
      "target": "159",
      "year": 1923,
      "field": "Chemistry",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Debye–Hückel_equation",
      "unrecognized?": "missing",
      "subfield": "Electrochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 319 => 414",
      "selected": false,
      "interaction": "cc",
      "source": "319",
      "target": "414",
      "year": 1918,
      "field": "Mathematics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Quadratic_residue#The_Pólya–Vinogradov_inequality",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 239",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "239",
      "year": 1902,
      "field": "Physics",
      "type": "pendulum",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Lorentz_pendulum",
      "unrecognized?": "missing",
      "subfield": "Classical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 94 => 390",
      "selected": false,
      "interaction": "cc",
      "source": "94",
      "target": "390",
      "year": 1941,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Flory–Stockmayer_theory",
      "unrecognized?": "missing",
      "subfield": "Polymers"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 348 => 210",
      "selected": false,
      "interaction": "cc",
      "source": "348",
      "target": "210",
      "year": 1900,
      "field": "Mathematics",
      "type": "method",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 143 => 192",
      "selected": false,
      "interaction": "cc",
      "source": "143",
      "target": "192",
      "year": 1935,
      "field": "Biology",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Helmholtz–Kohlrausch_effect",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 386 => 25",
      "selected": false,
      "interaction": "cc",
      "source": "386",
      "target": "25",
      "year": 1884,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Stefan–Boltzmann_law#History",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 37 => 401",
      "selected": false,
      "interaction": "cc",
      "source": "37",
      "target": "401",
      "year": "missing",
      "field": "Mathematics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 178 => 77",
      "selected": false,
      "interaction": "cc",
      "source": "178",
      "target": "77",
      "year": 1933,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kapitsa–Dirac_effect",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 101 => 55",
      "selected": false,
      "interaction": "cc",
      "source": "101",
      "target": "55",
      "year": 1926,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Franck–Condon_principle#cite_note-1",
      "unrecognized?": "missing",
      "subfield": "Quantum Chemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 147 => 316",
      "selected": false,
      "interaction": "cc",
      "source": "147",
      "target": "316",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hilbert–Poincaré_series",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 258",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "258",
      "year": "missing",
      "field": "Mathematics",
      "type": "determinant",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Menger_determinant",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 284 => 117",
      "selected": false,
      "interaction": "cc",
      "source": "284",
      "target": "117",
      "year": 1970,
      "field": "Physics",
      "type": "action",
      "reference": "https://en.wikipedia.org/wiki/Nambu–Goto_action#cite_note-1",
      "unrecognized?": "missing",
      "subfield": "String Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 301 => 376",
      "selected": false,
      "interaction": "cc",
      "source": "301",
      "target": "376",
      "year": "missing",
      "field": "Mathematics",
      "type": "condition",
      "reference": "https://en.wikipedia.org/wiki/Palais–Smale_compactness_condition",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 215 => 196",
      "selected": false,
      "interaction": "cc",
      "source": "215",
      "target": "196",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Kolmogorov_inequality",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 173",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "173",
      "year": 1777,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gaussian_elimination",
      "unrecognized?": "Chinese mathematicians?",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 128 => 29",
      "selected": false,
      "interaction": "cc",
      "source": "128",
      "target": "29",
      "year": 1909,
      "field": "Chemistry",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 239 => 240",
      "selected": false,
      "interaction": "cc",
      "source": "239",
      "target": "240",
      "year": 1869,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Clausius–Mossotti_relation#Lorentz–Lorenz_equation",
      "unrecognized?": "missing",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 40 => 129",
      "selected": false,
      "interaction": "cc",
      "source": "40",
      "target": "129",
      "year": 1881,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cartan–Hadamard_theorem",
      "unrecognized?": "Hans Carl Friedrich von Mangoldt",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 94 => 334",
      "selected": false,
      "interaction": "cc",
      "source": "94",
      "target": "334",
      "year": 1943,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Flory–Rehner_equation",
      "unrecognized?": "missing",
      "subfield": "Polymers"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 286 => 82",
      "selected": false,
      "interaction": "cc",
      "source": "286",
      "target": "82",
      "year": "missing",
      "field": "Chemistry",
      "type": "equation",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Electrochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 107 => 222",
      "selected": false,
      "interaction": "cc",
      "source": "107",
      "target": "222",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 128 => 430",
      "selected": false,
      "interaction": "cc",
      "source": "128",
      "target": "430",
      "year": 1932,
      "field": "Chemistry",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 193 => 369",
      "selected": false,
      "interaction": "cc",
      "source": "193",
      "target": "369",
      "year": 1965,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 202",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "202",
      "year": 1875,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cauchy–Kowalevski_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 350 => 403",
      "selected": false,
      "interaction": "cc",
      "source": "350",
      "target": "403",
      "year": 1958,
      "field": "Engineering",
      "type": "instability",
      "reference": "https://en.wikipedia.org/wiki/Saffman–Taylor_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 153 => 145",
      "selected": false,
      "interaction": "cc",
      "source": "153",
      "target": "145",
      "year": 1952,
      "field": "missing",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Holstein–Herring_method",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 6",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "6",
      "year": 1886,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Bacharach_theorem",
      "unrecognized?": "Michel Chasles",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 54 => 115",
      "selected": false,
      "interaction": "cc",
      "source": "54",
      "target": "115",
      "year": "missing",
      "field": "Mathematics",
      "type": "coefficient",
      "reference": "https://en.wikipedia.org/wiki/Clebsch–Gordan_coefficients",
      "unrecognized?": "missing",
      "subfield": "Representation Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 356 => 47",
      "selected": false,
      "interaction": "cc",
      "source": "356",
      "target": "47",
      "year": 1942,
      "field": "Physics",
      "type": "limit",
      "reference": "https://en.wikipedia.org/wiki/Schönberg–Chandrasekhar_limit",
      "unrecognized?": "missing",
      "subfield": "Astrophysics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 108 => 290",
      "selected": false,
      "interaction": "cc",
      "source": "108",
      "target": "290",
      "year": 1953,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Gell-Mann–Nishijima_formula",
      "unrecognized?": "Nakano",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 393 => 438",
      "selected": false,
      "interaction": "cc",
      "source": "393",
      "target": "438",
      "year": 1948,
      "field": "Physics",
      "type": "model",
      "reference": "https://en.wikipedia.org/wiki/Stoner–Wohlfarth_model",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 86 => 280",
      "selected": false,
      "interaction": "cc",
      "source": "86",
      "target": "280",
      "year": 1963,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Euclid–Mullin_sequence",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 34 => 415",
      "selected": false,
      "interaction": "cc",
      "source": "34",
      "target": "415",
      "year": 1930,
      "field": "Chemistry",
      "type": "equation",
      "reference": "missing",
      "unrecognized?": "Erdey-Grúz",
      "subfield": "Electrochemistry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 203 => 140",
      "selected": false,
      "interaction": "cc",
      "source": "203",
      "target": "140",
      "year": 1925,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 133 => 138",
      "selected": false,
      "interaction": "cc",
      "source": "133",
      "target": "138",
      "year": 1983,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hartle–Hawking_state",
      "unrecognized?": "missing",
      "subfield": "Cosmology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 3 => 23",
      "selected": false,
      "interaction": "cc",
      "source": "3",
      "target": "23",
      "year": 1949,
      "field": "Physics",
      "type": "effect",
      "reference": "https://en.wikipedia.org/wiki/Aharonov–Bohm_effect",
      "unrecognized?": "Werner Ehrenberg and Raymond Siday",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 284 => 114",
      "selected": false,
      "interaction": "cc",
      "source": "284",
      "target": "114",
      "year": 1960,
      "field": "Physics",
      "type": "fermion",
      "reference": "https://en.wikipedia.org/wiki/Goldstone_boson#Nambu–Goldstone_fermions",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 98 => 18",
      "selected": false,
      "interaction": "cc",
      "source": "98",
      "target": "18",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fourier–Bessel_series",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 349 => 405",
      "selected": false,
      "interaction": "cc",
      "source": "349",
      "target": "405",
      "year": 1912,
      "field": "Physics",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Sackur–Tetrode_equation",
      "unrecognized?": "missing",
      "subfield": "Thermodynamics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 292 => 154",
      "selected": false,
      "interaction": "cc",
      "source": "292",
      "target": "154",
      "year": 1985,
      "field": "Engineering",
      "type": "algorithm",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Simulation"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 10 => 47",
      "selected": false,
      "interaction": "cc",
      "source": "10",
      "target": "47",
      "year": 1946,
      "field": "missing",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Batchelor–Chandrasekhar_equation",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 228 => 299",
      "selected": false,
      "interaction": "cc",
      "source": "228",
      "target": "299",
      "year": 1981,
      "field": "missing",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 392 => 427",
      "selected": false,
      "interaction": "cc",
      "source": "392",
      "target": "427",
      "year": 1885,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Stone–Weierstrass_theorem",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 65 => 23",
      "selected": false,
      "interaction": "cc",
      "source": "65",
      "target": "23",
      "year": 1952,
      "field": "Physics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/de_Broglie–Bohm_theory",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 161 => 387",
      "selected": false,
      "interaction": "cc",
      "source": "161",
      "target": "387",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Parallel_axis_theorem",
      "unrecognized?": "missing",
      "subfield": "Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 89 => 400",
      "selected": false,
      "interaction": "cc",
      "source": "89",
      "target": "400",
      "year": 1933,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fekete–Szegő_inequality",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 190 => 218",
      "selected": false,
      "interaction": "cc",
      "source": "190",
      "target": "218",
      "year": "missing",
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hertz–Knudsen_equation",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 382",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "382",
      "year": 1944,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Squire_jet",
      "unrecognized?": "N. A. Slezkin",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 256 => 25",
      "selected": false,
      "interaction": "cc",
      "source": "256",
      "target": "25",
      "year": 1860,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Maxwell–Boltzmann_distribution",
      "unrecognized?": "missing",
      "subfield": "Statistical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 45 => 188",
      "selected": false,
      "interaction": "cc",
      "source": "45",
      "target": "188",
      "year": 1859,
      "field": "Mathematics",
      "type": "metric",
      "reference": "https://en.wikipedia.org/wiki/Cayley–Klein_metric",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 156 => 282",
      "selected": false,
      "interaction": "cc",
      "source": "156",
      "target": "282",
      "year": 1973,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Horrocks–Mumford_bundle",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 316 => 21",
      "selected": false,
      "interaction": "cc",
      "source": "316",
      "target": "21",
      "year": 1898,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kelvin%27s_circulation_theorem#Poincaré–Bjerknes_circulation_theorem",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 31 => 167",
      "selected": false,
      "interaction": "cc",
      "source": "31",
      "target": "167",
      "year": 1970,
      "field": "Mathematics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Box–Jenkins_method",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 129",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "129",
      "year": 1821,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Cauchy–Hadamard_theorem",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 103 => 197",
      "selected": false,
      "interaction": "cc",
      "source": "103",
      "target": "197",
      "year": 1938,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Frenkel–Kontorova_model",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 315",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "315",
      "year": 1917,
      "field": "Engineering",
      "type": "equation of state",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Plesset_equation",
      "unrecognized?": "W. H. Besant",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 187 => 275",
      "selected": false,
      "interaction": "cc",
      "source": "187",
      "target": "275",
      "year": "missing",
      "field": "missing",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Arithmetical_hierarchy",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 229",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "229",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Lifshitz_model",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 285 => 391",
      "selected": false,
      "interaction": "cc",
      "source": "285",
      "target": "391",
      "year": "missing",
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Navier–Stokes_equations",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 288 => 331",
      "selected": false,
      "interaction": "cc",
      "source": "288",
      "target": "331",
      "year": 1690,
      "field": "Mathematics",
      "type": "method",
      "reference": "https://en.wikipedia.org/wiki/Newton%27s_method",
      "unrecognized?": "missing",
      "subfield": "Numerics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 235",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "235",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Picard–Lindelöf_theorem",
      "unrecognized?": "missing",
      "subfield": "Differential Equations"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 338 => 341",
      "selected": false,
      "interaction": "cc",
      "source": "338",
      "target": "341",
      "year": 1865,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Riemann–Roch_theorem",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 332",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "332",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Raychaudhuri_equation",
      "unrecognized?": "missing",
      "subfield": "Relativity"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 132 => 236",
      "selected": false,
      "interaction": "cc",
      "source": "132",
      "target": "236",
      "year": 1923,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Second_Hardy–Littlewood_conjecture",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 142 => 91",
      "selected": false,
      "interaction": "cc",
      "source": "142",
      "target": "91",
      "year": 1932,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hellmann–Feynman_theorem",
      "unrecognized?": "Güttinger, Pauli",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 333 => 403",
      "selected": false,
      "interaction": "cc",
      "source": "333",
      "target": "403",
      "year": 1883,
      "field": "Engineering",
      "type": "instability",
      "reference": "https://en.wikipedia.org/wiki/Rayleigh–Taylor_instability",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 392 => 419",
      "selected": false,
      "interaction": "cc",
      "source": "392",
      "target": "419",
      "year": 1931,
      "field": "Physics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Stone–von_Neumann_theorem#CITEREFvon_Neumann1931",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 83 => 47",
      "selected": false,
      "interaction": "cc",
      "source": "83",
      "target": "47",
      "year": 1907,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Emden–Chandrasekhar_equation",
      "unrecognized?": "missing",
      "subfield": "Astrophysics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 212 => 272",
      "selected": false,
      "interaction": "cc",
      "source": "212",
      "target": "272",
      "year": 1959,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Lamb–Mössbauer_factor",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 361",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "361",
      "year": 1821,
      "field": "Mathematics",
      "type": "inequality",
      "reference": "https://en.wikipedia.org/wiki/Cauchy–Schwarz_inequality",
      "unrecognized?": "Viktor Bunyakovsky",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 225",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "225",
      "year": 1942,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Levich_problem",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 241",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "241",
      "year": 1911,
      "field": "Social Sciences",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Euler–Lotka_equation",
      "unrecognized?": "missing",
      "subfield": "Demographics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 271 => 301",
      "selected": false,
      "interaction": "cc",
      "source": "271",
      "target": "301",
      "year": "missing",
      "field": "Mathematics",
      "type": "lemma",
      "reference": "https://en.wikipedia.org/wiki/Morse–Palais_lemma",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 379 => 73",
      "selected": false,
      "interaction": "cc",
      "source": "379",
      "target": "73",
      "year": 984,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Snell%27s_law",
      "unrecognized?": "Ibn Sahl",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 397 => 233",
      "selected": false,
      "interaction": "cc",
      "source": "397",
      "target": "233",
      "year": "missing",
      "field": "Mathematics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Sturm–Liouville_theory",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 338 => 147",
      "selected": false,
      "interaction": "cc",
      "source": "338",
      "target": "147",
      "year": "missing",
      "field": "Mathematics",
      "type": "problem",
      "reference": "https://en.wikipedia.org/wiki/Riemann–Hilbert_problem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 293 => 370",
      "selected": false,
      "interaction": "cc",
      "source": "293",
      "target": "370",
      "year": 1915,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Nyquist–Shannon_sampling_theorem",
      "unrecognized?": "E. T. Whittaker, Vladimir Kotelnikov",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 147 => 355",
      "selected": false,
      "interaction": "cc",
      "source": "147",
      "target": "355",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Hilbert–Schmidt_operator",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 419 => 270",
      "selected": false,
      "interaction": "cc",
      "source": "419",
      "target": "270",
      "year": 1947,
      "field": "Economics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/von_Neumann–Morgenstern_utility_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 379 => 323",
      "selected": false,
      "interaction": "cc",
      "source": "379",
      "target": "323",
      "year": 1615,
      "field": "Mathematics",
      "type": "problem",
      "reference": "https://en.wikipedia.org/wiki/Snellius–Pothenot_problem",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 274 => 301",
      "selected": false,
      "interaction": "cc",
      "source": "274",
      "target": "301",
      "year": 1957,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Mostow–Palais_theorem",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 87 => 36",
      "selected": false,
      "interaction": "cc",
      "source": "87",
      "target": "36",
      "year": "missing",
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Cauchy_stress_tensor#Euler–Cauchy_stress_principle_–_stress_vector",
      "unrecognized?": "missing",
      "subfield": "Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 311 => 221",
      "selected": false,
      "interaction": "cc",
      "source": "311",
      "target": "221",
      "year": 1897,
      "field": "Mathematics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Picard–Lefschetz_theory",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 120 => 45",
      "selected": false,
      "interaction": "cc",
      "source": "120",
      "target": "45",
      "year": "missing",
      "field": "Mathematics",
      "type": "algebra",
      "reference": "https://en.wikipedia.org/wiki/Grassmann–Cayley_algebra",
      "unrecognized?": "missing",
      "subfield": "Algebra"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 330 => 22",
      "selected": false,
      "interaction": "cc",
      "source": "330",
      "target": "22",
      "year": 1947,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Rao–Blackwell_theorem",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 320 => 387",
      "selected": false,
      "interaction": "cc",
      "source": "320",
      "target": "387",
      "year": 1833,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Poncelet–Steiner_theorem",
      "unrecognized?": "missing",
      "subfield": "Geometry"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 287 => 402",
      "selected": false,
      "interaction": "cc",
      "source": "287",
      "target": "402",
      "year": 1965,
      "field": "Mathematics",
      "type": "height",
      "reference": "https://en.wikipedia.org/wiki/Néron–Tate_height",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 370 => 134",
      "selected": false,
      "interaction": "cc",
      "source": "370",
      "target": "134",
      "year": 1948,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Shannon–Hartley_theorem#Historical_development",
      "unrecognized?": "missing",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 392 => 46",
      "selected": false,
      "interaction": "cc",
      "source": "392",
      "target": "46",
      "year": 1937,
      "field": "Mathematics",
      "type": "compactification",
      "reference": "https://en.wikipedia.org/wiki/Stone–Čech_compactification",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 36 => 122",
      "selected": false,
      "interaction": "cc",
      "source": "36",
      "target": "122",
      "year": 1839,
      "field": "Engineering",
      "type": "tensor",
      "reference": "https://en.wikipedia.org/wiki/Finite_strain_theory#The_right_Cauchy–Green_deformation_tensor",
      "unrecognized?": "missing",
      "subfield": "Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 194 => 148",
      "selected": false,
      "interaction": "cc",
      "source": "194",
      "target": "148",
      "year": "missing",
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Low-discrepancy_sequence#The_Koksma–Hlawka_inequality",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 72 => 339",
      "selected": false,
      "interaction": "cc",
      "source": "72",
      "target": "339",
      "year": 1906,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Denjoy–Riesz_theorem",
      "unrecognized?": "missing",
      "subfield": "Topology"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 118 => 48",
      "selected": false,
      "interaction": "cc",
      "source": "118",
      "target": "48",
      "year": 1910,
      "field": "Chemistry",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Double_layer_(surface_science)#Gouy–Chapman",
      "unrecognized?": "missing",
      "subfield": "Electronics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 276 => 125",
      "selected": false,
      "interaction": "cc",
      "source": "276",
      "target": "125",
      "year": 1940,
      "field": "Engineering",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Space_charge#Drift_regime_(Mott–Gurney_law)",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 169 => 293",
      "selected": false,
      "interaction": "cc",
      "source": "169",
      "target": "293",
      "year": 1926,
      "field": "Engineering",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Johnson–Nyquist_noise#History",
      "unrecognized?": "missing",
      "subfield": "Electronics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 307 => 432",
      "selected": false,
      "interaction": "cc",
      "source": "307",
      "target": "432",
      "year": 1927,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Peter–Weyl_theorem",
      "unrecognized?": "missing",
      "subfield": "Harmonic Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 318 => 227",
      "selected": false,
      "interaction": "cc",
      "source": "318",
      "target": "227",
      "year": "missing",
      "field": "Mathematics",
      "type": "group",
      "reference": "https://en.wikipedia.org/wiki/Poisson–Lie_group",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 104 => 4",
      "selected": false,
      "interaction": "cc",
      "source": "104",
      "target": "4",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Fresnel–Arago_laws",
      "unrecognized?": "missing",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 144 => 231",
      "selected": false,
      "interaction": "cc",
      "source": "144",
      "target": "231",
      "year": 1882,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Lindemann–Weierstrass_theorem",
      "unrecognized?": "Karl Weierstrass",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 208 => 224",
      "selected": false,
      "interaction": "cc",
      "source": "208",
      "target": "224",
      "year": 1951,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kullback–Leibler_divergence",
      "unrecognized?": "missing",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 198 => 419",
      "selected": false,
      "interaction": "cc",
      "source": "198",
      "target": "419",
      "year": 1931,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Koopman–von_Neumann_classical_mechanics",
      "unrecognized?": "missing",
      "subfield": "Classical Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 417 => 157",
      "selected": false,
      "interaction": "cc",
      "source": "417",
      "target": "157",
      "year": 1938,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://en.wikipedia.org/wiki/Kármán–Howarth_equation",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 203 => 205",
      "selected": false,
      "interaction": "cc",
      "source": "203",
      "target": "205",
      "year": 1926,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Kramers–Kronig_relations",
      "unrecognized?": "missing",
      "subfield": "Optics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 71 => 242",
      "selected": false,
      "interaction": "cc",
      "source": "71",
      "target": "242",
      "year": 1976,
      "field": "Mathematics",
      "type": "theory",
      "reference": "https://en.wikipedia.org/wiki/Deligne–Lusztig_theory",
      "unrecognized?": "missing",
      "subfield": "Group Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 241 => 416",
      "selected": false,
      "interaction": "cc",
      "source": "241",
      "target": "416",
      "year": 1910,
      "field": "Biology",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 338 => 220",
      "selected": false,
      "interaction": "cc",
      "source": "338",
      "target": "220",
      "year": "missing",
      "field": "missing",
      "type": "lemma",
      "reference": "https://en.wikipedia.org/wiki/Riemann–Lebesgue_lemma",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 236 => 302",
      "selected": false,
      "interaction": "cc",
      "source": "236",
      "target": "302",
      "year": 1931,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Littlewood–Paley_theory",
      "unrecognized?": "missing",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 324 => 10",
      "selected": false,
      "interaction": "cc",
      "source": "324",
      "target": "10",
      "year": 1904,
      "field": "Engineering",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Prandtl–Batchelor_theorem",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 31 => 58",
      "selected": false,
      "interaction": "cc",
      "source": "31",
      "target": "58",
      "year": 1964,
      "field": "Mathematics",
      "type": "transform",
      "reference": "https://en.wikipedia.org/wiki/Power_transform#Box–Cox_transformation",
      "unrecognized?": "missing",
      "subfield": "Probability/Statistics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 132 => 329",
      "selected": false,
      "interaction": "cc",
      "source": "132",
      "target": "329",
      "year": 1918,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Partition_function_(number_theory)#Approximation_formulas",
      "unrecognized?": "missing",
      "subfield": "Number Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 391 => 82",
      "selected": false,
      "interaction": "cc",
      "source": "391",
      "target": "82",
      "year": 1905,
      "field": "Engineering",
      "type": "equation",
      "reference": "https://thermopedia.com/content/1156/",
      "unrecognized?": "Sutherland",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 80 => 381",
      "selected": false,
      "interaction": "cc",
      "source": "80",
      "target": "381",
      "year": 1927,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Free_electron_model",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 9 => 328",
      "selected": false,
      "interaction": "cc",
      "source": "9",
      "target": "328",
      "year": 1976,
      "field": "Mathematics",
      "type": "conjecture",
      "reference": "https://en.wikipedia.org/wiki/Bass–Quillen_conjecture",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 78 => 412",
      "selected": false,
      "interaction": "cc",
      "source": "78",
      "target": "412",
      "year": 1983,
      "field": "Mathematics",
      "type": "missing",
      "reference": "https://math.stackexchange.com/questions/3640450/reconciling-donsker-varadhan-definition-of-kl-divergence-with-the-usual-defini",
      "unrecognized?": "missing",
      "subfield": "Information Theory"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 216 => 442",
      "selected": false,
      "interaction": "cc",
      "source": "216",
      "target": "442",
      "year": 1948,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Landau–Yang_theorem",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 297 => 309",
      "selected": false,
      "interaction": "cc",
      "source": "297",
      "target": "309",
      "year": 1935,
      "field": "Physics",
      "type": "process",
      "reference": "https://en.wikipedia.org/wiki/Oppenheimer–Phillips_process",
      "unrecognized?": "missing",
      "subfield": "Particle Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 43 => 427",
      "selected": false,
      "interaction": "cc",
      "source": "43",
      "target": "427",
      "year": 1859,
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Casorati–Weierstrass_theorem",
      "unrecognized?": "Sokhotski, Briot, Bouquet",
      "subfield": "Analysis"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 403 => 325",
      "selected": false,
      "interaction": "cc",
      "source": "403",
      "target": "325",
      "year": 1916,
      "field": "Engineering",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Taylor–Proudman_theorem",
      "unrecognized?": "missing",
      "subfield": "Fluid Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 189 => 291",
      "selected": false,
      "interaction": "cc",
      "source": "189",
      "target": "291",
      "year": 1928,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Klein–Nishina_formula",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 158 => 336",
      "selected": false,
      "interaction": "cc",
      "source": "158",
      "target": "336",
      "year": 1950,
      "field": "Physics",
      "type": "missing",
      "reference": "missing",
      "unrecognized?": "missing",
      "subfield": "Solid-State Physics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 20 => 354",
      "selected": false,
      "interaction": "cc",
      "source": "20",
      "target": "354",
      "year": 1820,
      "field": "Physics",
      "type": "law",
      "reference": "https://en.wikipedia.org/wiki/Biot–Savart_law",
      "unrecognized?": "missing",
      "subfield": "Electromagnetism"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 302 => 435",
      "selected": false,
      "interaction": "cc",
      "source": "302",
      "target": "435",
      "year": "missing",
      "field": "Mathematics",
      "type": "theorem",
      "reference": "https://en.wikipedia.org/wiki/Paley–Wiener_theorem",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 82 => 147",
      "selected": false,
      "interaction": "cc",
      "source": "82",
      "target": "147",
      "year": 1915,
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Einstein–Hilbert_action",
      "unrecognized?": "missing",
      "subfield": "Relativity"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 345 => 322",
      "selected": false,
      "interaction": "cc",
      "source": "345",
      "target": "322",
      "year": 1957,
      "field": "Engineering",
      "type": "phase",
      "reference": "https://en.wikipedia.org/wiki/Ruddlesden-Popper_phase",
      "unrecognized?": "missing",
      "subfield": "Materials"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 19 => 374",
      "selected": false,
      "interaction": "cc",
      "source": "19",
      "target": "374",
      "year": 1930,
      "field": "Physics",
      "type": "curve",
      "reference": "https://en.wikipedia.org/wiki/Bethe–Slater_curve",
      "unrecognized?": "missing",
      "subfield": "Quantum Mechanics"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 276 => 19",
      "selected": false,
      "interaction": "cc",
      "source": "276",
      "target": "19",
      "year": 1930,
      "field": "Physics",
      "type": "formula",
      "reference": "https://en.wikipedia.org/wiki/Mott–Bethe_formula",
      "unrecognized?": "missing",
      "subfield": "missing"
    },
    "selected": false
  }, {
    "data": {
      "id": "Edge 161 => 104",
      "selected": false,
      "interaction": "cc",
      "source": "161",
      "target": "104",
      "year": "missing",
      "field": "Physics",
      "type": "missing",
      "reference": "https://en.wikipedia.org/wiki/Huygens–Fresnel_principle",
      "unrecognized?": "missing",
      "subfield": "Optics"
    },
    "selected": false
  }]
};
elements.nodes.forEach(function (n) {
  n.data.orgPos = {
    x: n.position.x,
    y: n.position.y
  };
});
/* harmony default export */ __webpack_exports__["default"] = (elements);

/***/ }),

/***/ "./src/client/cy-conf/index.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/index.js ***!
  \*************************************/
/*! exports provided: style, elements, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./src/client/cy-conf/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _style__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elements */ "./src/client/cy-conf/elements.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elements", function() { return _elements__WEBPACK_IMPORTED_MODULE_1__["default"]; });




/* harmony default export */ __webpack_exports__["default"] = ({
  style: _style__WEBPACK_IMPORTED_MODULE_0__["default"],
  elements: _elements__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./src/client/cy-conf/style.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/style.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\ncore {\n\tactive-bg-color: #fff;\n\tactive-bg-opacity: 0.333;\n}\n\nedge {\n\tcurve-style: haystack;\n\thaystack-radius: 0;\n\topacity: 0.333;\n\twidth: 2;\n\tz-index: 0;\n\toverlay-opacity: 0;\n\tmid-target-arrow-shape: triangle;\n\tmid-target-arrow-color: #FACD37;\n\n  events: no;\n}\n\nnode {\n\twidth: 40;\n\theight: 40;\n\tfont-size: 9;\n\tfont-weight: bold;\n\tmin-zoomed-font-size: 4;\n\tlabel: data(family_name);\n\ttext-wrap: wrap;\n\ttext-max-width: 50;\n\ttext-valign: center;\n\ttext-halign: center;\n\ttext-events: yes;\n\tcolor: #000;\n\ttext-outline-width: 1;\n\ttext-outline-color: #fff;\n\ttext-outline-opacity: 1;\n\toverlay-color: #fff;\n}\n\nedge[interaction = \"cc\"] {\n\tline-color: #FACD37;\n\tmid-target-arrow-color: #DE3128;\n\topacity: 0.666;\n\tz-index: 9;\n\twidth: 4;\n\tmid-target-arrow-shape: triangle;\n}\n\nnode[NodeType = \"Cheese\"],\nnode[NodeType = \"CheeseType\"] {\n\tbackground-color: #FACD37;\n\ttext-outline-color: #FACD37;\n}\n\nnode[NodeType = \"Cheese\"][Quality],\nnode[NodeType = \"CheeseType\"][Quality] {\n\twidth: mapData(Quality, 70, 100, 20, 50);\n\theight: mapData(Quality, 70, 100, 20, 50);\n}\n\nnode[NodeType = \"WhiteWine\"] {\n\tbackground-color: white;\n\ttext-outline-color: white;\n}\n\nedge[interaction = \"cw\"] {\n\tline-color: white;\n}\n\nnode[NodeType = \"RedWine\"] {\n\tbackground-color: #DE3128;\n\ttext-outline-color: #DE3128;\n}\n\nedge[interaction = \"cr\"] {\n\tline-color: #DE3128;\n}\n\nnode[NodeType = \"Cider\"] {\n\tbackground-color: #A4EB34;\n\ttext-outline-color: #A4EB34;\n}\n\nnode.highlighted {\n\tmin-zoomed-font-size: 0;\n  z-index: 9999;\n}\n\nedge.highlighted {\n\topacity: 0.8;\n\twidth: 4;\n\tz-index: 9999;\n}\n\n.faded {\n  events: no;\n}\n\nnode.faded {\n  opacity: 0.08;\n}\n\nedge.faded {\n  opacity: 0.06;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\n");

/***/ }),

/***/ "./src/client/env.js":
/*!***************************!*\
  !*** ./src/client/env.js ***!
  \***************************/
/*! exports provided: NODE_ENV, isProd, isDev */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NODE_ENV", function() { return NODE_ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProd", function() { return isProd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDev", function() { return isDev; });
var NODE_ENV = "development";
var isProd = NODE_ENV === 'production';
var isDev = !isProd;

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/client/env.js");
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _components_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/app */ "./src/client/components/app.js");




if (!_env__WEBPACK_IMPORTED_MODULE_0__["isProd"]) {
  // set up livereload for dev
  var script = document.createElement('script');
  script.src = 'http://' + location.hostname + ':35729/livereload.js?snipver=1';
  document.head.appendChild(script);
}

var root = document.createElement('div');
root.setAttribute('id', 'root');
document.body.appendChild(root);
Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(_components_app__WEBPACK_IMPORTED_MODULE_2__["AppComponent"]), root);
console.log("You can view the source code of this Cytoscape.js-powered app at https://github.com/cytoscape/wineandcheesemap");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5janMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hlYXAvbGliL2hlYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLm1lbW9pemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jb21wb25lbnRzL2N5dG9zY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbm9kZS1pbmZvLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2N5LWNvbmYvZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jeS1jb25mL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY3ktY29uZi9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2Vudi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2luZGV4LmpzIl0sIm5hbWVzIjpbIkFwcENvbXBvbmVudCIsInByb3BzIiwiY3kiLCJDeXRvc2NhcGUiLCJlbGVtZW50cyIsInN0eWxlIiwibGF5b3V0IiwibmFtZSIsInNlbGVjdGlvblR5cGUiLCJib3hTZWxlY3Rpb25FbmFibGVkIiwiem9vbWluZ0VuYWJsZWQiLCJ1c2VyWm9vbWluZ0VuYWJsZWQiLCJub2RlcyIsInBhbmlmeSIsInVuZ3JhYmlmeSIsImNvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwiYnVzIiwiaXNEZXYiLCJ3aW5kb3ciLCJzdGF0ZSIsIm9uIiwib25TaG93SW5mbyIsIm5vZGUiLCJzZXRTdGF0ZSIsImluZm9Ob2RlIiwib25IaWRlSW5mbyIsInJlbW92ZUxpc3RlbmVyIiwiaCIsIkN5dG9zY2FwZUNvbXBvbmVudCIsIk5vZGVJbmZvIiwiTWVudSIsIkNvbXBvbmVudCIsImlkIiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1vdW50IiwiZml0Iiwib25UYXAiLCJlIiwidGFyZ2V0IiwidW5oaWdobGlnaHQiLCJoaWRlSW5mbyIsImNsb3NlTWVudSIsImhpZ2hsaWdodCIsInNob3dJbmZvIiwib3BlbiIsImlzTWVudU9wZW4iLCJvbk9wZW5NZW51IiwiZm9jdXNUZXh0Qm94Iiwib25VcGRhdGVTZWFyY2giLCJzZWFyY2hNYXRjaE5vZGVzIiwiZGVib3VuY2VkVXBkYXRlU2VhcmNoIiwiZGVib3VuY2UiLCJ1cGRhdGVTZWFyY2giLCJvbkNsb3NlTWVudSIsIm9wZW5NZW51IiwiaW5wdXQiLCJyZXN1bHRzIiwicXVlcnlTdHJpbmciLCJ2YWx1ZSIsInNjcm9sbFRvIiwiZm9jdXMiLCJjbG9zZWQiLCJzZWFyY2hSZXN1bHRzIiwibWFwIiwib25DbGljayIsInNlbGVjdE5vZGUiLCJjbGFzc05hbWVzIiwidG9nZ2xlTWVudSIsInR5cGUiLCJwbGFjZWhvbGRlciIsIm9uS2V5RG93biIsImRhdGEiLCJmYW1pbHlfbmFtZSIsImNvdW50cnkiLCJiaXJ0aF9jb3VudHJ5IiwiaGFzQ291bnRyeSIsInVybCIsInJlZmVyZW5jZSIsInJhY2UiLCJoYXNSYWNlIiwiZ2VuZGVyIiwiYmlydGh5ciIsImJpcnRoX3llYXIiLCJkZWF0aHlyIiwiZGVhdGhfeWVhciIsImhyZWYiLCJsYXlvdXRQYWRkaW5nIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJlYXNpbmciLCJtaW5NZXRyaWNWYWx1ZSIsIm1pblNpbWlsYXJpdHlWYWx1ZSIsImRlbGF5UHJvbWlzZSIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0T3JnUG9zIiwibiIsIk9iamVjdCIsImFzc2lnbiIsIkV2ZW50RW1pdHRlciIsIm1lbnUiLCJjb2xsZWN0aW9uIiwiZW1pdCIsImxhc3RIaWdobGlnaHRlZCIsImhpZ2hsaWdodEluUHJvZ3Jlc3MiLCJhbGxFbGVzIiwibmhvb2QiLCJjbG9zZWROZWlnaGJvcmhvb2QiLCJvdGhlcnMiLCJsYXN0VW5oaWdobGlnaHRlZCIsIm5vdCIsInNob3dPdmVydmlldyIsImJhdGNoIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsInBvc2l0aW9ucyIsImFuaW1hdGUiLCJhbmltYXRpb25FYXNpbmciLCJwYWRkaW5nIiwicnVuIiwicHJvbWlzZU9uIiwicnVuTGF5b3V0IiwicCIsImJvdW5kaW5nQm94IiwieDEiLCJ4IiwieDIiLCJ5MSIsInkiLCJ5MiIsImF2b2lkT3ZlcmxhcCIsImNvbmNlbnRyaWMiLCJlbGUiLCJzYW1lIiwibGV2ZWxXaWR0aCIsInByb21pc2UiLCJzaG93T3RoZXJzRmFkZWQiLCJ0aGVuIiwiaGFzSGlnaGxpZ2h0IiwiYWxsTm9kZXMiLCJzdG9wIiwiaGlkZU90aGVycyIsInJlc2V0Q2xhc3NlcyIsImFuaW1hdGVUb09yZ1BvcyIsImFsbCIsImFuaW1hdGlvbiIsInBvc2l0aW9uIiwicGxheSIsInJlc3RvcmVQb3NpdGlvbnMiLCJub3JtYWxpemUiLCJzdHIiLCJ0b0xvd2VyQ2FzZSIsImdldFdvcmRzIiwic3BsaXQiLCJxdWVyeVdvcmRzIiwiYWRkV29yZHMiLCJ3b3JkTGlzdCIsIndvcmRzU3RyIiwicHVzaCIsImNhY2hlTm9kZVdvcmRzIiwiU3lub255bSIsIk5vZGVUeXBlRm9ybWF0dGVkIiwiTWlsayIsIlR5cGUiLCJDb3VudHJ5IiwiZ2V0U3RyaW5nU2ltaWxhcml0eSIsInF1ZXJ5V29yZCIsIm5vZGVXb3JkIiwiaW5kZXgiLCJpbmRleE9mIiwiZGlmZiIsIk1hdGgiLCJhYnMiLCJsZW5ndGgiLCJtYXhMZW5ndGgiLCJtYXgiLCJnZXRNZXRyaWMiLCJub2RlV29yZHMiLCJzY29yZSIsImkiLCJqIiwic2ltaWxhcml0eSIsImdldE5vZGVNZXRyaWMiLCJtZW1vaXplIiwiY2FjaGVkTm9kZVdvcmRzIiwiZm9yRWFjaCIsImZpbHRlciIsInNvcnQiLCJub2RlQSIsIm5vZGVCIiwib3JnUG9zIiwiTk9ERV9FTlYiLCJwcm9jZXNzIiwiaXNQcm9kIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJyb290Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsInJlbmRlciIsImNvbnNvbGUiLCJsb2ciXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7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RVAsS0FBSztBQUNMOzs7QUFHQTtBQUNBLHNDQUFzQztBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DOzs7QUFHcEMsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEMsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFNBQVM7OztBQUdULG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxrQ0FBa0M7O0FBRWxDLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixtQ0FBbUM7OztBQUduQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxtQkFBbUIsT0FBTztBQUMxQix1QkFBdUIsU0FBUztBQUNoQzs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHFCQUFxQjs7O0FBRzNCLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DOztBQUVBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUYseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLEdBQUc7OztBQUdILG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLE1BQU07OztBQUdOLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUEsOENBQThDOztBQUU5QztBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxjQUFjOztBQUVkLDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsR0FBRzs7O0FBR0gsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDs7QUFFekg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxhQUFhOztBQUViLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QixpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQSwyQ0FBMkM7O0FBRTNDLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RCxtQkFBbUIsY0FBYztBQUNqQyxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7O0FBR2hDLHNCQUFzQjs7QUFFdEI7QUFDQSxLQUFLO0FBQ0w7OztBQUdBLDRDQUE0QztBQUM1Qzs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLE9BQU87OztBQUdQLHVCQUF1QixnQkFBZ0I7QUFDdkMseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQyw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUEsNEJBQTRCOzs7QUFHNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLE9BQU87OztBQUdQLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQixpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLG1CQUFtQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOzs7QUFHNUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLHNGQUFzRjs7QUFFdEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckIsaUNBQWlDOztBQUVqQzs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQix5Q0FBeUM7O0FBRXpDLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQixtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQixtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxzQkFBc0I7O0FBRXRCO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTtBQUNuRTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkMsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QyxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBLGVBQWU7O0FBRWYscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQix1REFBdUQ7O0FBRXZELG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLDBFQUEwRTtBQUMxRTs7QUFFQSwyREFBMkQ7QUFDM0QsR0FBRzs7O0FBR0gsbUJBQW1CLHVCQUF1QjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0EsaUJBQWlCOztBQUVqQixnQkFBZ0I7O0FBRWhCLGlCQUFpQjtBQUNqQjs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGlCQUFpQixxQkFBcUI7QUFDdEMsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQSxHQUFHOzs7QUFHSCxRQUFROztBQUVSLFNBQVM7O0FBRVQsUUFBUTs7QUFFUixRQUFROztBQUVSLFFBQVE7O0FBRVIsUUFBUTs7QUFFUjtBQUNBLGFBQWE7O0FBRWI7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0Isc0JBQXNCO0FBQ3RCOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLEdBQUc7OztBQUdIOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0wscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxXQUFXO0FBQ1gscUNBQXFDO0FBQ3JDLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsNkRBQTZEO0FBQzdEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUI7QUFDdkI7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLFdBQVc7O0FBRVg7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7O0FBRUwsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQ0FBMEM7O0FBRTFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0MsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNK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O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxvRUFBb0U7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGOztBQUV4RixxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR04scUNBQXFDLFNBQVM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUwsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBLDRCQUE0QjtBQUM1QixHQUFHOzs7QUFHSCxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLDZCQUE2QjtBQUNoRCxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FB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Q0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEMsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxRQUFRO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILDZCQUE2Qjs7QUFFN0IsNkJBQTZCOztBQUU3Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5QkFBeUI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5QkFBeUIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRyxTQUFTOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHNCQUFzQjs7QUFFbkY7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQixFQUFFO0FBQ3hFLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTs7QUFFaEUsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsS0FBSyxZQUFZO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsaUJBQWlCOztBQUVqQixrQkFBa0I7O0FBRWxCLGdCQUFnQjs7QUFFaEIsZUFBZTs7QUFFZixtQkFBbUI7O0FBRW5CLHNCQUFzQjs7QUFFdEIsdUJBQXVCOztBQUV2QixtQkFBbUI7O0FBRW5CLG1CQUFtQjs7QUFFbkIscUJBQXFCOztBQUVyQixzQkFBc0I7O0FBRXRCLDJCQUEyQjs7QUFFM0IsbUJBQW1COztBQUVuQixxQkFBcUI7O0FBRXJCLHdCQUF3Qjs7QUFFeEIsc0JBQXNCOztBQUV0Qiw2QkFBNkI7O0FBRTdCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEIsdUJBQXVCLGFBQWE7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1COztBQUVuQjtBQUNBLDZCQUE2QixlQUFlO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLCtCQUErQjs7QUFFL0IsMkNBQTJDOztBQUUzQyxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLHdEQUF3RDs7QUFFeEQsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUEscUJBQXFCLGlCQUFpQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCOztBQUVyQixrQkFBa0I7O0FBRWxCLGlCQUFpQjs7QUFFakIscUJBQXFCOztBQUVyQiw4QkFBOEI7O0FBRTlCLCtCQUErQjs7QUFFL0IscUJBQXFCOztBQUVyQix1QkFBdUI7O0FBRXZCLDBCQUEwQjs7QUFFMUIsd0JBQXdCOztBQUV4QixxQkFBcUI7O0FBRXJCLDJCQUEyQjs7QUFFM0IsK0JBQStCOztBQUUvQixvQ0FBb0M7QUFDcEMsd0JBQXdCLHlDQUF5Qzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLCtCQUErQixrQkFBa0I7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDhCQUE4Qjs7QUFFaEQsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBLG9CQUFvQjs7QUFFcEIsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZUFBZTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkMsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBLE9BQU87O0FBRVA7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9COztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDRCQUE0QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxT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OztBQUVqSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUNBQW1DLDBCQUEwQixvQkFBb0I7QUFDdkk7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBTSxJQUFJLENBQUNDLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsTUFBeEI7QUFDQTNLLFFBQVEsQ0FBQzRLLElBQVQsQ0FBY0gsV0FBZCxDQUEwQkMsSUFBMUI7QUFFQUcscURBQU0sQ0FBQ3BMLGdEQUFDLENBQUM1Qiw0REFBRCxDQUFGLEVBQWtCNk0sSUFBbEIsQ0FBTjtBQUVBSSxPQUFPLENBQUNDLEdBQVIsbUgiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvY2xpZW50L2luZGV4LmpzXCIpO1xuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSwgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciB1dGlsID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2xvZGFzaC5kZWJvdW5jZScpKTtcbnZhciBIZWFwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hlYXAnKSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG52YXIgd2luZG93JDEgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIG5hdmlnYXRvciA9IHdpbmRvdyQxID8gd2luZG93JDEubmF2aWdhdG9yIDogbnVsbDtcbnZhciBkb2N1bWVudCQxID0gd2luZG93JDEgPyB3aW5kb3ckMS5kb2N1bWVudCA6IG51bGw7XG5cbnZhciB0eXBlb2ZzdHIgPSBfdHlwZW9mKCcnKTtcblxudmFyIHR5cGVvZm9iaiA9IF90eXBlb2Yoe30pO1xuXG52YXIgdHlwZW9mZm4gPSBfdHlwZW9mKGZ1bmN0aW9uICgpIHt9KTtcblxudmFyIHR5cGVvZmh0bWxlbGUgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MRWxlbWVudCk7XG5cbnZhciBpbnN0YW5jZVN0ciA9IGZ1bmN0aW9uIGluc3RhbmNlU3RyKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5pbnN0YW5jZVN0cmluZyAmJiBmbihvYmouaW5zdGFuY2VTdHJpbmcpID8gb2JqLmluc3RhbmNlU3RyaW5nKCkgOiBudWxsO1xufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PSB0eXBlb2ZzdHI7XG59O1xudmFyIGZuID0gZnVuY3Rpb24gZm4ob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZmZuO1xufTtcbnZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xufTtcbnZhciBwbGFpbk9iamVjdCA9IGZ1bmN0aW9uIHBsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmogJiYgIWFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xudmFyIG9iamVjdCA9IGZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqO1xufTtcbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IF90eXBlb2YoMSkgJiYgIWlzTmFOKG9iaik7XG59O1xudmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKG9iaikge1xuICByZXR1cm4gbnVtYmVyKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG59O1xudmFyIGh0bWxFbGVtZW50ID0gZnVuY3Rpb24gaHRtbEVsZW1lbnQob2JqKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG59O1xudmFyIGVsZW1lbnRPckNvbGxlY3Rpb24gPSBmdW5jdGlvbiBlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gZWxlbWVudChvYmopIHx8IGNvbGxlY3Rpb24ob2JqKTtcbn07XG52YXIgZWxlbWVudCA9IGZ1bmN0aW9uIGVsZW1lbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbn07XG52YXIgY29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3Rpb24ob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgIW9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvcmUgPSBmdW5jdGlvbiBjb3JlKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvcmUnO1xufTtcbnZhciBzdHlsZXNoZWV0ID0gZnVuY3Rpb24gc3R5bGVzaGVldChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdzdHlsZXNoZWV0Jztcbn07XG52YXIgZXZlbnQgPSBmdW5jdGlvbiBldmVudChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdldmVudCc7XG59O1xudmFyIGVtcHR5U3RyaW5nID0gZnVuY3Rpb24gZW1wdHlTdHJpbmcob2JqKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAvLyBudWxsIGlzIGVtcHR5XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAob2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3Rcbn07XG52YXIgZG9tRWxlbWVudCA9IGZ1bmN0aW9uIGRvbUVsZW1lbnQob2JqKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG59O1xudmFyIGJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3gob2JqKSB7XG4gIHJldHVybiBwbGFpbk9iamVjdChvYmopICYmIG51bWJlcihvYmoueDEpICYmIG51bWJlcihvYmoueDIpICYmIG51bWJlcihvYmoueTEpICYmIG51bWJlcihvYmoueTIpO1xufTtcbnZhciBwcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iamVjdChvYmopICYmIGZuKG9iai50aGVuKTtcbn07XG52YXIgbXMgPSBmdW5jdGlvbiBtcygpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llfHRyaWRlbnR8ZWRnZS9pKTtcbn07IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4sIGtleUZuKSB7XG4gIGlmICgha2V5Rm4pIHtcbiAgICBrZXlGbiA9IGZ1bmN0aW9uIGtleUZuKCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncy5qb2luKCckJyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBtZW1vaXplZEZuID0gZnVuY3Rpb24gbWVtb2l6ZWRGbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgayA9IGtleUZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHZhciBjYWNoZSA9IG1lbW9pemVkRm4uY2FjaGU7XG5cbiAgICBpZiAoIShyZXQgPSBjYWNoZVtrXSkpIHtcbiAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBtZW1vaXplZEZuLmNhY2hlID0ge307XG4gIHJldHVybiBtZW1vaXplZEZuO1xufTtcblxudmFyIGNhbWVsMmRhc2ggPSBtZW1vaXplKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuICctJyArIHYudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBkYXNoMmNhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBwcmVwZW5kQ2FtZWwgPSBtZW1vaXplKGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufSwgZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gIHJldHVybiBwcmVmaXggKyAnJCcgKyBzdHI7XG59KTtcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgaWYgKGVtcHR5U3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgbnVtYmVyJDEgPSAnKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKSc7XG52YXIgcmdiYSA9ICdyZ2JbYV0/XFxcXCgoJyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICdbJV0/KSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJykpP1xcXFwpJztcbnZhciByZ2JhTm9CYWNrUmVmcyA9ICdyZ2JbYV0/XFxcXCgoPzonICsgbnVtYmVyJDEgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0/KSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyJDEgKyAnKSk/XFxcXCknO1xudmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnWyVdKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpKT9cXFxcKSc7XG52YXIgaHNsYU5vQmFja1JlZnMgPSAnaHNsW2FdP1xcXFwoKD86JyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJykpP1xcXFwpJztcbnZhciBoZXgzID0gJ1xcXFwjWzAtOWEtZkEtRl17M30nO1xudmFyIGhleDYgPSAnXFxcXCNbMC05YS1mQS1GXXs2fSc7XG5cbnZhciBhc2NlbmRpbmcgPSBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkZXNjZW5kaW5nID0gZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiAtMSAqIGFzY2VuZGluZyhhLCBiKTtcbn07XG5cbnZhciBleHRlbmQgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KSA6IGZ1bmN0aW9uICh0Z3QpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3NbaV07XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG52YXIgaGV4MnR1cGxlID0gZnVuY3Rpb24gaGV4MnR1cGxlKGhleCkge1xuICBpZiAoIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gJyMnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgdmFyIHIsIGcsIGI7XG4gIHZhciBiYXNlID0gMTY7XG5cbiAgaWYgKHNob3J0SGV4KSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFsyXSArIGhleFsyXSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFszXSArIGhleFszXSwgYmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsyXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFszXSArIGhleFs0XSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFs1XSArIGhleFs2XSwgYmFzZSk7XG4gIH1cblxuICByZXR1cm4gW3IsIGcsIGJdO1xufTsgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG5cbnZhciBoc2wydHVwbGUgPSBmdW5jdGlvbiBoc2wydHVwbGUoaHNsKSB7XG4gIHZhciByZXQ7XG4gIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuXG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyBoc2xhICsgJyQnKS5leGVjKGhzbCk7XG5cbiAgaWYgKG0pIHtcbiAgICAvLyBnZXQgaHVlXG4gICAgaCA9IHBhcnNlSW50KG1bMV0pO1xuXG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoID0gKDM2MCAtIC0xICogaCAlIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIGlmIChoID4gMzYwKSB7XG4gICAgICBoID0gaCAlIDM2MDtcbiAgICB9XG5cbiAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgcyA9IHBhcnNlRmxvYXQobVsyXSk7XG5cbiAgICBpZiAocyA8IDAgfHwgcyA+IDEwMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuXG5cbiAgICBzID0gcyAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgbCA9IHBhcnNlRmxvYXQobVszXSk7XG5cbiAgICBpZiAobCA8IDAgfHwgbCA+IDEwMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG5cblxuICAgIGwgPSBsIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBhID0gbVs0XTtcblxuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuXG4gICAgICBpZiAoYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBhbHBoYSBpcyBbMCwgMV1cblxuICAgIH0gLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG5cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBNYXRoLnJvdW5kKGwgKiAyNTUpOyAvLyBhY2hyb21hdGljXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgciA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpKTtcbiAgICAgIGcgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCkpO1xuICAgICAgYiA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpKTtcbiAgICB9XG5cbiAgICByZXQgPSBbciwgZywgYiwgYV07XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTsgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG5cbnZhciByZ2IydHVwbGUgPSBmdW5jdGlvbiByZ2IydHVwbGUocmdiKSB7XG4gIHZhciByZXQ7XG4gIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyByZ2JhICsgJyQnKS5leGVjKHJnYik7XG5cbiAgaWYgKG0pIHtcbiAgICByZXQgPSBbXTtcbiAgICB2YXIgaXNQY3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSBtW2ldO1xuXG4gICAgICBpZiAoY2hhbm5lbFtjaGFubmVsLmxlbmd0aCAtIDFdID09PSAnJScpIHtcbiAgICAgICAgaXNQY3RbaV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjaGFubmVsID0gcGFyc2VGbG9hdChjaGFubmVsKTtcblxuICAgICAgaWYgKGlzUGN0W2ldKSB7XG4gICAgICAgIGNoYW5uZWwgPSBjaGFubmVsIC8gMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuXG4gICAgICByZXQucHVzaChNYXRoLmZsb29yKGNoYW5uZWwpKTtcbiAgICB9XG5cbiAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgdmFyIGFsbEFyZVBjdCA9IGlzUGN0WzFdICYmIGlzUGN0WzJdICYmIGlzUGN0WzNdO1xuXG4gICAgaWYgKGF0TGVhc3RPbmVJc1BjdCAmJiAhYWxsQXJlUGN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtdXN0IGFsbCBiZSBwZXJjZW50IHZhbHVlcyBpZiBvbmUgaXNcblxuXG4gICAgdmFyIGFscGhhID0gbVs0XTtcblxuICAgIGlmIChhbHBoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEpO1xuXG4gICAgICBpZiAoYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuXG4gICAgICByZXQucHVzaChhbHBoYSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG52YXIgY29sb3JuYW1lMnR1cGxlID0gZnVuY3Rpb24gY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB7XG4gIHJldHVybiBjb2xvcnNbY29sb3IudG9Mb3dlckNhc2UoKV07XG59O1xudmFyIGNvbG9yMnR1cGxlID0gZnVuY3Rpb24gY29sb3IydHVwbGUoY29sb3IpIHtcbiAgcmV0dXJuIChhcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwpIHx8IGNvbG9ybmFtZTJ0dXBsZShjb2xvcikgfHwgaGV4MnR1cGxlKGNvbG9yKSB8fCByZ2IydHVwbGUoY29sb3IpIHx8IGhzbDJ0dXBsZShjb2xvcik7XG59O1xudmFyIGNvbG9ycyA9IHtcbiAgLy8gc3BlY2lhbCBjb2xvdXIgbmFtZXNcbiAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSxcbiAgLy8gTkIgYWxwaGEgPT09IDBcbiAgLy8gcmVndWxhciBjb2xvdXJzXG4gIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuXG52YXIgc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwKG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgIH1cblxuICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChvYmpba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIG9ialtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICBvYmpba2V5XSA9IG9wdGlvbnMudmFsdWU7XG4gICAgfVxuICB9XG59OyAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuXG52YXIgZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwKG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgIH1cblxuICAgIG9iaiA9IG9ialtrZXldO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59OyAvLyBkZWxldGVzIHRoZSBlbnRyeSBpbiB0aGUgbWFwXG5cbnZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdyQxID8gd2luZG93JDEucGVyZm9ybWFuY2UgOiBudWxsO1xudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudmFyIHJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHdpbmRvdyQxKSB7XG4gICAgaWYgKHdpbmRvdyQxLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3ckMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3ckMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHdpbmRvdyQxLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGlmIChmbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHBub3coKSk7XG4gICAgICB9LCAxMDAwIC8gNjApO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICByZXR1cm4gcmFmKGZuKTtcbn07XG52YXIgcGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG52YXIgREVGQVVMVF9TRUVEID0gNTM4MTtcbnZhciBoYXNoSXRlcmFibGVJbnRzID0gZnVuY3Rpb24gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvcikge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9TRUVEO1xuICAvLyBkamIyL3N0cmluZy1oYXNoXG4gIHZhciBoYXNoID0gc2VlZDtcbiAgdmFyIGVudHJ5O1xuXG4gIGZvciAoOzspIHtcbiAgICBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgKyBoYXNoICsgZW50cnkudmFsdWUgfCAwO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59O1xudmFyIGhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KG51bSkge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9TRUVEO1xuICAvLyBkamIyL3N0cmluZy1oYXNoXG4gIHJldHVybiAoc2VlZCA8PCA1KSArIHNlZWQgKyBudW0gfCAwO1xufTtcbnZhciBoYXNoSW50c0FycmF5ID0gZnVuY3Rpb24gaGFzaEludHNBcnJheShpbnRzLCBzZWVkKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW5ndGggPSBpbnRzLmxlbmd0aDtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IGludHNbaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvciwgc2VlZCk7XG59O1xudmFyIGhhc2hTdHJpbmcgPSBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0ciwgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5ncyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzKCkge1xuICByZXR1cm4gaGFzaFN0cmluZ3NBcnJheShhcmd1bWVudHMpO1xufTtcbnZhciBoYXNoU3RyaW5nc0FycmF5ID0gZnVuY3Rpb24gaGFzaFN0cmluZ3NBcnJheShzdHJzKSB7XG4gIHZhciBoYXNoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdHIgPSBzdHJzW2ldO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0ciwgaGFzaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG4vKmdsb2JhbCBjb25zb2xlICovXG52YXIgd2FybmluZ3NFbmFibGVkID0gdHJ1ZTtcbnZhciB3YXJuU3VwcG9ydGVkID0gY29uc29sZS53YXJuICE9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG52YXIgdHJhY2VTdXBwb3J0ZWQgPSBjb25zb2xlLnRyYWNlICE9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG52YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgdHJ1ZWlmeSA9IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBmYWxzaWZ5ID0gZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB6ZXJvaWZ5ID0gZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59O1xudmFyIHdhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoZW5hYmxlZCkge1xuICBpZiAoZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2FybmluZ3NFbmFibGVkID0gISFlbmFibGVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB3YXJuaW5nc0VuYWJsZWQ7XG4gIH1cbn07XG52YXIgd2FybiA9IGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKCF3YXJuaW5ncygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHdhcm5TdXBwb3J0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhtc2cpO1xuXG4gICAgaWYgKHRyYWNlU3VwcG9ydGVkKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn07IC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG5cbnZhciBjb3B5ID0gZnVuY3Rpb24gY29weShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChhcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmUob2JqKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xudmFyIGNvcHlBcnJheSA9IGZ1bmN0aW9uIGNvcHlBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5zbGljZSgpO1xufTtcbnZhciB1dWlkID0gZnVuY3Rpb24gdXVpZChhLCBiXG4vKiBwbGFjZWhvbGRlcnMgKi9cbikge1xuICBmb3IgKCAvLyBsb29wIDopXG4gIGIgPSBhID0gJyc7IC8vIGIgLSByZXN1bHQgLCBhIC0gbnVtZXJpYyBsZXRpYWJsZVxuICBhKysgPCAzNjsgLy9cbiAgYiArPSBhICogNTEgJiA1MiAvLyBpZiBcImFcIiBpcyBub3QgOSBvciAxNCBvciAxOSBvciAyNFxuICA/IC8vICByZXR1cm4gYSByYW5kb20gbnVtYmVyIG9yIDRcbiAgKGEgXiAxNSAvLyBpZiBcImFcIiBpcyBub3QgMTVcbiAgPyAvLyBnZW5ldGF0ZSBhIHJhbmRvbSBudW1iZXIgZnJvbSAwIHRvIDE1XG4gIDggXiBNYXRoLnJhbmRvbSgpICogKGEgXiAyMCA/IDE2IDogNCkgLy8gdW5sZXNzIFwiYVwiIGlzIDIwLCBpbiB3aGljaCBjYXNlIGEgcmFuZG9tIG51bWJlciBmcm9tIDggdG8gMTFcbiAgOiA0IC8vICBvdGhlcndpc2UgNFxuICApLnRvU3RyaW5nKDE2KSA6ICctJyAvLyAgaW4gb3RoZXIgY2FzZXMgKGlmIFwiYVwiIGlzIDksMTQsMTksMjQpIGluc2VydCBcIi1cIlxuICApIHtcbiAgfVxuXG4gIHJldHVybiBiO1xufTtcbnZhciBfc3RhdGljRW1wdHlPYmplY3QgPSB7fTtcbnZhciBzdGF0aWNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uIHN0YXRpY0VtcHR5T2JqZWN0KCkge1xuICByZXR1cm4gX3N0YXRpY0VtcHR5T2JqZWN0O1xufTtcbnZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKF9kZWZhdWx0cykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9kZWZhdWx0cyk7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0cykge1xuICAgIHZhciBmaWxsZWRPcHRzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIG9wdFZhbCA9IG9wdHMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9wdHNba2V5XTtcbiAgICAgIGZpbGxlZE9wdHNba2V5XSA9IG9wdFZhbCA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRzW2tleV0gOiBvcHRWYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGxlZE9wdHM7XG4gIH07XG59O1xudmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGVsZSwgbWFueUNvcGllcykge1xuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBlbGUpIHtcbiAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG5cbiAgICAgIGlmICghbWFueUNvcGllcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgY2xlYXJBcnJheSA9IGZ1bmN0aW9uIGNsZWFyQXJyYXkoYXJyKSB7XG4gIGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCk7XG59O1xudmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGFyciwgb3RoZXJBcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IG90aGVyQXJyW2ldO1xuICAgIGFyci5wdXNoKGVsKTtcbiAgfVxufTtcbnZhciBnZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByb3BOYW1lID0gcHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgfVxuXG4gIHJldHVybiBvYmpbcHJvcE5hbWVdO1xufTtcbnZhciBzZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICBvYmpbcHJvcE5hbWVdID0gdmFsdWU7XG59O1xuXG4vKiBnbG9iYWwgTWFwICovXG52YXIgT2JqZWN0TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0TWFwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RNYXApO1xuXG4gICAgdGhpcy5fb2JqID0ge307XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0TWFwLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHRoaXMuX29ialtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JqZWN0TWFwO1xufSgpO1xuXG52YXIgTWFwJDEgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyA/IE1hcCA6IE9iamVjdE1hcDtcblxuLyogZ2xvYmFsIFNldCAqL1xudmFyIHVuZGVmID0gIFwidW5kZWZpbmVkXCIgO1xuXG52YXIgT2JqZWN0U2V0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2V0KGFycmF5T3JPYmplY3RTZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2V0KTtcblxuICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zaXplID0gMDtcblxuICAgIGlmIChhcnJheU9yT2JqZWN0U2V0ICE9IG51bGwpIHtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmIChhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nICE9IG51bGwgJiYgYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZygpID09PSB0aGlzLmluc3RhbmNlU3RyaW5nKCkpIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldC50b0FycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZChhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPYmplY3RTZXQsIFt7XG4gICAga2V5OiBcImluc3RhbmNlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgIGlmIChvW3ZhbF0gIT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgIGlmIChvW3ZhbF0gPT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpbdmFsXSA9PT0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmplY3RTZXQ7XG59KCk7XG5cbnZhciBTZXQkMSA9ICh0eXBlb2YgU2V0ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU2V0KSkgIT09IHVuZGVmID8gU2V0IDogT2JqZWN0U2V0O1xuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQoY3ksIHBhcmFtcywgcmVzdG9yZSkge1xuICByZXN0b3JlID0gcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2U7XG5cbiAgaWYgKGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgIWNvcmUoY3kpKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UgYW5kIHBhcmFtZXRlcnMgc2V0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwOyAvLyB0cnkgdG8gYXV0b21hdGljYWxseSBpbmZlciB0aGUgZ3JvdXAgaWYgdW5zcGVjaWZpZWRcblxuICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgIGlmIChwYXJhbXMuZGF0YSAmJiBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCkge1xuICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgfVxuICB9IC8vIHZhbGlkYXRlIGdyb3VwXG5cblxuICBpZiAoZ3JvdXAgIT09ICdub2RlcycgJiYgZ3JvdXAgIT09ICdlZGdlcycpIHtcbiAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgZ3JvdXAgKyAnYCcpO1xuICAgIHJldHVybjtcbiAgfSAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cblxuXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7IC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBzaW5nbGU6IHRydWUsXG4gICAgLy8gaW5kaWNhdGVzIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LFxuICAgIC8vIGRhdGEgb2JqZWN0XG4gICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLFxuICAgIGF1dG9QYWRkaW5nOiB1bmRlZmluZWQsXG4gICAgY29tcG91bmRCb3VuZHNDbGVhbjogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgY29tcG91bmQgZGltZW5zaW9ucyBuZWVkIHRvIGJlIHJlY2FsY3VsYXRlZCB0aGUgbmV4dCB0aW1lIGRpbWVuc2lvbnMgYXJlIHJlYWRcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgIGdyb3VwOiBncm91cCxcbiAgICAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgIHN0eWxlOiB7fSxcbiAgICAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICByc3R5bGU6IHt9LFxuICAgIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICBzdHlsZUN4dHM6IFtdLFxuICAgIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgc3R5bGVLZXlzOiB7fSxcbiAgICAvLyBwZXItZ3JvdXAga2V5cyBvZiBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICByZW1vdmVkOiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RlZFxuICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICBsb2NrZWQ6IHBhcmFtcy5sb2NrZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICBncmFiYmVkOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgZ3JhYmJhYmxlOiBwYXJhbXMuZ3JhYmJhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgcGFubmFibGU6IHBhcmFtcy5wYW5uYWJsZSA9PT0gdW5kZWZpbmVkID8gZ3JvdXAgPT09ICdlZGdlcycgPyB0cnVlIDogZmFsc2UgOiBwYXJhbXMucGFubmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBoYXMgcGFzc3Rocm91Z2ggcGFubmluZyBlbmFibGVkXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjbGFzc2VzOiBuZXcgU2V0JDEoKSxcbiAgICAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICByc2NyYXRjaDoge30sXG4gICAgLy8gb2JqZWN0IGluIHdoaWNoIHRoZSByZW5kZXJlciBjYW4gc3RvcmUgaW5mb3JtYXRpb25cbiAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdHNcbiAgICBlZGdlczogW10sXG4gICAgLy8gYXJyYXkgb2YgY29ubmVjdGVkIGVkZ2VzXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgcGFyZW50OiBudWxsLFxuICAgIC8vIHBhcmVudCByZWZcbiAgICB0cmF2ZXJzYWxDYWNoZToge30sXG4gICAgLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgICBiYWNrZ3JvdW5kaW5nOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGJhY2tncm91bmQgaW1hZ2VzIGFyZSBsb2FkaW5nXG4gICAgYmJDYWNoZTogbnVsbCxcbiAgICAvLyBjYWNoZSBvZiB0aGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICBiYkNhY2hlU2hpZnQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyBzaGlmdCBhcHBsaWVkIHRvIGNhY2hlZCBiYiB0byBiZSBhcHBsaWVkIG9uIG5leHQgZ2V0XG4gICAgYm9keUJvdW5kczogbnVsbCxcbiAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCB3L28gb3ZlcmxheVxuICAgIG92ZXJsYXlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgaW5jbHVkaW5nIG92ZXJsYXlcbiAgICBsYWJlbEJvdW5kczoge1xuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGxhYmVsc1xuICAgICAgYWxsOiBudWxsLFxuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgbWFpbjogbnVsbFxuICAgIH0sXG4gICAgYXJyb3dCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlZGdlIGFycm93c1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgJ21pZC1zb3VyY2UnOiBudWxsLFxuICAgICAgJ21pZC10YXJnZXQnOiBudWxsXG4gICAgfVxuICB9O1xuXG4gIGlmIChfcC5wb3NpdGlvbi54ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi54ID0gMDtcbiAgfVxuXG4gIGlmIChfcC5wb3NpdGlvbi55ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi55ID0gMDtcbiAgfSAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcblxuXG4gIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbikge1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIF9wLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH1cblxuICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gIGlmIChhcnJheShwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXM7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSkge1xuICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuXG4gICAgaWYgKCFjbHMgfHwgY2xzID09PSAnJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgX3AuY2xhc3Nlcy5hZGQoY2xzKTtcbiAgfVxuXG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICB2YXIgYnlwYXNzID0gcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3M7XG5cbiAgaWYgKGJ5cGFzcykge1xuICAgIHdhcm4oJ1NldHRpbmcgYSBgc3R5bGVgIGJ5cGFzcyBhdCBlbGVtZW50IGNyZWF0aW9uIGlzIGRlcHJlY2F0ZWQnKTtcbiAgICB0aGlzLnN0eWxlKGJ5cGFzcyk7XG4gIH1cblxuICBpZiAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxudmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uIGRlZmluZVNlYXJjaChwYXJhbXMpIHtcbiAgcGFyYW1zID0ge1xuICAgIGJmczogcGFyYW1zLmJmcyB8fCAhcGFyYW1zLmRmcyxcbiAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgfTsgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuXG4gIHJldHVybiBmdW5jdGlvbiBzZWFyY2hGbihyb290cywgZm4kMSwgZGlyZWN0ZWQpIHtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmIChwbGFpbk9iamVjdChyb290cykgJiYgIWVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpKSB7XG4gICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHMgfHwgb3B0aW9ucy5yb290O1xuICAgICAgZm4kMSA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfVxuXG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFmbihmbiQxKSA/IGZuJDEgOiBkaXJlY3RlZDtcbiAgICBmbiQxID0gZm4oZm4kMSkgPyBmbiQxIDogZnVuY3Rpb24gKCkge307XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgdiA9IHJvb3RzID0gc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIFYgPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGZvdW5kO1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7IC8vIGVucXVldWUgdlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2aSA9IHZbaV07XG4gICAgICB2YXIgdmlJZCA9IHZpLmlkKCk7XG5cbiAgICAgIGlmICh2aS5pc05vZGUoKSkge1xuICAgICAgICBRLnVuc2hpZnQodmkpO1xuXG4gICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgVlt2aUlkXSA9IHRydWU7XG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2aSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZDJkZXB0aFt2aUlkXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgIHZhciB2ID0gcGFyYW1zLmJmcyA/IFEuc2hpZnQoKSA6IFEucG9wKCk7XG4gICAgICB2YXIgdklkID0gdi5pZCgpO1xuXG4gICAgICBpZiAocGFyYW1zLmRmcykge1xuICAgICAgICBpZiAoVlt2SWRdKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIFZbdklkXSA9IHRydWU7XG4gICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godik7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoW3ZJZF07XG4gICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVt2SWRdO1xuICAgICAgdmFyIHNyYyA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS5zb3VyY2UoKSA6IG51bGw7XG4gICAgICB2YXIgdGd0ID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnRhcmdldCgpIDogbnVsbDtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiB2LnNhbWUoc3JjKSA/IHRndFswXSA6IHNyY1swXTtcbiAgICAgIHZhciByZXQgPSB2b2lkIDA7XG4gICAgICByZXQgPSBmbiQxKHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG5cbiAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuXG4gICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuICghZGlyZWN0ZWQgfHwgZS5zb3VyY2UoKS5zYW1lKHYpKSAmJiBlZGdlcy5oYXMoZSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdndFZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tfaTJdO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gIW4uc2FtZSh2KSAmJiBub2Rlcy5oYXMobik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgd0lkID0gdy5pZCgpO1xuXG4gICAgICAgIGlmICh3Lmxlbmd0aCAhPT0gMCAmJiAhVlt3SWRdKSB7XG4gICAgICAgICAgdyA9IHdbMF07XG4gICAgICAgICAgUS5wdXNoKHcpO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgIFZbd0lkXSA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbm5lY3RlZEJ5W3dJZF0gPSBlO1xuICAgICAgICAgIGlkMmRlcHRoW3dJZF0gPSBpZDJkZXB0aFt2SWRdICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfbG9vcDogd2hpbGUgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wMigpO1xuXG4gICAgICBzd2l0Y2ggKF9yZXQpIHtcbiAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgYnJlYWsgX2xvb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW19pXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbbm9kZS5pZCgpXTtcblxuICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICBjb25uZWN0ZWRFbGVzLm1lcmdlKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRFbGVzLm1lcmdlKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBjeS5jb2xsZWN0aW9uKGNvbm5lY3RlZEVsZXMpLFxuICAgICAgZm91bmQ6IGN5LmNvbGxlY3Rpb24oZm91bmQpXG4gICAgfTtcbiAgfTtcbn07IC8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xuXG5cbnZhciBlbGVzZm4gPSB7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICBiZnM6IHRydWVcbiAgfSksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgZGZzOiB0cnVlXG4gIH0pXG59OyAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5cbmVsZXNmbi5iZnMgPSBlbGVzZm4uYnJlYWR0aEZpcnN0U2VhcmNoO1xuZWxlc2ZuLmRmcyA9IGVsZXNmbi5kZXB0aEZpcnN0U2VhcmNoO1xuXG52YXIgZGlqa3N0cmFEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQxID0ge1xuICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgd2VpZ2h0OiBhcmdzWzFdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX2RpamtzdHJhRGVmYXVsdHMgPSBkaWprc3RyYURlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2RpamtzdHJhRGVmYXVsdHMucm9vdCxcbiAgICAgICAgd2VpZ2h0ID0gX2RpamtzdHJhRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9kaWprc3RyYURlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgc291cmNlID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0gOiByb290WzBdO1xuICAgIHZhciBkaXN0ID0ge307XG4gICAgdmFyIHByZXYgPSB7fTtcbiAgICB2YXIga25vd25EaXN0ID0ge307XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG5vZGUpIHtcbiAgICAgIHJldHVybiBkaXN0W25vZGUuaWQoKV07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24gc2V0RGlzdChub2RlLCBkKSB7XG4gICAgICBkaXN0W25vZGUuaWQoKV0gPSBkO1xuICAgICAgUS51cGRhdGVJdGVtKG5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgZGlzdFtub2RlLmlkKCldID0gbm9kZS5zYW1lKHNvdXJjZSkgPyAwIDogSW5maW5pdHk7XG4gICAgICBRLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RCZXR3ZWVuID0gZnVuY3Rpb24gZGlzdEJldHdlZW4odSwgdikge1xuICAgICAgdmFyIHV2cyA9IChkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpKS5pbnRlcnNlY3QoZWRnZXMpO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1dnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gdXZzW19pXTtcblxuICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAgIGlmIChfd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlKSB7XG4gICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IF93ZWlnaHQ7XG4gICAgICAgICAgc21hbGxlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgIGRpc3Q6IHNtYWxsZXN0RGlzdGFuY2VcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHdoaWxlIChRLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciB1ID0gUS5wb3AoKTtcbiAgICAgIHZhciBzbWFsbGV0c0Rpc3QgPSBnZXREaXN0KHUpO1xuICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcbiAgICAgIGtub3duRGlzdFt1aWRdID0gc21hbGxldHNEaXN0O1xuXG4gICAgICBpZiAoc21hbGxldHNEaXN0ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmVpZ2hib3JzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbX2kyXTtcbiAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4odSwgdik7XG4gICAgICAgIHZhciBhbHQgPSBzbWFsbGV0c0Rpc3QgKyB2RGlzdC5kaXN0O1xuXG4gICAgICAgIGlmIChhbHQgPCBnZXREaXN0KHYpKSB7XG4gICAgICAgICAgc2V0RGlzdCh2LCBhbHQpO1xuICAgICAgICAgIHByZXZbdmlkXSA9IHtcbiAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcblxuICAgIH0gLy8gd2hpbGVcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uIGRpc3RhbmNlVG8obm9kZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgcmV0dXJuIGtub3duRGlzdFt0YXJnZXQuaWQoKV07XG4gICAgICB9LFxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG4gICAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUy51bnNoaWZ0KHRhcmdldCk7XG5cbiAgICAgICAgICB3aGlsZSAocHJldlt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByZXZbdWlkXTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLmVkZ2UpO1xuICAgICAgICAgICAgUy51bnNoaWZ0KHAubm9kZSk7XG4gICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgdWlkID0gdS5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKFMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kMiA9IHtcbiAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBrcnVza2FsOiBmdW5jdGlvbiBrcnVza2FsKHdlaWdodEZuKSB7XG4gICAgd2VpZ2h0Rm4gPSB3ZWlnaHRGbiB8fCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfTtcblxuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBmb3Jlc3QgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBBID0gbm9kZXM7IC8vIGFzc3VtZXMgYnlHcm91cCgpIGNyZWF0ZXMgbmV3IGNvbGxlY3Rpb25zIHRoYXQgY2FuIGJlIHNhZmVseSBtdXRhdGVkXG5cbiAgICB2YXIgZmluZFNldEluZGV4ID0gZnVuY3Rpb24gZmluZFNldEluZGV4KGVsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG5cbiAgICAgICAgaWYgKGVsZXMuaGFzKGVsZSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIHN0YXJ0IHdpdGggb25lIGZvcmVzdCBwZXIgbm9kZVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvcmVzdFtpXSA9IHRoaXMuc3Bhd24obm9kZXNbaV0pO1xuICAgIH1cblxuICAgIHZhciBTID0gZWRnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHdlaWdodEZuKGEpIC0gd2VpZ2h0Rm4oYik7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgUy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gU1tfaV07XG4gICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICB2YXIgc2V0VUluZGV4ID0gZmluZFNldEluZGV4KHUpO1xuICAgICAgdmFyIHNldFZJbmRleCA9IGZpbmRTZXRJbmRleCh2KTtcbiAgICAgIHZhciBzZXRVID0gZm9yZXN0W3NldFVJbmRleF07XG4gICAgICB2YXIgc2V0ViA9IGZvcmVzdFtzZXRWSW5kZXhdO1xuXG4gICAgICBpZiAoc2V0VUluZGV4ICE9PSBzZXRWSW5kZXgpIHtcbiAgICAgICAgQS5tZXJnZShlZGdlKTsgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG5cbiAgICAgICAgc2V0VS5tZXJnZShzZXRWKTtcbiAgICAgICAgZm9yZXN0LnNwbGljZShzZXRWSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBBO1xuICB9XG59O1xuXG52YXIgYVN0YXJEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgcm9vdDogbnVsbCxcbiAgZ29hbDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBoZXVyaXN0aWM6IGZ1bmN0aW9uIGhldXJpc3RpYyhlZGdlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJDMgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24gYVN0YXIob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBfYVN0YXJEZWZhdWx0cyA9IGFTdGFyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgIHJvb3QgPSBfYVN0YXJEZWZhdWx0cy5yb290LFxuICAgICAgICBnb2FsID0gX2FTdGFyRGVmYXVsdHMuZ29hbCxcbiAgICAgICAgaGV1cmlzdGljID0gX2FTdGFyRGVmYXVsdHMuaGV1cmlzdGljLFxuICAgICAgICBkaXJlY3RlZCA9IF9hU3RhckRlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICB3ZWlnaHQgPSBfYVN0YXJEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICBnb2FsID0gY3kuY29sbGVjdGlvbihnb2FsKVswXTtcbiAgICB2YXIgc2lkID0gcm9vdC5pZCgpO1xuICAgIHZhciB0aWQgPSBnb2FsLmlkKCk7XG4gICAgdmFyIGdTY29yZSA9IHt9O1xuICAgIHZhciBmU2NvcmUgPSB7fTtcbiAgICB2YXIgY2xvc2VkU2V0SWRzID0ge307XG4gICAgdmFyIG9wZW5TZXQgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZTY29yZVthLmlkKCldIC0gZlNjb3JlW2IuaWQoKV07XG4gICAgfSk7XG4gICAgdmFyIG9wZW5TZXRJZHMgPSBuZXcgU2V0JDEoKTtcbiAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICB2YXIgY2FtZUZyb21FZGdlID0ge307XG5cbiAgICB2YXIgYWRkVG9PcGVuU2V0ID0gZnVuY3Rpb24gYWRkVG9PcGVuU2V0KGVsZSwgaWQpIHtcbiAgICAgIG9wZW5TZXQucHVzaChlbGUpO1xuICAgICAgb3BlblNldElkcy5hZGQoaWQpO1xuICAgIH07XG5cbiAgICB2YXIgY01pbiwgY01pbklkO1xuXG4gICAgdmFyIHBvcEZyb21PcGVuU2V0ID0gZnVuY3Rpb24gcG9wRnJvbU9wZW5TZXQoKSB7XG4gICAgICBjTWluID0gb3BlblNldC5wb3AoKTtcbiAgICAgIGNNaW5JZCA9IGNNaW4uaWQoKTtcbiAgICAgIG9wZW5TZXRJZHNbXCJkZWxldGVcIl0oY01pbklkKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzSW5PcGVuU2V0ID0gZnVuY3Rpb24gaXNJbk9wZW5TZXQoaWQpIHtcbiAgICAgIHJldHVybiBvcGVuU2V0SWRzLmhhcyhpZCk7XG4gICAgfTtcblxuICAgIGFkZFRvT3BlblNldChyb290LCBzaWQpO1xuICAgIGdTY29yZVtzaWRdID0gMDtcbiAgICBmU2NvcmVbc2lkXSA9IGhldXJpc3RpYyhyb290KTsgLy8gQ291bnRlclxuXG4gICAgdmFyIHN0ZXBzID0gMDsgLy8gTWFpbiBsb29wXG5cbiAgICB3aGlsZSAob3BlblNldC5zaXplKCkgPiAwKSB7XG4gICAgICBwb3BGcm9tT3BlblNldCgpO1xuICAgICAgc3RlcHMrKzsgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgaWYgKGNNaW5JZCA9PT0gdGlkKSB7XG4gICAgICAgIHZhciBwYXRoID0gW107XG4gICAgICAgIHZhciBwYXRoTm9kZSA9IGdvYWw7XG4gICAgICAgIHZhciBwYXRoTm9kZUlkID0gdGlkO1xuICAgICAgICB2YXIgcGF0aEVkZ2UgPSBjYW1lRnJvbUVkZ2VbcGF0aE5vZGVJZF07XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoTm9kZSk7XG5cbiAgICAgICAgICBpZiAocGF0aEVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHBhdGhFZGdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoTm9kZSA9IGNhbWVGcm9tW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgICAgaWYgKHBhdGhOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGhOb2RlSWQgPSBwYXRoTm9kZS5pZCgpO1xuICAgICAgICAgIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgICBkaXN0YW5jZTogZ1Njb3JlW2NNaW5JZF0sXG4gICAgICAgICAgcGF0aDogdGhpcy5zcGF3bihwYXRoKSxcbiAgICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG5cblxuICAgICAgY2xvc2VkU2V0SWRzW2NNaW5JZF0gPSB0cnVlOyAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaWYgZ3JhcGggaXMgZGlyZWN0ZWQgb3Igbm90XG5cbiAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tpXTsgLy8gZWRnZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcblxuICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZChlLmlkKCkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY01pbiBtdXN0IGJlIHRoZSBzb3VyY2Ugb2YgZWRnZSBpZiBkaXJlY3RlZFxuXG5cbiAgICAgICAgaWYgKGRpcmVjdGVkICYmIGUuZGF0YSgnc291cmNlJykgIT09IGNNaW5JZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdTcmMgPSBlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgd1RndCA9IGUudGFyZ2V0KCk7XG4gICAgICAgIHZhciB3ID0gd1NyYy5pZCgpICE9PSBjTWluSWQgPyB3U3JjIDogd1RndDtcbiAgICAgICAgdmFyIHdpZCA9IHcuaWQoKTsgLy8gbm9kZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcblxuICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZCh3aWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuXG5cbiAgICAgICAgaWYgKGNsb3NlZFNldElkc1t3aWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG5cblxuICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW5JZF0gKyB3ZWlnaHQoZSk7IC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgLy8gT1JcbiAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG5cbiAgICAgICAgaWYgKCFpc0luT3BlblNldCh3aWQpKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgYWRkVG9PcGVuU2V0KHcsIHdpZCk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuXG5cbiAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3aWRdKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcblxuICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgZGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIHN0ZXBzOiBzdGVwc1xuICAgIH07XG4gIH1cbn07IC8vIGVsZXNmblxuXG52YXIgZmxveWRXYXJzaGFsbERlZmF1bHRzID0gZGVmYXVsdHMoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJDQgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbiBmbG95ZFdhcnNoYWxsKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0ID0gZmxveWRXYXJzaGFsbERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICB3ZWlnaHQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC5kaXJlY3RlZDtcblxuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcblxuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgdmFyIE4gPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIE5zcSA9IE4gKiBOO1xuXG4gICAgdmFyIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgYXRJbmRleCA9IGZ1bmN0aW9uIGF0SW5kZXgoaSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH07IC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgIHZhciBkaXN0ID0gbmV3IEFycmF5KE5zcSk7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IE5zcTsgbisrKSB7XG4gICAgICB2YXIgaiA9IG4gJSBOO1xuICAgICAgdmFyIGkgPSAobiAtIGopIC8gTjtcblxuICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgZGlzdFtuXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXN0W25dID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfSAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcblxuXG4gICAgdmFyIG5leHQgPSBuZXcgQXJyYXkoTnNxKTtcbiAgICB2YXIgZWRnZU5leHQgPSBuZXcgQXJyYXkoTnNxKTsgLy8gUHJvY2VzcyBlZGdlc1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpWzBdO1xuXG4gICAgICBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGV4Y2x1ZGUgbG9vcHNcblxuXG4gICAgICB2YXIgcyA9IGluZGV4T2Yoc3JjKTtcbiAgICAgIHZhciB0ID0gaW5kZXhPZih0Z3QpO1xuICAgICAgdmFyIHN0ID0gcyAqIE4gKyB0OyAvLyBzb3VyY2UgdG8gdGFyZ2V0IGluZGV4XG5cbiAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7IC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcblxuXG4gICAgICBpZiAoZGlzdFtzdF0gPiBfd2VpZ2h0KSB7XG4gICAgICAgIGRpc3Rbc3RdID0gX3dlaWdodDtcbiAgICAgICAgbmV4dFtzdF0gPSB0O1xuICAgICAgICBlZGdlTmV4dFtzdF0gPSBlZGdlO1xuICAgICAgfSAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZVxuXG5cbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRzID0gdCAqIE4gKyBzOyAvLyB0YXJnZXQgdG8gc291cmNlIGluZGV4XG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiBkaXN0W3RzXSA+IF93ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3RzXSA9IF93ZWlnaHQ7XG4gICAgICAgICAgbmV4dFt0c10gPSBzO1xuICAgICAgICAgIGVkZ2VOZXh0W3RzXSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIE1haW4gbG9vcFxuXG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IE47IGsrKykge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgX2kyKyspIHtcbiAgICAgICAgdmFyIGlrID0gX2kyICogTiArIGs7XG5cbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IE47IF9qKyspIHtcbiAgICAgICAgICB2YXIgaWogPSBfaTIgKiBOICsgX2o7XG4gICAgICAgICAgdmFyIGtqID0gayAqIE4gKyBfajtcblxuICAgICAgICAgIGlmIChkaXN0W2lrXSArIGRpc3Rba2pdIDwgZGlzdFtpal0pIHtcbiAgICAgICAgICAgIGRpc3RbaWpdID0gZGlzdFtpa10gKyBkaXN0W2tqXTtcbiAgICAgICAgICAgIG5leHRbaWpdID0gbmV4dFtpa107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldEFyZ0VsZSA9IGZ1bmN0aW9uIGdldEFyZ0VsZShlbGUpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nKGVsZSkgPyBjeS5maWx0ZXIoZWxlKSA6IGVsZSlbMF07XG4gICAgfTtcblxuICAgIHZhciBpbmRleE9mQXJnRWxlID0gZnVuY3Rpb24gaW5kZXhPZkFyZ0VsZShlbGUpIHtcbiAgICAgIHJldHVybiBpbmRleE9mKGdldEFyZ0VsZShlbGUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiBkaXN0YW5jZShmcm9tLCB0bykge1xuICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgIHJldHVybiBkaXN0W2kgKiBOICsgal07XG4gICAgICB9LFxuICAgICAgcGF0aDogZnVuY3Rpb24gcGF0aChmcm9tLCB0bykge1xuICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgIHZhciBmcm9tTm9kZSA9IGF0SW5kZXgoaSk7XG5cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICByZXR1cm4gZnJvbU5vZGUuY29sbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRbaSAqIE4gKyBqXSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXRoID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICB2YXIgcHJldiA9IGk7XG4gICAgICAgIHZhciBlZGdlO1xuICAgICAgICBwYXRoLm1lcmdlKGZyb21Ob2RlKTtcblxuICAgICAgICB3aGlsZSAoaSAhPT0gaikge1xuICAgICAgICAgIHByZXYgPSBpO1xuICAgICAgICAgIGkgPSBuZXh0W2kgKiBOICsgal07XG4gICAgICAgICAgZWRnZSA9IGVkZ2VOZXh0W3ByZXYgKiBOICsgaV07XG4gICAgICAgICAgcGF0aC5tZXJnZShlZGdlKTtcbiAgICAgICAgICBwYXRoLm1lcmdlKGF0SW5kZXgoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIGZsb3lkV2Fyc2hhbGxcblxufTsgLy8gZWxlc2ZuXG5cbnZhciBiZWxsbWFuRm9yZERlZmF1bHRzID0gZGVmYXVsdHMoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJDUgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24gYmVsbG1hbkZvcmQob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2JlbGxtYW5Gb3JkRGVmYXVsdHMgPSBiZWxsbWFuRm9yZERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICB3ZWlnaHQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgIHJvb3QgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5yb290O1xuXG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXMsXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5mb01hcCA9IG5ldyBNYXAkMSgpO1xuICAgIHZhciBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gZmFsc2U7XG4gICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzID0gW107XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07IC8vIGluIGNhc2Ugc2VsZWN0b3IgcGFzc2VkXG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIHZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhub2RlKSB7XG4gICAgICB2YXIgb2JqID0gaW5mb01hcC5nZXQobm9kZS5pZCgpKTtcblxuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGluZm9NYXAuc2V0KG5vZGUuaWQoKSwgb2JqKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIGdldE5vZGVGcm9tVG8gPSBmdW5jdGlvbiBnZXROb2RlRnJvbVRvKHRvKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyh0bykgPyBjeS4kKHRvKSA6IHRvKVswXTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc3RhbmNlVG8gPSBmdW5jdGlvbiBkaXN0YW5jZVRvKHRvKSB7XG4gICAgICByZXR1cm4gZ2V0SW5mbyhnZXROb2RlRnJvbVRvKHRvKSkuZGlzdDtcbiAgICB9O1xuXG4gICAgdmFyIHBhdGhUbyA9IGZ1bmN0aW9uIHBhdGhUbyh0bykge1xuICAgICAgdmFyIHRoaXNTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcm9vdDtcbiAgICAgIHZhciBlbmQgPSBnZXROb2RlRnJvbVRvKHRvKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgbm9kZSA9IGVuZDtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNwYXduKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKG5vZGUpLFxuICAgICAgICAgICAgZWRnZSA9IF9nZXRJbmZvLmVkZ2UsXG4gICAgICAgICAgICBwcmVkID0gX2dldEluZm8ucHJlZDtcblxuICAgICAgICBwYXRoLnVuc2hpZnQobm9kZVswXSk7XG5cbiAgICAgICAgaWYgKG5vZGUuc2FtZSh0aGlzU3RhcnQpICYmIHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChlZGdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBwcmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlcy5zcGF3bihwYXRoKTtcbiAgICB9OyAvLyBJbml0aWFsaXphdGlvbnMgeyBkaXN0LCBwcmVkLCBlZGdlIH1cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGluZm8gPSBnZXRJbmZvKG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS5zYW1lKHJvb3QpKSB7XG4gICAgICAgIGluZm8uZGlzdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLmRpc3QgPSBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaW5mby5wcmVkID0gbnVsbDtcbiAgICAgIGluZm8uZWRnZSA9IG51bGw7XG4gICAgfSAvLyBFZGdlcyByZWxheGF0aW9uXG5cblxuICAgIHZhciByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcblxuICAgIHZhciBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KG5vZGUxLCBub2RlMiwgZWRnZSwgaW5mbzEsIGluZm8yLCB3ZWlnaHQpIHtcbiAgICAgIHZhciBkaXN0ID0gaW5mbzEuZGlzdCArIHdlaWdodDtcblxuICAgICAgaWYgKGRpc3QgPCBpbmZvMi5kaXN0ICYmICFlZGdlLnNhbWUoaW5mbzEuZWRnZSkpIHtcbiAgICAgICAgaW5mbzIuZGlzdCA9IGRpc3Q7XG4gICAgICAgIGluZm8yLnByZWQgPSBub2RlMTtcbiAgICAgICAgaW5mbzIuZWRnZSA9IGVkZ2U7XG4gICAgICAgIHJlcGxhY2VkRWRnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgbnVtRWRnZXM7IGUrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICB2YXIgc3JjSW5mbyA9IGdldEluZm8oc3JjKTtcbiAgICAgICAgdmFyIHRndEluZm8gPSBnZXRJbmZvKHRndCk7XG4gICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHNyYywgdGd0LCBlZGdlLCBzcmNJbmZvLCB0Z3RJbmZvLCBfd2VpZ2h0KTsgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcblxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQodGd0LCBzcmMsIGVkZ2UsIHRndEluZm8sIHNyY0luZm8sIF93ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVwbGFjZWRFZGdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBsYWNlZEVkZ2UpIHtcbiAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICBmb3IgKHZhciBfZSA9IDA7IF9lIDwgbnVtRWRnZXM7IF9lKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2VdO1xuXG4gICAgICAgIHZhciBfc3JjID0gX2VkZ2Uuc291cmNlKCk7XG5cbiAgICAgICAgdmFyIF90Z3QgPSBfZWRnZS50YXJnZXQoKTtcblxuICAgICAgICB2YXIgX3dlaWdodDIgPSB3ZWlnaHRGbihfZWRnZSk7XG5cbiAgICAgICAgdmFyIHNyY0Rpc3QgPSBnZXRJbmZvKF9zcmMpLmRpc3Q7XG4gICAgICAgIHZhciB0Z3REaXN0ID0gZ2V0SW5mbyhfdGd0KS5kaXN0O1xuXG4gICAgICAgIGlmIChzcmNEaXN0ICsgX3dlaWdodDIgPCB0Z3REaXN0IHx8ICFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgd2FybignR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZCcpO1xuICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGRpc3RhbmNlVG8sXG4gICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUsXG4gICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlczogbmVnYXRpdmVXZWlnaHRDeWNsZXNcbiAgICB9O1xuICB9IC8vIGJlbGxtYW5Gb3JkXG5cbn07IC8vIGVsZXNmblxuXG52YXIgc3FydDIgPSBNYXRoLnNxcnQoMik7IC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4vLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxuXG52YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gIGlmIChyZW1haW5pbmdFZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICBlcnJvcihcIkthcmdlci1TdGVpbiBtdXN0IGJlIHJ1biBvbiBhIGNvbm5lY3RlZCAoc3ViKWdyYXBoXCIpO1xuICB9XG5cbiAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuICB2YXIgbmV3RWRnZXMgPSByZW1haW5pbmdFZGdlczsgLy8gcmUtdXNlIGFycmF5XG4gIC8vIERlbGV0ZSBhbGwgZWRnZXMgYmV0d2VlbiBwYXJ0aXRpb24xIGFuZCBwYXJ0aXRpb24yXG5cbiAgZm9yICh2YXIgaSA9IG5ld0VkZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICB2YXIgc3JjID0gZWRnZVsxXTtcbiAgICB2YXIgdGd0ID0gZWRnZVsyXTtcblxuICAgIGlmIChub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24yIHx8IG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgIG5ld0VkZ2VzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH0gLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG5cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmV3RWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9lZGdlID0gbmV3RWRnZXNbX2ldO1xuXG4gICAgaWYgKF9lZGdlWzFdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAvLyBDaGVjayBzb3VyY2VcbiAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgbmV3RWRnZXNbX2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICB9IGVsc2UgaWYgKF9lZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAvLyBDaGVjayB0YXJnZXRcbiAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgbmV3RWRnZXNbX2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICB9XG4gIH0gLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcblxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVNYXAubGVuZ3RoOyBfaTIrKykge1xuICAgIGlmIChub2RlTWFwW19pMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgIG5vZGVNYXBbX2kyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0VkZ2VzO1xufTsgLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG5cblxudmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbiBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcywgc2l6ZSwgc2l6ZUxpbWl0KSB7XG4gIHdoaWxlIChzaXplID4gc2l6ZUxpbWl0KSB7XG4gICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICB2YXIgZWRnZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKTsgLy8gQ29sbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuXG4gICAgcmVtYWluaW5nRWRnZXMgPSBjb2xsYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG4gICAgc2l6ZS0tO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xufTtcblxudmFyIGVsZXNmbiQ2ID0ge1xuICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uIGthcmdlclN0ZWluKCkge1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIHNxcnQyKTtcblxuICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgIGVycm9yKCdBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyLVN0ZWluIGFsZ29yaXRobScpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuXG5cbiAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIGVkZ2VJbmRleGVzLnB1c2goW2ksIG5vZGVzLmluZGV4T2YoZS5zb3VyY2UoKSksIG5vZGVzLmluZGV4T2YoZS50YXJnZXQoKSldKTtcbiAgICB9IC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcblxuXG4gICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluQ3V0RWRnZUluZGV4ZXMgPSBbXTtcbiAgICB2YXIgbWluQ3V0Tm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7IC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuXG4gICAgdmFyIG1ldGFOb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgbWV0YU5vZGVNYXAyID0gbmV3IEFycmF5KG51bU5vZGVzKTtcblxuICAgIHZhciBjb3B5Tm9kZXNNYXAgPSBmdW5jdGlvbiBjb3B5Tm9kZXNNYXAoZnJvbSwgdG8pIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICB0b1tfaTNdID0gZnJvbVtfaTNdO1xuICAgICAgfVxuICAgIH07IC8vIE1haW4gbG9vcFxuXG5cbiAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgIC8vIFJlc2V0IG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgICBtZXRhTm9kZU1hcFtfaTRdID0gX2k0O1xuICAgICAgfSAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcblxuXG4gICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLnNsaWNlKCksIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG4gICAgICB2YXIgZWRnZXNTdGF0ZTIgPSBlZGdlc1N0YXRlLnNsaWNlKCk7IC8vIGNvcHlcbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG5cbiAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWV0YU5vZGVNYXAyKTsgLy8gUnVuIDIgaXRlcmF0aW9ucyBzdGFydGluZyBpbiB0aGUgc3RvcCBzdGF0ZVxuXG4gICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcbiAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUyLCBzdG9wU2l6ZSwgMik7IC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG5cbiAgICAgIGlmIChyZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczE7XG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMjtcbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwMiwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuXG5cbiAgICB2YXIgY3V0ID0gdGhpcy5zcGF3bihtaW5DdXRFZGdlSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlZGdlc1tlWzBdXTtcbiAgICB9KSk7XG4gICAgdmFyIHBhcnRpdGlvbjEgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHBhcnRpdGlvbjIgPSB0aGlzLnNwYXduKCk7IC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuXG4gICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0Tm9kZU1hcFswXTtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG1pbkN1dE5vZGVNYXAubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0Tm9kZU1hcFtfaTVdO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTVdO1xuXG4gICAgICBpZiAocGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uKSB7XG4gICAgICAgIHBhcnRpdGlvbjEubWVyZ2Uobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0aXRpb24yLm1lcmdlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXQgPSB7XG4gICAgICBjdXQ6IGN1dCxcbiAgICAgIHBhcnRpdGlvbjE6IHBhcnRpdGlvbjEsXG4gICAgICBwYXJ0aXRpb24yOiBwYXJ0aXRpb24yXG4gICAgfTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGNvcHlQb3NpdGlvbiA9IGZ1bmN0aW9uIGNvcHlQb3NpdGlvbihwKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54LFxuICAgIHk6IHAueVxuICB9O1xufTtcbnZhciBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCAqIHpvb20gKyBwYW4ueCxcbiAgICB5OiBwLnkgKiB6b29tICsgcGFuLnlcbiAgfTtcbn07XG52YXIgcmVuZGVyZWRUb01vZGVsUG9zaXRpb24gPSBmdW5jdGlvbiByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAocC54IC0gcGFuLngpIC8gem9vbSxcbiAgICB5OiAocC55IC0gcGFuLnkpIC8gem9vbVxuICB9O1xufTtcbnZhciBhcnJheTJwb2ludCA9IGZ1bmN0aW9uIGFycmF5MnBvaW50KGFycikge1xuICByZXR1cm4ge1xuICAgIHg6IGFyclswXSxcbiAgICB5OiBhcnJbMV1cbiAgfTtcbn07XG52YXIgbWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgbWluID0gTWF0aC5taW4odmFsLCBtaW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW47XG59O1xudmFyIG1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICBtYXggPSBNYXRoLm1heCh2YWwsIG1heCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn07XG52YXIgbWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIHRvdGFsID0gMDtcbiAgdmFyIG4gPSAwO1xuXG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICB0b3RhbCArPSB2YWw7XG4gICAgICBuKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvdGFsIC8gbjtcbn07XG52YXIgbWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBjb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc29ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIGluY2x1ZGVIb2xlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcblxuICBpZiAoY29weSkge1xuICAgIGFyciA9IGFyci5zbGljZShiZWdpbiwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5kIDwgYXJyLmxlbmd0aCkge1xuICAgICAgYXJyLnNwbGljZShlbmQsIGFyci5sZW5ndGggLSBlbmQpO1xuICAgIH1cblxuICAgIGlmIChiZWdpbiA+IDApIHtcbiAgICAgIGFyci5zcGxpY2UoMCwgYmVnaW4pO1xuICAgIH1cbiAgfSAvLyBhbGwgbm9uIGZpbml0ZSAoZS5nLiBJbmZpbml0eSwgTmFOKSBlbGVtZW50cyBtdXN0IGJlIC1JbmZpbml0eSBzbyB0aGV5IGdvIHRvIHRoZSBzdGFydFxuXG5cbiAgdmFyIG9mZiA9IDA7IC8vIG9mZnNldCBmcm9tIG5vbi1maW5pdGUgdmFsdWVzXG5cbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB2ID0gYXJyW2ldO1xuXG4gICAgaWYgKGluY2x1ZGVIb2xlcykge1xuICAgICAgaWYgKCFpc0Zpbml0ZSh2KSkge1xuICAgICAgICBhcnJbaV0gPSAtSW5maW5pdHk7XG4gICAgICAgIG9mZisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBpdCBpZiB3ZSBkb24ndCB3YW50IHRvIGNvbnNpZGVyIGhvbGVzXG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTsgLy8gcmVxdWlyZXMgY29weSA9IHRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoZSBvcmlnXG4gIH1cblxuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IobGVuIC8gMik7XG5cbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICByZXR1cm4gYXJyW21pZCArIDEgKyBvZmZdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoYXJyW21pZCAtIDEgKyBvZmZdICsgYXJyW21pZCArIG9mZl0pIC8gMjtcbiAgfVxufTtcbnZhciBkZWcycmFkID0gZnVuY3Rpb24gZGVnMnJhZChkZWcpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiBkZWcgLyAxODA7XG59O1xudmFyIGdldEFuZ2xlRnJvbURpc3AgPSBmdW5jdGlvbiBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihkaXNwWSwgZGlzcFgpIC0gTWF0aC5QSSAvIDI7XG59O1xudmFyIGxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMik7XG59O1xudmFyIHNpZ251bSA9IGZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGRpc3QgPSBmdW5jdGlvbiBkaXN0KHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHNxZGlzdChwMSwgcDIpKTtcbn07XG52YXIgc3FkaXN0ID0gZnVuY3Rpb24gc3FkaXN0KHAxLCBwMikge1xuICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG52YXIgaW5QbGFjZVN1bU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIGluUGxhY2VTdW1Ob3JtYWxpemUodikge1xuICB2YXIgbGVuZ3RoID0gdi5sZW5ndGg7IC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuXG4gIHZhciB0b3RhbCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRvdGFsICs9IHZbaV07XG4gIH0gLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgIHZbX2ldID0gdltfaV0gLyB0b3RhbDtcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcblxudmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uIHFiZXppZXJBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqIHAwICsgMiAqICgxIC0gdCkgKiB0ICogcDEgKyB0ICogdCAqIHAyO1xufTtcbnZhciBxYmV6aWVyUHRBdCA9IGZ1bmN0aW9uIHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBxYmV6aWVyQXQocDAueCwgcDEueCwgcDIueCwgdCksXG4gICAgeTogcWJlemllckF0KHAwLnksIHAxLnksIHAyLnksIHQpXG4gIH07XG59O1xudmFyIGxpbmVBdCA9IGZ1bmN0aW9uIGxpbmVBdChwMCwgcDEsIHQsIGQpIHtcbiAgdmFyIHZlYyA9IHtcbiAgICB4OiBwMS54IC0gcDAueCxcbiAgICB5OiBwMS55IC0gcDAueVxuICB9O1xuICB2YXIgdmVjRGlzdCA9IGRpc3QocDAsIHAxKTtcbiAgdmFyIG5vcm1WZWMgPSB7XG4gICAgeDogdmVjLnggLyB2ZWNEaXN0LFxuICAgIHk6IHZlYy55IC8gdmVjRGlzdFxuICB9O1xuICB0ID0gdCA9PSBudWxsID8gMCA6IHQ7XG4gIGQgPSBkICE9IG51bGwgPyBkIDogdCAqIHZlY0Rpc3Q7XG4gIHJldHVybiB7XG4gICAgeDogcDAueCArIG5vcm1WZWMueCAqIGQsXG4gICAgeTogcDAueSArIG5vcm1WZWMueSAqIGRcbiAgfTtcbn07XG52YXIgYm91bmQgPSBmdW5jdGlvbiBib3VuZChtaW4sIHZhbCwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsKSk7XG59OyAvLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xuXG52YXIgbWFrZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gbWFrZUJvdW5kaW5nQm94KGJiKSB7XG4gIGlmIChiYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBJbmZpbml0eSxcbiAgICAgIHkxOiBJbmZpbml0eSxcbiAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICB5MjogLUluZmluaXR5LFxuICAgICAgdzogMCxcbiAgICAgIGg6IDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCkge1xuICAgIGlmIChiYi54MiAhPSBudWxsICYmIGJiLnkyICE9IG51bGwgJiYgYmIueDIgPj0gYmIueDEgJiYgYmIueTIgPj0gYmIueTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDIsXG4gICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgdzogYmIueDIgLSBiYi54MSxcbiAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGJiLncgIT0gbnVsbCAmJiBiYi5oICE9IG51bGwgJiYgYmIudyA+PSAwICYmIGJiLmggPj0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgIHc6IGJiLncsXG4gICAgICAgIGg6IGJiLmhcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xudmFyIGNvcHlCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNvcHlCb3VuZGluZ0JveChiYikge1xuICByZXR1cm4ge1xuICAgIHgxOiBiYi54MSxcbiAgICB4MjogYmIueDIsXG4gICAgdzogYmIudyxcbiAgICB5MTogYmIueTEsXG4gICAgeTI6IGJiLnkyLFxuICAgIGg6IGJiLmhcbiAgfTtcbn07XG52YXIgY2xlYXJCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNsZWFyQm91bmRpbmdCb3goYmIpIHtcbiAgYmIueDEgPSBJbmZpbml0eTtcbiAgYmIueTEgPSBJbmZpbml0eTtcbiAgYmIueDIgPSAtSW5maW5pdHk7XG4gIGJiLnkyID0gLUluZmluaXR5O1xuICBiYi53ID0gMDtcbiAgYmIuaCA9IDA7XG59O1xudmFyIHVwZGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgLy8gdXBkYXRlIGJiMSB3aXRoIGJiMiBib3VuZHNcbiAgYmIxLngxID0gTWF0aC5taW4oYmIxLngxLCBiYjIueDEpO1xuICBiYjEueDIgPSBNYXRoLm1heChiYjEueDIsIGJiMi54Mik7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICBiYjEueTEgPSBNYXRoLm1pbihiYjEueTEsIGJiMi55MSk7XG4gIGJiMS55MiA9IE1hdGgubWF4KGJiMS55MiwgYmIyLnkyKTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgeCwgeSkge1xuICBiYi54MSA9IE1hdGgubWluKGJiLngxLCB4KTtcbiAgYmIueDIgPSBNYXRoLm1heChiYi54MiwgeCk7XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi55MSA9IE1hdGgubWluKGJiLnkxLCB5KTtcbiAgYmIueTIgPSBNYXRoLm1heChiYi55MiwgeSk7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94KGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBiYi54MSAtPSBwYWRkaW5nO1xuICBiYi54MiArPSBwYWRkaW5nO1xuICBiYi55MSAtPSBwYWRkaW5nO1xuICBiYi55MiArPSBwYWRkaW5nO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIHJldHVybiBiYjtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmIpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFswXTtcbiAgdmFyIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdDtcblxuICBpZiAocGFkZGluZy5sZW5ndGggPT09IDEpIHtcbiAgICB0b3AgPSByaWdodCA9IGJvdHRvbSA9IGxlZnQgPSBwYWRkaW5nWzBdO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAyKSB7XG4gICAgdG9wID0gYm90dG9tID0gcGFkZGluZ1swXTtcbiAgICBsZWZ0ID0gcmlnaHQgPSBwYWRkaW5nWzFdO1xuICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIF9wYWRkaW5nID0gX3NsaWNlZFRvQXJyYXkocGFkZGluZywgNCk7XG5cbiAgICB0b3AgPSBfcGFkZGluZ1swXTtcbiAgICByaWdodCA9IF9wYWRkaW5nWzFdO1xuICAgIGJvdHRvbSA9IF9wYWRkaW5nWzJdO1xuICAgIGxlZnQgPSBfcGFkZGluZ1szXTtcbiAgfVxuXG4gIGJiLngxIC09IGxlZnQ7XG4gIGJiLngyICs9IHJpZ2h0O1xuICBiYi55MSAtPSB0b3A7XG4gIGJiLnkyICs9IGJvdHRvbTtcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xuXG52YXIgYXNzaWduQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBhc3NpZ25Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICBiYjEueDEgPSBiYjIueDE7XG4gIGJiMS55MSA9IGJiMi55MTtcbiAgYmIxLngyID0gYmIyLngyO1xuICBiYjEueTIgPSBiYjIueTI7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbn07XG52YXIgYXNzaWduU2hpZnRUb0JvdW5kaW5nQm94ID0gZnVuY3Rpb24gYXNzaWduU2hpZnRUb0JvdW5kaW5nQm94KGJiLCBkZWx0YSkge1xuICBiYi54MSArPSBkZWx0YS54O1xuICBiYi54MiArPSBkZWx0YS54O1xuICBiYi55MSArPSBkZWx0YS55O1xuICBiYi55MiArPSBkZWx0YS55O1xufTtcbnZhciBib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYjEsIGJiMikge1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MSA+IGJiMi54Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueDEgPiBiYjEueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcblxuXG4gIGlmIChiYjEueDIgPCBiYjIueDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLngyIDwgYmIxLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuXG5cbiAgaWYgKGJiMS55MiA8IGJiMi55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueTIgPCBiYjEueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG5cblxuICBpZiAoYmIxLnkxID4gYmIyLnkyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJiMi55MSA+IGJiMS55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcblxuXG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkge1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG52YXIgcG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gcG9pbnRJbkJvdW5kaW5nQm94KGJiLCBwdCkge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYiwgcHQueCwgcHQueSk7XG59O1xudmFyIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MSwgYmIyLnkxKSAmJiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngyLCBiYjIueTIpO1xufTtcbnZhciByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyOyAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuXG4gIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zOyAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuXG4gIHtcbiAgICB2YXIgcmlnaHRTdGFydFggPSBub2RlWCArIGhhbGZXaWR0aCArIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgdmFyIHJpZ2h0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9IC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG5cbiAge1xuICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICB7XG4gICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBsZWZ0U3RhcnRYLCBsZWZ0U3RhcnRZLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG5cbiAgdmFyIGFyY0ludGVyc2VjdGlvbnM7IC8vIFRvcCBMZWZ0XG5cbiAge1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9IC8vIFRvcCBSaWdodFxuXG4gIHtcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfSAvLyBCb3R0b20gUmlnaHRcblxuICB7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH0gLy8gQm90dG9tIExlZnRcblxuICB7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG59O1xudmFyIGluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24gaW5MaW5lVmljaW5pdHkoeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2UpIHtcbiAgdmFyIHQgPSB0b2xlcmFuY2U7XG4gIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgdmFyIHgyID0gTWF0aC5tYXgobHgxLCBseDIpO1xuICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcbiAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0ICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcbnZhciBpbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24gaW5CZXppZXJWaWNpbml0eSh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgdmFyIGJiID0ge1xuICAgIHgxOiBNYXRoLm1pbih4MSwgeDMsIHgyKSAtIHRvbGVyYW5jZSxcbiAgICB4MjogTWF0aC5tYXgoeDEsIHgzLCB4MikgKyB0b2xlcmFuY2UsXG4gICAgeTE6IE1hdGgubWluKHkxLCB5MywgeTIpIC0gdG9sZXJhbmNlLFxuICAgIHkyOiBNYXRoLm1heCh5MSwgeTMsIHkyKSArIHRvbGVyYW5jZVxuICB9OyAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcblxuICBpZiAoeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBzb2x2ZVF1YWRyYXRpYyA9IGZ1bmN0aW9uIHNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHZhbCkge1xuICBjIC09IHZhbDtcbiAgdmFyIHIgPSBiICogYiAtIDQgKiBhICogYztcblxuICBpZiAociA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3FydFIgPSBNYXRoLnNxcnQocik7XG4gIHZhciBkZW5vbSA9IDIgKiBhO1xuICB2YXIgcm9vdDEgPSAoLWIgKyBzcXJ0UikgLyBkZW5vbTtcbiAgdmFyIHJvb3QyID0gKC1iIC0gc3FydFIpIC8gZGVub207XG4gIHJldHVybiBbcm9vdDEsIHJvb3QyXTtcbn07XG52YXIgc29sdmVDdWJpYyA9IGZ1bmN0aW9uIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG4gIC8vIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDYXJkYW5vIG1ldGhvZCBmcm9tIHRoZSB5ZWFyIDE1NDVcbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuICB2YXIgZXBzaWxvbiA9IDAuMDAwMDE7IC8vIGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hpbGUga2VlcGluZyB0aGUgb3ZlcmFsbCBleHByZXNzaW9uIGNsb3NlIGluIHZhbHVlXG5cbiAgaWYgKGEgPT09IDApIHtcbiAgICBhID0gZXBzaWxvbjtcbiAgfVxuXG4gIGIgLz0gYTtcbiAgYyAvPSBhO1xuICBkIC89IGE7XG4gIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG4gIHEgPSAoMy4wICogYyAtIGIgKiBiKSAvIDkuMDtcbiAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gIHIgLz0gNTQuMDtcbiAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHRlcm0xID0gYiAvIDMuMDtcblxuICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHMgPSByICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgcyA9IHMgPCAwID8gLU1hdGgucG93KC1zLCAxLjAgLyAzLjApIDogTWF0aC5wb3cocywgMS4wIC8gMy4wKTtcbiAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHQgPSB0IDwgMCA/IC1NYXRoLnBvdygtdCwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHQsIDEuMCAvIDMuMCk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgdGVybTEgPSBNYXRoLnNxcnQoMy4wKSAqICgtdCArIHMpIC8gMjtcbiAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcblxuICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgcjEzID0gciA8IDAgPyAtTWF0aC5wb3coLXIsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhyLCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBxID0gLXE7XG4gIGR1bTEgPSBxICogcSAqIHE7XG4gIGR1bTEgPSBNYXRoLmFjb3MociAvIE1hdGguc3FydChkdW0xKSk7XG4gIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gIHJlc3VsdFsyXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgMi4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmV0dXJuO1xufTtcbnZhciBzcWRpc3RUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzICsgeTEgKiB5MSAtIDQgKiB5MSAqIHkyICsgMiAqIHkxICogeTMgKyA0ICogeTIgKiB5MiAtIDQgKiB5MiAqIHkzICsgeTMgKiB5MztcbiAgdmFyIGIgPSAxLjAgKiA5ICogeDEgKiB4MiAtIDMgKiB4MSAqIHgxIC0gMyAqIHgxICogeDMgLSA2ICogeDIgKiB4MiArIDMgKiB4MiAqIHgzICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcbiAgdmFyIGMgPSAxLjAgKiAzICogeDEgKiB4MSAtIDYgKiB4MSAqIHgyICsgeDEgKiB4MyAtIHgxICogeCArIDIgKiB4MiAqIHgyICsgMiAqIHgyICogeCAtIHgzICogeCArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4ICsgeTEgKiB5MiAtIHkxICogeTEgKyB5MSAqIHkgLSB5MiAqIHk7IC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICB2YXIgcm9vdHMgPSBbXTsgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuXG4gIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyKSB7XG4gICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZCAmJiByb290c1tpbmRleF0gPj0gMCAmJiByb290c1tpbmRleF0gPD0gMS4wKSB7XG4gICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgIH1cbiAgfVxuXG4gIHBhcmFtcy5wdXNoKDEuMCk7XG4gIHBhcmFtcy5wdXNoKDAuMCk7XG4gIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTsgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG5cbiAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbn07XG52YXIgc3FkaXN0VG9GaW5pdGVMaW5lID0gZnVuY3Rpb24gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgdmFyIGxpbmVTcSA9IGxpbmVbMF0gKiBsaW5lWzBdICsgbGluZVsxXSAqIGxpbmVbMV07XG4gIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgdmFyIGFkalNxID0gZG90UHJvZHVjdCAqIGRvdFByb2R1Y3QgLyBsaW5lU3E7XG5cbiAgaWYgKGRvdFByb2R1Y3QgPCAwKSB7XG4gICAgcmV0dXJuIGh5cFNxO1xuICB9XG5cbiAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICB9XG5cbiAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICB2YXIgeTM7IC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcblxuICB2YXIgdXAgPSAwOyAvLyBsZXQgZG93biA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgIHkxID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuXG4gICAgaWYgKHgxID09IHggJiYgeDIgPT0geCkgOyBlbHNlIGlmICh4MSA+PSB4ICYmIHggPj0geDIgfHwgeDEgPD0geCAmJiB4IDw9IHgyKSB7XG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gLy8gaWYoIHkzIDwgeSApe1xuICAgICAgLy8gZG93bisrO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgcG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpOyAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuXG4gIHZhciBhbmdsZTtcblxuICBpZiAoZGlyZWN0aW9uWzBdICE9IG51bGwpIHtcbiAgICBhbmdsZSA9IE1hdGguYXRhbihkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0pO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7IC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvcyAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbn07XG52YXIgcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjdXRQb2x5Z29uUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgc3F1YXJlZENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyAqIGNvcm5lclJhZGl1cztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgIH1cblxuICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNF0gPSBjcDB4O1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAxXSA9IGNwMHk7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDJdID0gY3AxeDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgM10gPSBjcDF5O1xuICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICBvcnRoeCAqPSAtMTtcbiAgICAgIG9ydGh5ICo9IC0xO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGN4IC0geCwgMikgKyBNYXRoLnBvdyhjeSAtIHksIDIpO1xuXG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBzcXVhcmVkQ29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFBvbHlnb25Qb2ludHMpO1xufTtcbnZhciBqb2luTGluZXMgPSBmdW5jdGlvbiBqb2luTGluZXMobGluZVNldCkge1xuICB2YXIgdmVydGljZXMgPSBuZXcgQXJyYXkobGluZVNldC5sZW5ndGggLyAyKTtcbiAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbaSAqIDRdO1xuICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0W2kgKiA0ICsgM107XG5cbiAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsyXTtcbiAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgfVxuXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksIHRydWUpO1xuICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICB2ZXJ0aWNlc1tpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcbnZhciBleHBhbmRQb2x5Z29uID0gZnVuY3Rpb24gZXhwYW5kUG9seWdvbihwb2ludHMsIHBhZCkge1xuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgY3VycmVudFBvaW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICB9IC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cblxuICAgIHZhciBvZmZzZXRYID0gbmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTsgLy8gTm9ybWFsaXplXG5cbiAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbn07XG52YXIgaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBlbGxpcHNlV3JhZGl1cywgZWxsaXBzZUhyYWRpdXMpIHtcbiAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICByZXR1cm4gWyhjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5XTtcbn07XG52YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gIHggLT0gY2VudGVyWDtcbiAgeSAtPSBjZW50ZXJZO1xuICB4IC89IHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gIHkgLz0gaGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gIHJldHVybiB4ICogeCArIHkgKiB5IDw9IDE7XG59OyAvLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxuXG52YXIgaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVDaXJjbGUoeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cykge1xuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcblxuICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG4gIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICB2YXIgYyA9IGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0gLSByYWRpdXMgKiByYWRpdXM7XG4gIHZhciBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcblxuICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG5cbiAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gIH1cblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICB9XG59O1xudmFyIG1pZE9mVGhyZWUgPSBmdW5jdGlvbiBtaWRPZlRocmVlKGEsIGIsIGMpIHtcbiAgaWYgKGIgPD0gYSAmJiBhIDw9IGMgfHwgYyA8PSBhICYmIGEgPD0gYikge1xuICAgIHJldHVybiBhO1xuICB9IGVsc2UgaWYgKGEgPD0gYiAmJiBiIDw9IGMgfHwgYyA8PSBiICYmIGIgPD0gYSkge1xuICAgIHJldHVybiBiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjO1xuICB9XG59OyAvLyAoeDEseTEpPT4oeDIseTIpIGludGVyc2VjdCB3aXRoICh4Myx5Myk9Pih4NCx5NClcblxudmFyIGZpbml0ZUxpbmVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gZmluaXRlTGluZXNJbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG4gIHZhciBkeDEzID0geDEgLSB4MztcbiAgdmFyIGR4MjEgPSB4MiAtIHgxO1xuICB2YXIgZHg0MyA9IHg0IC0geDM7XG4gIHZhciBkeTEzID0geTEgLSB5MztcbiAgdmFyIGR5MjEgPSB5MiAtIHkxO1xuICB2YXIgZHk0MyA9IHk0IC0geTM7XG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcblxuICBpZiAodV9iICE9PSAwKSB7XG4gICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG5cbiAgICB2YXIgX21pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuXG4gICAgdmFyIF9tYXggPSAxICsgZmxwdFRocmVzaG9sZDtcblxuICAgIGlmIChfbWluIDw9IHVhICYmIHVhIDw9IF9tYXggJiYgX21pbiA8PSB1YiAmJiB1YiA8PSBfbWF4KSB7XG4gICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcbiAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4NCkgPT09IHg0KSB7XG4gICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgIH0gLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcblxuXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHgzKSA9PT0geDMpIHtcbiAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgfSAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG5cblxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDMsIHg0LCB4MikgPT09IHgyKSB7XG4gICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07IC8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgKVxuLy8gaW50ZXJzZWN0IGEgbm9kZSBwb2x5Z29uIChwdHMgdHJhbnNmb3JtZWQpXG4vL1xuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSApXG4vLyBpbnRlcnNlY3QgdGhlIHBvaW50cyAobm8gdHJhbnNmb3JtKVxuXG52YXIgcG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBkb1RyYW5zZm9ybSA9IHRydWU7XG5cbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiAoZG9UcmFuc2Zvcm0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG5cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gIH1cblxuICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pMisrKSB7XG4gICAgY3VycmVudFggPSBwb2ludHNbX2kyICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbX2kyICogMiArIDFdO1xuXG4gICAgaWYgKF9pMiA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFggPSBwb2ludHNbKF9pMiArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1soX2kyICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFkpO1xuXG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xudmFyIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVBvaW50cy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICB2YXIgc291cmNlVXYgPSB2b2lkIDAsXG4gICAgICAgIGRlc3RVdiA9IHZvaWQgMDtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBzb3VyY2VVdiA9IGJhc2VQb2ludHMubGVuZ3RoIC0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlVXYgPSBpICogNCAtIDI7XG4gICAgfVxuXG4gICAgZGVzdFV2ID0gaSAqIDQgKyAyO1xuICAgIHZhciBweCA9IGNlbnRlclggKyBoYWxmVyAqIGJhc2VQb2ludHNbaSAqIDRdO1xuICAgIHZhciBweSA9IGNlbnRlclkgKyBoYWxmSCAqIGJhc2VQb2ludHNbaSAqIDQgKyAxXTtcbiAgICB2YXIgY29zVGhldGEgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl0gKiBiYXNlUG9pbnRzW2Rlc3RVdl0gLSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgIHZhciBjcDB5ID0gcHkgLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2XTtcbiAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDJdID0gY3AweDtcbiAgICAgIGxpbmVzW2Jhc2VQb2ludHMubGVuZ3RoIC0gMV0gPSBjcDB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lc1tpICogNCAtIDJdID0gY3AweDtcbiAgICAgIGxpbmVzW2kgKiA0IC0gMV0gPSBjcDB5O1xuICAgIH1cblxuICAgIGxpbmVzW2kgKiA0XSA9IGNwMXg7XG4gICAgbGluZXNbaSAqIDQgKyAxXSA9IGNwMXk7XG4gICAgdmFyIG9ydGh4ID0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBvcnRoeSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY29zQWxwaGEgPSBvcnRoeCAqIGJhc2VQb2ludHNbZGVzdFV2XSArIG9ydGh5ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgIGlmIChjb3NBbHBoYSA8IDApIHtcbiAgICAgIG9ydGh4ICo9IC0xO1xuICAgICAgb3J0aHkgKj0gLTE7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gY3AweCArIG9ydGh4ICogY29ybmVyUmFkaXVzO1xuICAgIHZhciBjeSA9IGNwMHkgKyBvcnRoeSAqIGNvcm5lclJhZGl1cztcbiAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN4LCBjeSwgY29ybmVyUmFkaXVzKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpbmVzLmxlbmd0aCAvIDQ7IF9pMysrKSB7XG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgbGluZXNbX2kzICogNF0sIGxpbmVzW19pMyAqIDQgKyAxXSwgbGluZXNbX2kzICogNCArIDJdLCBsaW5lc1tfaTMgKiA0ICsgM10sIGZhbHNlKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgbG93ZXN0SW50ZXJzZWN0aW9uID0gW2ludGVyc2VjdGlvbnNbMF0sIGludGVyc2VjdGlvbnNbMV1dO1xuICAgIHZhciBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMF0gLSB4LCAyKSArIE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblsxXSAtIHksIDIpO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgaW50ZXJzZWN0aW9ucy5sZW5ndGggLyAyOyBfaTQrKykge1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMl0gLSB4LCAyKSArIE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdIC0geSwgMik7XG5cbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gbG93ZXN0U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblswXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMl07XG4gICAgICAgIGxvd2VzdEludGVyc2VjdGlvblsxXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdO1xuICAgICAgICBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvd2VzdEludGVyc2VjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciBzaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG5cbiAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xufTtcbnZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgcG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKTtcbiAgcG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uIGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpIHtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogaV07XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfSAvLyBzdHJldGNoIGZhY3RvcnNcblxuXG4gIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICB2YXIgc3kgPSAyIC8gKG1heFkgLSBtaW5ZKTtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzaWRlczsgX2k1KyspIHtcbiAgICB4ID0gcG9pbnRzWzIgKiBfaTVdID0gcG9pbnRzWzIgKiBfaTVdICogc3g7XG4gICAgeSA9IHBvaW50c1syICogX2k1ICsgMV0gPSBwb2ludHNbMiAqIF9pNSArIDFdICogc3k7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICB9XG5cbiAgaWYgKG1pblkgPCAtMSkge1xuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHNpZGVzOyBfaTYrKykge1xuICAgICAgeSA9IHBvaW50c1syICogX2k2ICsgMV0gPSBwb2ludHNbMiAqIF9pNiArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBzaWRlcyAlIDIgPT09IDAgPyBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoc2lkZXMgKiAyKTtcbiAgdmFyIGN1cnJlbnRBbmdsZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcbiAgICBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsgLy8geFxuXG4gICAgcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsgLy8geVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuXG52YXIgZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xufTsgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1c1xuXG52YXIgZ2V0Um91bmRQb2x5Z29uUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gMTAsIGhlaWdodCAvIDEwLCA4KTtcbn07XG52YXIgZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkge1xuICByZXR1cm4gODtcbn07XG52YXIgYmV6aWVyUHRzVG9RdWFkQ29lZmYgPSBmdW5jdGlvbiBiZXppZXJQdHNUb1F1YWRDb2VmZihwMCwgcDEsIHAyKSB7XG4gIHJldHVybiBbcDAgLSAyICogcDEgKyBwMiwgMiAqIChwMSAtIHAwKSwgcDBdO1xufTsgLy8gZ2V0IGN1cnZlIHdpZHRoLCBoZWlnaHQsIGFuZCBjb250cm9sIHBvaW50IHBvc2l0aW9uIG9mZnNldHMgYXMgYSBwZXJjZW50YWdlIG9mIG5vZGUgaGVpZ2h0IC8gd2lkdGhcblxudmFyIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIGhlaWdodE9mZnNldDogTWF0aC5taW4oMTUsIDAuMDUgKiBoZWlnaHQpLFxuICAgIHdpZHRoT2Zmc2V0OiBNYXRoLm1pbigxMDAsIDAuMjUgKiB3aWR0aCksXG4gICAgY3RybFB0T2Zmc2V0UGN0OiAwLjA1XG4gIH07XG59O1xuXG52YXIgcGFnZVJhbmtEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgZGFtcGluZ0ZhY3RvcjogMC44LFxuICBwcmVjaXNpb246IDAuMDAwMDAxLFxuICBpdGVyYXRpb25zOiAyMDAsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufSk7XG52YXIgZWxlc2ZuJDcgPSB7XG4gIHBhZ2VSYW5rOiBmdW5jdGlvbiBwYWdlUmFuayhvcHRpb25zKSB7XG4gICAgdmFyIF9wYWdlUmFua0RlZmF1bHRzID0gcGFnZVJhbmtEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgZGFtcGluZ0ZhY3RvciA9IF9wYWdlUmFua0RlZmF1bHRzLmRhbXBpbmdGYWN0b3IsXG4gICAgICAgIHByZWNpc2lvbiA9IF9wYWdlUmFua0RlZmF1bHRzLnByZWNpc2lvbixcbiAgICAgICAgaXRlcmF0aW9ucyA9IF9wYWdlUmFua0RlZmF1bHRzLml0ZXJhdGlvbnMsXG4gICAgICAgIHdlaWdodCA9IF9wYWdlUmFua0RlZmF1bHRzLndlaWdodDtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtTm9kZXNTcWQgPSBudW1Ob2RlcyAqIG51bU5vZGVzO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDsgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBBcnJheShudW1Ob2Rlc1NxZCk7XG4gICAgdmFyIGNvbHVtblN1bSA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzOyAvLyBDcmVhdGUgbnVsbCBtYXRyaXhcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBuID0gaSAqIG51bU5vZGVzICsgajtcbiAgICAgICAgbWF0cml4W25dID0gMDtcbiAgICAgIH1cblxuICAgICAgY29sdW1uU3VtW2ldID0gMDtcbiAgICB9IC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtRWRnZXM7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyY0lkID0gZWRnZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuZGF0YSgndGFyZ2V0Jyk7IC8vIERvbid0IGluY2x1ZGUgbG9vcHMgaW4gdGhlIG1hdHJpeFxuXG4gICAgICBpZiAoc3JjSWQgPT09IHRndElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcyA9IG5vZGVzLmluZGV4T2ZJZChzcmNJZCk7XG4gICAgICB2YXIgdCA9IG5vZGVzLmluZGV4T2ZJZCh0Z3RJZCk7XG4gICAgICB2YXIgdyA9IHdlaWdodChlZGdlKTtcblxuICAgICAgdmFyIF9uID0gdCAqIG51bU5vZGVzICsgczsgLy8gVXBkYXRlIG1hdHJpeFxuXG5cbiAgICAgIG1hdHJpeFtfbl0gKz0gdzsgLy8gVXBkYXRlIGNvbHVtbiBzdW1cblxuICAgICAgY29sdW1uU3VtW3NdICs9IHc7XG4gICAgfSAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcblxuXG4gICAgdmFyIHAgPSAxLjAgLyBudW1Ob2RlcyArIGFkZGl0aW9uYWxQcm9iOyAvLyBTaG9ydGhhbmRcbiAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cblxuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBudW1Ob2RlczsgX2orKykge1xuICAgICAgaWYgKGNvbHVtblN1bVtfal0gPT09IDApIHtcbiAgICAgICAgLy8gTm8gJ2xpbmtzJyBvdXQgZnJvbSBub2RlIGp0aCwgYXNzdW1lIGVxdWFsIHByb2JhYmlsaXR5IGZvciBlYWNoIHBvc3NpYmxlIG5vZGVcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtTm9kZXM7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9uMiA9IF9pMiAqIG51bU5vZGVzICsgX2o7XG5cbiAgICAgICAgICBtYXRyaXhbX24yXSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX24zID0gX2kzICogbnVtTm9kZXMgKyBfajtcblxuICAgICAgICAgIG1hdHJpeFtfbjNdID0gbWF0cml4W19uM10gLyBjb2x1bW5TdW1bX2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG5cblxuICAgIHZhciBlaWdlbnZlY3RvciA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIHRlbXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBwcmV2aW91czsgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgZWlnZW52ZWN0b3JbX2k0XSA9IDE7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAgIC8vIFRlbXAgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBudW1Ob2RlczsgX2k1KyspIHtcbiAgICAgICAgdGVtcFtfaTVdID0gMDtcbiAgICAgIH0gLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG5cblxuICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbnVtTm9kZXM7IF9pNisrKSB7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG51bU5vZGVzOyBfajIrKykge1xuICAgICAgICAgIHZhciBfbjQgPSBfaTYgKiBudW1Ob2RlcyArIF9qMjtcblxuICAgICAgICAgIHRlbXBbX2k2XSArPSBtYXRyaXhbX240XSAqIGVpZ2VudmVjdG9yW19qMl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5QbGFjZVN1bU5vcm1hbGl6ZSh0ZW1wKTtcbiAgICAgIHByZXZpb3VzID0gZWlnZW52ZWN0b3I7XG4gICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG4gICAgICB0ZW1wID0gcHJldmlvdXM7XG4gICAgICB2YXIgZGlmZiA9IDA7IC8vIENvbXB1dGUgZGlmZmVyZW5jZSAoc3F1YXJlZCBtb2R1bGUpIG9mIGJvdGggdmVjdG9yc1xuXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBudW1Ob2RlczsgX2k3KyspIHtcbiAgICAgICAgdmFyIGRlbHRhID0gcHJldmlvdXNbX2k3XSAtIGVpZ2VudmVjdG9yW19pN107XG4gICAgICAgIGRpZmYgKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgIH0gLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuXG5cbiAgICAgIGlmIChkaWZmIDwgcHJlY2lzaW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gQ29uc3RydWN0IHJlc3VsdFxuXG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgcmFuazogZnVuY3Rpb24gcmFuayhub2RlKSB7XG4gICAgICAgIG5vZGUgPSBjeS5jb2xsZWN0aW9uKG5vZGUpWzBdO1xuICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3Jbbm9kZXMuaW5kZXhPZihub2RlKV07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIHBhZ2VSYW5rXG5cbn07IC8vIGVsZXNmblxuXG52YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIGFscGhhOiAwXG59KTtcbnZhciBlbGVzZm4kOCA9IHtcbiAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMkMShvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGlmICghb3B0aW9ucy5kaXJlY3RlZCkge1xuICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhEZWdyZWUgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cbiAgICAgICAgb3B0aW9ucy5yb290ID0gbm9kZTtcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG1heERlZ3JlZSA8IGN1cnJEZWdyZWUuZGVncmVlKSB7XG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBmdW5jdGlvbiBkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhEZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bU5vZGVzOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcblxuICAgICAgICB2YXIgaWQgPSBfbm9kZS5pZCgpOyAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcblxuXG4gICAgICAgIG9wdGlvbnMucm9vdCA9IF9ub2RlO1xuXG4gICAgICAgIHZhciBfY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKTtcblxuICAgICAgICBpZiAobWF4SW5kZWdyZWUgPCBfY3VyckRlZ3JlZS5pbmRlZ3JlZSkgbWF4SW5kZWdyZWUgPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IF9jdXJyRGVncmVlLm91dGRlZ3JlZSkgbWF4T3V0ZGVncmVlID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgICBpbmRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIG91dGRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogZnVuY3Rpb24gaW5kZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heEluZGVncmVlO1xuICAgICAgICB9LFxuICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uIG91dGRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlc1tub2RlLmlkKCldIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLy8gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWRcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMkMShvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICByb290ID0gX29wdGlvbnMucm9vdCxcbiAgICAgICAgd2VpZ2h0ID0gX29wdGlvbnMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9vcHRpb25zLmRpcmVjdGVkLFxuICAgICAgICBhbHBoYSA9IF9vcHRpb25zLmFscGhhO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdO1xuXG4gICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oY2FsbGluZ0VsZXMpO1xuICAgICAgdmFyIGsgPSBjb25uRWRnZXMubGVuZ3RoO1xuICAgICAgdmFyIHMgPSAwOyAvLyBOb3csIHN1bSBlZGdlIHdlaWdodHNcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcyArPSB3ZWlnaHQoY29ubkVkZ2VzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICB2YXIgaW5jb21pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UudGFyZ2V0KCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvdXRnb2luZyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5zb3VyY2UoKS5zYW1lKHJvb3QpICYmIGNhbGxpbmdFbGVzLmhhcyhlZGdlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGtfaW4gPSBpbmNvbWluZy5sZW5ndGg7XG4gICAgICB2YXIga19vdXQgPSBvdXRnb2luZy5sZW5ndGg7XG4gICAgICB2YXIgc19pbiA9IDA7XG4gICAgICB2YXIgc19vdXQgPSAwOyAvLyBOb3csIHN1bSBpbmNvbWluZyBlZGdlIHdlaWdodHNcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jb21pbmcubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBzX2luICs9IHdlaWdodChpbmNvbWluZ1tfaTJdKTtcbiAgICAgIH0gLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG5cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgb3V0Z29pbmcubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBzX291dCArPSB3ZWlnaHQob3V0Z29pbmdbX2kzXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBNYXRoLnBvdyhrX2luLCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19pbiwgYWxwaGEpLFxuICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KGtfb3V0LCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19vdXQsIGFscGhhKVxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gZGVncmVlQ2VudHJhbGl0eVxuXG59OyAvLyBlbGVzZm5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcblxuZWxlc2ZuJDguZGMgPSBlbGVzZm4kOC5kZWdyZWVDZW50cmFsaXR5O1xuZWxlc2ZuJDguZGNuID0gZWxlc2ZuJDguZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kOC5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxudmFyIGRlZmF1bHRzJDIgPSBkZWZhdWx0cyh7XG4gIGhhcm1vbmljOiB0cnVlLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodCgpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICByb290OiBudWxsXG59KTtcbnZhciBlbGVzZm4kOSA9IHtcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkMihvcHRpb25zKSxcbiAgICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMuaGFybW9uaWMsXG4gICAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgIHZhciBtYXhDbG9zZW5lc3MgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoe1xuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTsgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICB2YXIgbm9kZV9pID0gbm9kZXNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVfaSwgbm9kZXNbal0pO1xuXG4gICAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFybW9uaWMpIHtcbiAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcykge1xuICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBjbG9zZW5lc3Nlc1tub2RlX2kuaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uIGNsb3NlbmVzcyhub2RlKSB7XG4gICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpWzBdLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBjbG9zZW5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzMiA9IGRlZmF1bHRzJDIob3B0aW9ucyksXG4gICAgICAgIHJvb3QgPSBfZGVmYXVsdHMyLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9kZWZhdWx0czIud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0czIuZGlyZWN0ZWQsXG4gICAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzMi5oYXJtb25pYztcblxuICAgIHJvb3QgPSB0aGlzLmZpbHRlcihyb290KVswXTsgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG5cbiAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAoIW4uc2FtZShyb290KSkge1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8obik7XG5cbiAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSAxIC8gZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gIH0gLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG59OyAvLyBlbGVzZm5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcblxuZWxlc2ZuJDkuY2MgPSBlbGVzZm4kOS5jbG9zZW5lc3NDZW50cmFsaXR5O1xuZWxlc2ZuJDkuY2NuID0gZWxlc2ZuJDkuY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4kOS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcblxudmFyIGRlZmF1bHRzJDMgPSBkZWZhdWx0cyh7XG4gIHdlaWdodDogbnVsbCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kYSA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBiZXR3ZWVubmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyQzKG9wdGlvbnMpLFxuICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodDtcblxuICAgIHZhciB3ZWlnaHRlZCA9IHdlaWdodCAhPSBudWxsO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gc3RhcnRpbmdcblxuICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBBID0ge307XG4gICAgdmFyIF9DID0ge307XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIEMgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICBfQ1trZXldID0gdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9DW2tleV07XG4gICAgICB9XG4gICAgfTsgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG5cbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW3ZpZF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbdmlkXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuXG4gICAgICBDLnNldCh2aWQsIDApO1xuICAgIH1cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHMpIHtcbiAgICAgIHZhciBzaWQgPSBWW3NdLmlkKCk7XG4gICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgIH0pOyAvLyBxdWV1ZVxuICAgICAgLy8gaW5pdCBkaWN0aW9uYXJpZXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFYubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfdmlkID0gVltfaV0uaWQoKTtcblxuICAgICAgICBQW192aWRdID0gW107XG4gICAgICAgIGdbX3ZpZF0gPSAwO1xuICAgICAgICBkW192aWRdID0gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGdbc2lkXSA9IDE7IC8vIHNpZ21hXG5cbiAgICAgIGRbc2lkXSA9IDA7IC8vIGRpc3RhbmNlIHRvIHNcblxuICAgICAgUS5wdXNoKHNpZCk7XG5cbiAgICAgIHdoaWxlICghUS5lbXB0eSgpKSB7XG4gICAgICAgIHZhciBfdiA9IFEucG9wKCk7XG5cbiAgICAgICAgUy5wdXNoKF92KTtcblxuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEFbX3ZdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IEFbX3ZdW2pdO1xuICAgICAgICAgICAgdmFyIHZFbGUgPSBjeS5nZXRFbGVtZW50QnlJZChfdik7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHZFbGUuZWRnZXNUbyh3KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSB2RWxlLmVkZ2VzVG8odylbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGdlID0gdy5lZGdlc1RvKHZFbGUpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodChlZGdlKTtcbiAgICAgICAgICAgIHcgPSB3LmlkKCk7XG5cbiAgICAgICAgICAgIGlmIChkW3ddID4gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGRbd10gPSBkW192XSArIGVkZ2VXZWlnaHQ7XG5cbiAgICAgICAgICAgICAgaWYgKFEubm9kZXMuaW5kZXhPZih3KSA8IDApIHtcbiAgICAgICAgICAgICAgICAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICBRLnB1c2godyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgIFEudXBkYXRlSXRlbSh3KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdbd10gPSAwO1xuICAgICAgICAgICAgICBQW3ddID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkW3ddID09IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBnW3ddID0gZ1t3XSArIGdbX3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgQVtfdl0ubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgX3cgPSBBW192XVtfal0uaWQoKTtcblxuICAgICAgICAgICAgaWYgKGRbX3ddID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIFEucHVzaChfdyk7XG4gICAgICAgICAgICAgIGRbX3ddID0gZFtfdl0gKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZFtfd10gPT0gZFtfdl0gKyAxKSB7XG4gICAgICAgICAgICAgIGdbX3ddID0gZ1tfd10gKyBnW192XTtcblxuICAgICAgICAgICAgICBQW193XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgVi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGVbVltfaTJdLmlkKCldID0gMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3cyID0gUy5wb3AoKTtcblxuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBQW193Ml0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBfdjIgPSBQW193Ml1bX2oyXTtcbiAgICAgICAgICBlW192Ml0gPSBlW192Ml0gKyBnW192Ml0gLyBnW193Ml0gKiAoMSArIGVbX3cyXSk7XG5cbiAgICAgICAgICBpZiAoX3cyICE9IFZbc10uaWQoKSkge1xuICAgICAgICAgICAgQy5zZXQoX3cyLCBDLmdldChfdzIpICsgZVtfdzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrKSB7XG4gICAgICBfbG9vcChzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uIGJldHdlZW5uZXNzKG5vZGUpIHtcbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpO1xuICAgICAgfSxcbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gYmV0d2Vlbm5lc3NOb3JtYWxpemVkKG5vZGUpIHtcbiAgICAgICAgaWYgKG1heCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBjeS5jb2xsZWN0aW9uKG5vZGUpLmlkKCk7XG4gICAgICAgIHJldHVybiBDLmdldChpZCkgLyBtYXg7XG4gICAgICB9XG4gICAgfTsgLy8gYWxpYXNcblxuICAgIHJldC5iZXR3ZWVubmVzc05vcm1hbGlzZWQgPSByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpemVkO1xuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gYmV0d2Vlbm5lc3NDZW50cmFsaXR5XG5cbn07IC8vIGVsZXNmblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuXG5lbGVzZm4kYS5iYyA9IGVsZXNmbiRhLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG52YXIgZGVmYXVsdHMkNCA9IGRlZmF1bHRzKHtcbiAgZXhwYW5kRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIHRpbWUgb2YgY29tcHV0YXRpb24gYW5kIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgdG8gc29tZSBleHRlbnQ6IE0gKiBNXG4gIGluZmxhdGVGYWN0b3I6IDIsXG4gIC8vIGFmZmVjdHMgY2x1c3RlciBncmFudWxhcml0eSAodGhlIGdyZWF0ZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBjbHVzdGVycyk6IE0oaSxqKSAvIEUoailcbiAgbXVsdEZhY3RvcjogMSxcbiAgLy8gb3B0aW9uYWwgc2VsZiBsb29wcyBmb3IgZWFjaCBub2RlLiBVc2UgYSBuZXV0cmFsIHZhbHVlIHRvIGltcHJvdmUgY2x1c3RlciBjb21wdXRhdGlvbnMuXG4gIG1heEl0ZXJhdGlvbnM6IDIwLFxuICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIG9mIHRoZSBNQ0wgYWxnb3JpdGhtIGluIGEgc2luZ2xlIHJ1blxuICBhdHRyaWJ1dGVzOiBbLy8gYXR0cmlidXRlcy9mZWF0dXJlcyB1c2VkIHRvIGdyb3VwIG5vZGVzLCBpZS4gc2ltaWxhcml0eSB2YWx1ZXMgYmV0d2VlbiBub2Rlc1xuICBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9XVxufSk7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyQ0KG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG52YXIgZ2V0U2ltaWxhcml0eSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoZWRnZSwgYXR0cmlidXRlcykge1xuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHRvdGFsICs9IGF0dHJpYnV0ZXNbaV0oZWRnZSk7XG4gIH1cblxuICByZXR1cm4gdG90YWw7XG59O1xuXG52YXIgYWRkTG9vcHMgPSBmdW5jdGlvbiBhZGRMb29wcyhNLCBuLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBNW2kgKiBuICsgaV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoTSwgbikge1xuICB2YXIgc3VtO1xuXG4gIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG47IGNvbCsrKSB7XG4gICAgc3VtID0gMDtcblxuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG47IHJvdysrKSB7XG4gICAgICBzdW0gKz0gTVtyb3cgKiBuICsgY29sXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcm93ID0gMDsgX3JvdyA8IG47IF9yb3crKykge1xuICAgICAgTVtfcm93ICogbiArIGNvbF0gPSBNW19yb3cgKiBuICsgY29sXSAvIHN1bTtcbiAgICB9XG4gIH1cbn07IC8vIFRPRE86IGJsb2NrZWQgbWF0cml4IG11bHRpcGxpY2F0aW9uP1xuXG5cbnZhciBtbXVsdCA9IGZ1bmN0aW9uIG1tdWx0KEEsIEIsIG4pIHtcbiAgdmFyIEMgPSBuZXcgQXJyYXkobiAqIG4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIENbaSAqIG4gKyBqXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIENbaSAqIG4gKyBfal0gKz0gQVtpICogbiArIGtdICogQltrICogbiArIF9qXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQztcbn07XG5cbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoTSwgbiwgZXhwYW5kRmFjdG9yXG4vKiogcG93ZXIgKiovXG4pIHtcbiAgdmFyIF9NID0gTS5zbGljZSgwKTtcblxuICBmb3IgKHZhciBwID0gMTsgcCA8IGV4cGFuZEZhY3RvcjsgcCsrKSB7XG4gICAgTSA9IG1tdWx0KE0sIF9NLCBuKTtcbiAgfVxuXG4gIHJldHVybiBNO1xufTtcblxudmFyIGluZmxhdGUgPSBmdW5jdGlvbiBpbmZsYXRlKE0sIG4sIGluZmxhdGVGYWN0b3Jcbi8qKiByICoqL1xuKSB7XG4gIHZhciBfTSA9IG5ldyBBcnJheShuICogbik7IC8vIE0oaSxqKSBeIGluZmxhdGVQb3dlclxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICogbjsgaSsrKSB7XG4gICAgX01baV0gPSBNYXRoLnBvdyhNW2ldLCBpbmZsYXRlRmFjdG9yKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZShfTSwgbik7XG4gIHJldHVybiBfTTtcbn07XG5cbnZhciBoYXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXNDb252ZXJnZWQoTSwgX00sIG4yLCByb3VuZEZhY3Rvcikge1xuICAvLyBDaGVjayB0aGF0IGJvdGggbWF0cmljZXMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyAoaSxqKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4yOyBpKyspIHtcbiAgICB2YXIgdjEgPSBNYXRoLnJvdW5kKE1baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7IC8vIHRydW5jYXRlIHRvICdyb3VuZEZhY3RvcicgZGVjaW1hbCBwbGFjZXNcblxuICAgIHZhciB2MiA9IE1hdGgucm91bmQoX01baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7XG5cbiAgICBpZiAodjEgIT09IHYyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKE0sIG4sIG5vZGVzLCBjeSkge1xuICB2YXIgY2x1c3RlcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBjbHVzdGVyID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgLy8gUm93LXdpc2UgYXR0cmFjdG9ycyBhbmQgZWxlbWVudHMgdGhhdCB0aGV5IGF0dHJhY3QgYmVsb25nIGluIHNhbWUgY2x1c3RlclxuICAgICAgaWYgKE1hdGgucm91bmQoTVtpICogbiArIGpdICogMTAwMCkgLyAxMDAwID4gMCkge1xuICAgICAgICBjbHVzdGVyLnB1c2gobm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbHVzdGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY2x1c3RlcnMucHVzaChjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgaXNEdXBsaWNhdGUgPSBmdW5jdGlvbiBpc0R1cGxpY2F0ZShjMSwgYzIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYzJbaV0gfHwgYzFbaV0uaWQoKSAhPT0gYzJbaV0uaWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaSAhPSBqICYmIGlzRHVwbGljYXRlKGNsdXN0ZXJzW2ldLCBjbHVzdGVyc1tqXSkpIHtcbiAgICAgICAgY2x1c3RlcnMuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBtYXJrb3ZDbHVzdGVyaW5nID0gZnVuY3Rpb24gbWFya292Q2x1c3RlcmluZyhvcHRpb25zKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTpcblxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMob3B0aW9ucyk7IC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcblxuICB2YXIgaWQycG9zaXRpb24gPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICB9IC8vIEdlbmVyYXRlIHN0b2NoYXN0aWMgbWF0cml4IE0gZnJvbSBpbnB1dCBncmFwaCBHIChzaG91bGQgYmUgc3ltbWV0cmljL3VuZGlyZWN0ZWQpXG5cblxuICB2YXIgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIG4yID0gbiAqIG47XG5cbiAgdmFyIE0gPSBuZXcgQXJyYXkobjIpLFxuICAgICAgX007XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgTVtfaV0gPSAwO1xuICB9XG5cbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgdmFyIF9pMiA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgdmFyIGogPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgIHZhciBzaW0gPSBnZXRTaW1pbGFyaXR5KGVkZ2UsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgTVtfaTIgKiBuICsgal0gKz0gc2ltOyAvLyBHIHNob3VsZCBiZSBzeW1tZXRyaWMgYW5kIHVuZGlyZWN0ZWRcblxuICAgIE1baiAqIG4gKyBfaTJdICs9IHNpbTtcbiAgfSAvLyBCZWdpbiBNYXJrb3YgY2x1c3RlciBhbGdvcml0aG1cbiAgLy8gU3RlcCAxOiBBZGQgc2VsZiBsb29wcyB0byBlYWNoIG5vZGUsIGllLiBhZGQgbXVsdEZhY3RvciB0byBtYXRyaXggZGlhZ29uYWxcblxuXG4gIGFkZExvb3BzKE0sIG4sIG9wdHMubXVsdEZhY3Rvcik7IC8vIFN0ZXAgMjogTSA9IG5vcm1hbGl6ZSggTSApO1xuXG4gIG5vcm1hbGl6ZShNLCBuKTtcbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAzOlxuXG4gICAgX00gPSBleHBhbmQoTSwgbiwgb3B0cy5leHBhbmRGYWN0b3IpOyAvLyBTdGVwIDQ6XG5cbiAgICBNID0gaW5mbGF0ZShfTSwgbiwgb3B0cy5pbmZsYXRlRmFjdG9yKTsgLy8gU3RlcCA1OiBjaGVjayB0byBzZWUgaWYgfnN0ZWFkeSBzdGF0ZSBoYXMgYmVlbiByZWFjaGVkXG5cbiAgICBpZiAoIWhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIDQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH0gLy8gQnVpbGQgY2x1c3RlcnMgZnJvbSBtYXRyaXhcblxuXG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbihNLCBuLCBub2RlcywgY3kpOyAvLyBSZW1vdmUgZHVwbGljYXRlIGNsdXN0ZXJzIGR1ZSB0byBzeW1tZXRyeSBvZiBncmFwaCBhbmQgTSBtYXRyaXhcblxuICBjbHVzdGVycyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgbWFya292Q2x1c3RlcmluZyQxID0ge1xuICBtYXJrb3ZDbHVzdGVyaW5nOiBtYXJrb3ZDbHVzdGVyaW5nLFxuICBtY2w6IG1hcmtvdkNsdXN0ZXJpbmdcbn07XG5cbi8vIENvbW1vbiBkaXN0YW5jZSBtZXRyaWNzIGZvciBjbHVzdGVyaW5nIGFsZ29yaXRobXNcblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn07XG5cbnZhciBhYnNEaWZmID0gZnVuY3Rpb24gYWJzRGlmZihwLCBxKSB7XG4gIHJldHVybiBNYXRoLmFicyhxIC0gcCk7XG59O1xuXG52YXIgYWRkQWJzRGlmZiA9IGZ1bmN0aW9uIGFkZEFic0RpZmYodG90YWwsIHAsIHEpIHtcbiAgcmV0dXJuIHRvdGFsICsgYWJzRGlmZihwLCBxKTtcbn07XG5cbnZhciBhZGRTcXVhcmVkRGlmZiA9IGZ1bmN0aW9uIGFkZFNxdWFyZWREaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIE1hdGgucG93KHEgLSBwLCAyKTtcbn07XG5cbnZhciBzcXJ0ID0gZnVuY3Rpb24gc3FydCh4KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeCk7XG59O1xuXG52YXIgbWF4QWJzRGlmZiA9IGZ1bmN0aW9uIG1heEFic0RpZmYoY3VycmVudE1heCwgcCwgcSkge1xuICByZXR1cm4gTWF0aC5tYXgoY3VycmVudE1heCwgYWJzRGlmZihwLCBxKSk7XG59O1xuXG52YXIgZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIGluaXQsIHZpc2l0KSB7XG4gIHZhciBwb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBpZGVudGl0eTtcbiAgdmFyIHJldCA9IGluaXQ7XG4gIHZhciBwLCBxO1xuXG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IGxlbmd0aDsgZGltKyspIHtcbiAgICBwID0gZ2V0UChkaW0pO1xuICAgIHEgPSBnZXRRKGRpbSk7XG4gICAgcmV0ID0gdmlzaXQocmV0LCBwLCBxKTtcbiAgfVxuXG4gIHJldHVybiBwb3N0KHJldCk7XG59O1xuXG52YXIgZGlzdGFuY2VzID0ge1xuICBldWNsaWRlYW46IGZ1bmN0aW9uIGV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmLCBzcXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIHNpbmdsZSBhdHRyIGNhc2UsIG1vcmUgZWZmaWNpZW50IHRvIGF2b2lkIHNxcnRcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICAgIH1cbiAgfSxcbiAgc3F1YXJlZEV1Y2xpZGVhbjogZnVuY3Rpb24gc3F1YXJlZEV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZik7XG4gIH0sXG4gIG1hbmhhdHRhbjogZnVuY3Rpb24gbWFuaGF0dGFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICB9LFxuICBtYXg6IGZ1bmN0aW9uIG1heChsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAtSW5maW5pdHksIG1heEFic0RpZmYpO1xuICB9XG59OyAvLyBpbiBjYXNlIHRoZSB1c2VyIGFjY2lkZW50YWxseSBkb2Vzbid0IHVzZSBjYW1lbCBjYXNlXG5cbmRpc3RhbmNlc1snc3F1YXJlZC1ldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuZGlzdGFuY2VzWydzcXVhcmVkZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmZ1bmN0aW9uIGNsdXN0ZXJpbmdEaXN0YW5jZSAobWV0aG9kLCBsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSkge1xuICB2YXIgaW1wbDtcblxuICBpZiAoZm4obWV0aG9kKSkge1xuICAgIGltcGwgPSBtZXRob2Q7XG4gIH0gZWxzZSB7XG4gICAgaW1wbCA9IGRpc3RhbmNlc1ttZXRob2RdIHx8IGRpc3RhbmNlcy5ldWNsaWRlYW47XG4gIH1cblxuICBpZiAobGVuZ3RoID09PSAwICYmIGZuKG1ldGhvZCkpIHtcbiAgICByZXR1cm4gaW1wbChub2RlUCwgbm9kZVEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbXBsKGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdHMkNSA9IGRlZmF1bHRzKHtcbiAgazogMixcbiAgbTogMixcbiAgc2Vuc2l0aXZpdHlUaHJlc2hvbGQ6IDAuMDAwMSxcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICBtYXhJdGVyYXRpb25zOiAxMCxcbiAgYXR0cmlidXRlczogW10sXG4gIHRlc3RNb2RlOiBmYWxzZSxcbiAgdGVzdENlbnRyb2lkczogbnVsbFxufSk7XG5cbnZhciBzZXRPcHRpb25zJDEgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZmF1bHRzJDUob3B0aW9ucyk7XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbnZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdCh0eXBlLCBub2RlLCBjZW50cm9pZCwgYXR0cmlidXRlcywgbW9kZSkge1xuICB2YXIgbm9Ob2RlUCA9IG1vZGUgIT09ICdrTWVkb2lkcyc7XG4gIHZhciBnZXRQID0gbm9Ob2RlUCA/IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGNlbnRyb2lkW2ldO1xuICB9IDogZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShjZW50cm9pZCk7XG4gIH07XG5cbiAgdmFyIGdldFEgPSBmdW5jdGlvbiBnZXRRKGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShub2RlKTtcbiAgfTtcblxuICB2YXIgbm9kZVAgPSBjZW50cm9pZDtcbiAgdmFyIG5vZGVRID0gbm9kZTtcbiAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbn07XG5cbnZhciByYW5kb21DZW50cm9pZHMgPSBmdW5jdGlvbiByYW5kb21DZW50cm9pZHMobm9kZXMsIGssIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5kaW0gPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgdmFyIG1pbiA9IG5ldyBBcnJheShuZGltKTtcbiAgdmFyIG1heCA9IG5ldyBBcnJheShuZGltKTtcbiAgdmFyIGNlbnRyb2lkcyA9IG5ldyBBcnJheShrKTtcbiAgdmFyIGNlbnRyb2lkID0gbnVsbDsgLy8gRmluZCBtaW4sIG1heCB2YWx1ZXMgZm9yIGVhY2ggYXR0cmlidXRlIGRpbWVuc2lvblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmRpbTsgaSsrKSB7XG4gICAgbWluW2ldID0gbm9kZXMubWluKGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICAgIG1heFtpXSA9IG5vZGVzLm1heChhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgfSAvLyBCdWlsZCBrIGNlbnRyb2lkcywgZWFjaCByZXByZXNlbnRlZCBhcyBhbiBuLWRpbSBmZWF0dXJlIHZlY3RvclxuXG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICBjZW50cm9pZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5kaW07IF9pKyspIHtcbiAgICAgIGNlbnRyb2lkW19pXSA9IE1hdGgucmFuZG9tKCkgKiAobWF4W19pXSAtIG1pbltfaV0pICsgbWluW19pXTsgLy8gcmFuZG9tIGluaXRpYWwgdmFsdWVcbiAgICB9XG5cbiAgICBjZW50cm9pZHNbY10gPSBjZW50cm9pZDtcbiAgfVxuXG4gIHJldHVybiBjZW50cm9pZHM7XG59O1xuXG52YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIGRpc3RhbmNlLCBhdHRyaWJ1dGVzLCB0eXBlKSB7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXN0ID0gZ2V0RGlzdChkaXN0YW5jZSwgbm9kZSwgY2VudHJvaWRzW2ldLCBhdHRyaWJ1dGVzLCB0eXBlKTtcblxuICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICBtaW4gPSBkaXN0O1xuICAgICAgaW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbnZhciBidWlsZENsdXN0ZXIgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXIoY2VudHJvaWQsIG5vZGVzLCBhc3NpZ25tZW50KSB7XG4gIHZhciBjbHVzdGVyID0gW107XG4gIHZhciBub2RlID0gbnVsbDtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgbm9kZSA9IG5vZGVzW25dO1xuXG4gICAgaWYgKGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9PT0gY2VudHJvaWQpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJOb2RlIFwiICsgbm9kZS5pZCgpICsgXCIgaXMgYXNzb2NpYXRlZCB3aXRoIG1lZG9pZCAjOiBcIiArIG0pO1xuICAgICAgY2x1c3Rlci5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbHVzdGVyO1xufTtcblxudmFyIGhhdmVWYWx1ZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlVmFsdWVzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHYyIC0gdjEpIDw9IHNlbnNpdGl2aXR5VGhyZXNob2xkO1xufTtcblxudmFyIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHYxW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHYxW2ldW2pdIC0gdjJbaV1bal0pO1xuXG4gICAgICBpZiAoZGlmZiA+IHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzZWVuQmVmb3JlID0gZnVuY3Rpb24gc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKG5vZGUgPT09IG1lZG9pZHNbaV0pIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHJhbmRvbU1lZG9pZHMgPSBmdW5jdGlvbiByYW5kb21NZWRvaWRzKG5vZGVzLCBrKSB7XG4gIHZhciBtZWRvaWRzID0gbmV3IEFycmF5KGspOyAvLyBGb3Igc21hbGwgZGF0YSBzZXRzLCB0aGUgcHJvYmFiaWxpdHkgb2YgbWVkb2lkIGNvbmZsaWN0IGlzIGdyZWF0ZXIsXG4gIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiBvciBjaG9zZSB0aGlzIG5vZGUgYmVmb3JlLlxuXG4gIGlmIChub2Rlcy5sZW5ndGggPCA1MCkge1xuICAgIC8vIFJhbmRvbWx5IHNlbGVjdCBrIG1lZG9pZHMgZnJvbSB0aGUgbiBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldOyAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNob3NlbiB0aGlzIG5vZGUgdG8gYmUgYSBtZWRvaWQsIGRvbid0IGNob29zZSBpdCBhZ2FpbiAoZm9yIHNtYWxsIGRhdGEgc2V0cykuXG4gICAgICAvLyBJbnN0ZWFkIGNob29zZSBhIGRpZmZlcmVudCByYW5kb20gbm9kZS5cblxuICAgICAgd2hpbGUgKHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgaSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgICAgfVxuXG4gICAgICBtZWRvaWRzW2ldID0gbm9kZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVsYXRpdmVseSBsYXJnZSBkYXRhIHNldCwgc28gcHJldHR5IHNhZmUgdG8gbm90IGNoZWNrIGFuZCBqdXN0IHNlbGVjdCByYW5kb20gbm9kZXNcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrOyBfaTIrKykge1xuICAgICAgbWVkb2lkc1tfaTJdID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lZG9pZHM7XG59O1xuXG52YXIgZmluZENvc3QgPSBmdW5jdGlvbiBmaW5kQ29zdChwb3RlbnRpYWxOZXdNZWRvaWQsIGNsdXN0ZXIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGNvc3QgPSAwO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3Rlci5sZW5ndGg7IG4rKykge1xuICAgIGNvc3QgKz0gZ2V0RGlzdCgnbWFuaGF0dGFuJywgY2x1c3RlcltuXSwgcG90ZW50aWFsTmV3TWVkb2lkLCBhdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgfVxuXG4gIHJldHVybiBjb3N0O1xufTtcblxudmFyIGtNZWFucyA9IGZ1bmN0aW9uIGtNZWFucyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgbm9kZSA9IG51bGw7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogIyBvZiBjbHVzdGVycywgZGlzdGFuY2UgbWV0cmljLCBldGMuXG5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDEob3B0aW9ucyk7IC8vIEJlZ2luIGstbWVhbnMgYWxnb3JpdGhtXG5cbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIHZhciBhc3NpZ25tZW50ID0ge307XG4gIHZhciBjZW50cm9pZHM7IC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBjZW50cm9pZCBwb3NpdGlvbnNcblxuICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykge1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICBjZW50cm9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBjZW50cm9pZFxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG5cbiAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lYW5zJyk7XG4gICAgfSAvLyBTdGVwIDM6IEZvciBlYWNoIG9mIHRoZSBrIGNsdXN0ZXJzLCB1cGRhdGUgaXRzIGNlbnRyb2lkXG5cblxuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3B0cy5rOyBjKyspIHtcbiAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBjbHVzdGVyXG4gICAgICB2YXIgY2x1c3RlciA9IGJ1aWxkQ2x1c3RlcihjLCBub2RlcywgYXNzaWdubWVudCk7XG5cbiAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBjbHVzdGVyIGlzIGVtcHR5LCBicmVhayBvdXQgZWFybHkgJiBtb3ZlIHRvIG5leHQgY2x1c3RlclxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVXBkYXRlIGNlbnRyb2lkcyBieSBjYWxjdWxhdGluZyBhdmcgb2YgYWxsIG5vZGVzIHdpdGhpbiB0aGUgY2x1c3Rlci5cblxuXG4gICAgICB2YXIgbmRpbSA9IG9wdHMuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZHNbY107IC8vIFsgZGltXzEsIGRpbV8yLCBkaW1fMywgLi4uICwgZGltX24gXVxuXG4gICAgICB2YXIgbmV3Q2VudHJvaWQgPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgICB2YXIgc3VtID0gbmV3IEFycmF5KG5kaW0pO1xuXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG5kaW07IGQrKykge1xuICAgICAgICBzdW1bZF0gPSAwLjA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGNsdXN0ZXJbaV07XG4gICAgICAgICAgc3VtW2RdICs9IG9wdHMuYXR0cmlidXRlc1tkXShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0NlbnRyb2lkW2RdID0gc3VtW2RdIC8gY2x1c3Rlci5sZW5ndGg7IC8vIENoZWNrIHRvIHNlZSBpZiBhbGdvcml0aG0gaGFzIGNvbnZlcmdlZCwgaS5lLiB3aGVuIGNlbnRyb2lkcyBubyBsb25nZXIgY2hhbmdlXG5cbiAgICAgICAgaWYgKCFoYXZlVmFsdWVzQ29udmVyZ2VkKG5ld0NlbnRyb2lkW2RdLCBjZW50cm9pZFtkXSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjZW50cm9pZHNbY10gPSBuZXdDZW50cm9pZDtcbiAgICAgIGNsdXN0ZXJzW2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIga01lZG9pZHMgPSBmdW5jdGlvbiBrTWVkb2lkcyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgbm9kZSA9IG51bGw7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpOyAvLyBCZWdpbiBrLW1lZG9pZHMgYWxnb3JpdGhtXG5cbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIHZhciBtZWRvaWRzO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY3VyQ29zdDtcbiAgdmFyIG1pbkNvc3RzID0gbmV3IEFycmF5KG9wdHMuayk7IC8vIG1pbmltdW0gY29zdCBjb25maWd1cmF0aW9uIGZvciBlYWNoIGNsdXN0ZXJcbiAgLy8gU3RlcCAxOiBJbml0aWFsaXplIGsgbWVkb2lkc1xuXG4gIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSA7IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1lZG9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgfVxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBtZWRvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuXG4gICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBtZWRvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICAgIH1cblxuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAzOiBGb3IgZWFjaCBtZWRvaWQgbSwgYW5kIGZvciBlYWNoIG5vZGUgYXNzY2lhdGVkIHdpdGggbWVkaW9kIG0sXG4gICAgLy8gc2VsZWN0IHRoZSBub2RlIHdpdGggdGhlIGxvd2VzdCBjb25maWd1cmF0aW9uIGNvc3QgYXMgbmV3IG1lZG9pZC5cblxuICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWVkb2lkcy5sZW5ndGg7IG0rKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIG1lZG9pZFxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIobSwgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG1pbkNvc3RzW21dID0gZmluZENvc3QobWVkb2lkc1ttXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTsgLy8gb3JpZ2luYWwgY29zdFxuICAgICAgLy8gU2VsZWN0IGRpZmZlcmVudCBtZWRvaWQgaWYgaXRzIGNvbmZpZ3VyYXRpb24gaGFzIHRoZSBsb3dlc3QgY29zdFxuXG4gICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3Rlci5sZW5ndGg7IF9uKyspIHtcbiAgICAgICAgY3VyQ29zdCA9IGZpbmRDb3N0KGNsdXN0ZXJbX25dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIGlmIChjdXJDb3N0IDwgbWluQ29zdHNbbV0pIHtcbiAgICAgICAgICBtaW5Db3N0c1ttXSA9IGN1ckNvc3Q7XG4gICAgICAgICAgbWVkb2lkc1ttXSA9IGNsdXN0ZXJbX25dO1xuICAgICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsdXN0ZXJzW21dID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgdXBkYXRlQ2VudHJvaWRzID0gZnVuY3Rpb24gdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cykge1xuICB2YXIgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIHdlaWdodFtuXVtjXSA9IE1hdGgucG93KFVbbl1bY10sIG9wdHMubSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGNlbnRyb2lkcy5sZW5ndGg7IF9jKyspIHtcbiAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgbnVtZXJhdG9yID0gMDtcbiAgICAgIGRlbm9taW5hdG9yID0gMDtcblxuICAgICAgZm9yICh2YXIgX24yID0gMDsgX24yIDwgbm9kZXMubGVuZ3RoOyBfbjIrKykge1xuICAgICAgICBudW1lcmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdICogb3B0cy5hdHRyaWJ1dGVzW2RpbV0obm9kZXNbX24yXSk7XG4gICAgICAgIGRlbm9taW5hdG9yICs9IHdlaWdodFtfbjJdW19jXTtcbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzW19jXVtkaW1dID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdXBkYXRlTWVtYmVyc2hpcCA9IGZ1bmN0aW9uIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpIHtcbiAgLy8gU2F2ZSBwcmV2aW91cyBzdGVwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVS5sZW5ndGg7IGkrKykge1xuICAgIF9VW2ldID0gVVtpXS5zbGljZSgpO1xuICB9XG5cbiAgdmFyIHN1bSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcbiAgdmFyIHBvdyA9IDIgLyAob3B0cy5tIC0gMSk7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNlbnRyb2lkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAvLyBhZ2FpbnN0IGFsbCBvdGhlciBjZW50cm9pZHNcbiAgICAgICAgbnVtZXJhdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2NdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgZGVub21pbmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNba10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICBzdW0gKz0gTWF0aC5wb3cobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIHBvdyk7XG4gICAgICB9XG5cbiAgICAgIFVbbl1bY10gPSAxIC8gc3VtO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGFzc2lnbiQxID0gZnVuY3Rpb24gYXNzaWduKG5vZGVzLCBVLCBvcHRzLCBjeSkge1xuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbY10gPSBbXTtcbiAgfVxuXG4gIHZhciBtYXg7XG4gIHZhciBpbmRleDtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IFUubGVuZ3RoOyBuKyspIHtcbiAgICAvLyBmb3IgZWFjaCBub2RlIChVIGlzIE4geCBDIG1hdHJpeClcbiAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgaW5kZXggPSAtMTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhlIG5vZGUgaXMgbW9zdCBsaWtlbHkgdG8gYmVsb25nIGluXG5cbiAgICBmb3IgKHZhciBfYzIgPSAwOyBfYzIgPCBVWzBdLmxlbmd0aDsgX2MyKyspIHtcbiAgICAgIGlmIChVW25dW19jMl0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gVVtuXVtfYzJdO1xuICAgICAgICBpbmRleCA9IF9jMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbHVzdGVyc1tpbmRleF0ucHVzaChub2Rlc1tuXSk7XG4gIH0gLy8gVHVybiBldmVyeSBhcnJheSBpbnRvIGEgY29sbGVjdGlvbiBvZiBub2Rlc1xuXG5cbiAgZm9yICh2YXIgX2MzID0gMDsgX2MzIDwgY2x1c3RlcnMubGVuZ3RoOyBfYzMrKykge1xuICAgIGNsdXN0ZXJzW19jM10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW19jM10pO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGZ1enp5Q01lYW5zID0gZnVuY3Rpb24gZnV6enlDTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDEob3B0aW9ucyk7IC8vIEJlZ2luIGZ1enp5IGMtbWVhbnMgYWxnb3JpdGhtXG5cbiAgdmFyIGNsdXN0ZXJzO1xuICB2YXIgY2VudHJvaWRzO1xuICB2YXIgVTtcblxuICB2YXIgX1U7XG5cbiAgdmFyIHdlaWdodDsgLy8gU3RlcCAxOiBJbml0aWFsaXplIGxldGlhYmxlcy5cblxuICBfVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBfVVtpXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9XG5cbiAgVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBVW19pM10gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHRzLms7IGorKykge1xuICAgICAgVVtfaTRdW2pdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRvdGFsICs9IFVbX2k0XVtqXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgb3B0cy5rOyBfaisrKSB7XG4gICAgICBVW19pNF1bX2pdID0gVVtfaTRdW19qXSAvIHRvdGFsO1xuICAgIH1cbiAgfVxuXG4gIGNlbnRyb2lkcyA9IG5ldyBBcnJheShvcHRzLmspO1xuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG9wdHMuazsgX2k1KyspIHtcbiAgICBjZW50cm9pZHNbX2k1XSA9IG5ldyBBcnJheShvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHdlaWdodCA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICB3ZWlnaHRbX2k2XSA9IG5ldyBBcnJheShvcHRzLmspO1xuICB9IC8vIGVuZCBpbml0IEZDTVxuXG5cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAyOiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkcyBmb3IgZWFjaCBzdGVwLlxuXG4gICAgdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cyk7IC8vIFN0ZXAgMzogVXBkYXRlIHRoZSBwYXJ0aXRpb24gbWF0cml4IFUuXG5cbiAgICB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKTsgLy8gU3RlcCA0OiBDaGVjayBmb3IgY29udmVyZ2VuY2UuXG5cbiAgICBpZiAoIWhhdmVNYXRyaWNlc0NvbnZlcmdlZChVLCBfVSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfSAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnMgd2l0aCBoaWdoZXN0IHByb2JhYmlsaXR5LlxuXG5cbiAgY2x1c3RlcnMgPSBhc3NpZ24kMShub2RlcywgVSwgb3B0cywgY3kpO1xuICByZXR1cm4ge1xuICAgIGNsdXN0ZXJzOiBjbHVzdGVycyxcbiAgICBkZWdyZWVPZk1lbWJlcnNoaXA6IFVcbiAgfTtcbn07XG5cbnZhciBrQ2x1c3RlcmluZyA9IHtcbiAga01lYW5zOiBrTWVhbnMsXG4gIGtNZWRvaWRzOiBrTWVkb2lkcyxcbiAgZnV6enlDTWVhbnM6IGZ1enp5Q01lYW5zLFxuICBmY206IGZ1enp5Q01lYW5zXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbnZhciBkZWZhdWx0cyQ2ID0gZGVmYXVsdHMoe1xuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIG5vZGVzXG4gIGxpbmthZ2U6ICdtaW4nLFxuICAvLyBsaW5rYWdlIGNyaXRlcmlvbiA6IGhvdyB0byBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gY2x1c3RlcnMgb2Ygbm9kZXNcbiAgbW9kZTogJ3RocmVzaG9sZCcsXG4gIC8vIG1vZGU6J3RocmVzaG9sZCcgPT4gY2x1c3RlcnMgbXVzdCBiZSB0aHJlc2hvbGQgZGlzdGFuY2UgYXBhcnRcbiAgdGhyZXNob2xkOiBJbmZpbml0eSxcbiAgLy8gdGhlIGRpc3RhbmNlIHRocmVzaG9sZFxuICAvLyBtb2RlOidkZW5kcm9ncmFtJyA9PiB0aGUgbm9kZXMgYXJlIG9yZ2FuaXNlZCBhcyBsZWF2ZXMgaW4gYSB0cmVlIChzaWJsaW5ncyBhcmUgY2xvc2UpLCBtZXJnaW5nIG1ha2VzIGNsdXN0ZXJzXG4gIGFkZERlbmRyb2dyYW06IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGFkZCB0aGUgZGVuZHJvZ3JhbSB0byB0aGUgZ3JhcGggZm9yIHZpelxuICBkZW5kcm9ncmFtRGVwdGg6IDAsXG4gIC8vIGRlcHRoIGF0IHdoaWNoIGRlbmRyb2dyYW0gYnJhbmNoZXMgYXJlIG1lcmdlZCBpbnRvIHRoZSByZXR1cm5lZCBjbHVzdGVyc1xuICBhdHRyaWJ1dGVzOiBbXSAvLyBhcnJheSBvZiBhdHRyIGZ1bmN0aW9uc1xuXG59KTtcbnZhciBsaW5rYWdlQWxpYXNlcyA9IHtcbiAgJ3NpbmdsZSc6ICdtaW4nLFxuICAnY29tcGxldGUnOiAnbWF4J1xufTtcblxudmFyIHNldE9wdGlvbnMkMiA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IGRlZmF1bHRzJDYob3B0aW9ucyk7XG4gIHZhciBwcmVmZXJyZWRBbGlhcyA9IGxpbmthZ2VBbGlhc2VzW29wdHMubGlua2FnZV07XG5cbiAgaWYgKHByZWZlcnJlZEFsaWFzICE9IG51bGwpIHtcbiAgICBvcHRzLmxpbmthZ2UgPSBwcmVmZXJyZWRBbGlhcztcbiAgfVxuXG4gIHJldHVybiBvcHRzO1xufTtcblxudmFyIG1lcmdlQ2xvc2VzdCA9IGZ1bmN0aW9uIG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKSB7XG4gIC8vIEZpbmQgdHdvIGNsb3Nlc3QgY2x1c3RlcnMgZnJvbSBjYWNoZWQgbWluc1xuICB2YXIgbWluS2V5ID0gMDtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgZGlzdDtcbiAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuXG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGNsdXN0ZXJzW2ldLmtleTtcbiAgICB2YXIgX2Rpc3QgPSBkaXN0c1trZXldW21pbnNba2V5XV07XG5cbiAgICBpZiAoX2Rpc3QgPCBtaW4pIHtcbiAgICAgIG1pbktleSA9IGtleTtcbiAgICAgIG1pbiA9IF9kaXN0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLm1vZGUgPT09ICd0aHJlc2hvbGQnICYmIG1pbiA+PSBvcHRzLnRocmVzaG9sZCB8fCBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyAmJiBjbHVzdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYzEgPSBpbmRleFttaW5LZXldO1xuICB2YXIgYzIgPSBpbmRleFttaW5zW21pbktleV1dO1xuICB2YXIgbWVyZ2VkOyAvLyBNZXJnZSB0d28gY2xvc2VzdCBjbHVzdGVyc1xuXG4gIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgIG1lcmdlZCA9IHtcbiAgICAgIGxlZnQ6IGMxLFxuICAgICAgcmlnaHQ6IGMyLFxuICAgICAga2V5OiBjMS5rZXlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1lcmdlZCA9IHtcbiAgICAgIHZhbHVlOiBjMS52YWx1ZS5jb25jYXQoYzIudmFsdWUpLFxuICAgICAga2V5OiBjMS5rZXlcbiAgICB9O1xuICB9XG5cbiAgY2x1c3RlcnNbYzEuaW5kZXhdID0gbWVyZ2VkO1xuICBjbHVzdGVycy5zcGxpY2UoYzIuaW5kZXgsIDEpO1xuICBpbmRleFtjMS5rZXldID0gbWVyZ2VkOyAvLyBVcGRhdGUgZGlzdGFuY2VzIHdpdGggbmV3IG1lcmdlZCBjbHVzdGVyXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNsdXN0ZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBjdXIgPSBjbHVzdGVyc1tfaV07XG5cbiAgICBpZiAoYzEua2V5ID09PSBjdXIua2V5KSB7XG4gICAgICBkaXN0ID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtaW4nKSB7XG4gICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcblxuICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPiBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWF4Jykge1xuICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG5cbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldIDwgZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21lYW4nKSB7XG4gICAgICBkaXN0ID0gKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gKiBjMS5zaXplICsgZGlzdHNbYzIua2V5XVtjdXIua2V5XSAqIGMyLnNpemUpIC8gKGMxLnNpemUgKyBjMi5zaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWUsIGMxLnZhbHVlKTtlbHNlIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZVswXSwgYzEudmFsdWVbMF0pO1xuICAgIH1cblxuICAgIGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPSBkaXN0c1tjdXIua2V5XVtjMS5rZXldID0gZGlzdDsgLy8gZGlzdGFuY2UgbWF0cml4IGlzIHN5bW1ldHJpY1xuICB9IC8vIFVwZGF0ZSBjYWNoZWQgbWluc1xuXG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBrZXkxID0gY2x1c3RlcnNbX2kyXS5rZXk7XG5cbiAgICBpZiAobWluc1trZXkxXSA9PT0gYzEua2V5IHx8IG1pbnNba2V5MV0gPT09IGMyLmtleSkge1xuICAgICAgdmFyIF9taW4gPSBrZXkxO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBrZXkyID0gY2x1c3RlcnNbal0ua2V5O1xuXG4gICAgICAgIGlmIChkaXN0c1trZXkxXVtrZXkyXSA8IGRpc3RzW2tleTFdW19taW5dKSB7XG4gICAgICAgICAgX21pbiA9IGtleTI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWluc1trZXkxXSA9IF9taW47XG4gICAgfVxuXG4gICAgY2x1c3RlcnNbX2kyXS5pbmRleCA9IF9pMjtcbiAgfSAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuXG5cbiAgYzEua2V5ID0gYzIua2V5ID0gYzEuaW5kZXggPSBjMi5pbmRleCA9IG51bGw7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGdldEFsbENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4ocm9vdCwgYXJyLCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybjtcblxuICBpZiAocm9vdC52YWx1ZSkge1xuICAgIGFyci5wdXNoKHJvb3QudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgYXJyKTtcbiAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgYXJyKTtcbiAgfVxufTtcblxudmFyIGJ1aWxkRGVuZHJvZ3JhbSA9IGZ1bmN0aW9uIGJ1aWxkRGVuZHJvZ3JhbShyb290LCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybiAnJztcblxuICBpZiAocm9vdC5sZWZ0ICYmIHJvb3QucmlnaHQpIHtcbiAgICB2YXIgbGVmdFN0ciA9IGJ1aWxkRGVuZHJvZ3JhbShyb290LmxlZnQsIGN5KTtcbiAgICB2YXIgcmlnaHRTdHIgPSBidWlsZERlbmRyb2dyYW0ocm9vdC5yaWdodCwgY3kpO1xuICAgIHZhciBub2RlID0gY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnbm9kZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBpZDogbGVmdFN0ciArICcsJyArIHJpZ2h0U3RyXG4gICAgICB9XG4gICAgfSk7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IGxlZnRTdHIsXG4gICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IHJpZ2h0U3RyLFxuICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlLmlkKCk7XG4gIH0gZWxzZSBpZiAocm9vdC52YWx1ZSkge1xuICAgIHJldHVybiByb290LnZhbHVlLmlkKCk7XG4gIH1cbn07XG5cbnZhciBidWlsZENsdXN0ZXJzRnJvbVRyZWUgPSBmdW5jdGlvbiBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdCwgaywgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gW107XG4gIHZhciBsZWZ0ID0gW10sXG4gICAgICByaWdodCA9IFtdLFxuICAgICAgbGVhdmVzID0gW107XG5cbiAgaWYgKGsgPT09IDApIHtcbiAgICAvLyBkb24ndCBjdXQgdHJlZSwgc2ltcGx5IHJldHVybiBhbGwgbm9kZXMgYXMgMSBzaW5nbGUgY2x1c3RlclxuICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICBsZWF2ZXMgPSBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlYXZlcyldO1xuICB9IGVsc2UgaWYgKGsgPT09IDEpIHtcbiAgICAvLyBjdXQgYXQgcm9vdFxuICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAvLyBsZWFmIG5vZGVcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlZnQpLCBjeS5jb2xsZWN0aW9uKHJpZ2h0KV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBsZWZ0ID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QubGVmdCwgayAtIDEsIGN5KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSByaWdodCA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LnJpZ2h0LCBrIC0gMSwgY3kpO1xuICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICB9XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcgPSBmdW5jdGlvbiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogbGlua2FnZSB0eXBlLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cblxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTtcbiAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuXG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTsgLy8gQmVnaW4gaGllcmFyY2hpY2FsIGFsZ29yaXRobVxuXG5cbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIHZhciBkaXN0cyA9IFtdOyAvLyBkaXN0YW5jZXMgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcblxuICB2YXIgbWlucyA9IFtdOyAvLyBjbG9zZXN0IGNsdXN0ZXIgZm9yIGVhY2ggY2x1c3RlclxuXG4gIHZhciBpbmRleCA9IFtdOyAvLyBoYXNoIG9mIGFsbCBjbHVzdGVycyBieSBrZXlcbiAgLy8gSW4gYWdnbG9tZXJhdGl2ZSAoYm90dG9tLXVwKSBjbHVzdGVyaW5nLCBlYWNoIG5vZGUgc3RhcnRzIGFzIGl0cyBvd24gY2x1c3RlclxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgY2x1c3RlciA9IHtcbiAgICAgIHZhbHVlOiBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyA/IG5vZGVzW25dIDogW25vZGVzW25dXSxcbiAgICAgIGtleTogbixcbiAgICAgIGluZGV4OiBuXG4gICAgfTtcbiAgICBjbHVzdGVyc1tuXSA9IGNsdXN0ZXI7XG4gICAgaW5kZXhbbl0gPSBjbHVzdGVyO1xuICAgIGRpc3RzW25dID0gW107XG4gICAgbWluc1tuXSA9IDA7XG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgdmFyIGRpc3QgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgICAvLyBtb2RlcyBzdG9yZSBjbHVzdGVyIHZhbHVlcyBkaWZmZXJlbnRseVxuICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZSwgY2x1c3RlcnNbal0udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWVbMF0sIGNsdXN0ZXJzW2pdLnZhbHVlWzBdKTtcbiAgICAgIH1cblxuICAgICAgZGlzdHNbaV1bal0gPSBkaXN0O1xuICAgICAgZGlzdHNbal1baV0gPSBkaXN0O1xuXG4gICAgICBpZiAoZGlzdCA8IGRpc3RzW2ldW21pbnNbaV1dKSB7XG4gICAgICAgIG1pbnNbaV0gPSBqOyAvLyBDYWNoZSBtaW5zOiBjbG9zZXN0IGNsdXN0ZXIgdG8gY2x1c3RlciBpIGlzIGNsdXN0ZXIgalxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBGaW5kIHRoZSBjbG9zZXN0IHBhaXIgb2YgY2x1c3RlcnMgYW5kIG1lcmdlIHRoZW0gaW50byBhIHNpbmdsZSBjbHVzdGVyLlxuICAvLyBVcGRhdGUgZGlzdGFuY2VzIGJldHdlZW4gbmV3IGNsdXN0ZXIgYW5kIGVhY2ggb2YgdGhlIG9sZCBjbHVzdGVycywgYW5kIGxvb3AgdW50aWwgdGhyZXNob2xkIHJlYWNoZWQuXG5cblxuICB2YXIgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuXG4gIHdoaWxlIChtZXJnZWQpIHtcbiAgICBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG4gIH1cblxuICB2YXIgcmV0Q2x1c3RlcnM7IC8vIERlbmRyb2dyYW0gbW9kZSBidWlsZHMgdGhlIGhpZXJhcmNoeSBhbmQgYWRkcyBpbnRlcm1lZGlhcnkgbm9kZXMgKyBlZGdlc1xuICAvLyBpbiBhZGRpdGlvbiB0byByZXR1cm5pbmcgdGhlIGNsdXN0ZXJzLlxuXG4gIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgIHJldENsdXN0ZXJzID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKGNsdXN0ZXJzWzBdLCBvcHRzLmRlbmRyb2dyYW1EZXB0aCwgY3kpO1xuICAgIGlmIChvcHRzLmFkZERlbmRyb2dyYW0pIGJ1aWxkRGVuZHJvZ3JhbShjbHVzdGVyc1swXSwgY3kpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlZ3VsYXIgbW9kZSBzaW1wbHkgcmV0dXJucyB0aGUgY2x1c3RlcnNcbiAgICByZXRDbHVzdGVycyA9IG5ldyBBcnJheShjbHVzdGVycy5sZW5ndGgpO1xuICAgIGNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGNsdXN0ZXIsIGkpIHtcbiAgICAgIC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gICAgICBjbHVzdGVyLmtleSA9IGNsdXN0ZXIuaW5kZXggPSBudWxsO1xuICAgICAgcmV0Q2x1c3RlcnNbaV0gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIudmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldENsdXN0ZXJzO1xufTtcblxudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSA9IHtcbiAgaGllcmFyY2hpY2FsQ2x1c3RlcmluZzogaGllcmFyY2hpY2FsQ2x1c3RlcmluZyxcbiAgaGNhOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbnZhciBkZWZhdWx0cyQ3ID0gZGVmYXVsdHMoe1xuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIGF0dHJpYnV0ZXMgYmV0d2VlbiB0d28gbm9kZXNcbiAgcHJlZmVyZW5jZTogJ21lZGlhbicsXG4gIC8vIHN1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuICBkYW1waW5nOiAwLjgsXG4gIC8vIGRhbXBpbmcgZmFjdG9yIGJldHdlZW4gWzAuNSwgMSlcbiAgbWF4SXRlcmF0aW9uczogMTAwMCxcbiAgLy8gbWF4IG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1blxuICBtaW5JdGVyYXRpb25zOiAxMDAsXG4gIC8vIG1pbiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW4gaW4gb3JkZXIgZm9yIGNsdXN0ZXJpbmcgdG8gc3RvcFxuICBhdHRyaWJ1dGVzOiBbLy8gZnVuY3Rpb25zIHRvIHF1YW50aWZ5IHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gYW55IHR3byBwb2ludHNcbiAgICAvLyBlLmcuIG5vZGUgPT4gbm9kZS5kYXRhKCd3ZWlnaHQnKVxuICBdXG59KTtcblxudmFyIHNldE9wdGlvbnMkMyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgZG1wID0gb3B0aW9ucy5kYW1waW5nO1xuICB2YXIgcHJlZiA9IG9wdGlvbnMucHJlZmVyZW5jZTtcblxuICBpZiAoISgwLjUgPD0gZG1wICYmIGRtcCA8IDEpKSB7XG4gICAgZXJyb3IoXCJEYW1waW5nIG11c3QgcmFuZ2Ugb24gWzAuNSwgMSkuICBHb3Q6IFwiLmNvbmNhdChkbXApKTtcbiAgfVxuXG4gIHZhciB2YWxpZFByZWZzID0gWydtZWRpYW4nLCAnbWVhbicsICdtaW4nLCAnbWF4J107XG5cbiAgaWYgKCEodmFsaWRQcmVmcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHByZWY7XG4gIH0pIHx8IG51bWJlcihwcmVmKSkpIHtcbiAgICBlcnJvcihcIlByZWZlcmVuY2UgbXVzdCBiZSBvbmUgb2YgW1wiLmNvbmNhdCh2YWxpZFByZWZzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIFwiJ1wiLmNvbmNhdChwLCBcIidcIik7XG4gICAgfSkuam9pbignLCAnKSwgXCJdIG9yIGEgbnVtYmVyLiAgR290OiBcIikuY29uY2F0KHByZWYpKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0cyQ3KG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG52YXIgZ2V0U2ltaWxhcml0eSQxID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eSh0eXBlLCBuMSwgbjIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG4sIGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShuKTtcbiAgfTsgLy8gbmIgbmVnYXRpdmUgYmVjYXVzZSBzaW1pbGFyaXR5IHNob3VsZCBoYXZlIGFuIGludmVyc2UgcmVsYXRpb25zaGlwIHRvIGRpc3RhbmNlXG5cblxuICByZXR1cm4gLWNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cihuMSwgaSk7XG4gIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjIsIGkpO1xuICB9LCBuMSwgbjIpO1xufTtcblxudmFyIGdldFByZWZlcmVuY2UgPSBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlKFMsIHByZWZlcmVuY2UpIHtcbiAgLy8gbGFyZ2VyIHByZWZlcmVuY2UgPSBncmVhdGVyICMgb2YgY2x1c3RlcnNcbiAgdmFyIHAgPSBudWxsO1xuXG4gIGlmIChwcmVmZXJlbmNlID09PSAnbWVkaWFuJykge1xuICAgIHAgPSBtZWRpYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21lYW4nKSB7XG4gICAgcCA9IG1lYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21pbicpIHtcbiAgICBwID0gbWluKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtYXgnKSB7XG4gICAgcCA9IG1heChTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDdXN0b20gcHJlZmVyZW5jZSBudW1iZXIsIGFzIHNldCBieSB1c2VyXG4gICAgcCA9IHByZWZlcmVuY2U7XG4gIH1cblxuICByZXR1cm4gcDtcbn07XG5cbnZhciBmaW5kRXhlbXBsYXJzID0gZnVuY3Rpb24gZmluZEV4ZW1wbGFycyhuLCBSLCBBKSB7XG4gIHZhciBpbmRpY2VzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoUltpICogbiArIGldICsgQVtpICogbiArIGldID4gMCkge1xuICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzO1xufTtcblxudmFyIGFzc2lnbkNsdXN0ZXJzID0gZnVuY3Rpb24gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgICB2YXIgZSA9IGV4ZW1wbGFyc1tlaV07XG5cbiAgICAgIGlmIChTW2kgKiBuICsgZV0gPiBtYXgpIHtcbiAgICAgICAgaW5kZXggPSBlO1xuICAgICAgICBtYXggPSBTW2kgKiBuICsgZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgY2x1c3RlcnMucHVzaChpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2VpID0gMDsgX2VpIDwgZXhlbXBsYXJzLmxlbmd0aDsgX2VpKyspIHtcbiAgICBjbHVzdGVyc1tleGVtcGxhcnNbX2VpXV0gPSBleGVtcGxhcnNbX2VpXTtcbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBhc3NpZ24kMiA9IGZ1bmN0aW9uIGFzc2lnbihuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcblxuICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgIHZhciBpaSA9IFtdO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgaWYgKGNsdXN0ZXJzW2NdID09PSBleGVtcGxhcnNbZWldKSB7XG4gICAgICAgIGlpLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heEkgPSAtMTtcbiAgICB2YXIgbWF4U3VtID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaWkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IFNbaWlbal0gKiBuICsgaWlbaV1dO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3VtID4gbWF4U3VtKSB7XG4gICAgICAgIG1heEkgPSBpO1xuICAgICAgICBtYXhTdW0gPSBzdW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhlbXBsYXJzW2VpXSA9IGlpW21heEldO1xuICB9XG5cbiAgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIGFmZmluaXR5UHJvcGFnYXRpb24ob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDMob3B0aW9ucyk7IC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcblxuICB2YXIgaWQycG9zaXRpb24gPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICB9IC8vIEJlZ2luIGFmZmluaXR5IHByb3BhZ2F0aW9uIGFsZ29yaXRobVxuXG5cbiAgdmFyIG47IC8vIG51bWJlciBvZiBkYXRhIHBvaW50c1xuXG4gIHZhciBuMjsgLy8gc2l6ZSBvZiBtYXRyaWNlc1xuXG4gIHZhciBTOyAvLyBzaW1pbGFyaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgdmFyIHA7IC8vIHByZWZlcmVuY2Uvc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG5cbiAgdmFyIFI7IC8vIHJlc3BvbnNpYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgdmFyIEE7IC8vIGF2YWlsYWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIG4gPSBub2Rlcy5sZW5ndGg7XG4gIG4yID0gbiAqIG47IC8vIEluaXRpYWxpemUgYW5kIGJ1aWxkIFMgc2ltaWxhcml0eSBtYXRyaXhcblxuICBTID0gbmV3IEFycmF5KG4yKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICBTW19pXSA9IC1JbmZpbml0eTsgLy8gZm9yIGNhc2VzIHdoZXJlIHR3byBkYXRhIHBvaW50cyBzaG91bGRuJ3QgYmUgbGlua2VkIHRvZ2V0aGVyXG4gIH1cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuOyBfaTIrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoX2kyICE9PSBqKSB7XG4gICAgICAgIFNbX2kyICogbiArIGpdID0gZ2V0U2ltaWxhcml0eSQxKG9wdHMuZGlzdGFuY2UsIG5vZGVzW19pMl0sIG5vZGVzW2pdLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQbGFjZSBwcmVmZXJlbmNlcyBvbiB0aGUgZGlhZ29uYWwgb2YgU1xuXG5cbiAgcCA9IGdldFByZWZlcmVuY2UoUywgb3B0cy5wcmVmZXJlbmNlKTtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuOyBfaTMrKykge1xuICAgIFNbX2kzICogbiArIF9pM10gPSBwO1xuICB9IC8vIEluaXRpYWxpemUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcblxuXG4gIFIgPSBuZXcgQXJyYXkobjIpO1xuXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG4yOyBfaTQrKykge1xuICAgIFJbX2k0XSA9IDAuMDtcbiAgfSAvLyBJbml0aWFsaXplIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuXG5cbiAgQSA9IG5ldyBBcnJheShuMik7XG5cbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbjI7IF9pNSsrKSB7XG4gICAgQVtfaTVdID0gMC4wO1xuICB9XG5cbiAgdmFyIG9sZCA9IG5ldyBBcnJheShuKTtcbiAgdmFyIFJwID0gbmV3IEFycmF5KG4pO1xuICB2YXIgc2UgPSBuZXcgQXJyYXkobik7XG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbjsgX2k2KyspIHtcbiAgICBvbGRbX2k2XSA9IDAuMDtcbiAgICBScFtfaTZdID0gMC4wO1xuICAgIHNlW19pNl0gPSAwO1xuICB9XG5cbiAgdmFyIGUgPSBuZXcgQXJyYXkobiAqIG9wdHMubWluSXRlcmF0aW9ucyk7XG5cbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgZVtfaTddID0gMDtcbiAgfVxuXG4gIHZhciBpdGVyO1xuXG4gIGZvciAoaXRlciA9IDA7IGl0ZXIgPCBvcHRzLm1heEl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgIC8vIG1haW4gYWxnb3JpdGhtaWMgbG9vcFxuICAgIC8vIFVwZGF0ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG47IF9pOCsrKSB7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgIG1heDIgPSAtSW5maW5pdHksXG4gICAgICAgICAgbWF4SSA9IC0xLFxuICAgICAgICAgIEFTID0gMC4wO1xuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBvbGRbX2pdID0gUltfaTggKiBuICsgX2pdO1xuICAgICAgICBBUyA9IEFbX2k4ICogbiArIF9qXSArIFNbX2k4ICogbiArIF9qXTtcblxuICAgICAgICBpZiAoQVMgPj0gbWF4KSB7XG4gICAgICAgICAgbWF4MiA9IG1heDtcbiAgICAgICAgICBtYXggPSBBUztcbiAgICAgICAgICBtYXhJID0gX2o7XG4gICAgICAgIH0gZWxzZSBpZiAoQVMgPiBtYXgyKSB7XG4gICAgICAgICAgbWF4MiA9IEFTO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG47IF9qMisrKSB7XG4gICAgICAgIFJbX2k4ICogbiArIF9qMl0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgX2oyXSAtIG1heCkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2oyXTtcbiAgICAgIH1cblxuICAgICAgUltfaTggKiBuICsgbWF4SV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgbWF4SV0gLSBtYXgyKSArIG9wdHMuZGFtcGluZyAqIG9sZFttYXhJXTtcbiAgICB9IC8vIFVwZGF0ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcblxuXG4gICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbjsgX2k5KyspIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBuOyBfajMrKykge1xuICAgICAgICBvbGRbX2ozXSA9IEFbX2ozICogbiArIF9pOV07XG4gICAgICAgIFJwW19qM10gPSBNYXRoLm1heCgwLCBSW19qMyAqIG4gKyBfaTldKTtcbiAgICAgICAgc3VtICs9IFJwW19qM107XG4gICAgICB9XG5cbiAgICAgIHN1bSAtPSBScFtfaTldO1xuICAgICAgUnBbX2k5XSA9IFJbX2k5ICogbiArIF9pOV07XG4gICAgICBzdW0gKz0gUnBbX2k5XTtcblxuICAgICAgZm9yICh2YXIgX2o0ID0gMDsgX2o0IDwgbjsgX2o0KyspIHtcbiAgICAgICAgQVtfajQgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIE1hdGgubWluKDAsIHN1bSAtIFJwW19qNF0pICsgb3B0cy5kYW1waW5nICogb2xkW19qNF07XG4gICAgICB9XG5cbiAgICAgIEFbX2k5ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoc3VtIC0gUnBbX2k5XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2k5XTtcbiAgICB9IC8vIENoZWNrIGZvciBjb252ZXJnZW5jZVxuXG5cbiAgICB2YXIgSyA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG47IF9pMTArKykge1xuICAgICAgdmFyIEUgPSBBW19pMTAgKiBuICsgX2kxMF0gKyBSW19pMTAgKiBuICsgX2kxMF0gPiAwID8gMSA6IDA7XG4gICAgICBlW2l0ZXIgJSBvcHRzLm1pbkl0ZXJhdGlvbnMgKiBuICsgX2kxMF0gPSBFO1xuICAgICAgSyArPSBFO1xuICAgIH1cblxuICAgIGlmIChLID4gMCAmJiAoaXRlciA+PSBvcHRzLm1pbkl0ZXJhdGlvbnMgLSAxIHx8IGl0ZXIgPT0gb3B0cy5tYXhJdGVyYXRpb25zIC0gMSkpIHtcbiAgICAgIHZhciBfc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBuOyBfaTExKyspIHtcbiAgICAgICAgc2VbX2kxMV0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IG9wdHMubWluSXRlcmF0aW9uczsgX2o1KyspIHtcbiAgICAgICAgICBzZVtfaTExXSArPSBlW19qNSAqIG4gKyBfaTExXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZVtfaTExXSA9PT0gMCB8fCBzZVtfaTExXSA9PT0gb3B0cy5taW5JdGVyYXRpb25zKSB7XG4gICAgICAgICAgX3N1bSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfc3VtID09PSBuKSB7XG4gICAgICAgIC8vIHRoZW4gd2UgaGF2ZSBjb252ZXJnZW5jZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSWRlbnRpZnkgZXhlbXBsYXJzIChjbHVzdGVyIGNlbnRlcnMpXG5cblxuICB2YXIgZXhlbXBsYXJzSW5kaWNlcyA9IGZpbmRFeGVtcGxhcnMobiwgUiwgQSk7IC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVyc1xuXG4gIHZhciBjbHVzdGVySW5kaWNlcyA9IGFzc2lnbiQyKG4sIFMsIGV4ZW1wbGFyc0luZGljZXMpO1xuICB2YXIgY2x1c3RlcnMgPSB7fTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBjKyspIHtcbiAgICBjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW2NdXSA9IFtdO1xuICB9XG5cbiAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2Rlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgIHZhciBwb3MgPSBpZDJwb3NpdGlvbltub2Rlc1tfaTEyXS5pZCgpXTtcblxuICAgIHZhciBjbHVzdGVySW5kZXggPSBjbHVzdGVySW5kaWNlc1twb3NdO1xuXG4gICAgaWYgKGNsdXN0ZXJJbmRleCAhPSBudWxsKSB7XG4gICAgICAvLyB0aGUgbm9kZSBtYXkgaGF2ZSBub3QgYmVlbiBhc3NpZ25lZCBhIGNsdXN0ZXIgaWYgbm8gdmFsaWQgYXR0cmlidXRlcyB3ZXJlIHNwZWNpZmllZFxuICAgICAgY2x1c3RlcnNbY2x1c3RlckluZGV4XS5wdXNoKG5vZGVzW19pMTJdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgX2MrKykge1xuICAgIHJldENsdXN0ZXJzW19jXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tfY11dKTtcbiAgfVxuXG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG5cbnZhciBhZmZpbml0eVByb3BhZ2F0aW9uJDEgPSB7XG4gIGFmZmluaXR5UHJvcGFnYXRpb246IGFmZmluaXR5UHJvcGFnYXRpb24sXG4gIGFwOiBhZmZpbml0eVByb3BhZ2F0aW9uXG59O1xuXG52YXIgaGllcmhvbHplckRlZmF1bHRzID0gZGVmYXVsdHMoe1xuICByb290OiB1bmRlZmluZWQsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGIgPSB7XG4gIGhpZXJob2x6ZXI6IGZ1bmN0aW9uIGhpZXJob2x6ZXIob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMV1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9oaWVyaG9semVyRGVmYXVsdHMgPSBoaWVyaG9semVyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgIHJvb3QgPSBfaGllcmhvbHplckRlZmF1bHRzLnJvb3QsXG4gICAgICAgIGRpcmVjdGVkID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgZGZsYWcgPSBmYWxzZTtcbiAgICB2YXIgb2RkSW47XG4gICAgdmFyIG9kZE91dDtcbiAgICB2YXIgc3RhcnRWZXJ0ZXg7XG4gICAgaWYgKHJvb3QpIHN0YXJ0VmVydGV4ID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0uaWQoKSA6IHJvb3RbMF0uaWQoKTtcbiAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICB2YXIgZWRnZXMgPSB7fTtcblxuICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHZhciBpbmQgPSBlbGUuaW5kZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgdmFyIG91dGQgPSBlbGUub3V0ZGVncmVlKHRydWUpO1xuICAgICAgICAgIHZhciBkMSA9IGluZCAtIG91dGQ7XG4gICAgICAgICAgdmFyIGQyID0gb3V0ZCAtIGluZDtcblxuICAgICAgICAgIGlmIChkMSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkSW4pIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZEluID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA9PSAxKSB7XG4gICAgICAgICAgICBpZiAob2RkT3V0KSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRPdXQgPSBpZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGQyID4gMSB8fCBkMSA+IDEpIHtcbiAgICAgICAgICAgIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUub3V0Z29lcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0VkZ2UoKSkgbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbdW5kZWZpbmVkLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgdmFyIGQgPSBlbGUuZGVncmVlKHRydWUpO1xuXG4gICAgICAgICAgaWYgKGQgJSAyKSB7XG4gICAgICAgICAgICBpZiAoIW9kZEluKSBvZGRJbiA9IGlkO2Vsc2UgaWYgKCFvZGRPdXQpIG9kZE91dCA9IGlkO2Vsc2UgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IFtlbGUuc291cmNlKCkuaWQoKSwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgdHJhaWw6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKGRmbGFnKSByZXR1cm4gcmVzdWx0O2Vsc2UgaWYgKG9kZE91dCAmJiBvZGRJbikge1xuICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4ICYmIG9kZEluICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN0YXJ0VmVydGV4KSBzdGFydFZlcnRleCA9IGVsZXNbMF0uaWQoKTtcbiAgICB9XG5cbiAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIHdhbGsodikge1xuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdjtcbiAgICAgIHZhciBzdWJ0b3VyID0gW3ZdO1xuICAgICAgdmFyIGFkaiwgYWRqVGFpbCwgYWRqSGVhZDtcblxuICAgICAgd2hpbGUgKG5vZGVzW2N1cnJlbnROb2RlXS5sZW5ndGgpIHtcbiAgICAgICAgYWRqID0gbm9kZXNbY3VycmVudE5vZGVdLnNoaWZ0KCk7XG4gICAgICAgIGFkalRhaWwgPSBlZGdlc1thZGpdWzBdO1xuICAgICAgICBhZGpIZWFkID0gZWRnZXNbYWRqXVsxXTtcblxuICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gYWRqSGVhZCkge1xuICAgICAgICAgIG5vZGVzW2FkakhlYWRdID0gbm9kZXNbYWRqSGVhZF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpIZWFkO1xuICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RlZCAmJiBjdXJyZW50Tm9kZSAhPSBhZGpUYWlsKSB7XG4gICAgICAgICAgbm9kZXNbYWRqVGFpbF0gPSBub2Rlc1thZGpUYWlsXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkalRhaWw7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoYWRqKTtcbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGN1cnJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YnRvdXI7XG4gICAgfTtcblxuICAgIHZhciB0cmFpbCA9IFtdO1xuICAgIHZhciBzdWJ0b3VyID0gW107XG4gICAgc3VidG91ciA9IHdhbGsoc3RhcnRWZXJ0ZXgpO1xuXG4gICAgd2hpbGUgKHN1YnRvdXIubGVuZ3RoICE9IDEpIHtcbiAgICAgIGlmIChub2Rlc1tzdWJ0b3VyWzBdXS5sZW5ndGggPT0gMCkge1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnRvdXIgPSB3YWxrKHN1YnRvdXIuc2hpZnQoKSkuY29uY2F0KHN1YnRvdXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTsgLy8gZmluYWwgbm9kZVxuXG4gICAgZm9yICh2YXIgZCBpbiBub2Rlcykge1xuICAgICAgaWYgKG5vZGVzW2RdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5mb3VuZCA9IHRydWU7XG4gICAgcmVzdWx0LnRyYWlsID0gdGhpcy5zcGF3bih0cmFpbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGVsZXNmbiRjID0ge307XG5bZWxlc2ZuLCBlbGVzZm4kMSwgZWxlc2ZuJDIsIGVsZXNmbiQzLCBlbGVzZm4kNCwgZWxlc2ZuJDUsIGVsZXNmbiQ2LCBlbGVzZm4kNywgZWxlc2ZuJDgsIGVsZXNmbiQ5LCBlbGVzZm4kYSwgbWFya292Q2x1c3RlcmluZyQxLCBrQ2x1c3RlcmluZywgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyQxLCBhZmZpbml0eVByb3BhZ2F0aW9uJDEsIGVsZXNmbiRiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoZWxlc2ZuJGMsIHByb3BzKTtcbn0pO1xuXG4vKiFcbkVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG5MaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qL1xuXG4vKiAgcHJvbWlzZSBzdGF0ZXMgW1Byb21pc2VzL0ErIDIuMV0gICovXG52YXIgU1RBVEVfUEVORElORyA9IDA7XG4vKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cblxudmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7XG4vKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cblxudmFyIFNUQVRFX1JFSkVDVEVEID0gMjtcbi8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG4vKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG5cbnZhciBhcGkgPSBmdW5jdGlvbiBhcGkoZXhlY3V0b3IpIHtcbiAgLyogIG9wdGlvbmFsbHkgc3VwcG9ydCBub24tY29uc3RydWN0b3IvcGxhaW4tZnVuY3Rpb24gY2FsbCAgKi9cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGFwaSkpIHJldHVybiBuZXcgYXBpKGV4ZWN1dG9yKTtcbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuXG4gIHRoaXMuaWQgPSAnVGhlbmFibGUvMS4wLjcnO1xuICB0aGlzLnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgLyogIGluaXRpYWwgc3RhdGUgICovXG5cbiAgdGhpcy5mdWxmaWxsVmFsdWUgPSB1bmRlZmluZWQ7XG4gIC8qICBpbml0aWFsIHZhbHVlICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cblxuICB0aGlzLnJlamVjdFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgLyogIGluaXRpYWwgcmVhc29uICovXG5cbiAgLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuXG4gIHRoaXMub25GdWxmaWxsZWQgPSBbXTtcbiAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgdGhpcy5vblJlamVjdGVkID0gW107XG4gIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gIC8qICBwcm92aWRlIG9wdGlvbmFsIGluZm9ybWF0aW9uLWhpZGluZyBwcm94eSAgKi9cblxuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gIH07XG4gIC8qICBzdXBwb3J0IG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uICAqL1xuXG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09ICdmdW5jdGlvbicpIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xufTtcbi8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuXG5cbmFwaS5wcm90b3R5cGUgPSB7XG4gIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICBmdWxmaWxsOiBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfRlVMRklMTEVELCAnZnVsZmlsbFZhbHVlJywgdmFsdWUpO1xuICB9LFxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX1JFSkVDVEVELCAncmVqZWN0UmVhc29uJywgdmFsdWUpO1xuICB9LFxuXG4gIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBjdXJyID0gdGhpcztcbiAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cblxuICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChyZXNvbHZlcihvbkZ1bGZpbGxlZCwgbmV4dCwgJ2Z1bGZpbGwnKSk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG5cbiAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChyZXNvbHZlcihvblJlamVjdGVkLCBuZXh0LCAncmVqZWN0JykpO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgICByZXR1cm4gbmV4dC5wcm94eTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICB9XG59O1xuLyogIGRlbGl2ZXIgYW4gYWN0aW9uICAqL1xuXG52YXIgZGVsaXZlciA9IGZ1bmN0aW9uIGRlbGl2ZXIoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgY3Vyci5zdGF0ZSA9IHN0YXRlO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG5cbiAgICBjdXJyW25hbWVdID0gdmFsdWU7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cblxuICAgIGV4ZWN1dGUoY3Vycik7XG4gIH1cblxuICByZXR1cm4gY3Vycjtcbn07XG4vKiAgZXhlY3V0ZSBhbGwgaGFuZGxlcnMgICovXG5cblxudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKGN1cnIpIHtcbiAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25GdWxmaWxsZWQnLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7ZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uUmVqZWN0ZWQnLCBjdXJyLnJlamVjdFJlYXNvbik7XG59O1xuLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG5cblxudmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIG5hbWUsIHZhbHVlKSB7XG4gIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cblxuICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gIC8qICBzaG9ydC1jaXJjdWl0IHByb2Nlc3NpbmcgICovXG4gIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuXG4gIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gIGN1cnJbbmFtZV0gPSBbXTtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cblxuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlcnNbaV0odmFsdWUpO1xuICAgIH1cbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi41XSAgKi9cblxuICB9O1xuICAvKiAgZXhlY3V0ZSBwcm9jZWR1cmUgYXN5bmNocm9ub3VzbHkgICovXG5cbiAgLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cblxuXG4gIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSBzZXRJbW1lZGlhdGUoZnVuYyk7ZWxzZSBzZXRUaW1lb3V0KGZ1bmMsIDApO1xufTtcbi8qICBnZW5lcmF0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uICAqL1xuXG5cbnZhciByZXNvbHZlciA9IGZ1bmN0aW9uIHJlc29sdmVyKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgIG5leHRbbWV0aG9kXS5jYWxsKG5leHQsIHZhbHVlKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBjYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4xLCAyLjIuMy4xLCAyLjIuNSwgMy4yXSAgKi9cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0LnJlamVjdChlKTtcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShuZXh0LCByZXN1bHQpO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgICAgfVxuICB9O1xufTtcbi8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi9cblxuLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xuXG5cbnZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB4KSB7XG4gIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cblxuXG4gIHZhciB0aGVuO1xuXG4gIGlmIChfdHlwZW9mKHgpID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4gPSB4LnRoZW47XG4gICAgfVxuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMSwgMy41XSAgKi9cbiAgICBjYXRjaCAoZSkge1xuICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qICBoYW5kbGUgb3duIFRoZW5hYmxlcyAgICBbUHJvbWlzZXMvQSsgMi4zLjJdXG4gICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuXG5cbiAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovXG5cbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cblxuICAgICAgICBpZiAoeSA9PT0geClcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nKSk7ZWxzZSByZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgfSxcbiAgICAgIC8qICByZWplY3RQcm9taXNlICAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cblxuXG4gIHByb21pc2UuZnVsZmlsbCh4KTtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjMuNCwgMi4zLjMuNF0gICovXG59OyAvLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5cblxuYXBpLmFsbCA9IGZ1bmN0aW9uIChwcykge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZUFsbCwgcmVqZWN0QWxsKSB7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkocHMubGVuZ3RoKTtcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24gZnVsZmlsbChpLCB2YWwpIHtcbiAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICBkb25lQ291bnQrKztcblxuICAgICAgaWYgKGRvbmVDb3VudCA9PT0gcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmVBbGwodmFscyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICB2YXIgaXNQcm9taXNlID0gcCAhPSBudWxsICYmIHAudGhlbiAhPSBudWxsO1xuXG4gICAgICAgIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdEFsbChlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSkoaSk7XG4gICAgfVxuICB9KTtcbn07XG5cbmFwaS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzb2x2ZSh2YWwpO1xuICB9KTtcbn07XG5cbmFwaS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsKTtcbiAgfSk7XG59O1xuXG52YXIgUHJvbWlzZSQxID0gdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IGFwaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gQW5pbWF0aW9uKHRhcmdldCwgb3B0cywgb3B0czIpIHtcbiAgdmFyIGlzQ29yZSA9IGNvcmUodGFyZ2V0KTtcbiAgdmFyIGlzRWxlID0gIWlzQ29yZTtcblxuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gZXh0ZW5kKHtcbiAgICBkdXJhdGlvbjogMTAwMFxuICB9LCBvcHRzLCBvcHRzMik7XG5cbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcblxuICBpZiAoX3AuY29tcGxldGUgJiYgZm4oX3AuY29tcGxldGUpKSB7XG4gICAgX3AuY29tcGxldGVzLnB1c2goX3AuY29tcGxldGUpO1xuICB9XG5cbiAgaWYgKGlzRWxlKSB7XG4gICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICAgIF9wLnN0YXJ0UG9zaXRpb24gPSBfcC5zdGFydFBvc2l0aW9uIHx8IHtcbiAgICAgIHg6IHBvcy54LFxuICAgICAgeTogcG9zLnlcbiAgICB9O1xuICAgIF9wLnN0YXJ0U3R5bGUgPSBfcC5zdGFydFN0eWxlIHx8IHRhcmdldC5jeSgpLnN0eWxlKCkuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSh0YXJnZXQsIF9wLnN0eWxlKTtcbiAgfVxuXG4gIGlmIChpc0NvcmUpIHtcbiAgICB2YXIgcGFuID0gdGFyZ2V0LnBhbigpO1xuICAgIF9wLnN0YXJ0UGFuID0ge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH07XG4gICAgX3Auc3RhcnRab29tID0gdGFyZ2V0Lnpvb20oKTtcbiAgfSAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuXG5cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcbn07XG5cbnZhciBhbmlmbiA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5leHRlbmQoYW5pZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnYW5pbWF0aW9uJztcbiAgfSxcbiAgaG9vazogZnVuY3Rpb24gaG9vaygpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKCFfcC5ob29rZWQpIHtcbiAgICAgIC8vIGFkZCB0byB0YXJnZXQncyBhbmltYXRpb24gcXVldWVcbiAgICAgIHZhciBxO1xuICAgICAgdmFyIHRBbmkgPSBfcC50YXJnZXQuX3ByaXZhdGUuYW5pbWF0aW9uO1xuXG4gICAgICBpZiAoX3AucXVldWUpIHtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuXG4gICAgICBxLnB1c2godGhpcyk7IC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuXG4gICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihfcC50YXJnZXQpKSB7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbChfcC50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBfcC5ob29rZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7IC8vIGF1dG9yZXdpbmRcblxuICAgIGlmIChfcC5wcm9ncmVzcyA9PT0gMSkge1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpOyAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBzdGFydCB0aGUgYW5pbWF0aW9uLi4uXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG5cbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob29rKCk7IC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGFwcGx5IHRoZSBhbmltYXRpb24gYXQgdGhpcyBwcm9ncmVzc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFwcGx5aW5nOiBmdW5jdGlvbiBhcHBseWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hcHBseWluZztcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgX3Auc3RvcHBlZCA9IHRydWU7IC8vIHRvIGJlIHJlbW92ZWQgZnJvbSBhbmltYXRpb24gcXVldWVzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmV3aW5kOiBmdW5jdGlvbiByZXdpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMCk7XG4gIH0sXG4gIGZhc3Rmb3J3YXJkOiBmdW5jdGlvbiBmYXN0Zm9yd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygxKTtcbiAgfSxcbiAgdGltZTogZnVuY3Rpb24gdGltZSh0KSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcyAqIF9wLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcyh0IC8gX3AuZHVyYXRpb24pO1xuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKHApIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb21wbGV0ZWQ6IGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wcm9ncmVzcyA9PT0gMTtcbiAgfSxcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGEsIGIpIHtcbiAgICAgIHZhciBfcGEgPSBfcFthXTtcblxuICAgICAgaWYgKF9wYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3BbYV0gPSBfcFtiXTtcbiAgICAgIF9wW2JdID0gX3BhO1xuICAgIH07XG5cbiAgICBzd2FwKCd6b29tJywgJ3N0YXJ0Wm9vbScpO1xuICAgIHN3YXAoJ3BhbicsICdzdGFydFBhbicpO1xuICAgIHN3YXAoJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nKTsgLy8gc3dhcCBzdHlsZXNcblxuICAgIGlmIChfcC5zdHlsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVtuYW1lXTtcbiAgICAgICAgX3Auc3RhcnRTdHlsZVtuYW1lXSA9IHByb3A7XG4gICAgICAgIF9wLnN0eWxlW2ldID0gc3RhcnRTdHlsZVByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKHR5cGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBhcnI7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgYXJyID0gX3AuZnJhbWVzO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIGFyciA9IF9wLmNvbXBsZXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhcnIucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcbmFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuYW5pZm4ucnVuID0gYW5pZm4ucGxheTtcbmFuaWZuLnJ1bm5pbmcgPSBhbmlmbi5wbGF5aW5nO1xuXG52YXIgZGVmaW5lID0ge1xuICBhbmltYXRlZDogZnVuY3Rpb24gYW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVkSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlZFxuICBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSxcbiAgLy8gY2xlYXJRdWV1ZVxuICBkZWxheTogZnVuY3Rpb24gZGVsYXkoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIC8vIGRlbGF5XG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbih7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuICBhbmltYXRpb246IGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICB2YXIgaXNDb3JlID0gIXNlbGZJc0FycmF5TGlrZTtcbiAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPT09IDA7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLmR1cmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA2MDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlcykge1xuICAgICAgICBwcm9wZXJ0aWVzLnN0eWxlID0gc3R5bGUuZ2V0UHJvcHNMaXN0KHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MpO1xuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWxlcyAmJiBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbik7XG4gICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcblxuXG4gICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMucGFuQnkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcblxuXG4gICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG5cbiAgICAgIGlmIChpc0NvcmUgJiYgY2VudGVyICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbihjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tKTtcblxuICAgICAgICBpZiAoY2VudGVyUGFuICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcblxuXG4gICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMuZml0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydChmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nKTtcblxuICAgICAgICBpZiAoZml0VnAgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuO1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3ZlcnJpZGUgem9vbSAoJiBwb3RlbnRpYWxseSBwYW4pIHcvIHpvb20gb2JqIGlmIHNldFxuXG5cbiAgICAgIGlmIChpc0NvcmUgJiYgcGxhaW5PYmplY3QocHJvcGVydGllcy56b29tKSkge1xuICAgICAgICB2YXIgdnAgPSBjeS5nZXRab29tZWRWaWV3cG9ydChwcm9wZXJ0aWVzLnpvb20pO1xuXG4gICAgICAgIGlmICh2cCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHZwLnpvb21lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gdnAuem9vbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHZwLnBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgfSAvLyBtYW51YWxseSBob29rIGFuZCBydW4gdGhlIGFuaW1hdGlvblxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBxdWV1ZSA9IGVsZS5hbmltYXRlZCgpICYmIChwcm9wZXJ0aWVzLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcHJvcGVydGllcy5xdWV1ZSk7XG4gICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKHByb3BlcnRpZXMsIHF1ZXVlID8ge1xuICAgICAgICAgIHF1ZXVlOiB0cnVlXG4gICAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKGNsZWFyUXVldWUsIGp1bXBUb0VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmIChqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNsZWFyIHRoZSBxdWV1ZSBvZiBmdXR1cmUgYW5pbWF0aW9uc1xuXG5cbiAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghanVtcFRvRW5kKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB3ZSBoYXZlIHRvIG5vdGlmeSAodGhlIGFuaW1hdGlvbiBsb29wIGRvZXNuJ3QgZG8gaXQgZm9yIHVzIG9uIGBzdG9wYClcblxuXG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0gLy8gc3RvcFxuXG59OyAvLyBkZWZpbmVcblxudmFyIGRlZmluZSQxID0ge1xuICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30sXG4gICAgICAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KHNlbGYpIHt9LFxuICAgICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoc2VsZiwgb2JqKSB7fSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChzZWxmKSB7fSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkYXRhSW1wbChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmOyAvLyAuZGF0YSgnZm9vJywgLi4uKVxuXG4gICAgICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIC8vIHNldCBvciBnZXQgcHJvcGVydHlcbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycpXG4gICAgICAgIGlmIChwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZ2V0XG4gICAgICAgICAgdmFyIHJldDtcblxuICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDsgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuXG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIGNoYW5nZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuXG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChlbGUpKSB7XG4gICAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcblxuXG4gICAgICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgICAgICB9IC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcblxuXG4gICAgICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyAuZGF0YSh7ICdmb28nOiAnYmFyJyB9KVxuXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIC8vIGV4dGVuZFxuICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgdmFyIGssIHY7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgb2JqKTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBrID0ga2V5c1tfaV07XG4gICAgICAgICAgdiA9IG9ialtrXTtcblxuICAgICAgICAgIHZhciBfdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tdO1xuXG4gICAgICAgICAgaWYgKF92YWxpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGUgPSBhbGxbal07XG5cbiAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KF9lbGUpKSB7XG4gICAgICAgICAgICAgICAgX2VsZS5fcHJpdmF0ZVtwLmZpZWxkXVtrXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcblxuXG4gICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICB9IC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcblxuXG4gICAgICAgIHAub25TZXQoc2VsZik7XG5cbiAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICB9IC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dCaW5kaW5nICYmIGZuKG5hbWUpKSB7XG4gICAgICAgIC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgdmFyIGZuJDEgPSBuYW1lO1xuICAgICAgICBzZWxmLm9uKHAuYmluZGluZ0V2ZW50LCBmbiQxKTsgLy8gLmRhdGEoKVxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0IHdob2xlIG9iamVjdFxuICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTtcbiAgICAgICAgICBfcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LFxuICAvLyBkYXRhXG4gIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG5cbiAgICB9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKG5hbWVzKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuXG4gICAgICBpZiAoc3RyaW5nKG5hbWVzKSkge1xuICAgICAgICAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgdmFyIGtleXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGVtcHR5U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba2V5XTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuXG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrKSB7XG4gICAgICAgICAgICAgIGFsbFtpX2FdLl9wcml2YXRlW3AuZmllbGRdW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9IC8vIC5yZW1vdmVEYXRhKClcblxuICAgICAgfSBlbHNlIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG4gICAgICAgIGZvciAodmFyIF9pX2EgPSAwLCBfbF9hID0gYWxsLmxlbmd0aDsgX2lfYSA8IF9sX2E7IF9pX2ErKykge1xuICAgICAgICAgIHZhciBfcHJpdmF0ZUZpZWxkcyA9IGFsbFtfaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXTtcblxuICAgICAgICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzKF9wcml2YXRlRmllbGRzKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IF9rZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBfa2V5ID0gX2tleXNbX2kyXTtcbiAgICAgICAgICAgIHZhciB2YWxpZEtleVRvRGVsZXRlID0gIXAuaW1tdXRhYmxlS2V5c1tfa2V5XTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkS2V5VG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbX2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0gLy8gcmVtb3ZlRGF0YVxuXG59OyAvLyBkZWZpbmVcblxudmFyIGRlZmluZSQyID0ge1xuICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24gZXZlbnRBbGlhc2VzT24ocHJvdG8pIHtcbiAgICB2YXIgcCA9IHByb3RvO1xuICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgcC51bmxpc3RlbiA9IHAudW5iaW5kID0gcC5vZmYgPSBwLnJlbW92ZUxpc3RlbmVyO1xuICAgIHAudHJpZ2dlciA9IHAuZW1pdDsgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuXG4gICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uIChldmVudHMsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGUpIHtcbiAgICAgICAgICBzZWxmLm9mZi5hcHBseShzZWxmLCBvZmZBcmdzKTtcbiAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgdmFyIG9mZkFyZ3MgPSBvbkFyZ3MuY29uY2F0KFtdKTtcbiAgICAgICAgc2VsZi5vbi5hcHBseShzZWxmLCBvbkFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufTsgLy8gZGVmaW5lXG5cbi8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxudmFyIGRlZmluZSQzID0ge307XG5bZGVmaW5lLCBkZWZpbmUkMSwgZGVmaW5lJDJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgZXh0ZW5kKGRlZmluZSQzLCBtKTtcbn0pO1xuXG52YXIgZWxlc2ZuJGQgPSB7XG4gIGFuaW1hdGU6IGRlZmluZSQzLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUkMy5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZSQzLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZSQzLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZSQzLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUkMy5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUkMy5zdG9wKClcbn07XG5cbnZhciBlbGVzZm4kZSA9IHtcbiAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcyhfY2xhc3Nlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChfY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIHNlbGZbMF0uX3ByaXZhdGUuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgcmV0dXJuIHJldC5wdXNoKGNscyk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKCFhcnJheShfY2xhc3NlcykpIHtcbiAgICAgIC8vIGV4dHJhY3QgY2xhc3NlcyBmcm9tIHN0cmluZ1xuICAgICAgX2NsYXNzZXMgPSAoX2NsYXNzZXMgfHwgJycpLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgdmFyIGNsYXNzZXNTZXQgPSBuZXcgU2V0JDEoX2NsYXNzZXMpOyAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBfcC5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgZWxlIGhhcyBhbGwgb2YgdGhlIHBhc3NlZCBjbGFzc2VzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IF9jbGFzc2VzW2ldO1xuICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuXG4gICAgICAgIGlmICghZWxlSGFzQ2xhc3MpIHtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcblxuXG4gICAgICBpZiAoIWNoYW5nZWRFbGUpIHtcbiAgICAgICAgY2hhbmdlZEVsZSA9IGVsZUNsYXNzZXMuc2l6ZSAhPT0gX2NsYXNzZXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZEVsZSkge1xuICAgICAgICBfcC5jbGFzc2VzID0gY2xhc3Nlc1NldDtcbiAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfSAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcblxuXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgdHJ1ZSk7XG4gIH0sXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXMuaGFzKGNsYXNzTmFtZSk7XG4gIH0sXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhjbGFzc2VzLCB0b2dnbGUpIHtcbiAgICBpZiAoIWFycmF5KGNsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdG9nZ2xlVW5kZWZkID0gdG9nZ2xlID09PSB1bmRlZmluZWQ7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gZWxlLl9wcml2YXRlLmNsYXNzZXM7XG4gICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgIHZhciBjaGFuZ2VkTm93ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgIWhhc0NsYXNzKSB7XG4gICAgICAgICAgZWxlQ2xhc3Nlcy5hZGQoY2xzKTtcbiAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghdG9nZ2xlIHx8IHRvZ2dsZVVuZGVmZCAmJiBoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXNbXCJkZWxldGVcIl0oY2xzKTtcbiAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hhbmdlZEVsZSAmJiBjaGFuZ2VkTm93KSB7XG4gICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuXG4gICAgfSAvLyBmb3IgaSBlbGVzXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIGZhbHNlKTtcbiAgfSxcbiAgZmxhc2hDbGFzczogZnVuY3Rpb24gZmxhc2hDbGFzcyhjbGFzc2VzLCBkdXJhdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICB9XG5cbiAgICBzZWxmLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn07XG5lbGVzZm4kZS5jbGFzc05hbWUgPSBlbGVzZm4kZS5jbGFzc05hbWVzID0gZWxlc2ZuJGUuY2xhc3NlcztcblxudmFyIHRva2VucyA9IHtcbiAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLFxuICAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiBsZXQgbmFtZXMsIGV0Y1xuICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLFxuICAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLFxuICAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pKlwiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSonXCIsXG4gIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gIG51bWJlcjogbnVtYmVyJDEsXG4gIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsXG4gIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLFxuICAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgc3ViamVjdDogJ1xcXFwkJyxcbiAgZ3JvdXA6ICdub2RlfGVkZ2V8XFxcXConLFxuICBkaXJlY3RlZEVkZ2U6ICdcXFxccystPlxcXFxzKycsXG4gIHVuZGlyZWN0ZWRFZGdlOiAnXFxcXHMrPC0+XFxcXHMrJ1xufTtcbnRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lXG5cbnRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcblxudG9rZW5zLmNsYXNzTmFtZSA9IHRva2Vucy52YXJpYWJsZTsgLy8gYSBjbGFzcyBuYW1lIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG50b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHMsIG9wLCBpOyAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIG9wID0gb3BzW2ldO1xuICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICB9IC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuXG5cbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcblxuICAgIGlmIChvcC5pbmRleE9mKCchJykgPj0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwIG9wcyB0aGF0IGV4cGxpY2l0bHkgY29udGFpbiAhXG5cblxuICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cblxuICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBNYWtlIGEgbmV3IHF1ZXJ5IG9iamVjdFxuICpcbiAqIEBwcm9wIHR5cGUge1R5cGV9IFRoZSB0eXBlIGVudW0gKGludCkgb2YgdGhlIHF1ZXJ5XG4gKiBAcHJvcCBjaGVja3MgTGlzdCBvZiBjaGVja3MgdG8gbWFrZSBhZ2FpbnN0IGFuIGVsZSB0byB0ZXN0IGZvciBhIG1hdGNoXG4gKi9cbnZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uIG5ld1F1ZXJ5KCkge1xuICByZXR1cm4ge1xuICAgIGNoZWNrczogW11cbiAgfTtcbn07XG5cbi8qKlxuICogQSBjaGVjayB0eXBlIGVudW0tbGlrZSBvYmplY3QuICBVc2VzIGludGVnZXIgdmFsdWVzIGZvciBmYXN0IG1hdGNoKCkgbG9va3VwLlxuICogVGhlIG9yZGVyaW5nIGRvZXMgbm90IG1hdHRlciBhcyBsb25nIGFzIHRoZSBpbnRzIGFyZSB1bmlxdWUuXG4gKi9cbnZhciBUeXBlID0ge1xuICAvKiogRS5nLiBub2RlICovXG4gIEdST1VQOiAwLFxuXG4gIC8qKiBBIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgKi9cbiAgQ09MTEVDVElPTjogMSxcblxuICAvKiogQSBmaWx0ZXIoZWxlKSBmdW5jdGlvbiAqL1xuICBGSUxURVI6IDIsXG5cbiAgLyoqIEUuZy4gW2ZvbyA+IDFdICovXG4gIERBVEFfQ09NUEFSRTogMyxcblxuICAvKiogRS5nLiBbZm9vXSAqL1xuICBEQVRBX0VYSVNUOiA0LFxuXG4gIC8qKiBFLmcuIFs/Zm9vXSAqL1xuICBEQVRBX0JPT0w6IDUsXG5cbiAgLyoqIEUuZy4gW1tkZWdyZWUgPiAyXV0gKi9cbiAgTUVUQV9DT01QQVJFOiA2LFxuXG4gIC8qKiBFLmcuIDpzZWxlY3RlZCAqL1xuICBTVEFURTogNyxcblxuICAvKiogRS5nLiAjZm9vICovXG4gIElEOiA4LFxuXG4gIC8qKiBFLmcuIC5mb28gKi9cbiAgQ0xBU1M6IDksXG5cbiAgLyoqIEUuZy4gI2ZvbyA8LT4gI2JhciAqL1xuICBVTkRJUkVDVEVEX0VER0U6IDEwLFxuXG4gIC8qKiBFLmcuICNmb28gLT4gI2JhciAqL1xuICBESVJFQ1RFRF9FREdFOiAxMSxcblxuICAvKiogRS5nLiAkI2ZvbyAtPiAjYmFyICovXG4gIE5PREVfU09VUkNFOiAxMixcblxuICAvKiogRS5nLiAjZm9vIC0+ICQjYmFyICovXG4gIE5PREVfVEFSR0VUOiAxMyxcblxuICAvKiogRS5nLiAkI2ZvbyA8LT4gI2JhciAqL1xuICBOT0RFX05FSUdIQk9SOiAxNCxcblxuICAvKiogRS5nLiAjZm9vID4gI2JhciAqL1xuICBDSElMRDogMTUsXG5cbiAgLyoqIEUuZy4gI2ZvbyAjYmFyICovXG4gIERFU0NFTkRBTlQ6IDE2LFxuXG4gIC8qKiBFLmcuICQjZm9vID4gI2JhciAqL1xuICBQQVJFTlQ6IDE3LFxuXG4gIC8qKiBFLmcuICQjZm9vICNiYXIgKi9cbiAgQU5DRVNUT1I6IDE4LFxuXG4gIC8qKiBFLmcuICNmb28gPiAkYmFyID4gI2JheiAqL1xuICBDT01QT1VORF9TUExJVDogMTksXG5cbiAgLyoqIEFsd2F5cyBtYXRjaGVzLCB1c2VmdWwgcGxhY2Vob2xkZXIgZm9yIHN1YmplY3QgaW4gYENPTVBPVU5EX1NQTElUYCAqL1xuICBUUlVFOiAyMFxufTtcblxudmFyIHN0YXRlU2VsZWN0b3JzID0gW3tcbiAgc2VsZWN0b3I6ICc6c2VsZWN0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5zZWxlY3RlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuc2VsZWN0YWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5sb2NrZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dmlzaWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aGlkZGVuJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dHJhbnNwYXJlbnQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudHJhbnNwYXJlbnQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpncmFiYmVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpmcmVlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cmVtb3ZlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5zaWRlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiYWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuZ3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphbmltYXRlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuYW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFuaW1hdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGRsZXNzJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGRsZXNzKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y29tcG91bmQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb29wJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNpbXBsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1NpbXBsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hY3RpdmUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzppbmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bm9uYmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59XS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIG4uYi4gc2VsZWN0b3JzIHRoYXQgYXJlIHN0YXJ0aW5nIHN1YnN0cmluZ3Mgb2Ygb3RoZXJzIG11c3QgaGF2ZSB0aGUgbG9uZ2VyIG9uZXMgZmlyc3RcbiAgcmV0dXJuIGRlc2NlbmRpbmcoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG59KTtcblxudmFyIGxvb2t1cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbFRvRm4gPSB7fTtcbiAgdmFyIHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZVNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHMgPSBzdGF0ZVNlbGVjdG9yc1tpXTtcbiAgICBzZWxUb0ZuW3Muc2VsZWN0b3JdID0gcy5tYXRjaGVzO1xuICB9XG5cbiAgcmV0dXJuIHNlbFRvRm47XG59KCk7XG5cbnZhciBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyA9IGZ1bmN0aW9uIHN0YXRlU2VsZWN0b3JNYXRjaGVzKHNlbCwgZWxlKSB7XG4gIHJldHVybiBsb29rdXBbc2VsXShlbGUpO1xufTtcbnZhciBzdGF0ZVNlbGVjdG9yUmVnZXggPSAnKCcgKyBzdGF0ZVNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMuc2VsZWN0b3I7XG59KS5qb2luKCd8JykgKyAnKSc7XG5cbi8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuXG52YXIgY2xlYW5NZXRhQ2hhcnMgPSBmdW5jdGlvbiBjbGVhbk1ldGFDaGFycyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxcXFxcKCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKScsICdnJyksIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgICByZXR1cm4gJDE7XG4gIH0pO1xufTtcblxudmFyIHJlcGxhY2VMYXN0UXVlcnkgPSBmdW5jdGlvbiByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBleGFtaW5pbmdRdWVyeSwgcmVwbGFjZW1lbnRRdWVyeSkge1xuICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9IHJlcGxhY2VtZW50UXVlcnk7XG59OyAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4vLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbi8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGVjdG9yW2ldXG4vLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIG1hdGNoKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuXG5cbnZhciBleHBycyA9IFt7XG4gIG5hbWU6ICdncm91cCcsXG4gIC8vIGp1c3QgdXNlZCBmb3IgaWRlbnRpZnlpbmcgd2hlbiBkZWJ1Z2dpbmdcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnKCcgKyB0b2tlbnMuZ3JvdXAgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYpIHtcbiAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgICAgZ3JvdXAgPSBfcmVmMlswXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuR1JPVVAsXG4gICAgICB2YWx1ZTogZ3JvdXAgPT09ICcqJyA/IGdyb3VwIDogZ3JvdXAgKyAncydcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnc3RhdGUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6IHN0YXRlU2VsZWN0b3JSZWdleCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgIHN0YXRlID0gX3JlZjRbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLlNUQVRFLFxuICAgICAgdmFsdWU6IHN0YXRlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2lkJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjUpIHtcbiAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICAgIGlkID0gX3JlZjZbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLklELFxuICAgICAgdmFsdWU6IGNsZWFuTWV0YUNoYXJzKGlkKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdjbGFzc05hbWUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcLignICsgdG9rZW5zLmNsYXNzTmFtZSArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjcpIHtcbiAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMSksXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWY4WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5DTEFTUyxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFFeGlzdHMnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY5KSB7XG4gICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAxKSxcbiAgICAgICAgdmFyaWFibGUgPSBfcmVmMTBbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfRVhJU1QsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAzKSxcbiAgICAgICAgdmFyaWFibGUgPSBfcmVmMTJbMF0sXG4gICAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxMlsxXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMTJbMl07XG5cbiAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFCb29sJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy5ib29sT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMykge1xuICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxuICAgICAgICBib29sT3AgPSBfcmVmMTRbMF0sXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjE0WzFdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0JPT0wsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdtZXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJyArIHRva2Vucy5tZXRhICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLm51bWJlciArICcpXFxcXHMqXFxcXF1cXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxNSkge1xuICAgIHZhciBfcmVmMTYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTUsIDMpLFxuICAgICAgICBtZXRhID0gX3JlZjE2WzBdLFxuICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTZbMV0sXG4gICAgICAgIG51bWJlciA9IF9yZWYxNlsyXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuTUVUQV9DT01QQVJFLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbmV4dFF1ZXJ5JyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIHZhciBjdXJyZW50U3ViamVjdCA9IHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0O1xuICAgIHZhciBlZGdlQ291bnQgPSBzZWxlY3Rvci5lZGdlQ291bnQ7XG4gICAgdmFyIGNvbXBvdW5kQ291bnQgPSBzZWxlY3Rvci5jb21wb3VuZENvdW50O1xuICAgIHZhciBsYXN0USA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICAgIGxhc3RRLnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBsYXN0US5lZGdlQ291bnQgPSBlZGdlQ291bnQ7XG4gICAgbGFzdFEuY29tcG91bmRDb3VudCA9IGNvbXBvdW5kQ291bnQ7XG4gICAgc2VsZWN0b3IuZWRnZUNvdW50ID0gMDtcbiAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50ID0gMDsgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuXG4gICAgdmFyIG5leHRRdWVyeSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCsrXSA9IG5ld1F1ZXJ5KCk7XG4gICAgcmV0dXJuIG5leHRRdWVyeTsgLy8gdGhpcyBpcyB0aGUgbmV3IHF1ZXJ5IHRvIGJlIGZpbGxlZCBieSB0aGUgZm9sbG93aW5nIGV4cHJzXG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RpcmVjdGVkRWRnZScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5ESVJFQ1RFRF9FREdFLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzb3VyY2UvdGFyZ2V0XG4gICAgICB2YXIgc3JjVGd0USA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX3NvdXJjZSA9IHF1ZXJ5O1xuXG4gICAgICB2YXIgX3RhcmdldCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHNyY1RndFEuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLk5PREVfU09VUkNFLFxuICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgIHRhcmdldDogX3RhcmdldFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBzcmNUZ3RRKTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrO1xuICAgICAgcmV0dXJuIF90YXJnZXQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgd2l0aCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICd1bmRpcmVjdGVkRWRnZScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy51bmRpcmVjdGVkRWRnZSxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlVORElSRUNURURfRURHRSxcbiAgICAgICAgbm9kZXM6IFtzb3VyY2UsIHRhcmdldF1cbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWlnaGJvdXJob29kXG4gICAgICB2YXIgbmhvb2RRID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBub2RlID0gcXVlcnk7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZXdRdWVyeSgpO1xuICAgICAgbmhvb2RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX05FSUdIQk9SLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBuZWlnaGJvcjogbmVpZ2hib3JcbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgbmhvb2RRKTtcbiAgICAgIHJldHVybiBuZWlnaGJvcjsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIG5laWdoYm9yIHdpdGggZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdjaGlsZCcsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBjaGlsZCBxdWVyeVxuICAgICAgdmFyIHBhcmVudENoaWxkUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGNoaWxkID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHBhcmVudENoaWxkUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNISUxELFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIHBhcmVudENoaWxkUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHZhciBfY2hpbGQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX3BhcmVudCA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgIF9wYXJlbnQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH0pOyAvLyBwYXJlbnQgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG5cblxuICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBwYXJlbnQ6IF9wYXJlbnQsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQgLy8gZW1wdHkgZm9yIG5vd1xuXG4gICAgICB9KTtcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTsgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuXG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2NoaWxkOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGNoaWxkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBxdWVyeVxuICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICB2YXIgX3BhcmVudDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2NoaWxkMiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHZhciBwY1FDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgcGFyZW50OiBfcGFyZW50MixcbiAgICAgICAgY2hpbGQ6IF9jaGlsZDJcbiAgICAgIH1dOyAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcblxuICAgICAgX3BhcmVudDIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBwY1FDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDI7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZFxuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnZGVzY2VuZGFudCcsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5kZXNjZW5kYW50LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIGRlZmF1bHQ6IGRlc2NlbmRhbnQgcXVlcnlcbiAgICAgIHZhciBhbmNDaFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBkZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBhbmNlc3RvciA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgYW5jQ2hRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuREVTQ0VOREFOVCxcbiAgICAgICAgYW5jZXN0b3I6IGFuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBkZXNjZW5kYW50XG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGFuY0NoUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG5cbiAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2Rlc2NlbmRhbnQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2FuY2VzdG9yID0gbmV3UXVlcnkoKTsgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcblxuXG4gICAgICBjb21wb3VuZC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQ09NUE9VTkRfU1BMSVQsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgc3ViamVjdDogc3ViamVjdFxuICAgICAgfSk7IC8vIHBvcHVsYXRlIHRoZSBzdWJqZWN0IGFuZCByZXBsYWNlIHRoZSBxIGF0IHRoZSBvbGQgc3BvdCAod2l0aGluIGxlZnQpIHdpdGggVFJVRVxuXG4gICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcblxuICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG4gICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcblxuICAgICAgX2FuY2VzdG9yLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gYW5jZXN0b3IgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG5cblxuICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IsXG4gICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50IC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGRlc2NlbmRhbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW5jZXN0b3IgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9hbmNlc3RvcjIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2Rlc2NlbmRhbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIGFkUUNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IyLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudDJcbiAgICAgIH1dOyAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcblxuICAgICAgX2FuY2VzdG9yMi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IGFkUUNoZWNrczsgLy8gcGMgcXVlcnkgdGFrZXMgb3ZlclxuXG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2Rlc2NlbmRhbnQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N1YmplY3QnLFxuICBtb2RpZmllcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgIT09IHF1ZXJ5KSB7XG4gICAgICB3YXJuKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yLnRvU3RyaW5nKCkgKyAnYCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gcXVlcnk7XG4gICAgdmFyIHRvcFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICB2YXIgdG9wQ2hrID0gdG9wUS5jaGVja3NbMF07XG4gICAgdmFyIHRvcFR5cGUgPSB0b3BDaGsgPT0gbnVsbCA/IG51bGwgOiB0b3BDaGsudHlwZTtcblxuICAgIGlmICh0b3BUeXBlID09PSBUeXBlLkRJUkVDVEVEX0VER0UpIHtcbiAgICAgIC8vIGRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSB0YXJnZXRcbiAgICAgIC8vIGNoYW5nZSB0byB0YXJnZXQgbm9kZSBjaGVja1xuICAgICAgdG9wQ2hrLnR5cGUgPSBUeXBlLk5PREVfVEFSR0VUO1xuICAgIH0gZWxzZSBpZiAodG9wVHlwZSA9PT0gVHlwZS5VTkRJUkVDVEVEX0VER0UpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZSB3aXRoIHN1YmplY3Qgb24gdGhlIHNlY29uZCBub2RlXG4gICAgICAvLyBjaGFuZ2UgdG8gbmVpZ2hib3IgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX05FSUdIQk9SO1xuICAgICAgdG9wQ2hrLm5vZGUgPSB0b3BDaGsubm9kZXNbMV07IC8vIHNlY29uZCBub2RlIGlzIHN1YmplY3RcblxuICAgICAgdG9wQ2hrLm5laWdoYm9yID0gdG9wQ2hrLm5vZGVzWzBdOyAvLyBjbGVhbiB1cCB1bnVzZWQgZmllbGRzIGZvciBuZXcgdHlwZVxuXG4gICAgICB0b3BDaGsubm9kZXMgPSBudWxsO1xuICAgIH1cbiAgfVxufV07XG5leHBycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBlLnJlZ2V4T2JqID0gbmV3IFJlZ0V4cCgnXicgKyBlLnJlZ2V4KTtcbn0pO1xuXG4vKipcbiAqIE9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gKiBAcmV0dXJucyBUaGUgbWF0Y2hlZCBleHByZXNzaW9uIGFuZCB0aGUgbmV3bHkgcmVtYWluaW5nIHRleHQgYHsgZXhwciwgbWF0Y2gsIG5hbWUsIHJlbWFpbmluZyB9YFxuICovXG5cbnZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uIGNvbnN1bWVFeHByKHJlbWFpbmluZykge1xuICB2YXIgZXhwcjtcbiAgdmFyIG1hdGNoO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGUgPSBleHByc1tqXTtcbiAgICB2YXIgbiA9IGUubmFtZTtcbiAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChlLnJlZ2V4T2JqKTtcblxuICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbTtcbiAgICAgIGV4cHIgPSBlO1xuICAgICAgbmFtZSA9IG47XG4gICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwcjogZXhwcixcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1haW5pbmc6IHJlbWFpbmluZ1xuICB9O1xufTtcbi8qKlxuICogQ29uc3VtZSBhbGwgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbWFpbmluZyBUaGUgdGV4dCB0byBjb25zdW1lXG4gKiBAcmV0dXJucyBUaGUgdGV4dCB3aXRoIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZFxuICovXG5cblxudmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKSB7XG4gIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gcmVtYWluaW5nO1xufTtcbi8qKlxuICogUGFyc2UgdGhlIHN0cmluZyBhbmQgc3RvcmUgdGhlIHBhcnNlZCByZXByZXNlbnRhdGlvbiBpbiB0aGUgU2VsZWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHN0cmluZ1xuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBzZWxlY3RvciB3YXMgc3VjY2Vzc2Z1bGx5IHBhcnNlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqL1xuXG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHNlbGVjdG9yKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlbWFpbmluZyA9IHNlbGYuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHZhciBjdXJyZW50UXVlcnkgPSBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgc2VsZi5sZW5ndGggPSAxO1xuICByZW1haW5pbmcgPSBjb25zdW1lV2hpdGVzcGFjZShyZW1haW5pbmcpOyAvLyBnZXQgcmlkIG9mIGxlYWRpbmcgd2hpdGVzcGFjZVxuXG4gIGZvciAoOzspIHtcbiAgICB2YXIgZXhwckluZm8gPSBjb25zdW1lRXhwcihyZW1haW5pbmcpO1xuXG4gICAgaWYgKGV4cHJJbmZvLmV4cHIgPT0gbnVsbCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYGlzIGludmFsaWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBleHBySW5mby5tYXRjaC5zbGljZSgxKTsgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IGluIGN1cnJlbnRRdWVyeVxuXG4gICAgICB2YXIgcmV0ID0gZXhwckluZm8uZXhwci5wb3B1bGF0ZShzZWxmLCBjdXJyZW50UXVlcnksIGFyZ3MpO1xuXG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudFF1ZXJ5ID0gcmV0OyAvLyBjaGFuZ2UgdGhlIGN1cnJlbnQgcXVlcnkgdG8gYmUgZmlsbGVkIGlmIHRoZSBleHByIHNwZWNpZmllc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbWFpbmluZyA9IGV4cHJJbmZvLnJlbWFpbmluZzsgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG5cbiAgICBpZiAocmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhc3RRID0gc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzZWxmLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICBsYXN0US5zdWJqZWN0ID0gc2VsZi5jdXJyZW50U3ViamVjdDtcbiAgfVxuXG4gIGxhc3RRLmVkZ2VDb3VudCA9IHNlbGYuZWRnZUNvdW50O1xuICBsYXN0US5jb21wb3VuZENvdW50ID0gc2VsZi5jb21wb3VuZENvdW50O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxID0gc2VsZltpXTsgLy8gaW4gZnV0dXJlLCB0aGlzIGNvdWxkIHBvdGVudGlhbGx5IGJlIGFsbG93ZWQgaWYgdGhlcmUgd2VyZSBvcGVyYXRvciBwcmVjZWRlbmNlIGFuZCBkZXRlY3Rpb24gb2YgaW52YWxpZCBjb21iaW5hdGlvbnNcblxuICAgIGlmIChxLmNvbXBvdW5kQ291bnQgPiAwICYmIHEuZWRnZUNvdW50ID4gMCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBib3RoIGEgY29tcG91bmQgc2VsZWN0b3IgYW5kIGFuIGVkZ2Ugc2VsZWN0b3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocS5lZGdlQ291bnQgPiAxKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGludmFsaWQgYmVjYXVzZSBpdCB1c2VzIG11bHRpcGxlIGVkZ2Ugc2VsZWN0b3JzJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChxLmVkZ2VDb3VudCA9PT0gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBkZXByZWNhdGVkLiAgRWRnZSBzZWxlY3RvcnMgZG8gbm90IHRha2UgZWZmZWN0IG9uIGNoYW5nZXMgdG8gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMgYWZ0ZXIgYW4gZWRnZSBpcyBhZGRlZCwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBVc2UgYSBjbGFzcyBvciBkYXRhIHNlbGVjdG9yIG9uIGVkZ2VzIGluc3RlYWQsIHVwZGF0aW5nIHRoZSBjbGFzcyBvciBkYXRhIG9mIGFuIGVkZ2Ugd2hlbiB5b3VyIGFwcCBkZXRlY3RzIGEgY2hhbmdlIGluIHNvdXJjZSBvciB0YXJnZXQgbm9kZXMuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7IC8vIHN1Y2Nlc3Ncbn07XG4vKipcbiAqIEdldCB0aGUgc2VsZWN0b3IgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuICBUaGlzIHZhbHVlIHVzZXMgZGVmYXVsdCBmb3JtYXR0aW5nLFxuICogc28gdGhpbmdzIGxpa2Ugc3BhY2luZyBtYXkgZGlmZmVyIGZyb20gdGhlIGlucHV0IHRleHQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqL1xuXG5cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICBpZiAodGhpcy50b1N0cmluZ0NhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZ0NhY2hlO1xuICB9XG5cbiAgdmFyIGNsZWFuID0gZnVuY3Rpb24gY2xlYW4ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGVhblZhbCA9IGZ1bmN0aW9uIGNsZWFuVmFsKHZhbCkge1xuICAgIGlmIChzdHJpbmcodmFsKSkge1xuICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xlYW4odmFsKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNwYWNlID0gZnVuY3Rpb24gc3BhY2UodmFsKSB7XG4gICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgfTtcblxuICB2YXIgY2hlY2tUb1N0cmluZyA9IGZ1bmN0aW9uIGNoZWNrVG9TdHJpbmcoY2hlY2ssIHN1YmplY3QpIHtcbiAgICB2YXIgdHlwZSA9IGNoZWNrLnR5cGUsXG4gICAgICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5HUk9VUDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBncm91cCA9IGNsZWFuKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0NPTVBBUkU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcjtcbiAgICAgICAgICByZXR1cm4gJ1snICsgZmllbGQgKyBzcGFjZShjbGVhbihvcGVyYXRvcikpICsgY2xlYW5WYWwodmFsdWUpICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0JPT0w6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgIF9maWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnWycgKyBjbGVhbihfb3BlcmF0b3IpICsgX2ZpZWxkICsgJ10nO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0VYSVNUOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9maWVsZDIgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgX2ZpZWxkMiArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuTUVUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvcjIgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgICAgX2ZpZWxkMyA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnW1snICsgX2ZpZWxkMyArIHNwYWNlKGNsZWFuKF9vcGVyYXRvcjIpKSArIGNsZWFuVmFsKHZhbHVlKSArICddXSc7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLlNUQVRFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5JRDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnIycgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuQ0xBU1M6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJy4nICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLlBBUkVOVDpcbiAgICAgIGNhc2UgVHlwZS5DSElMRDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBxdWVyeVRvU3RyaW5nKGNoZWNrLnBhcmVudCwgc3ViamVjdCkgKyBzcGFjZSgnPicpICsgcXVlcnlUb1N0cmluZyhjaGVjay5jaGlsZCwgc3ViamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLkFOQ0VTVE9SOlxuICAgICAgY2FzZSBUeXBlLkRFU0NFTkRBTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5hbmNlc3Rvciwgc3ViamVjdCkgKyAnICcgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmRlc2NlbmRhbnQsIHN1YmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5DT01QT1VORF9TUExJVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLmxlZnQsIHN1YmplY3QpO1xuICAgICAgICAgIHZhciBzdWIgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnN1YmplY3QsIHN1YmplY3QpO1xuICAgICAgICAgIHZhciByaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnJpZ2h0LCBzdWJqZWN0KTtcbiAgICAgICAgICByZXR1cm4gbGhzICsgKGxocy5sZW5ndGggPiAwID8gJyAnIDogJycpICsgc3ViICsgcmhzO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5UUlVFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24gcXVlcnlUb1N0cmluZyhxdWVyeSwgc3ViamVjdCkge1xuICAgIHJldHVybiBxdWVyeS5jaGVja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGNoaywgaSkge1xuICAgICAgcmV0dXJuIHN0ciArIChzdWJqZWN0ID09PSBxdWVyeSAmJiBpID09PSAwID8gJyQnIDogJycpICsgY2hlY2tUb1N0cmluZyhjaGssIHN1YmplY3QpO1xuICAgIH0sICcnKTtcbiAgfTtcblxuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcbiAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyhxdWVyeSwgcXVlcnkuc3ViamVjdCk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmIGkgPCB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHN0ciArPSAnLCAnO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudG9TdHJpbmdDYWNoZSA9IHN0cjtcbiAgcmV0dXJuIHN0cjtcbn07XG52YXIgcGFyc2UkMSA9IHtcbiAgcGFyc2U6IHBhcnNlLFxuICB0b1N0cmluZzogdG9TdHJpbmdcbn07XG5cbnZhciB2YWxDbXAgPSBmdW5jdGlvbiB2YWxDbXAoZmllbGRWYWwsIG9wZXJhdG9yLCB2YWx1ZSkge1xuICB2YXIgbWF0Y2hlcztcbiAgdmFyIGlzRmllbGRTdHIgPSBzdHJpbmcoZmllbGRWYWwpO1xuICB2YXIgaXNGaWVsZE51bSA9IG51bWJlcihmaWVsZFZhbCk7XG4gIHZhciBpc1ZhbFN0ciA9IHN0cmluZyh2YWx1ZSk7XG4gIHZhciBmaWVsZFN0ciwgdmFsU3RyO1xuICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gIHZhciBub3RFeHByID0gZmFsc2U7XG4gIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcblxuICBpZiAob3BlcmF0b3IuaW5kZXhPZignIScpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJyEnLCAnJyk7XG4gICAgbm90RXhwciA9IHRydWU7XG4gIH1cblxuICBpZiAob3BlcmF0b3IuaW5kZXhPZignQCcpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0ZpZWxkU3RyIHx8IGlzVmFsU3RyIHx8IGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGZpZWxkU3RyID0gIWlzRmllbGRTdHIgJiYgIWlzRmllbGROdW0gPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgfSAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gIC8vIGV2ZW4gaWYgd2UncmUgY29tcGFyaW5nIG51bWJlcnNcblxuXG4gIGlmIChjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFZhbCA9IGZpZWxkU3RyID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICB2YWx1ZSA9IHZhbFN0ciA9IHZhbFN0ci50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJyo9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPj0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJD0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoKSA+PSAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdePSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID09PSAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA9PT0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJz4nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc+PSc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc8JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPD0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICB9IC8vIGFwcGx5IHRoZSBub3Qgb3AsIGJ1dCBudWxsIHZhbHMgZm9yIGluZXF1YWxpdGllcyBzaG91bGQgYWx3YXlzIHN0YXkgbm9uLW1hdGNoaW5nXG5cblxuICBpZiAobm90RXhwciAmJiAoZmllbGRWYWwgIT0gbnVsbCB8fCAhaXNJbmVxQ21wKSkge1xuICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufTtcbnZhciBib29sQ21wID0gZnVuY3Rpb24gYm9vbENtcChmaWVsZFZhbCwgb3BlcmF0b3IpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJz8nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgY2FzZSAnISc6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPyBmYWxzZSA6IHRydWU7XG5cbiAgICBjYXNlICdeJzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA9PT0gdW5kZWZpbmVkO1xuICB9XG59O1xudmFyIGV4aXN0Q21wID0gZnVuY3Rpb24gZXhpc3RDbXAoZmllbGRWYWwpIHtcbiAgcmV0dXJuIGZpZWxkVmFsICE9PSB1bmRlZmluZWQ7XG59O1xudmFyIGRhdGEgPSBmdW5jdGlvbiBkYXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZS5kYXRhKGZpZWxkKTtcbn07XG52YXIgbWV0YSA9IGZ1bmN0aW9uIG1ldGEoZWxlLCBmaWVsZCkge1xuICByZXR1cm4gZWxlW2ZpZWxkXSgpO1xufTtcblxuLyoqIEEgbG9va3VwIG9mIGBtYXRjaChjaGVjaywgZWxlKWAgZnVuY3Rpb25zIGJ5IGBUeXBlYCBpbnQgKi9cblxudmFyIG1hdGNoID0gW107XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcXVlcnkgbWF0Y2hlcyBmb3IgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBxdWVyeSBUaGUgYHsgdHlwZSwgdmFsdWUsIC4uLiB9YCBxdWVyeSBvYmplY3RcbiAqIEBwYXJhbSBlbGUgVGhlIGVsZW1lbnQgdG8gY29tcGFyZSBhZ2FpbnN0XG4qL1xuXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMocXVlcnksIGVsZSkge1xuICByZXR1cm4gcXVlcnkuY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGspIHtcbiAgICByZXR1cm4gbWF0Y2hbY2hrLnR5cGVdKGNoaywgZWxlKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkdST1VQXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBncm91cCA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZ3JvdXAgPT09ICcqJyB8fCBncm91cCA9PT0gZWxlLmdyb3VwKCk7XG59O1xuXG5tYXRjaFtUeXBlLlNUQVRFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBzdGF0ZVNlbGVjdG9yID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzdGF0ZVNlbGVjdG9yLCBlbGUpO1xufTtcblxubWF0Y2hbVHlwZS5JRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgaWQgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5pZCgpID09PSBpZDtcbn07XG5cbm1hdGNoW1R5cGUuQ0xBU1NdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGNscyA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZWxlLmhhc0NsYXNzKGNscyk7XG59O1xuXG5tYXRjaFtUeXBlLk1FVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gdmFsQ21wKG1ldGEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG59O1xuXG5tYXRjaFtUeXBlLkRBVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gdmFsQ21wKGRhdGEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG59O1xuXG5tYXRjaFtUeXBlLkRBVEFfQk9PTF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBib29sQ21wKGRhdGEoZWxlLCBmaWVsZCksIG9wZXJhdG9yKTtcbn07XG5cbm1hdGNoW1R5cGUuREFUQV9FWElTVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBleGlzdENtcChkYXRhKGVsZSwgZmllbGQpKTtcbn07XG5cbm1hdGNoW1R5cGUuVU5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBxQSA9IGNoZWNrLm5vZGVzWzBdO1xuICB2YXIgcUIgPSBjaGVjay5ub2Rlc1sxXTtcbiAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKTtcbiAgdmFyIHRndCA9IGVsZS50YXJnZXQoKTtcbiAgcmV0dXJuIG1hdGNoZXMocUEsIHNyYykgJiYgbWF0Y2hlcyhxQiwgdGd0KSB8fCBtYXRjaGVzKHFCLCBzcmMpICYmIG1hdGNoZXMocUEsIHRndCk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfTkVJR0hCT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2subm9kZSwgZWxlKSAmJiBlbGUubmVpZ2hib3Job29kKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMoY2hlY2submVpZ2hib3IsIG4pO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuRElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5zb3VyY2UsIGVsZS5zb3VyY2UoKSkgJiYgbWF0Y2hlcyhjaGVjay50YXJnZXQsIGVsZS50YXJnZXQoKSk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfU09VUkNFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnNvdXJjZSwgZWxlKSAmJiBlbGUub3V0Z29lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyhjaGVjay50YXJnZXQsIG4pO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuTk9ERV9UQVJHRVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2sudGFyZ2V0LCBlbGUpICYmIGVsZS5pbmNvbWVycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzKGNoZWNrLnNvdXJjZSwgbik7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5DSElMRF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5jaGlsZCwgZWxlKSAmJiBtYXRjaGVzKGNoZWNrLnBhcmVudCwgZWxlLnBhcmVudCgpKTtcbn07XG5cbm1hdGNoW1R5cGUuUEFSRU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnBhcmVudCwgZWxlKSAmJiBlbGUuY2hpbGRyZW4oKS5zb21lKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMoY2hlY2suY2hpbGQsIGMpO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuREVTQ0VOREFOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5kZXNjZW5kYW50LCBlbGUpICYmIGVsZS5hbmNlc3RvcnMoKS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMoY2hlY2suYW5jZXN0b3IsIGEpO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuQU5DRVNUT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suYW5jZXN0b3IsIGVsZSkgJiYgZWxlLmRlc2NlbmRhbnRzKCkuc29tZShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBtYXRjaGVzKGNoZWNrLmRlc2NlbmRhbnQsIGQpO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuQ09NUE9VTkRfU1BMSVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suc3ViamVjdCwgZWxlKSAmJiBtYXRjaGVzKGNoZWNrLmxlZnQsIGVsZSkgJiYgbWF0Y2hlcyhjaGVjay5yaWdodCwgZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuVFJVRV0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxubWF0Y2hbVHlwZS5DT0xMRUNUSU9OXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBjb2xsZWN0aW9uLmhhcyhlbGUpO1xufTtcblxubWF0Y2hbVHlwZS5GSUxURVJdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpbHRlciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZmlsdGVyKGVsZSk7XG59O1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG5cbiAgaWYgKHNlbGYubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrc1swXS50eXBlID09PSBUeXBlLklEKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0RWxlbWVudEJ5SWQoc2VsZlswXS5jaGVja3NbMF0udmFsdWUpLmNvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbihlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICBpZiAobWF0Y2hlcyhxdWVyeSwgZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGlmIChzZWxmLnRleHQoKSA9PSBudWxsKSB7XG4gICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKHNlbGVjdG9yRnVuY3Rpb24pO1xufTsgLy8gZmlsdGVyXG4vLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG5cblxudmFyIG1hdGNoZXMkMSA9IGZ1bmN0aW9uIG1hdGNoZXMkMShlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICBpZiAobWF0Y2hlcyhxdWVyeSwgZWxlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTsgLy8gbWF0Y2hlc1xuXG5cbnZhciBtYXRjaGluZyA9IHtcbiAgbWF0Y2hlczogbWF0Y2hlcyQxLFxuICBmaWx0ZXI6IGZpbHRlclxufTtcblxudmFyIFNlbGVjdG9yID0gZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdGhpcy5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgdGhpcy5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gIHRoaXMuY29tcG91bmRDb3VudCA9IDA7XG4gIHRoaXMuZWRnZUNvdW50ID0gMDtcbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHN0cmluZyhzZWxlY3RvcikgJiYgc2VsZWN0b3IubWF0Y2goL15cXHMqJC8pKSA7IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICBjaGVja3M6IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuQ09MTEVDVElPTixcbiAgICAgICAgdmFsdWU6IHNlbGVjdG9yLmNvbGxlY3Rpb24oKVxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChmbihzZWxlY3RvcikpIHtcbiAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgIGNoZWNrczogW3tcbiAgICAgICAgdHlwZTogVHlwZS5GSUxURVIsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RvclxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlKHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcpO1xuICB9XG59O1xuXG52YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG5bcGFyc2UkMSwgbWF0Y2hpbmddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGV4dGVuZChzZWxmbiwgcCk7XG59KTtcblxuc2VsZm4udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaW5wdXRUZXh0O1xufTtcblxuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuc2VsZm4uZXEgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gdGhpc1tpXTtcbn07XG5cbnNlbGZuLnNhbWVUZXh0ID0gZnVuY3Rpb24gKG90aGVyU2VsKSB7XG4gIHJldHVybiAhdGhpcy5pbnZhbGlkICYmICFvdGhlclNlbC5pbnZhbGlkICYmIHRoaXMudGV4dCgpID09PSBvdGhlclNlbC50ZXh0KCk7XG59O1xuXG5zZWxmbi5hZGRRdWVyeSA9IGZ1bmN0aW9uIChxKSB7XG4gIHRoaXNbdGhpcy5sZW5ndGgrK10gPSBxO1xufTtcblxuc2VsZm4uc2VsZWN0b3IgPSBzZWxmbi50b1N0cmluZztcblxudmFyIGVsZXNmbiRmID0ge1xuICBhbGxBcmU6IGZ1bmN0aW9uIGFsbEFyZShzZWxlY3Rvcikge1xuICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgIH0pO1xuICB9LFxuICBzb21lOiBmdW5jdGlvbiBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcblxuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBzYW1lOiBmdW5jdGlvbiBzYW1lKGNvbGxlY3Rpb24pIHtcbiAgICAvLyBjaGVhcCBjb2xsZWN0aW9uIHJlZiBjaGVja1xuICAgIGlmICh0aGlzID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoOyAvLyBjaGVhcCBsZW5ndGggY2hlY2tcblxuICAgIGlmICh0aGlzTGVuZ3RoICE9PSBjb2xsZWN0aW9uTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVhcCBlbGVtZW50IHJlZiBjaGVja1xuXG5cbiAgICBpZiAodGhpc0xlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPT09IGNvbGxlY3Rpb25bMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uIGFsbEFyZU5laWdoYm9ycyhjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIG5ob29kLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH1cbn07XG5lbGVzZm4kZi5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuJGYuYWxsQXJlTmVpZ2hib3JzO1xuZWxlc2ZuJGYuaGFzID0gZWxlc2ZuJGYuY29udGFpbnM7XG5lbGVzZm4kZi5lcXVhbCA9IGVsZXNmbiRmLmVxdWFscyA9IGVsZXNmbiRmLnNhbWU7XG5cbnZhciBjYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKGZuLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZShhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGtleTtcblxuICAgIGlmIChzZWxlY3Rvck9yRWxlcyA9PSBudWxsKSB7XG4gICAgICBrZXkgPSAnJztcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oc2VsZWN0b3JPckVsZXMpICYmIHNlbGVjdG9yT3JFbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAga2V5ID0gc2VsZWN0b3JPckVsZXMuaWQoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDEgJiYga2V5KSB7XG4gICAgICB2YXIgX3AgPSBlbGVzWzBdLl9wcml2YXRlO1xuICAgICAgdmFyIHRjaCA9IF9wLnRyYXZlcnNhbENhY2hlID0gX3AudHJhdmVyc2FsQ2FjaGUgfHwge307XG4gICAgICB2YXIgY2ggPSB0Y2hbbmFtZV0gPSB0Y2hbbmFtZV0gfHwgW107XG4gICAgICB2YXIgaGFzaCA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgIHZhciBjYWNoZUhpdCA9IGNoW2hhc2hdO1xuXG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoW2hhc2hdID0gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGVsZXNmbiRnID0ge1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107IC8vIG9wdGltaXNhdGlvbiBmb3Igc2luZ2xlIGVsZSBjYWxsXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzWzBdLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3BhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmIChfcGFyZW50KSB7XG4gICAgICAgIHBhcmVudHMucHVzaChfcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG5cbiAgICB3aGlsZSAoZWxlcy5ub25lbXB0eSgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHBhcmVudHMucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uIGNvbW1vbkFuY2VzdG9ycyhzZWxlY3Rvcikge1xuICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzIHx8IHBhcmVudHM7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KHBhcmVudHMpOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3JwaGFuczogZnVuY3Rpb24gb3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgbm9ub3JwaGFuczogZnVuY3Rpb24gbm9ub3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjaGlsZHJlbjogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGVsZUNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZUNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGNoaWxkcmVuLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY2hpbGRyZW4nKSxcbiAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZGxlc3M6IGZ1bmN0aW9uIGlzQ2hpbGRsZXNzKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCAhPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgaXNPcnBoYW46IGZ1bmN0aW9uIGlzT3JwaGFuKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ID09IG51bGw7XG4gICAgfVxuICB9LFxuICBkZXNjZW5kYW50czogZnVuY3Rpb24gZGVzY2VuZGFudHMoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGFkZChlbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcblxuICAgICAgICBpZiAoZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSkge1xuICAgICAgICAgIGFkZChlbGUuY2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGQodGhpcy5jaGlsZHJlbigpKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICB2YXIgcSA9IFtdO1xuICB2YXIgZGlkID0gbmV3IFNldCQxKCk7XG4gIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgcS5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBlbGUpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChxLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgX2VsZSA9IHEuc2hpZnQoKTtcblxuICAgIGZuKF9lbGUpO1xuICAgIGRpZC5hZGQoX2VsZS5pZCgpKTtcblxuICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBfZWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghZGlkLmhhcyhjaGlsZC5pZCgpKSkge1xuICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbi8vIGZvciBpbnRlcm5hbCB1c2VcblxuXG5lbGVzZm4kZy5mb3JFYWNoRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRDaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBhZGRQYXJlbnQocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc0NoaWxkKCkpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcblxuICAgIGlmICghZGlkLmhhcyhwYXJlbnQuaWQoKSkpIHtcbiAgICAgIHEucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5lbGVzZm4kZy5mb3JFYWNoVXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50KTtcbn07XG5cbmZ1bmN0aW9uIGFkZFBhcmVudEFuZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGFkZFBhcmVudChxLCBkaWQsIGVsZSk7XG4gIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKTtcbn1cblxuZWxlc2ZuJGcuZm9yRWFjaFVwQW5kRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnRBbmRDaGlsZHJlbik7XG59OyAvLyBhbGlhc2VzXG5cblxuZWxlc2ZuJGcuYW5jZXN0b3JzID0gZWxlc2ZuJGcucGFyZW50cztcblxudmFyIGZuJDEsIGVsZXNmbiRoO1xuZm4kMSA9IGVsZXNmbiRoID0ge1xuICBkYXRhOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlRGF0YTogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZSQzLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUkMy5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcnNjcmF0Y2g6IGRlZmluZSQzLmRhdGEoe1xuICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSksXG4gIHJlbW92ZVJzY3JhdGNoOiBkZWZpbmUkMy5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuICBpZDogZnVuY3Rpb24gaWQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG59OyAvLyBhbGlhc2VzXG5cbmZuJDEuYXR0ciA9IGZuJDEuZGF0YTtcbmZuJDEucmVtb3ZlQXR0ciA9IGZuJDEucmVtb3ZlRGF0YTtcbnZhciBkYXRhJDEgPSBlbGVzZm4kaDtcblxudmFyIGVsZXNmbiRpID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGluY2x1ZGVMb29wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmNsdWRlTG9vcHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmlzTm9kZSgpICYmICFzZWxmLnJlbW92ZWQoKSkge1xuICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHNlbGZbMF07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbaV07XG5cbiAgICAgICAgaWYgKCFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKG5vZGUsIGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVncmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJGksIHtcbiAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUoZWRnZS50YXJnZXQoKSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pLFxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KSxcbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oZGVncmVlRm4sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXShpbmNsdWRlTG9vcHMpO1xuXG4gICAgICBpZiAoZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkpIHtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbmV4dGVuZChlbGVzZm4kaSwge1xuICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSksXG4gIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSlcbn0pO1xuZXh0ZW5kKGVsZXNmbiRpLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiB0b3RhbERlZ3JlZShpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZShpbmNsdWRlTG9vcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSk7XG5cbnZhciBmbiQyLCBlbGVzZm4kajtcblxudmFyIGJlZm9yZVBvc2l0aW9uU2V0ID0gZnVuY3Rpb24gYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBzaWxlbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoIWVsZS5sb2NrZWQoKSkge1xuICAgICAgdmFyIG9sZFBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgeDogbmV3UG9zLnggIT0gbnVsbCA/IG5ld1Bvcy54IC0gb2xkUG9zLnggOiAwLFxuICAgICAgICB5OiBuZXdQb3MueSAhPSBudWxsID8gbmV3UG9zLnkgLSBvbGRQb3MueSA6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSAmJiAhKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkpIHtcbiAgICAgICAgZWxlLmNoaWxkcmVuKCkuc2hpZnQoZGVsdGEsIHNpbGVudCk7XG4gICAgICB9XG5cbiAgICAgIGVsZS5zaGlmdENhY2hlZEJvdW5kaW5nQm94KGRlbHRhKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwb3NpdGlvbkRlZiA9IHtcbiAgZmllbGQ6ICdwb3NpdGlvbicsXG4gIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICBhbGxvd1NldHRpbmc6IHRydWUsXG4gIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gIHRyaWdnZXJGbk5hbWU6ICdlbWl0QW5kTm90aWZ5JyxcbiAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KGVsZSkge1xuICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICB9LFxuICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIGZhbHNlKTtcbiAgfSxcbiAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICB9LFxuICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgfVxufTtcbmZuJDIgPSBlbGVzZm4kaiA9IHtcbiAgcG9zaXRpb246IGRlZmluZSQzLmRhdGEocG9zaXRpb25EZWYpLFxuICAvLyBwb3NpdGlvbiBidXQgbm8gbm90aWZpY2F0aW9uIHRvIHJlbmRlcmVyXG4gIHNpbGVudFBvc2l0aW9uOiBkZWZpbmUkMy5kYXRhKGV4dGVuZCh7fSwgcG9zaXRpb25EZWYsIHtcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgdHJ1ZSk7XG4gICAgfVxuICB9KSksXG4gIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zKHBvcywgc2lsZW50KSB7XG4gICAgaWYgKHBsYWluT2JqZWN0KHBvcykpIHtcbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5zaWxlbnRQb3NpdGlvbihwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm4ocG9zKSkge1xuICAgICAgdmFyIF9mbiA9IHBvcztcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIHZhciBfcG9zID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChfcG9zID0gX2ZuKGVsZSwgaSkpIHtcbiAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5wb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiBzaWxlbnRQb3NpdGlvbnMocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKHBvcywgdHJ1ZSk7XG4gIH0sXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdChkaW0sIHZhbCwgc2lsZW50KSB7XG4gICAgdmFyIGRlbHRhO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KGRpbSkpIHtcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICB4OiBudW1iZXIoZGltLngpID8gZGltLnggOiAwLFxuICAgICAgICB5OiBudW1iZXIoZGltLnkpID8gZGltLnkgOiAwXG4gICAgICB9O1xuICAgICAgc2lsZW50ID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyKHZhbCkpIHtcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgZGVsdGFbZGltXSA9IHZhbDtcbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCArIGRlbHRhLngsXG4gICAgICAgICAgeTogcG9zLnkgKyBkZWx0YS55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNpbGVudFNoaWZ0OiBmdW5jdGlvbiBzaWxlbnRTaGlmdChkaW0sIHZhbCkge1xuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICB0aGlzLnNoaWZ0KGRpbSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIodmFsKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHZhbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiByZW5kZXJlZFBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcnBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBycG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG5cbiAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihkaW0sICh2YWwgLSBwYW5bZGltXSkgLyB6b29tKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHJwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwb3MsIHpvb20sIHBhbik7XG5cbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcnBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIHJlbGF0aXZlUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHBwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZWxlMiA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBfZWxlMi5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oZGltLCB2YWwgKyBvcmlnaW5bZGltXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgX2VsZTIucG9zaXRpb24oe1xuICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcblxuICAgICAgICB2YXIgX2hhc1BhcmVudCA9IF9wYXJlbnQgJiYgX3BhcmVudC5sZW5ndGggPiAwO1xuXG4gICAgICAgIHZhciBfcmVsYXRpdmVUb1BhcmVudCA9IF9oYXNQYXJlbnQ7XG5cbiAgICAgICAgaWYgKF9oYXNQYXJlbnQpIHtcbiAgICAgICAgICBfcGFyZW50ID0gX3BhcmVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfb3JpZ2luID0gX3JlbGF0aXZlVG9QYXJlbnQgPyBfcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCAtIF9vcmlnaW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAtIF9vcmlnaW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5mbiQyLm1vZGVsUG9zaXRpb24gPSBmbiQyLnBvaW50ID0gZm4kMi5wb3NpdGlvbjtcbmZuJDIubW9kZWxQb3NpdGlvbnMgPSBmbiQyLnBvaW50cyA9IGZuJDIucG9zaXRpb25zO1xuZm4kMi5yZW5kZXJlZFBvaW50ID0gZm4kMi5yZW5kZXJlZFBvc2l0aW9uO1xuZm4kMi5yZWxhdGl2ZVBvaW50ID0gZm4kMi5yZWxhdGl2ZVBvc2l0aW9uO1xudmFyIHBvc2l0aW9uID0gZWxlc2ZuJGo7XG5cbnZhciBmbiQzLCBlbGVzZm4kaztcbmZuJDMgPSBlbGVzZm4kayA9IHt9O1xuXG5lbGVzZm4kay5yZW5kZXJlZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveChvcHRpb25zKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcbiAgcmV0dXJuIHtcbiAgICB4MTogeDEsXG4gICAgeDI6IHgyLFxuICAgIHkxOiB5MSxcbiAgICB5MjogeTIsXG4gICAgdzogeDIgLSB4MSxcbiAgICBoOiB5MiAtIHkxXG4gIH07XG59O1xuXG5lbGVzZm4kay5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuZm9yRWFjaFVwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZWxlc2ZuJGsudXBkYXRlQ29tcG91bmRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gbm90IHBvc3NpYmxlIHRvIGRvIG9uIG5vbi1jb21wb3VuZCBncmFwaHMgb3Igd2l0aCB0aGUgc3R5bGUgZGlzYWJsZWRcblxuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIGJhdGNoaW5nIC0tIGJ1dCBib3VuZHMgd2lsbCBiZSBzdGFsZSAob3Igbm90IGV4aXN0IHlldClcblxuXG4gIGlmICghZm9yY2UgJiYgY3kuYmF0Y2hpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LmlzUGFyZW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX3AgPSBwYXJlbnQuX3ByaXZhdGU7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycpLnZhbHVlID09PSAnaW5jbHVkZSc7XG4gICAgdmFyIG1pbiA9IHtcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgbGVmdDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtbGVmdCcpLFxuICAgICAgICByaWdodDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtcmlnaHQnKVxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQnKS5wZlZhbHVlLFxuICAgICAgICB0b3A6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy10b3AnKSxcbiAgICAgICAgYm90dG9tOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJylcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KHtcbiAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsXG4gICAgICBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlLFxuICAgICAgLy8gdXBkYXRpbmcgdGhlIGNvbXBvdW5kIGJvdW5kcyBoYXBwZW5zIG91dHNpZGUgb2YgdGhlIHJlZ3VsYXJcbiAgICAgIC8vIGNhY2hlIGN5Y2xlIChpLmUuIGJlZm9yZSBmaXJlZCBldmVudHMpXG4gICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247IC8vIGlmIGNoaWxkcmVuIHRha2UgdXAgemVybyBhcmVhIHRoZW4ga2VlcCBwb3NpdGlvbiBhbmQgZmFsbCBiYWNrIG9uIHN0eWxlc2hlZXQgdy9oXG5cbiAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICBiYiA9IHtcbiAgICAgICAgdzogcGFyZW50LnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICBoOiBwYXJlbnQucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlXG4gICAgICB9O1xuICAgICAgYmIueDEgPSBwb3MueCAtIGJiLncgLyAyO1xuICAgICAgYmIueDIgPSBwb3MueCArIGJiLncgLyAyO1xuICAgICAgYmIueTEgPSBwb3MueSAtIGJiLmggLyAyO1xuICAgICAgYmIueTIgPSBwb3MueSArIGJiLmggLyAyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVCaWFzVmFsdWVzKHByb3BEaWZmLCBwcm9wQmlhcywgcHJvcEJpYXNDb21wbGVtZW50KSB7XG4gICAgICB2YXIgYmlhc0RpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNDb21wbGVtZW50RGlmZiA9IDA7XG4gICAgICB2YXIgYmlhc1RvdGFsID0gcHJvcEJpYXMgKyBwcm9wQmlhc0NvbXBsZW1lbnQ7XG5cbiAgICAgIGlmIChwcm9wRGlmZiA+IDAgJiYgYmlhc1RvdGFsID4gMCkge1xuICAgICAgICBiaWFzRGlmZiA9IHByb3BCaWFzIC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICAgIGJpYXNDb21wbGVtZW50RGlmZiA9IHByb3BCaWFzQ29tcGxlbWVudCAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBiaWFzRGlmZjogYmlhc0RpZmYsXG4gICAgICAgIGJpYXNDb21wbGVtZW50RGlmZjogYmlhc0NvbXBsZW1lbnREaWZmXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQYWRkaW5nVmFsdWVzKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdPYmplY3QsIHJlbGF0aXZlVG8pIHtcbiAgICAgIC8vIEFzc3VtaW5nIHBlcmNlbnRhZ2UgaXMgbnVtYmVyIGZyb20gMCB0byAxXG4gICAgICBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJyUnKSB7XG4gICAgICAgIHN3aXRjaCAocmVsYXRpdmVUbykge1xuICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG5cbiAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuXG4gICAgICAgICAgY2FzZSAnYXZlcmFnZSc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiAod2lkdGggKyBoZWlnaHQpIC8gMiA6IDA7XG5cbiAgICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IDA7XG5cbiAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJ3B4Jykge1xuICAgICAgICByZXR1cm4gcGFkZGluZ09iamVjdC5wZlZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxlZnRWYWwgPSBtaW4ud2lkdGgubGVmdC52YWx1ZTtcblxuICAgIGlmIChtaW4ud2lkdGgubGVmdC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgbGVmdFZhbCA9IGxlZnRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgIH1cblxuICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcblxuICAgIGlmIChtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIHJpZ2h0VmFsID0gcmlnaHRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgIH1cblxuICAgIHZhciB0b3BWYWwgPSBtaW4uaGVpZ2h0LnRvcC52YWx1ZTtcblxuICAgIGlmIChtaW4uaGVpZ2h0LnRvcC51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgIHRvcFZhbCA9IHRvcFZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgIH1cblxuICAgIHZhciBib3R0b21WYWwgPSBtaW4uaGVpZ2h0LmJvdHRvbS52YWx1ZTtcblxuICAgIGlmIChtaW4uaGVpZ2h0LmJvdHRvbS51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgIGJvdHRvbVZhbCA9IGJvdHRvbVZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgIH1cblxuICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi53aWR0aC52YWwgLSBiYi53LCBsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgdmFyIGRpZmZMZWZ0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICB2YXIgaGVpZ2h0Qmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLmhlaWdodC52YWwgLSBiYi5oLCB0b3BWYWwsIGJvdHRvbVZhbCk7XG4gICAgdmFyIGRpZmZUb3AgPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgdmFyIGRpZmZCb3R0b20gPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgIF9wLmF1dG9QYWRkaW5nID0gY29tcHV0ZVBhZGRpbmdWYWx1ZXMoYmIudywgYmIuaCwgcGFyZW50LnBzdHlsZSgncGFkZGluZycpLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nLXJlbGF0aXZlLXRvJykudmFsdWUpO1xuICAgIF9wLmF1dG9XaWR0aCA9IE1hdGgubWF4KGJiLncsIG1pbi53aWR0aC52YWwpO1xuICAgIHBvcy54ID0gKC1kaWZmTGVmdCArIGJiLngxICsgYmIueDIgKyBkaWZmUmlnaHQpIC8gMjtcbiAgICBfcC5hdXRvSGVpZ2h0ID0gTWF0aC5tYXgoYmIuaCwgbWluLmhlaWdodC52YWwpO1xuICAgIHBvcy55ID0gKC1kaWZmVG9wICsgYmIueTEgKyBiYi55MiArIGRpZmZCb3R0b20pIC8gMjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuY29tcG91bmRCb3VuZHNDbGVhbikge1xuICAgICAgdXBkYXRlKGVsZSk7XG5cbiAgICAgIGlmICghY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBub25pbmYgPSBmdW5jdGlvbiBub25pbmYoeCkge1xuICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHMoYiwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gIGlmICh4MiAtIHgxID09PSAwIHx8IHkyIC0geTEgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZG9uJ3QgdXBkYXRlIHdpdGggbnVsbCBkaW1cblxuXG4gIGlmICh4MSA9PSBudWxsIHx8IHkxID09IG51bGwgfHwgeDIgPT0gbnVsbCB8fCB5MiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYi54MSA9IHgxIDwgYi54MSA/IHgxIDogYi54MTtcbiAgYi54MiA9IHgyID4gYi54MiA/IHgyIDogYi54MjtcbiAgYi55MSA9IHkxIDwgYi55MSA/IHkxIDogYi55MTtcbiAgYi55MiA9IHkyID4gYi55MiA/IHkyIDogYi55MjtcbiAgYi53ID0gYi54MiAtIGIueDE7XG4gIGIuaCA9IGIueTIgLSBiLnkxO1xufTtcblxudmFyIHVwZGF0ZUJvdW5kc0Zyb21Cb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQm94KGIsIGIyKSB7XG4gIGlmIChiMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlQm91bmRzKGIsIGIyLngxLCBiMi55MSwgYjIueDIsIGIyLnkyKTtcbn07XG5cbnZhciBwcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gcHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KTtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tQXJyb3cgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGhhbGZBclcgPSByc3R5bGUuYXJyb3dXaWR0aCAvIDI7XG4gIHZhciBhcnJvd1R5cGUgPSBlbGUucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHg7XG4gIHZhciB5O1xuXG4gIGlmIChhcnJvd1R5cGUgIT09ICdub25lJykge1xuICAgIGlmIChwcmVmaXggPT09ICdzb3VyY2UnKSB7XG4gICAgICB4ID0gcnN0eWxlLnNyY1g7XG4gICAgICB5ID0gcnN0eWxlLnNyY1k7XG4gICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICd0YXJnZXQnKSB7XG4gICAgICB4ID0gcnN0eWxlLnRndFg7XG4gICAgICB5ID0gcnN0eWxlLnRndFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByc3R5bGUubWlkWDtcbiAgICAgIHkgPSByc3R5bGUubWlkWTtcbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgaW5kaXZpZHVhbCBhcnJvdyBib3VuZHNcblxuXG4gICAgdmFyIGJicyA9IF9wLmFycm93Qm91bmRzID0gX3AuYXJyb3dCb3VuZHMgfHwge307XG4gICAgdmFyIGJiID0gYmJzW3ByZWZpeF0gPSBiYnNbcHJlZml4XSB8fCB7fTtcbiAgICBiYi54MSA9IHggLSBoYWxmQXJXO1xuICAgIGJiLnkxID0geSAtIGhhbGZBclc7XG4gICAgYmIueDIgPSB4ICsgaGFsZkFyVztcbiAgICBiYi55MiA9IHkgKyBoYWxmQXJXO1xuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiLCAxKTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBiYi54MSwgYmIueTEsIGJiLngyLCBiYi55Mik7XG4gIH1cbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmVmaXhEYXNoO1xuXG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICB9IGVsc2Uge1xuICAgIHByZWZpeERhc2ggPSAnJztcbiAgfVxuXG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykuc3RyVmFsdWU7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJyk7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJyk7XG4gICAgdmFyIGxhYmVsV2lkdGggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbEhlaWdodCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsWSA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgdmFyIHBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICB2YXIgbHdfMiA9IGx3IC8gMjtcbiAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gc2hpZnQgYnkgbWFyZ2luIGFuZCBleHBhbmQgYnkgb3V0bGluZSBhbmQgYm9yZGVyXG5cblxuICAgIGx4MSArPSBtYXJnaW5YIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZztcbiAgICBseDIgKz0gbWFyZ2luWCArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmc7XG4gICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nO1xuICAgIGx5MiArPSBtYXJnaW5ZICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZzsgLy8gYWx3YXlzIHN0b3JlIHRoZSB1bnJvdGF0ZWQgbGFiZWwgYm91bmRzIHNlcGFyYXRlbHlcblxuICAgIHZhciBiYlByZWZpeCA9IHByZWZpeCB8fCAnbWFpbic7XG4gICAgdmFyIGJicyA9IF9wLmxhYmVsQm91bmRzO1xuICAgIHZhciBiYiA9IGJic1tiYlByZWZpeF0gPSBiYnNbYmJQcmVmaXhdIHx8IHt9O1xuICAgIGJiLngxID0gbHgxO1xuICAgIGJiLnkxID0gbHkxO1xuICAgIGJiLngyID0gbHgyO1xuICAgIGJiLnkyID0gbHkyO1xuICAgIGJiLncgPSBseDIgLSBseDE7XG4gICAgYmIuaCA9IGx5MiAtIGx5MTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYiwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIHZhciBpc0F1dG9yb3RhdGUgPSBpc0VkZ2UgJiYgcm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgICB2YXIgaXNQZlZhbHVlID0gcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDA7XG5cbiAgICBpZiAoaXNBdXRvcm90YXRlIHx8IGlzUGZWYWx1ZSkge1xuICAgICAgdmFyIHRoZXRhID0gaXNBdXRvcm90YXRlID8gcHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4KSA6IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTsgLy8gcm90YXRpb24gcG9pbnQgKGRlZmF1bHQgdmFsdWUgZm9yIGNlbnRlci1jZW50ZXIpXG5cbiAgICAgIHZhciB4byA9IChseDEgKyBseDIpIC8gMjtcbiAgICAgIHZhciB5byA9IChseTEgKyBseTIpIC8gMjtcblxuICAgICAgaWYgKCFpc0VkZ2UpIHtcbiAgICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHhvID0gbHgyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4byA9IGx4MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgeW8gPSBseTI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB5byA9IGx5MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIHhvO1xuICAgICAgICB5ID0geSAtIHlvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgeG8sXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyB5b1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgIGx4MSA9IE1hdGgubWluKHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHgyID0gTWF0aC5tYXgocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseTEgPSBNYXRoLm1pbihweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgIGx5MiA9IE1hdGgubWF4KHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgIH1cblxuICAgIHZhciBiYlByZWZpeFJvdCA9IGJiUHJlZml4ICsgJ1JvdCc7XG4gICAgdmFyIGJiUm90ID0gYmJzW2JiUHJlZml4Um90XSA9IGJic1tiYlByZWZpeFJvdF0gfHwge307XG4gICAgYmJSb3QueDEgPSBseDE7XG4gICAgYmJSb3QueTEgPSBseTE7XG4gICAgYmJSb3QueDIgPSBseDI7XG4gICAgYmJSb3QueTIgPSBseTI7XG4gICAgYmJSb3QudyA9IGx4MiAtIGx4MTtcbiAgICBiYlJvdC5oID0gbHkyIC0gbHkxO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gICAgdXBkYXRlQm91bmRzKF9wLmxhYmVsQm91bmRzLmFsbCwgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59OyAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcblxuXG52YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0aW9ucykge1xuICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgdmFyIGhlYWRsZXNzID0gY3kuaGVhZGxlc3MoKTtcbiAgdmFyIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBleDEsIGV4MiwgZXkxLCBleTI7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG5cbiAgdmFyIHgsIHk7IC8vIG5vZGUgcG9zXG5cbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIG1hbnVhbEV4cGFuc2lvbiA9IGlzTm9kZSAmJiBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCdib3VuZHMtZXhwYW5zaW9uJykucGZWYWx1ZSA6IFswXTsgLy8gbXVzdCB1c2UgYGRpc3BsYXlgIHByb3Agb25seSwgYXMgcmVhZGluZyBgY29tcG91bmQud2lkdGgoKWAgY2F1c2VzIHJlY3Vyc2lvblxuICAvLyAob3RoZXIgZmFjdG9ycyBsaWtlIHdpZHRoIHZhbHVlcyB3aWxsIGJlIGNvbnNpZGVyZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbiBhbnl3YXkpXG5cbiAgdmFyIGlzRGlzcGxheWVkID0gZnVuY3Rpb24gaXNEaXNwbGF5ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSAhPT0gJ25vbmUnO1xuICB9O1xuXG4gIHZhciBkaXNwbGF5ZWQgPSAhc3R5bGVFbmFibGVkIHx8IGlzRGlzcGxheWVkKGVsZSkgLy8gbXVzdCB0YWtlIGludG8gYWNjb3VudCBjb25uZWN0ZWQgbm9kZXMgYi9jIG9mIGltcGxpY2l0IGVkZ2UgaGlkaW5nIG9uIGRpc3BsYXk6bm9uZSBub2RlXG4gICYmICghaXNFZGdlIHx8IGlzRGlzcGxheWVkKGVsZS5zb3VyY2UoKSkgJiYgaXNEaXNwbGF5ZWQoZWxlLnRhcmdldCgpKSk7XG5cbiAgaWYgKGRpc3BsYXllZCkge1xuICAgIC8vIGRpc3BsYXllZCBzdWZmaWNlcywgc2luY2Ugd2Ugd2lsbCBmaW5kIHplcm8gYXJlYSBlbGVzIGFueXdheVxuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IDA7XG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gMDtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgIG92ZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgICAgIGlmIChvdmVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBvdmVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgd0hhbGYgPSAwO1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgdyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIHdIYWxmID0gdyAvIDI7XG4gICAgfVxuXG4gICAgaWYgKGlzTm9kZSAmJiBvcHRpb25zLmluY2x1ZGVOb2Rlcykge1xuICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgeCA9IHBvcy54O1xuICAgICAgeSA9IHBvcy55O1xuXG4gICAgICB2YXIgX3cgPSBlbGUub3V0ZXJXaWR0aCgpO1xuXG4gICAgICB2YXIgaGFsZlcgPSBfdyAvIDI7XG4gICAgICB2YXIgaCA9IGVsZS5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIGhhbGZIID0gaCAvIDI7IC8vIGhhbmRsZSBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgZXgyID0geCArIGhhbGZXO1xuICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgZXkyID0geSArIGhhbGZIO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICB9IGVsc2UgaWYgKGlzRWRnZSAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcykge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiAhaGVhZGxlc3MpIHtcbiAgICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnN0clZhbHVlOyAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBleDEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV5MSA9IE1hdGgubWluKHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuICAgICAgICBleTIgPSBNYXRoLm1heChyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTsgLy8gdGFrZSBpbnRvIGFjY291bnQgZWRnZSB3aWR0aFxuXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTsgLy8gcHJlY2lzZSBlZGdlc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICB2YXIgaHB0cyA9IHJzdHlsZS5oYXlzdGFja1B0cztcblxuICAgICAgICAgIGlmIChocHRzICYmIGhwdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBleDEgPSBocHRzWzBdLng7XG4gICAgICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgICAgICBleDIgPSBocHRzWzFdLng7XG4gICAgICAgICAgICBleTIgPSBocHRzWzFdLnk7XG5cbiAgICAgICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgICAgICB2YXIgX3RlbXAgPSBleTE7XG4gICAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgICAgZXkyID0gX3RlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHdIYWxmLCBleTEgLSB3SGFsZiwgZXgyICsgd0hhbGYsIGV5MiArIHdIYWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmVTdHlsZSA9PT0gJ2JlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgfHwgY3VydmVTdHlsZSA9PT0gJ3RheGknKSB7XG4gICAgICAgICAgdmFyIHB0cztcblxuICAgICAgICAgIHN3aXRjaCAoY3VydmVTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3VuYnVuZGxlZC1iZXppZXInOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUuYmV6aWVyUHRzO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICAgICAgY2FzZSAndGF4aSc6XG4gICAgICAgICAgICAgIHB0cyA9IHJzdHlsZS5saW5lUHRzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBwdCA9IHB0c1tqXTtcbiAgICAgICAgICAgICAgZXgxID0gcHQueCAtIHdIYWxmO1xuICAgICAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgICAgIGV5MSA9IHB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXkyID0gcHQueSArIHdIYWxmO1xuICAgICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBiZXppZXItbGlrZSBvciBzZWdtZW50LWxpa2UgZWRnZVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuICAgICAgICAvLyBmYWxsYmFjayBvbiBzb3VyY2UgYW5kIHRhcmdldCBwb3NpdGlvbnNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIHZhciBuMSA9IGVsZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIG4xcG9zID0gbjEucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG4yID0gZWxlLnRhcmdldCgpO1xuICAgICAgICB2YXIgbjJwb3MgPSBuMi5wb3NpdGlvbigpO1xuICAgICAgICBleDEgPSBuMXBvcy54O1xuICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICBleTIgPSBuMnBvcy55O1xuXG4gICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICB2YXIgX3RlbXAyID0gZXgxO1xuICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICBleDIgPSBfdGVtcDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMyA9IGV5MTtcbiAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgZXkyID0gX3RlbXAzO1xuICAgICAgICB9IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgIH0gLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcblxuICAgIH0gLy8gZWRnZXNcbiAgICAvLyBoYW5kbGUgZWRnZSBhcnJvdyBzaXplXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzICYmIGlzRWRnZSkge1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXNvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXRhcmdldCcpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICB9IC8vIGdob3N0XG4gICAgLy8vLy8vLy9cblxuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgdmFyIGdob3N0ID0gZWxlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgICAgIGlmIChnaG9zdCkge1xuICAgICAgICB2YXIgZ3ggPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgICAgIHZhciBneSA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYm91bmRzLngxICsgZ3gsIGJvdW5kcy55MSArIGd5LCBib3VuZHMueDIgKyBneCwgYm91bmRzLnkyICsgZ3kpO1xuICAgICAgfVxuICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuXG5cbiAgICB2YXIgYmJCb2R5ID0gX3AuYm9keUJvdW5kcyA9IF9wLmJvZHlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJCb2R5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJCb2R5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiQm9keSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcbiAgICAvLyBvdmVybGF5XG4gICAgLy8vLy8vLy8vL1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgZXgxID0gYm91bmRzLngxO1xuICAgICAgZXgyID0gYm91bmRzLngyO1xuICAgICAgZXkxID0gYm91bmRzLnkxO1xuICAgICAgZXkyID0gYm91bmRzLnkyO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gb3ZlcmxheVBhZGRpbmcsIGV5MSAtIG92ZXJsYXlQYWRkaW5nLCBleDIgKyBvdmVybGF5UGFkZGluZywgZXkyICsgb3ZlcmxheVBhZGRpbmcpO1xuICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuXG5cbiAgICB2YXIgYmJPdmVybGF5ID0gX3Aub3ZlcmxheUJvdW5kcyA9IF9wLm92ZXJsYXlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJPdmVybGF5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJPdmVybGF5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiT3ZlcmxheSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcbiAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgYmJMYWJlbHMgPSBfcC5sYWJlbEJvdW5kcyA9IF9wLmxhYmVsQm91bmRzIHx8IHt9O1xuXG4gICAgaWYgKGJiTGFiZWxzLmFsbCAhPSBudWxsKSB7XG4gICAgICBjbGVhckJvdW5kaW5nQm94KGJiTGFiZWxzLmFsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJiTGFiZWxzLmFsbCA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG5cbiAgfSAvLyBpZiBkaXNwbGF5ZWRcblxuXG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuXG4gIGlmIChib3VuZHMudyA+IDAgJiYgYm91bmRzLmggPiAwICYmIGRpc3BsYXllZCkge1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBtYW51YWxFeHBhbnNpb24pOyAvLyBleHBhbmQgYm91bmRzIGJ5IDEgYmVjYXVzZSBhbnRpYWxpYXNpbmcgY2FuIGluY3JlYXNlIHRoZSB2aXN1YWwvZWZmZWN0aXZlIHNpemUgYnkgMSBvbiBhbGwgc2lkZXNcblxuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJvdW5kcywgMSk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTtcblxudmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShvcHRzKSB7XG4gIHZhciBpID0gMDtcblxuICB2YXIgdGYgPSBmdW5jdGlvbiB0Zih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCA/IDEgOiAwKSA8PCBpKys7XG4gIH07XG5cbiAgdmFyIGtleSA9IDA7XG4gIGtleSArPSB0ZihvcHRzLmluY3VkZU5vZGVzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUVkZ2VzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVNYWluTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlT3ZlcmxheXMpO1xuICByZXR1cm4ga2V5O1xufTtcblxudmFyIGdldEJvdW5kaW5nQm94UG9zS2V5ID0gZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgcDEgPSBlbGUuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICB2YXIgcDIgPSBlbGUudGFyZ2V0KCkucG9zaXRpb24oKTtcblxuICAgIHZhciByID0gZnVuY3Rpb24gcih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocDEueCksIHIocDEueSksIHIocDIueCksIHIocDIueSldKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxudmFyIGNhY2hlZEJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgYmI7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBrZXkgPSBvcHRzID09IG51bGwgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkob3B0cyk7XG4gIHZhciB1c2luZ0RlZk9wdHMgPSBrZXkgPT09IGRlZkJiT3B0c0tleTtcbiAgdmFyIGN1cnJQb3NLZXkgPSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICB2YXIgaXNQb3NLZXlTYW1lID0gX3AuYmJDYWNoZVBvc0tleSA9PT0gY3VyclBvc0tleTtcbiAgdmFyIHVzZUNhY2hlID0gb3B0cy51c2VDYWNoZSAmJiBpc1Bvc0tleVNhbWU7XG5cbiAgdmFyIGlzRGlydHkgPSBmdW5jdGlvbiBpc0RpcnR5KGVsZSkge1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmJDYWNoZSA9PSBudWxsO1xuICB9O1xuXG4gIHZhciBuZWVkUmVjYWxjID0gIXVzZUNhY2hlIHx8IGlzRGlydHkoZWxlKSB8fCBpc0VkZ2UgJiYgaXNEaXJ0eShlbGUuc291cmNlKCkpIHx8IGlzRGlydHkoZWxlLnRhcmdldCgpKTtcblxuICBpZiAobmVlZFJlY2FsYykge1xuICAgIGlmICghaXNQb3NLZXlTYW1lKSB7XG4gICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgfVxuXG4gICAgYmIgPSBib3VuZGluZ0JveEltcGwoZWxlLCBkZWZCYk9wdHMpO1xuICAgIF9wLmJiQ2FjaGUgPSBiYjtcbiAgICBfcC5iYkNhY2hlU2hpZnQueCA9IF9wLmJiQ2FjaGVTaGlmdC55ID0gMDtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gY3VyclBvc0tleTtcbiAgfSBlbHNlIHtcbiAgICBiYiA9IF9wLmJiQ2FjaGU7XG4gIH1cblxuICBpZiAoIW5lZWRSZWNhbGMgJiYgKF9wLmJiQ2FjaGVTaGlmdC54ICE9PSAwIHx8IF9wLmJiQ2FjaGVTaGlmdC55ICE9PSAwKSkge1xuICAgIHZhciBzaGlmdCA9IGFzc2lnblNoaWZ0VG9Cb3VuZGluZ0JveDtcbiAgICB2YXIgZGVsdGEgPSBfcC5iYkNhY2hlU2hpZnQ7XG5cbiAgICB2YXIgc2FmZVNoaWZ0ID0gZnVuY3Rpb24gc2FmZVNoaWZ0KGJiLCBkZWx0YSkge1xuICAgICAgaWYgKGJiICE9IG51bGwpIHtcbiAgICAgICAgc2hpZnQoYmIsIGRlbHRhKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2hpZnQoYmIsIGRlbHRhKTtcbiAgICB2YXIgYm9keUJvdW5kcyA9IF9wLmJvZHlCb3VuZHMsXG4gICAgICAgIG92ZXJsYXlCb3VuZHMgPSBfcC5vdmVybGF5Qm91bmRzLFxuICAgICAgICBsYWJlbEJvdW5kcyA9IF9wLmxhYmVsQm91bmRzLFxuICAgICAgICBhcnJvd0JvdW5kcyA9IF9wLmFycm93Qm91bmRzO1xuICAgIHNhZmVTaGlmdChib2R5Qm91bmRzLCBkZWx0YSk7XG4gICAgc2FmZVNoaWZ0KG92ZXJsYXlCb3VuZHMsIGRlbHRhKTtcblxuICAgIGlmIChhcnJvd0JvdW5kcyAhPSBudWxsKSB7XG4gICAgICBzYWZlU2hpZnQoYXJyb3dCb3VuZHMuc291cmNlLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQoYXJyb3dCb3VuZHMudGFyZ2V0LCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQoYXJyb3dCb3VuZHNbJ21pZC1zb3VyY2UnXSwgZGVsdGEpO1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10sIGRlbHRhKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxCb3VuZHMgIT0gbnVsbCkge1xuICAgICAgc2FmZVNoaWZ0KGxhYmVsQm91bmRzLm1haW4sIGRlbHRhKTtcbiAgICAgIHNhZmVTaGlmdChsYWJlbEJvdW5kcy5hbGwsIGRlbHRhKTtcbiAgICAgIHNhZmVTaGlmdChsYWJlbEJvdW5kcy5zb3VyY2UsIGRlbHRhKTtcbiAgICAgIHNhZmVTaGlmdChsYWJlbEJvdW5kcy50YXJnZXQsIGRlbHRhKTtcbiAgICB9XG4gIH0gLy8gYWx3YXlzIHJlc2V0IHRoZSBzaGlmdCwgYmVjYXVzZSB3ZSBlaXRoZXIgYXBwbGllZCB0aGUgc2hpZnQgb3IgY2xlYXJlZCBpdCBieSBkb2luZyBhIGZyZXNoIHJlY2FsY1xuXG5cbiAgX3AuYmJDYWNoZVNoaWZ0LnggPSBfcC5iYkNhY2hlU2hpZnQueSA9IDA7IC8vIG5vdCB1c2luZyBkZWYgb3B0cyA9PiBuZWVkIHRvIGJ1aWxkIHVwIGJiIGZyb20gY29tYmluYXRpb24gb2Ygc3ViIGJic1xuXG4gIGlmICghdXNpbmdEZWZPcHRzKSB7XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZU5vZGVzICYmIGlzTm9kZSB8fCBvcHRzLmluY2x1ZGVFZGdlcyAmJiAhaXNOb2RlKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3Aub3ZlcmxheUJvdW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5ib2R5Qm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscyAmJiAoIWlzRWRnZSB8fCBvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMgJiYgb3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5hbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5tYWluUm90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgfVxuXG4gIHJldHVybiBiYjtcbn07XG5cbnZhciBkZWZCYk9wdHMgPSB7XG4gIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlTWFpbkxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVNvdXJjZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVRhcmdldExhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICB1c2VDYWNoZTogdHJ1ZVxufTtcbnZhciBkZWZCYk9wdHNLZXkgPSBnZXRLZXkoZGVmQmJPcHRzKTtcbnZhciBmaWxsZWRCYk9wdHMgPSBkZWZhdWx0cyhkZWZCYk9wdHMpO1xuXG5lbGVzZm4kay5ib3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBib3VuZHM7IC8vIHRoZSBtYWluIHVzZWNhc2UgaXMgZWxlLmJvdW5kaW5nQm94KCkgZm9yIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBuby9kZWYgb3B0aW9uc1xuICAvLyBzcGVjaWZpZWQgcy50LiB0aGUgY2FjaGUgaXMgdXNlZCwgc28gY2hlY2sgZm9yIHRoaXMgY2FzZSB0byBtYWtlIGl0IGZhc3RlciBieVxuICAvLyBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXNbMF0uX3ByaXZhdGUuYmJDYWNoZSAhPSBudWxsICYmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHRydWUpKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IGRlZkJiT3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICBib3VuZHMgPSBjYWNoZWRCb3VuZGluZ0JveEltcGwodGhpc1swXSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmQmJPcHRzO1xuICAgIHZhciBvcHRzID0gZmlsbGVkQmJPcHRzKG9wdGlvbnMpO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgICAgICAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gICAgICAgIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lO1xuICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZWxlID0gZWxlc1tfaV07XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKF9lbGUsIG9wdHMpKTtcbiAgICB9XG4gIH1cblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbmVsZXNmbiRrLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gdGhpc1tpXS5fcHJpdmF0ZTtcbiAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICBfcC5iYkNhY2hlU2hpZnQueCA9IF9wLmJiQ2FjaGVTaGlmdC55ID0gMDtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gbnVsbDtcbiAgICBfcC5ib2R5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5vdmVybGF5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5hbGwgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5tYWluID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpblJvdCA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtc291cmNlJ10gPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10gPSBudWxsO1xuICB9XG5cbiAgdGhpcy5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5lbGVzZm4kay5zaGlmdENhY2hlZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgYmIgPSBfcC5iYkNhY2hlO1xuXG4gICAgaWYgKGJiICE9IG51bGwpIHtcbiAgICAgIF9wLmJiQ2FjaGVTaGlmdC54ICs9IGRlbHRhLng7XG4gICAgICBfcC5iYkNhY2hlU2hpZnQueSArPSBkZWx0YS55O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gcHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGJveCBmb3IgY3VzdG9tIG5vZGUgcG9zaXRpb25zXG4vLyAtIGdvb2QgZm9yIHBlcmYgaW4gY2VydGFpbiBjYXNlcyBidXQgY3VycmVudGx5IHJlcXVpcmVzIGRpcnR5aW5nIHRoZSByZW5kZXJlZCBzdHlsZVxuLy8gLSB3b3VsZCBiZSBiZXR0ZXIgdG8gbm90IG1vZGlmeSB0aGUgbm9kZXMgYnV0IHRoZSBub2RlcyBhcmUgcmVhZCBkaXJlY3RseSBldmVyeXdoZXJlIGluIHRoZSByZW5kZXJlci4uLlxuLy8gLSB0cnkgdG8gdXNlIGZvciBvbmx5IHRoaW5ncyBsaWtlIGRpc2NyZXRlIGxheW91dHMgd2hlcmUgdGhlIG5vZGUgcG9zaXRpb24gd291bGQgY2hhbmdlIGFueXdheVxuXG5cbmVsZXNmbiRrLmJvdW5kaW5nQm94QXQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiAhbm9kZS5pc1BhcmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBsYWluT2JqZWN0KGZuKSkge1xuICAgIHZhciBvYmogPSBmbjtcblxuICAgIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH1cblxuICB2YXIgc3RvcmVPbGRQb3MgPSBmdW5jdGlvbiBzdG9yZU9sZFBvcyhub2RlLCBpKSB7XG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuYmJBdE9sZFBvcyA9IGZuKG5vZGUsIGkpO1xuICB9O1xuXG4gIHZhciBnZXRPbGRQb3MgPSBmdW5jdGlvbiBnZXRPbGRQb3Mobm9kZSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3M7XG4gIH07XG5cbiAgY3kuc3RhcnRCYXRjaCgpO1xuICBub2Rlcy5mb3JFYWNoKHN0b3JlT2xkUG9zKS5zaWxlbnRQb3NpdGlvbnMoZm4pO1xuXG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICB9XG5cbiAgdmFyIGJiID0gY29weUJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3goe1xuICAgIHVzZUNhY2hlOiBmYWxzZVxuICB9KSk7XG4gIG5vZGVzLnNpbGVudFBvc2l0aW9ucyhnZXRPbGRQb3MpO1xuICBjeS5lbmRCYXRjaCgpO1xuICByZXR1cm4gYmI7XG59O1xuXG5mbiQzLmJvdW5kaW5nYm94ID0gZm4kMy5iYiA9IGZuJDMuYm91bmRpbmdCb3g7XG5mbiQzLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbiQzLnJlbmRlcmVkQm91bmRpbmdCb3g7XG52YXIgYm91bmRzID0gZWxlc2ZuJGs7XG5cbnZhciBmbiQ0LCBlbGVzZm4kbDtcbmZuJDQgPSBlbGVzZm4kbCA9IHt9O1xuXG52YXIgZGVmaW5lRGltRm5zID0gZnVuY3Rpb24gZGVmaW5lRGltRm5zKG9wdHMpIHtcbiAgb3B0cy51cHBlcmNhc2VOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm5hbWUpO1xuICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSBjYXBpdGFsaXplKG9wdHMub3V0ZXJOYW1lKTtcblxuICBmbiQ0W29wdHMubmFtZV0gPSBmdW5jdGlvbiBkaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICByZXR1cm4gX3Bbb3B0cy5hdXRvTmFtZV0gfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkID0gZWxlLnBzdHlsZShvcHRzLm5hbWUpO1xuXG4gICAgICAgIHN3aXRjaCAoZC5zdHJWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfcC5yc3R5bGVbb3B0cy5sYWJlbE5hbWVdIHx8IDA7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGQucGZWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuJDRbJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiBvdXRlckRpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHZhciBkaW0gPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgICB2YXIgYm9yZGVyID0gZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTsgLy8gbi5iLiAxLzIgZWFjaCBzaWRlXG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBhZGRpbmcoKTtcbiAgICAgICAgcmV0dXJuIGRpbSArIGJvcmRlciArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZm4kNFsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBkID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG5cbiAgZm4kNFsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VPdXRlck5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgb2QgPSBlbGVbb3B0cy5vdXRlck5hbWVdKCk7XG4gICAgICByZXR1cm4gb2QgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICd3aWR0aCdcbn0pO1xuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ2hlaWdodCdcbn0pO1xuXG5lbGVzZm4kbC5wYWRkaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgaWYgKF9wLmF1dG9QYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5hdXRvUGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gIH1cbn07XG5cbmVsZXNmbiRsLnBhZGRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUuaGVpZ2h0KCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbn07XG5cbmVsZXNmbiRsLnBhZGRlZFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZS53aWR0aCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuXG52YXIgd2lkdGhIZWlnaHQgPSBlbGVzZm4kbDtcblxudmFyIGlmRWRnZSA9IGZ1bmN0aW9uIGlmRWRnZShlbGUsIGdldFZhbHVlKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICByZXR1cm4gZ2V0VmFsdWUoZWxlKTtcbiAgfVxufTtcblxudmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKGVsZSwgZ2V0UG9pbnQpIHtcbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihnZXRQb2ludChlbGUpLCBjeS56b29tKCksIGN5LnBhbigpKTtcbiAgfVxufTtcblxudmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMoZWxlLCBnZXRQb2ludHMpIHtcbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICByZXR1cm4gZ2V0UG9pbnRzKGVsZSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocCwgem9vbSwgcGFuKTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIGNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiBjb250cm9sUG9pbnRzKGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0Q29udHJvbFBvaW50cyhlbGUpO1xufTtcblxudmFyIHNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiBzZWdtZW50UG9pbnRzKGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U2VnbWVudFBvaW50cyhlbGUpO1xufTtcblxudmFyIHNvdXJjZUVuZHBvaW50ID0gZnVuY3Rpb24gc291cmNlRW5kcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRTb3VyY2VFbmRwb2ludChlbGUpO1xufTtcblxudmFyIHRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gdGFyZ2V0RW5kcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRUYXJnZXRFbmRwb2ludChlbGUpO1xufTtcblxudmFyIG1pZHBvaW50ID0gZnVuY3Rpb24gbWlkcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRFZGdlTWlkcG9pbnQoZWxlKTtcbn07XG5cbnZhciBwdHMgPSB7XG4gIGNvbnRyb2xQb2ludHM6IHtcbiAgICBnZXQ6IGNvbnRyb2xQb2ludHMsXG4gICAgbXVsdDogdHJ1ZVxuICB9LFxuICBzZWdtZW50UG9pbnRzOiB7XG4gICAgZ2V0OiBzZWdtZW50UG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc291cmNlRW5kcG9pbnQ6IHtcbiAgICBnZXQ6IHNvdXJjZUVuZHBvaW50XG4gIH0sXG4gIHRhcmdldEVuZHBvaW50OiB7XG4gICAgZ2V0OiB0YXJnZXRFbmRwb2ludFxuICB9LFxuICBtaWRwb2ludDoge1xuICAgIGdldDogbWlkcG9pbnRcbiAgfVxufTtcblxudmFyIHJlbmRlcmVkTmFtZSA9IGZ1bmN0aW9uIHJlbmRlcmVkTmFtZShuYW1lKSB7XG4gIHJldHVybiAncmVuZGVyZWQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG59O1xuXG52YXIgZWRnZVBvaW50cyA9IE9iamVjdC5rZXlzKHB0cykucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgdmFyIHNwZWMgPSBwdHNbbmFtZV07XG4gIHZhciByTmFtZSA9IHJlbmRlcmVkTmFtZShuYW1lKTtcblxuICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlmRWRnZSh0aGlzLCBzcGVjLmdldCk7XG4gIH07XG5cbiAgaWYgKHNwZWMubXVsdCkge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnModGhpcywgc3BlYy5nZXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxudmFyIGRpbWVuc2lvbnMgPSBleHRlbmQoe30sIHBvc2l0aW9uLCBib3VuZHMsIHdpZHRoSGVpZ2h0LCBlZGdlUG9pbnRzKTtcblxuLyohXG5FdmVudCBvYmplY3QgYmFzZWQgb24galF1ZXJ5IGV2ZW50cywgTUlUIGxpY2Vuc2VcblxuaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2UvXG5odHRwczovL3RsZHJsZWdhbC5jb20vbGljZW5zZS9taXQtbGljZW5zZVxuaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4qL1xudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQoc3JjLCBwcm9wcykge1xuICB0aGlzLnJlY3ljbGUoc3JjLCBwcm9wcyk7XG59O1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn0gLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5cblxuRXZlbnQucHJvdG90eXBlID0ge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdldmVudCc7XG4gIH0sXG4gIHJlY3ljbGU6IGZ1bmN0aW9uIHJlY3ljbGUoc3JjLCBwcm9wcykge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMucHJldmVudERlZmF1bHQpIHtcbiAgICAgIC8vIEJyb3dzZXIgRXZlbnQgb2JqZWN0XG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTsgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnR5cGUpIHtcbiAgICAgIC8vIFBsYWluIG9iamVjdCBjb250YWluaW5nIGFsbCBldmVudCBkZXRhaWxzXG4gICAgICBwcm9wcyA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlbnQgc3RyaW5nXG4gICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgfSAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCkge1xuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBwcm9wcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPSBudWxsID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICAgIHRoaXMuY3kgPSBwcm9wcy5jeTtcbiAgICAgIHRoaXMudGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9uO1xuICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3kgIT0gbnVsbCAmJiB0aGlzLnBvc2l0aW9uICE9IG51bGwgJiYgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmN5LnBhbigpO1xuICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgIH07XG4gICAgfSAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXG5cbiAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cblxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cblxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG4gIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG59O1xuXG52YXIgZXZlbnRSZWdleCA9IC9eKFteLl0rKShcXC4oPzpbXi5dKykpPyQvOyAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuXG52YXIgdW5pdmVyc2FsTmFtZXNwYWNlID0gJy4qJzsgLy8gbWF0Y2hlcyBhcyBpZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkIGFuZCBwcmV2ZW50cyB1c2VycyBmcm9tIHVuYmluZGluZyBhY2NpZGVudGFsbHlcblxudmFyIGRlZmF1bHRzJDggPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUocTEsIHEyKSB7XG4gICAgcmV0dXJuIHExID09PSBxMjtcbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoKVxuICAvKmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiovXG4gIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKClcbiAgLypjb250ZXh0LCBldnQqL1xuICB7fSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY29udGV4dFxuICAvKiwgbGlzdGVuZXIsIGV2ZW50T2JqKi9cbiAgKSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoKVxuICAvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAge30sXG4gIGFmdGVyRW1pdDogZnVuY3Rpb24gYWZ0ZXJFbWl0KClcbiAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gIHt9LFxuICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpXG4gIC8qY29udGV4dCovXG4gIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KClcbiAgLypjb250ZXh0Ki9cbiAge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBjb250ZXh0OiBudWxsXG59O1xudmFyIGRlZmF1bHRzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzJDgpO1xudmFyIGVtcHR5T3B0cyA9IHt9O1xuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZW1wdHlPcHRzO1xuICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gIC8vIG1pY3JvLW9wdGltaXNhdGlvbiB2cyBPYmplY3QuYXNzaWduKCkgLS0gcmVkdWNlcyBFbGVtZW50IGluc3RhbnRpYXRpb24gdGltZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBkZWZhdWx0c0tleXNbaV07XG4gICAgdGhpc1trZXldID0gb3B0c1trZXldIHx8IGRlZmF1bHRzJDhba2V5XTtcbiAgfVxuXG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5jb250ZXh0O1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICB0aGlzLmVtaXR0aW5nID0gMDtcbn1cblxudmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcblxudmFyIGZvckVhY2hFdmVudCA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudChzZWxmLCBoYW5kbGVyLCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgaWYgKGZuKHF1YWxpZmllcikpIHtcbiAgICBjYWxsYmFjayA9IHF1YWxpZmllcjtcbiAgICBxdWFsaWZpZXIgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNvbmZPdmVycmlkZXMpIHtcbiAgICBpZiAoY29uZiA9PSBudWxsKSB7XG4gICAgICBjb25mID0gY29uZk92ZXJyaWRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZiA9IGV4dGVuZCh7fSwgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgcmV0ID0gaGFuZGxlcihzZWxmLCBldnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG5cbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBhbGxvdyBleGl0aW5nIGVhcmx5XG5cbiAgICB9XG4gIH1cbn07XG5cbnZhciBtYWtlRXZlbnRPYmogPSBmdW5jdGlvbiBtYWtlRXZlbnRPYmooc2VsZiwgb2JqKSB7XG4gIHNlbGYuYWRkRXZlbnRGaWVsZHMoc2VsZi5jb250ZXh0LCBvYmopO1xuICByZXR1cm4gbmV3IEV2ZW50KG9iai50eXBlLCBvYmopO1xufTtcblxudmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgaWYgKGV2ZW50KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIG1ha2VFdmVudE9iaihzZWxmLCBldmVudHMpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcblxuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgIHZhciBldmVudE9iaiA9IG1ha2VFdmVudE9iaihzZWxmLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICB0YXJnZXQ6IHNlbGYuY29udGV4dFxuICAgICAgfSk7XG4gICAgICBoYW5kbGVyKHNlbGYsIGV2ZW50T2JqKTtcbiAgICB9XG4gIH1cbn07XG5cbnAub24gPSBwLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICBmb3JFYWNoRXZlbnQodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgICBpZiAoZm4oY2FsbGJhY2spKSB7XG4gICAgICBzZWxmLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAvLyBmdWxsIGV2ZW50IHN0cmluZ1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IG5hbWVzcGFjZSAoZS5nLiBcIi5mb29cIilcbiAgICAgICAgcXVhbGlmaWVyOiBxdWFsaWZpZXIsXG4gICAgICAgIC8vIGEgcmVzdHJpY3Rpb24gb24gd2hldGhlciB0byBtYXRjaCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgY29uZjogY29uZiAvLyBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb25cblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnAub25lID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICByZXR1cm4gdGhpcy5vbihldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIHtcbiAgICBvbmU6IHRydWVcbiAgfSk7XG59O1xuXG5wLnJlbW92ZUxpc3RlbmVyID0gcC5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZW1pdHRpbmcgIT09IDApIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IGNvcHlBcnJheSh0aGlzLmxpc3RlbmVycyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICBmb3JFYWNoRXZlbnQoX3RoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrXG4gICAgLyosIGNvbmYqL1xuICAgICkge1xuICAgICAgaWYgKChsaXN0ZW5lci50eXBlID09PSB0eXBlIHx8IGV2ZW50cyA9PT0gJyonKSAmJiAoIW5hbWVzcGFjZSAmJiBsaXN0ZW5lci5uYW1lc3BhY2UgIT09ICcuKicgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBuYW1lc3BhY2UpICYmICghcXVhbGlmaWVyIHx8IHNlbGYucXVhbGlmaWVyQ29tcGFyZShsaXN0ZW5lci5xdWFsaWZpZXIsIHF1YWxpZmllcikpICYmICghY2FsbGJhY2sgfHwgbGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnAucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcignKicpO1xufTtcblxucC5lbWl0ID0gcC50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50cywgZXh0cmFQYXJhbXMsIG1hbnVhbENhbGxiYWNrKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgdmFyIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICB0aGlzLmVtaXR0aW5nKys7XG5cbiAgaWYgKCFhcnJheShleHRyYVBhcmFtcykpIHtcbiAgICBleHRyYVBhcmFtcyA9IFtleHRyYVBhcmFtc107XG4gIH1cblxuICBmb3JFYWNoRXZlbnRPYmoodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50T2JqKSB7XG4gICAgaWYgKG1hbnVhbENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIGxpc3RlbmVycyA9IFt7XG4gICAgICAgIGV2ZW50OiBldmVudE9iai5ldmVudCxcbiAgICAgICAgdHlwZTogZXZlbnRPYmoudHlwZSxcbiAgICAgICAgbmFtZXNwYWNlOiBldmVudE9iai5uYW1lc3BhY2UsXG4gICAgICAgIGNhbGxiYWNrOiBtYW51YWxDYWxsYmFja1xuICAgICAgfV07XG4gICAgICBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgaWYgKGxpc3RlbmVyLnR5cGUgPT09IGV2ZW50T2JqLnR5cGUgJiYgKCFsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBldmVudE9iai5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSB1bml2ZXJzYWxOYW1lc3BhY2UpICYmIHNlbGYuZXZlbnRNYXRjaGVzKHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKSkge1xuICAgICAgICB2YXIgYXJncyA9IFtldmVudE9ial07XG5cbiAgICAgICAgaWYgKGV4dHJhUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgICBwdXNoKGFyZ3MsIGV4dHJhUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuYmVmb3JlRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmUpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVycyA9IHNlbGYubGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBzZWxmLmNhbGxiYWNrQ29udGV4dChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG4gICAgICAgIHZhciByZXQgPSBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgc2VsZi5hZnRlckVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXZlbnRPYmouc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZXZlbnRPYmoucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG5cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0OyBpKyspIHtcbiAgICAgIF9sb29wMihpKTtcbiAgICB9IC8vIGZvciBsaXN0ZW5lclxuXG5cbiAgICBpZiAoc2VsZi5idWJibGUoc2VsZi5jb250ZXh0KSAmJiAhZXZlbnRPYmouaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgc2VsZi5wYXJlbnQoc2VsZi5jb250ZXh0KS5lbWl0KGV2ZW50T2JqLCBleHRyYVBhcmFtcyk7XG4gICAgfVxuICB9LCBldmVudHMpO1xuICB0aGlzLmVtaXR0aW5nLS07XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuXG4gICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGUgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoZWxlLCBldnQpIHtcbiAgICBldnQuY3kgPSBlbGUuY3koKTtcbiAgICBldnQudGFyZ2V0ID0gZWxlO1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGVsZTtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdChjb250ZXh0LCBsaXN0ZW5lclxuICAvKiwgZXZlbnRPYmoqL1xuICApIHtcbiAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uY2UpIHtcbiAgICAgIGxpc3RlbmVyLmNvbmYub25jZUNvbGxlY3Rpb24ucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLnF1YWxpZmllciwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpID8gZWxlLnBhcmVudCgpIDogZWxlLmN5KCk7XG4gIH1cbn07XG5cbnZhciBhcmdTZWxlY3RvciA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcblxudmFyIGVsZXNmbiRtID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMsIGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgfSxcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrLCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIG9uY2VDb2xsZWN0aW9uOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGV4dHJhUGFyYW1zKSB7XG4gICAgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlbXB0eSBjb2xsZWN0aW9ucyBkb24ndCBuZWVkIHRvIG5vdGlmeSBhbnl0aGluZ1xuICAgIC8vIG5vdGlmeSByZW5kZXJlclxuXG5cbiAgICB0aGlzLmN5KCkubm90aWZ5KGV2ZW50LCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoZXZlbnQsIGV4dHJhUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbmRlZmluZSQzLmV2ZW50QWxpYXNlc09uKGVsZXNmbiRtKTtcblxudmFyIGVsZXNmbiRuID0ge1xuICBub2RlczogZnVuY3Rpb24gbm9kZXMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICAvLyBpbnRlcm5hbCBoZWxwZXIgdG8gZ2V0IG5vZGVzIGFuZCBlZGdlcyBhcyBzZXBhcmF0ZSBjb2xsZWN0aW9ucyB3aXRoIHNpbmdsZSBpdGVyYXRpb24gb3ZlciBlbGVtZW50c1xuICBieUdyb3VwOiBmdW5jdGlvbiBieUdyb3VwKCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLnNwYXduKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIG5vZGVzLm1lcmdlKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlcy5tZXJnZShlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBub2Rlczogbm9kZXMsXG4gICAgICBlZGdlczogZWRnZXNcbiAgICB9O1xuICB9LFxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdGhpcyBmaXJzdCBiL2MgaXQncyB0aGUgbW9zdCBjb21tb24vcGVyZm9ybWFudCBjYXNlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhfZmlsdGVyKSB8fCBlbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKF9maWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGZuKF9maWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBfZmlsdGVyLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IF9maWx0ZXIoZWxlLCBpLCBlbGVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGZpbHRlckVsZXMubWVyZ2UoZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsdGVyRWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bigpOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICB9LFxuICBub3Q6IGZ1bmN0aW9uIG5vdCh0b1JlbW92ZSkge1xuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgICB0b1JlbW92ZSA9IHRoaXMuZmlsdGVyKHRvUmVtb3ZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgck1hcCA9IHRvUmVtb3ZlLl9wcml2YXRlLm1hcDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IHJNYXAuaGFzKGVsZW1lbnQuaWQoKSk7XG5cbiAgICAgICAgaWYgKCFyZW1vdmUpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzKTtcbiAgICB9XG4gIH0sXG4gIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24gYWJzb2x1dGVDb21wbGVtZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubXV0YWJsZUVsZW1lbnRzKCkubm90KHRoaXMpO1xuICB9LFxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIGludGVyc2VjdChvdGhlcikge1xuICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICB2YXIgbWFwMiA9IGNvbDFTbWFsbGVyID8gY29sMi5fcHJpdmF0ZS5tYXAgOiBjb2wxLl9wcml2YXRlLm1hcDtcbiAgICB2YXIgY29sID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBjb2xbaV0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBlbnRyeSA9IG1hcDIuZ2V0KGlkKTtcblxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZW50cnkuZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gIH0sXG4gIHhvcjogZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYWRkKGNvbDEsIGNvbDIpO1xuICAgIGFkZChjb2wyLCBjb2wxKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gIH0sXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob3RoZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQgPSBbXTtcbiAgICB2YXIgcmlnaHQgPSBbXTtcbiAgICB2YXIgYm90aCA9IFtdO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyLCByZXRFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcblxuICAgICAgICBpZiAoaW5PdGhlcikge1xuICAgICAgICAgIGJvdGgucHVzaChlbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEVsZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZChjb2wxLCBjb2wyLCBsZWZ0KTtcbiAgICBhZGQoY29sMiwgY29sMSwgcmlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnNwYXduKGxlZnQsIHtcbiAgICAgICAgdW5pcXVlOiB0cnVlXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0OiB0aGlzLnNwYXduKHJpZ2h0LCB7XG4gICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICBib3RoOiB0aGlzLnNwYXduKGJvdGgsIHtcbiAgICAgICAgdW5pcXVlOiB0cnVlXG4gICAgICB9KVxuICAgIH07XG4gIH0sXG4gIGFkZDogZnVuY3Rpb24gYWRkKHRvQWRkKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWxlbWVudHMucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gdGhpcy5fcHJpdmF0ZS5tYXA7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9BZGQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXModG9BZGRbX2ldLmlkKCkpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godG9BZGRbX2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gIH0sXG4gIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UodG9BZGQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgaWYgKCF0b0FkZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRvQWRkICYmIHN0cmluZyh0b0FkZCkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHZhciBtYXAgPSBfcC5tYXA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBpZCA9IHRvQWRkRWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgYWRkID0gIW1hcC5oYXMoaWQpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgdmFyIF9pbmRleCA9IG1hcC5nZXQoaWQpLmluZGV4O1xuICAgICAgICB0aGlzW19pbmRleF0gPSB0b0FkZEVsZTtcbiAgICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICAgIGVsZTogdG9BZGRFbGUsXG4gICAgICAgICAgaW5kZXg6IF9pbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgdW5tZXJnZUF0OiBmdW5jdGlvbiB1bm1lcmdlQXQoaSkge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDsgLy8gcmVtb3ZlIGVsZVxuXG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICBtYXBbXCJkZWxldGVcIl0oaWQpO1xuICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7IC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSkge1xuICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzW2xhc3RFbGVJXTtcbiAgICAgIHZhciBsYXN0RWxlSWQgPSBsYXN0RWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB0aGlzW2xhc3RFbGVJXSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgbWFwLnNldChsYXN0RWxlSWQsIHtcbiAgICAgICAgZWxlOiBsYXN0RWxlLFxuICAgICAgICBpbmRleDogaVxuICAgICAgfSk7XG4gICAgfSAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuXG5cbiAgICB0aGlzLmxlbmd0aC0tO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZU9uZTogZnVuY3Rpb24gdW5tZXJnZU9uZShlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgIHZhciBlbnRyeSA9IG1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgfVxuXG4gICAgdmFyIGkgPSBlbnRyeS5pbmRleDtcbiAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2U6IGZ1bmN0aW9uIHVubWVyZ2UodG9SZW1vdmUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRvUmVtb3ZlICYmIHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgdG9SZW1vdmUgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudW5tZXJnZU9uZSh0b1JlbW92ZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VCeTogZnVuY3Rpb24gdW5tZXJnZUJ5KHRvUm1Gbikge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgaWYgKHRvUm1GbihlbGUpKSB7XG4gICAgICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBGbiwgdGhpc0FyZykge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBtYXBGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBtYXBGbihlbGUsIGksIGVsZXMpO1xuICAgICAgYXJyLnB1c2gocmV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHZhbCA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbCA9IGZuKHZhbCwgZWxlc1tpXSwgaSwgZWxlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgodmFsRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhFbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1heCxcbiAgICAgIGVsZTogbWF4RWxlXG4gICAgfTtcbiAgfSxcbiAgbWluOiBmdW5jdGlvbiBtaW4odmFsRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkVsZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuXG4gICAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWluLFxuICAgICAgZWxlOiBtaW5FbGVcbiAgICB9O1xuICB9XG59OyAvLyBhbGlhc2VzXG5cbnZhciBmbiQ1ID0gZWxlc2ZuJG47XG5mbiQ1Wyd1J10gPSBmbiQ1Wyd8J10gPSBmbiQ1WycrJ10gPSBmbiQ1LnVuaW9uID0gZm4kNS5vciA9IGZuJDUuYWRkO1xuZm4kNVsnXFxcXCddID0gZm4kNVsnISddID0gZm4kNVsnLSddID0gZm4kNS5kaWZmZXJlbmNlID0gZm4kNS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbiQ1LnN1YnRyYWN0ID0gZm4kNS5ub3Q7XG5mbiQ1WyduJ10gPSBmbiQ1WycmJ10gPSBmbiQ1WycuJ10gPSBmbiQ1LmFuZCA9IGZuJDUuaW50ZXJzZWN0aW9uID0gZm4kNS5pbnRlcnNlY3Q7XG5mbiQ1WydeJ10gPSBmbiQ1WycoKyknXSA9IGZuJDVbJygtKSddID0gZm4kNS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4kNS5zeW1kaWZmID0gZm4kNS54b3I7XG5mbiQ1LmZuRmlsdGVyID0gZm4kNS5maWx0ZXJGbiA9IGZuJDUuc3RkRmlsdGVyID0gZm4kNS5maWx0ZXI7XG5mbiQ1LmNvbXBsZW1lbnQgPSBmbiQ1LmFic2NvbXAgPSBmbiQ1LmFic29sdXRlQ29tcGxlbWVudDtcblxudmFyIGVsZXNmbiRvID0ge1xuICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICB9LFxuICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICB9LFxuICBpc0xvb3A6IGZ1bmN0aW9uIGlzTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdID09PSB0aGlzLnRhcmdldCgpWzBdO1xuICB9LFxuICBpc1NpbXBsZTogZnVuY3Rpb24gaXNTaW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSAhPT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogIEVsZW1lbnRzIGFyZSBkcmF3biBpbiBhIHNwZWNpZmljIG9yZGVyIGJhc2VkIG9uIGNvbXBvdW5kIGRlcHRoIChsb3cgdG8gaGlnaCksIHRoZSBlbGVtZW50IHR5cGUgKG5vZGVzIGFib3ZlIGVkZ2VzKSxcbiAqICBhbmQgei1pbmRleCAobG93IHRvIGhpZ2gpLiAgVGhlc2Ugc3R5bGVzIGFmZmVjdCBob3cgdGhpcyBhcHBsaWVzOlxuICpcbiAqICB6LWNvbXBvdW5kLWRlcHRoOiBNYXkgYmUgYGJvdHRvbSB8IG9ycGhhbiB8IGF1dG8gfCB0b3BgLiAgVGhlIGZpcnN0IGRyYXduIGlzIGBib3R0b21gLCB0aGVuIGBvcnBoYW5gIHdoaWNoIGlzIHRoZVxuICogICAgICBzYW1lIGRlcHRoIGFzIHRoZSByb290IG9mIHRoZSBjb21wb3VuZCBncmFwaCwgZm9sbG93ZWQgYnkgdGhlIGRlZmF1bHQgdmFsdWUgYGF1dG9gIHdoaWNoIGRyYXdzIGluIG9yZGVyIGZyb21cbiAqICAgICAgcm9vdCB0byBsZWF2ZXMgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLiAgVGhlIGxhc3QgZHJhd24gaXMgYHRvcGAuXG4gKiAgei1pbmRleC1jb21wYXJlOiBNYXkgYmUgYGF1dG8gfCBtYW51YWxgLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGF1dG9gIHdoaWNoIGFsd2F5cyBkcmF3cyBlZGdlcyB1bmRlciBub2Rlcy5cbiAqICAgICAgYG1hbnVhbGAgaWdub3JlcyB0aGlzIGNvbnZlbnRpb24gYW5kIGRyYXdzIGJhc2VkIG9uIHRoZSBgei1pbmRleGAgdmFsdWUgc2V0dGluZy5cbiAqICB6LWluZGV4OiBBbiBpbnRlZ2VyIHZhbHVlIHRoYXQgYWZmZWN0cyB0aGUgcmVsYXRpdmUgZHJhdyBvcmRlciBvZiBlbGVtZW50cy4gIEluIGdlbmVyYWwsIGFuIGVsZW1lbnQgd2l0aCBhIGhpZ2hlclxuICogICAgICBgei1pbmRleGAgd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgYW4gZWxlbWVudCB3aXRoIGEgbG93ZXIgYHotaW5kZXhgLlxuICovXG5cbnZhciB6SW5kZXhTb3J0ID0gZnVuY3Rpb24gekluZGV4U29ydChhLCBiKSB7XG4gIHZhciBjeSA9IGEuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpO1xuXG4gICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnpEZXB0aCgpIDogMDtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUudmFsdWUgPT09ICd0b3AnKSB7XG4gICAgICByZXR1cm4gTUFYX0lOVDtcbiAgICB9IC8vICdvcnBoYW4nXG5cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGRlcHRoRGlmZiA9IGdldERlcHRoKGEpIC0gZ2V0RGVwdGgoYik7XG5cbiAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBkZXB0aERpZmY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWluZGV4LWNvbXBhcmUnKTtcblxuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpID8gMSA6IDA7XG4gICAgfSAvLyAnbWFudWFsJ1xuXG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcblxuICBpZiAoZWxlRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBlbGVEaWZmO1xuICB9XG5cbiAgdmFyIHpEaWZmID0gYS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSAtIGIucHN0eWxlKCd6LWluZGV4JykudmFsdWU7XG5cbiAgaWYgKHpEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIHpEaWZmO1xuICB9IC8vIGNvbXBhcmUgaW5kaWNlcyBpbiB0aGUgY29yZSAob3JkZXIgYWRkZWQgdG8gZ3JhcGggdy8gbGFzdCBvbiB0b3ApXG5cblxuICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG59O1xuXG52YXIgZWxlc2ZuJHAgPSB7XG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4kMSwgdGhpc0FyZykge1xuICAgIGlmIChmbihmbiQxKSkge1xuICAgICAgdmFyIE4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gZm4kMS5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCB0aGlzXSkgOiBmbiQxKGVsZSwgaSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGFycmF5KTtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH0sXG4gIGVxOiBmdW5jdGlvbiBlcShpKSB7XG4gICAgcmV0dXJuIHRoaXNbaV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICB9LFxuICBub25lbXB0eTogZnVuY3Rpb24gbm9uZW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoc29ydEZuKSB7XG4gICAgaWYgKCFmbihzb3J0Rm4pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydChzb3J0Rm4pO1xuICAgIHJldHVybiB0aGlzLnNwYXduKHNvcnRlZCk7XG4gIH0sXG4gIHNvcnRCeVpJbmRleDogZnVuY3Rpb24gc29ydEJ5WkluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNvcnQoekluZGV4U29ydCk7XG4gIH0sXG4gIHpEZXB0aDogZnVuY3Rpb24gekRlcHRoKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBsZXQgY3kgPSBlbGUuY3koKTtcblxuXG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuXG4gICAgaWYgKGdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICB2YXIgZGVwdGggPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcblxuICAgICAgaWYgKCFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gTUFYX0lOVCAtIDE7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoc3JjRGVwdGgsIHRndERlcHRoLCAwKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICB9XG4gIH1cbn07XG5lbGVzZm4kcC5lYWNoID0gZWxlc2ZuJHAuZm9yRWFjaDtcblxudmFyIGdldExheW91dERpbWVuc2lvbk9wdGlvbnMgPSBkZWZhdWx0cyh7XG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRxID0ge1xuICAvLyBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIG5vZGUgZGltZW5zaW9ucyB7IHgsIHkgfSBiYXNlZCBvbiBvcHRpb25zIGdpdmVuXG4gIGxheW91dERpbWVuc2lvbnM6IGZ1bmN0aW9uIGxheW91dERpbWVuc2lvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBkaW1zO1xuXG4gICAgaWYgKCF0aGlzLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgIHZhciBiYkRpbSA9IHRoaXMuYm91bmRpbmdCb3goKTtcbiAgICAgIGRpbXMgPSB7XG4gICAgICAgIHc6IGJiRGltLncsXG4gICAgICAgIGg6IGJiRGltLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbXMgPSB7XG4gICAgICAgIHc6IHRoaXMub3V0ZXJXaWR0aCgpLFxuICAgICAgICBoOiB0aGlzLm91dGVySGVpZ2h0KClcbiAgICAgIH07XG4gICAgfSAvLyBzYW5pdGlzZSB0aGUgZGltZW5zaW9ucyBmb3IgZXh0ZXJuYWwgbGF5b3V0cyAoYXZvaWQgZGl2aXNpb24gYnkgemVybylcblxuXG4gICAgaWYgKGRpbXMudyA9PT0gMCB8fCBkaW1zLmggPT09IDApIHtcbiAgICAgIGRpbXMudyA9IGRpbXMuaCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpbXM7XG4gIH0sXG4gIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiBsYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmbikge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGxheW91dEVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIG5vZGVzICYgZWRnZXNcblxuICAgIHZhciBnZXRNZW1vaXplS2V5ID0gZnVuY3Rpb24gZ2V0TWVtb2l6ZUtleShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCgpO1xuICAgIH07XG5cbiAgICB2YXIgZm5NZW0gPSBtZW1vaXplKGZuLCBnZXRNZW1vaXplS2V5KTsgLy8gbWVtb2l6ZWQgdmVyc2lvbiBvZiBwb3NpdGlvbiBmdW5jdGlvblxuXG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSk7XG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0ge1xuICAgICAgICAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB1c2VTcGFjaW5nRmFjdG9yID0gb3B0aW9ucy5zcGFjaW5nRmFjdG9yICYmIG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAhPT0gMTtcblxuICAgIHZhciBzcGFjaW5nQmIgPSBmdW5jdGlvbiBzcGFjaW5nQmIoKSB7XG4gICAgICBpZiAoIXVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBmbk1lbShub2RlLCBpKTtcbiAgICAgICAgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCBwb3MueCwgcG9zLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmI7XG4gICAgfTtcblxuICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuICAgIHZhciBnZXRGaW5hbFBvcyA9IG1lbW9pemUoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSBmbk1lbShub2RlLCBpKTtcblxuICAgICAgaWYgKHVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBNYXRoLmFicyhvcHRpb25zLnNwYWNpbmdGYWN0b3IpO1xuICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIGJiLCBuZXdQb3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgICAgICBuZXdQb3MgPSBvcHRpb25zLnRyYW5zZm9ybShub2RlLCBuZXdQb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH0sIGdldE1lbW9pemVLZXkpO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgbmV3UG9zID0gZ2V0RmluYWxQb3Mobm9kZSwgaSk7XG4gICAgICAgIHZhciBhbmltYXRlTm9kZSA9IG9wdGlvbnMuYW5pbWF0ZUZpbHRlciA9PSBudWxsIHx8IG9wdGlvbnMuYW5pbWF0ZUZpbHRlcihub2RlLCBpKTtcblxuICAgICAgICBpZiAoYW5pbWF0ZU5vZGUpIHtcbiAgICAgICAgICB2YXIgYW5pID0gbm9kZS5hbmltYXRpb24oe1xuICAgICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goYW5pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIHZhciBmaXRBbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIGZpdDoge1xuICAgICAgICAgICAgYm91bmRpbmdCb3g6IGxheW91dEVsZXMuYm91bmRpbmdCb3hBdChnZXRGaW5hbFBvcyksXG4gICAgICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goZml0QW5pKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5wYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgem9vbVBhbkFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgem9vbTogb3B0aW9ucy56b29tLFxuICAgICAgICAgIHBhbjogb3B0aW9ucy5wYW4sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCh6b29tUGFuQW5pKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucGxheSgpO1xuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBQcm9taXNlJDEuYWxsKGxheW91dC5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0RmluYWxQb3MpO1xuXG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuem9vbSAhPSBudWxsKSB7XG4gICAgICAgIGN5Lnpvb20ob3B0aW9ucy56b29tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucGFuKSB7XG4gICAgICAgIGN5LnBhbihvcHRpb25zLnBhbik7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubWFrZUxheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9KSk7XG4gIH1cbn07IC8vIGFsaWFzZXM6XG5cbmVsZXNmbiRxLmNyZWF0ZUxheW91dCA9IGVsZXNmbiRxLm1ha2VMYXlvdXQgPSBlbGVzZm4kcS5sYXlvdXQ7XG5cbmZ1bmN0aW9uIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGNhY2hlID0gX3Auc3R5bGVDYWNoZSA9IF9wLnN0eWxlQ2FjaGUgfHwgW107XG4gIHZhciB2YWw7XG5cbiAgaWYgKCh2YWwgPSBjYWNoZVtrZXldKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBjYWNoZVtrZXldID0gZm4oZWxlKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFN0eWxlRnVuY3Rpb24oZWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuXG4gIHZhciBzZWxmRm4gPSBmdW5jdGlvbiBzZWxmRm4oZWxlKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwoZWxlKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkUHJvdG90eXBlU3R5bGVGdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgc2VsZkZuLCBlbGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGVsZXNmbiRyID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIGlmIChyZW5kZXJlciAmJiBzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh0aGlzLCB1c2VDYWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRpcnR5U3R5bGVDYWNoZTogZnVuY3Rpb24gZGlydHlTdHlsZUNhY2hlKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHZhciBkaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgdmFyIGVsZXM7XG4gICAgICBlbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICAgIGVsZXMubWVyZ2UoZWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgIGVsZXMuZm9yRWFjaChkaXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGRpcnR5KGVsZSk7XG4gICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZGlydHkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChjeS5iYXRjaGluZygpKSB7XG4gICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcbiAgICAgIGJFbGVzLm1lcmdlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcztcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSh1cGRhdGVkRWxlcyk7XG5cbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICAvLyBnZXQgdGhlIGludGVybmFsIHBhcnNlZCBzdHlsZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgcGFyc2VkU3R5bGU6IGZ1bmN0aW9uIHBhcnNlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGluY2x1ZGVOb25EZWZhdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBvdmVycmlkZGVuU3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgICBpZiAob3ZlcnJpZGRlblN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5TdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU5vbkRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbnVtZXJpY1N0eWxlOiBmdW5jdGlvbiBudW1lcmljU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmICghZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gcHN0eWxlLnBmVmFsdWUgIT09IHVuZGVmaW5lZCA/IHBzdHlsZS5wZlZhbHVlIDogcHN0eWxlLnZhbHVlO1xuICAgIH1cbiAgfSxcbiAgbnVtZXJpY1N0eWxlVW5pdHM6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZVVuaXRzKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUocHJvcGVydHkpLnVuaXRzO1xuICAgIH1cbiAgfSxcbiAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgY3NzIHByb3BlcnR5IGFzIGEgcmVuZGVyZWQgdmFsdWUgKGkuZS4gb24tc2NyZWVuIHZhbHVlKVxuICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICByZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZW5kZXJlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKGVsZSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfSxcbiAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgIC8vIHRoZW4gZXh0ZW5kIHRoZSBieXBhc3NcbiAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIGdldCB0aGUgcHJvcGVydHkgZnJvbSB0aGUgc3R5bGVcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgIHJldHVybiBzdHlsZS5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX2VsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChfZWxlKSB7XG4gICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZShfZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHJlbW92ZVN0eWxlOiBmdW5jdGlvbiByZW1vdmVTdHlsZShuYW1lcykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfZWxlMiA9IGVsZXNbX2ldO1xuICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyhfZWxlMiwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmNzcygnZGlzcGxheScsICdlbGVtZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbiBlZmZlY3RpdmVPcGFjaXR5KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcblxuICAgICAgaWYgKHBhcmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgIH1cbiAgfSxcbiAgdHJhbnNwYXJlbnQ6IGZ1bmN0aW9uIHRyYW5zcGFyZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGVsZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYWNrZ3JvdW5kaW5nOiBmdW5jdGlvbiBiYWNrZ3JvdW5kaW5nKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPaykge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwYXJlbnRzID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcblxuICBpZiAocGFyZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG5cbiAgICAgIGlmICghcGFyZW50T2socGFyZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHNwZWNzKSB7XG4gIHZhciBvayA9IHNwZWNzLm9rO1xuICB2YXIgZWRnZU9rVmlhTm9kZSA9IHNwZWNzLmVkZ2VPa1ZpYU5vZGUgfHwgc3BlY3Mub2s7XG4gIHZhciBwYXJlbnRPayA9IHNwZWNzLnBhcmVudE9rIHx8IHNwZWNzLm9rO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIW9rKGVsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGVkZ2VPa1ZpYU5vZGUoc3JjKSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChzcmMsIGVkZ2VPa1ZpYU5vZGUpKSAmJiAoc3JjID09PSB0Z3QgfHwgZWRnZU9rVmlhTm9kZSh0Z3QpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHRndCwgZWRnZU9rVmlhTm9kZSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBlbGVUYWtlc1VwU3BhY2UgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVRha2VzVXBTcGFjZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ2VsZW1lbnQnICYmIGVsZS53aWR0aCgpICE9PSAwICYmIChlbGUuaXNOb2RlKCkgPyBlbGUuaGVpZ2h0KCkgIT09IDAgOiB0cnVlKTtcbn0pO1xuZWxlc2ZuJHIudGFrZXNVcFNwYWNlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd0YWtlc1VwU3BhY2UnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVUYWtlc1VwU3BhY2Vcbn0pKTtcbnZhciBlbGVJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlSW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdldmVudHMnKS52YWx1ZSA9PT0gJ3llcycgJiYgZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBwYXJlbnRJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbigncGFyZW50SW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHJldHVybiBwYXJlbnQucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UocGFyZW50KTtcbn0pO1xuZWxlc2ZuJHIuaW50ZXJhY3RpdmUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2ludGVyYWN0aXZlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlSW50ZXJhY3RpdmUsXG4gIHBhcmVudE9rOiBwYXJlbnRJbnRlcmFjdGl2ZSxcbiAgZWRnZU9rVmlhTm9kZTogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG5cbmVsZXNmbiRyLm5vbmludGVyYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuaW50ZXJhY3RpdmUoKTtcbiAgfVxufTtcblxudmFyIGVsZVZpc2libGUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVZpc2libGUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGUucHN0eWxlKCdvcGFjaXR5JykucGZWYWx1ZSAhPT0gMCAmJiBlbGVUYWtlc1VwU3BhY2UoZWxlKTtcbn0pO1xudmFyIGVkZ2VWaXNpYmxlVmlhTm9kZSA9IGVsZVRha2VzVXBTcGFjZTtcbmVsZXNmbiRyLnZpc2libGUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Zpc2libGUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVWaXNpYmxlLFxuICBlZGdlT2tWaWFOb2RlOiBlZGdlVmlzaWJsZVZpYU5vZGVcbn0pKTtcblxuZWxlc2ZuJHIuaGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59O1xuXG5lbGVzZm4kci5pc0J1bmRsZWRCZXppZXIgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2lzQnVuZGxlZEJlemllcicsIGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIXRoaXMucmVtb3ZlZCgpICYmIHRoaXMucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJyAmJiB0aGlzLnRha2VzVXBTcGFjZSgpO1xufSk7XG5lbGVzZm4kci5ieXBhc3MgPSBlbGVzZm4kci5jc3MgPSBlbGVzZm4kci5zdHlsZTtcbmVsZXNmbiRyLnJlbmRlcmVkQ3NzID0gZWxlc2ZuJHIucmVuZGVyZWRTdHlsZTtcbmVsZXNmbiRyLnJlbW92ZUJ5cGFzcyA9IGVsZXNmbiRyLnJlbW92ZUNzcyA9IGVsZXNmbiRyLnJlbW92ZVN0eWxlO1xuZWxlc2ZuJHIucHN0eWxlID0gZWxlc2ZuJHIucGFyc2VkU3R5bGU7XG5cbnZhciBlbGVzZm4kcyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTsgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyKTtcbiAgICB9IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGZuKGFyZ3NbMF0pKSB7XG4gICAgICAgIHZhciBfaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBfaGFuZGxlcik7XG4gICAgICB9IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgICAgLy8gZS5nLiAocHJpdmF0ZSkgY3kubm9kZXMoKS5zZWxlY3QoWyd0YXBzZWxlY3QnXSlcbiAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAwIHx8IGFyZ3MubGVuZ3RoID09PSAxICYmIGFycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgdmFyIGFkZGxFdmVudHMgPSBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBudWxsO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICAgIHZhciBhYmxlID0gIXBhcmFtcy5hYmxlRmllbGQgfHwgZWxlLl9wcml2YXRlW3BhcmFtcy5hYmxlRmllbGRdO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSAhPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKGVsZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgICAgIGlmICghb3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWJsZSkge1xuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGFuZ2VkQ29sbCA9IHRoaXMuc3Bhd24oY2hhbmdlZEVsZXMpO1xuICAgICAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcblxuICAgICAgICAgIGNoYW5nZWRDb2xsLmVtaXQocGFyYW1zLmV2ZW50KTtcblxuICAgICAgICAgIGlmIChhZGRsRXZlbnRzKSB7XG4gICAgICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KGFkZGxFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldChwYXJhbXMpIHtcbiAgZWxlc2ZuJHNbcGFyYW1zLmZpZWxkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVGaWVsZCkge1xuICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoZWxlKTtcblxuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXTtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuJHNbcGFyYW1zLm9uXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICBldmVudDogcGFyYW1zLm9uLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgZWxlc2ZuJHNbcGFyYW1zLm9mZl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiBmYWxzZVxuICB9KTtcbn1cblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdsb2NrZWQnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdsb2NrJyxcbiAgb2ZmOiAndW5sb2NrJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSB8fCBlbGUucGFubmFibGUoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2dyYWJpZnknLFxuICBvZmY6ICd1bmdyYWJpZnknXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICBhYmxlRmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVBYmxlOiBmdW5jdGlvbiBvdmVycmlkZUFibGUoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0JyxcbiAgb2ZmOiAndW5zZWxlY3QnXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0aWZ5JyxcbiAgb2ZmOiAndW5zZWxlY3RpZnknXG59KTtcbmVsZXNmbiRzLmRlc2VsZWN0ID0gZWxlc2ZuJHMudW5zZWxlY3Q7XG5cbmVsZXNmbiRzLmdyYWJiZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gIH1cbn07XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnYWN0aXZlJyxcbiAgb246ICdhY3RpdmF0ZScsXG4gIG9mZjogJ3VuYWN0aXZhdGUnXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAncGFubmFibGUnLFxuICBvbjogJ3BhbmlmeScsXG4gIG9mZjogJ3VucGFuaWZ5J1xufSk7XG5cbmVsZXNmbiRzLmluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJHQgPSB7fTsgLy8gREFHIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmaW5lRGFnRXh0cmVtaXR5ID0gZnVuY3Rpb24gZGVmaW5lRGFnRXh0cmVtaXR5KHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZGFnRXh0cmVtaXR5SW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3F1YWxpZmllZCA9IGZhbHNlO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYXJhbXMubm9JbmNvbWluZ0VkZ2VzICYmIHRndCA9PT0gZWxlICYmIHNyYyAhPT0gZWxlIHx8IHBhcmFtcy5ub091dGdvaW5nRWRnZXMgJiYgc3JjID09PSBlbGUgJiYgdGd0ICE9PSBlbGUpIHtcbiAgICAgICAgICBkaXNxdWFsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlzcXVhbGlmaWVkKSB7XG4gICAgICAgIHJldC5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0LCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ09uZUhvcCA9IGZ1bmN0aW9uIGRlZmluZURhZ09uZUhvcChwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5vdXRnb2luZyAmJiBzcmMgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaCh0Z3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5pbmNvbWluZyAmJiB0Z3QgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaChzcmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ob0VsZXMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgZGVmaW5lRGFnQWxsSG9wcyA9IGZ1bmN0aW9uIGRlZmluZURhZ0FsbEhvcHMocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHNFbGVzID0gW107XG4gICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmFtcy5vdXRnb2luZyA/IGVsZXMub3V0Z29lcnMoKSA6IGVsZXMuaW5jb21lcnMoKTtcblxuICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG5cbiAgICAgIHZhciBuZXdOZXh0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5leHRbaV07XG4gICAgICAgIHZhciBuaWQgPSBuLmlkKCk7XG5cbiAgICAgICAgaWYgKCFzRWxlc0lkc1tuaWRdKSB7XG4gICAgICAgICAgc0VsZXNJZHNbbmlkXSA9IHRydWU7XG4gICAgICAgICAgc0VsZXMucHVzaChuKTtcbiAgICAgICAgICBuZXdOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5ld05leHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG5cbiAgICAgIGVsZXMgPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHNFbGVzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxuZWxlc2ZuJHQuY2xlYXJUcmF2ZXJzYWxDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXS5fcHJpdmF0ZS50cmF2ZXJzYWxDYWNoZSA9IG51bGw7XG4gIH1cbn07XG5cbmV4dGVuZChlbGVzZm4kdCwge1xuICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICByb290czogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICBub0luY29taW5nRWRnZXM6IHRydWVcbiAgfSksXG4gIC8vIGdldCB0aGUgbGVhZiBub2RlcyBpbiB0aGUgREFHXG4gIGxlYXZlczogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICBub091dGdvaW5nRWRnZXM6IHRydWVcbiAgfSksXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgLy8gdGhlc2Ugbm9kZXMgPWVkZ2VzPT4gb3V0Z29pbmcgbm9kZXNcbiAgb3V0Z29lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgb3V0Z29pbmc6IHRydWVcbiAgfSksICdvdXRnb2VycycpLFxuICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gIHN1Y2Nlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgcGFyZW50cyBpbiBncmFwaCB0aGVvcnlcbiAgLy8gdGhlc2Ugbm9kZXMgPD1lZGdlcz0gaW5jb21pbmcgbm9kZXNcbiAgaW5jb21lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgaW5jb21pbmc6IHRydWVcbiAgfSksICdpbmNvbWVycycpLFxuICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICBwcmVkZWNlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgIGluY29taW5nOiB0cnVlXG4gIH0pXG59KTsgLy8gTmVpZ2hib3VyaG9vZCBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4dGVuZChlbGVzZm4kdCwge1xuICBuZWlnaGJvcmhvb2Q6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGZvciBhbGwgbm9kZXNcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7IC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjOyAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuXG4gICAgICAgIGlmIChvdGhlck5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2gob3RoZXJOb2RlWzBdKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICB9IC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuXG5cbiAgICAgICAgZWxlbWVudHMucHVzaChlZGdlWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ25laWdoYm9yaG9vZCcpLFxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIGNsb3NlZE5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbiBvcGVuTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKHNlbGVjdG9yKTtcbiAgfVxufSk7IC8vIGFsaWFzZXNcblxuZWxlc2ZuJHQubmVpZ2hib3VyaG9vZCA9IGVsZXNmbiR0Lm5laWdoYm9yaG9vZDtcbmVsZXNmbiR0LmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4kdC5jbG9zZWROZWlnaGJvcmhvb2Q7XG5lbGVzZm4kdC5vcGVuTmVpZ2hib3VyaG9vZCA9IGVsZXNmbiR0Lm9wZW5OZWlnaGJvcmhvb2Q7IC8vIEVkZ2UgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHNyYztcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKHNlbGVjdG9yKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuICB0YXJnZXQ6IGNhY2hlKGZ1bmN0aW9uIHRhcmdldEltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldCB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoc2VsZWN0b3IpIDogdGd0O1xuICB9LCAndGFyZ2V0JyksXG4gIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAnc291cmNlJ1xuICB9KSxcbiAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0pXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlW3BhcmFtcy5hdHRyXTtcblxuICAgICAgaWYgKHNyYykge1xuICAgICAgICBzb3VyY2VzLnB1c2goc3JjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3VyY2VzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgZWRnZXNXaXRoOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLCAnZWRnZXNXaXRoJyksXG4gIGVkZ2VzVG86IGNhY2hlKGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHtcbiAgICB0aGlzSXNTcmM6IHRydWVcbiAgfSksICdlZGdlc1RvJylcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwob3RoZXJOb2Rlcykge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHAgPSBwYXJhbXMgfHwge307IC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuXG4gICAgaWYgKHN0cmluZyhvdGhlck5vZGVzKSkge1xuICAgICAgb3RoZXJOb2RlcyA9IGN5LiQob3RoZXJOb2Rlcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrKSB7XG4gICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG5cbiAgICAgICAgaWYgKCFlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRoaXNJc1NyYyB8fCBwLnRoaXNJc1RndCkge1xuICAgICAgICAgIGlmIChwLnRoaXNJc1NyYyAmJiAhdGhpc1RvT3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmICghbm9kZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICByZXRFbGVzLnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZEVkZ2VzJyksXG4gIGNvbm5lY3RlZE5vZGVzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVkZ2UuaXNFZGdlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldEVsZXMucHVzaChlZGdlLnNvdXJjZSgpWzBdKTtcbiAgICAgIHJldEVsZXMucHVzaChlZGdlLnRhcmdldCgpWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY29ubmVjdGVkTm9kZXMnKSxcbiAgcGFyYWxsZWxFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyksXG4gIGNvZGlyZWN0ZWRFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICBjb2RpcmVjdGVkOiB0cnVlXG4gIH0pLCAnY29kaXJlY3RlZEVkZ2VzJylcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICB9O1xuICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICByZXR1cm4gZnVuY3Rpb24gcGFyYWxsZWxFZGdlc0ltcGwoc2VsZWN0b3IpIHtcbiAgICAvLyBtaWNyby1vcHRpbWlzZWQgZm9yIHJlbmRlcmVyXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBwID0gcGFyYW1zOyAvLyBsb29rIGF0IGFsbCB0aGUgZWRnZXMgaW4gdGhlIGNvbGxlY3Rpb25cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIGVkZ2UxX3AgPSBlZGdlMS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzcmMxID0gZWRnZTFfcC5zb3VyY2U7XG4gICAgICB2YXIgc3JjaWQxID0gc3JjMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIHRndGlkMSA9IGVkZ2UxX3AuZGF0YS50YXJnZXQ7XG4gICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlczsgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciBjb2RpcmVjdGVkID0gdGd0aWQyID09PSB0Z3RpZDEgJiYgc3JjaWQyID09PSBzcmNpZDE7XG4gICAgICAgIHZhciBvcHBkaXJlY3RlZCA9IHNyY2lkMSA9PT0gdGd0aWQyICYmIHRndGlkMSA9PT0gc3JjaWQyO1xuXG4gICAgICAgIGlmIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCB8fCAhcC5jb2RpcmVjdGVkICYmIChjb2RpcmVjdGVkIHx8IG9wcGRpcmVjdGVkKSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59IC8vIE1pc2MgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbmV4dGVuZChlbGVzZm4kdCwge1xuICBjb21wb25lbnRzOiBmdW5jdGlvbiBjb21wb25lbnRzKHJvb3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIHZhciB2aXNpdGVkID0gY3kuY29sbGVjdGlvbigpO1xuICAgIHZhciB1bnZpc2l0ZWQgPSByb290ID09IG51bGwgPyBzZWxmLm5vZGVzKCkgOiByb290Lm5vZGVzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgIGlmIChyb290ICE9IG51bGwgJiYgdW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgIC8vIHJvb3QgbWF5IGNvbnRhaW4gb25seSBlZGdlc1xuICAgICAgdW52aXNpdGVkID0gcm9vdC5zb3VyY2VzKCk7IC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIG5vZGUgdG8gdXNlICh1bmRpcmVjdGVkKSwgc28ganVzdCB1c2UgdGhlIHNvdXJjZSBzaWRlc1xuICAgIH1cblxuICAgIHZhciB2aXNpdEluQ29tcG9uZW50ID0gZnVuY3Rpb24gdmlzaXRJbkNvbXBvbmVudChub2RlLCBjb21wb25lbnQpIHtcbiAgICAgIHZpc2l0ZWQubWVyZ2Uobm9kZSk7XG4gICAgICB1bnZpc2l0ZWQudW5tZXJnZShub2RlKTtcbiAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICB9O1xuXG4gICAgaWYgKHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICByZXR1cm4gc2VsZi5zcGF3bigpO1xuICAgIH1cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgLy8gZWFjaCBpdGVyYXRpb24geWllbGRzIGEgY29tcG9uZW50XG4gICAgICB2YXIgY21wdCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcbiAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgdmlzaXRJbkNvbXBvbmVudChyb290LCBjbXB0KTtcbiAgICAgIHNlbGYuYmZzKHtcbiAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICByb290czogcm9vdCxcbiAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KHYpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRJbkNvbXBvbmVudCh2LCBjbXB0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgICAgaWYgKHNlbGYuaGFzKGUpICYmIGNtcHQuaGFzKGUuc291cmNlKCkpICYmIGNtcHQuaGFzKGUudGFyZ2V0KCkpKSB7XG4gICAgICAgICAgICAvLyBoYXMoKSBpcyBjaGVhcFxuICAgICAgICAgICAgY21wdC5tZXJnZShlKTsgLy8gZm9yRWFjaCgpIG9ubHkgY29uc2lkZXJzIG5vZGVzIC0tIHNldHMgTiBhdCBjYWxsIHRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGRvIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfSB3aGlsZSAodW52aXNpdGVkLmxlbmd0aCA+IDApO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH0sXG4gIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuY3koKS5tdXRhYmxlRWxlbWVudHMoKS5jb21wb25lbnRzKGVsZSlbMF07XG4gIH1cbn0pO1xuZWxlc2ZuJHQuY29tcG9uZW50c09mID0gZWxlc2ZuJHQuY29tcG9uZW50cztcblxudmFyIGlkRmFjdG9yeSA9IHtcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKGN5LCBlbGVtZW50LCB0cnlUaGlzSWQpIHtcbiAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHV1aWQoKTtcblxuICAgIHdoaWxlIChjeS5oYXNFbGVtZW50V2l0aElkKGlkKSkge1xuICAgICAgaWQgPSB1dWlkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9XG59OyAvLyByZXByZXNlbnRzIGEgc2V0IG9mIG5vZGVzLCBlZGdlcywgb3IgYm90aCB0b2dldGhlclxuXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gIGlmIChjeSA9PT0gdW5kZWZpbmVkIHx8ICFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcCA9IG5ldyBNYXAkMSgpO1xuICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG5cbiAgaWYgKCFlbGVtZW50cykge1xuICAgIGVsZW1lbnRzID0gW107XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCAmJiBwbGFpbk9iamVjdChlbGVtZW50c1swXSkgJiYgIWVsZW1lbnQoZWxlbWVudHNbMF0pKSB7XG4gICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTsgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcblxuICAgIHZhciBlbGVzID0gW107XG4gICAgdmFyIGVsZXNJZHMgPSBuZXcgU2V0JDEoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoanNvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAganNvbi5kYXRhID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBfZGF0YSA9IGpzb24uZGF0YTsgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcblxuICAgICAgaWYgKF9kYXRhLmlkID09IG51bGwpIHtcbiAgICAgICAgX2RhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoY3ksIGpzb24pO1xuICAgICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhLmlkKSB8fCBlbGVzSWRzLmhhcyhfZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSBuZXcgRWxlbWVudChjeSwganNvbiwgZmFsc2UpO1xuICAgICAgZWxlcy5wdXNoKGVsZSk7XG4gICAgICBlbGVzSWRzLmFkZChfZGF0YS5pZCk7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciAodmFyIF9pID0gMCwgX2wgPSBlbGVtZW50cy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICB2YXIgZWxlbWVudCQxID0gZWxlbWVudHNbX2ldWzBdOyAvLyBbMF0gaW4gY2FzZSBlbGVtZW50cyBpcyBhbiBhcnJheSBvZiBjb2xsZWN0aW9ucywgcmF0aGVyIHRoYW4gYXJyYXkgb2YgZWxlbWVudHNcblxuICAgIGlmIChlbGVtZW50JDEgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gZWxlbWVudCQxLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IG9wdGlvbnMudW5pcXVlICYmICFtYXAuaGFzKGlkKSkge1xuICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICBpbmRleDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGVsZTogZWxlbWVudCQxXG4gICAgICB9KTtcbiAgICAgIHRoaXNbdGhpcy5sZW5ndGhdID0gZWxlbWVudCQxO1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH1cblxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBtYXA6IG1hcFxuICB9OyAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG5cbiAgaWYgKGNyZWF0ZWRFbGVtZW50cykge1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG59OyAvLyBGdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG5cblxudmFyIGVsZXNmbiR1ID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuJHUuaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnY29sbGVjdGlvbic7XG59O1xuXG5lbGVzZm4kdS5zcGF3biA9IGZ1bmN0aW9uIChjeSwgZWxlcywgb3B0cykge1xuICBpZiAoIWNvcmUoY3kpKSB7XG4gICAgLy8gY3kgaXMgb3B0aW9uYWxcbiAgICBvcHRzID0gZWxlcztcbiAgICBlbGVzID0gY3k7XG4gICAgY3kgPSB0aGlzLmN5KCk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXMsIG9wdHMpO1xufTtcblxuZWxlc2ZuJHUuc3Bhd25TZWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zcGF3bih0aGlzKTtcbn07XG5cbmVsZXNmbiR1LmN5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbn07XG5cbmVsZXNmbiR1LnJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeS5yZW5kZXJlcigpO1xufTtcblxuZWxlc2ZuJHUuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbMF07XG59O1xuXG5lbGVzZm4kdS5jb2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAoY29sbGVjdGlvbih0aGlzKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIC8vIGFuIGVsZW1lbnRcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgW3RoaXNdKTtcbiAgfVxufTtcblxuZWxlc2ZuJHUudW5pcXVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywge1xuICAgIHVuaXF1ZTogdHJ1ZVxuICB9KTtcbn07XG5cbmVsZXNmbiR1Lmhhc0VsZW1lbnRXaXRoSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5oYXMoaWQpO1xufTtcblxuZWxlc2ZuJHUuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKTtcblxuICByZXR1cm4gZW50cnkgPyBlbnRyeS5lbGUgOiBuZXcgQ29sbGVjdGlvbihjeSk7IC8vIGdldCBlbGUgb3IgZW1wdHkgY29sbGVjdGlvblxufTtcblxuZWxlc2ZuJHUuJGlkID0gZWxlc2ZuJHUuZ2V0RWxlbWVudEJ5SWQ7XG5cbmVsZXNmbiR1LnBvb2xJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgdmFyIGlkID0gdGhpc1swXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5cbmVsZXNmbiR1LmluZGV4T2YgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBpZCA9IGVsZVswXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5cbmVsZXNmbiR1LmluZGV4T2ZJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kdS5qc29uID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuXG4gIGlmIChlbGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG5cbiAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG5cbiAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAvLyBzZXRcbiAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgIGVsZS5kYXRhKG9iai5kYXRhKTtcbiAgICAgIHZhciBfZGF0YTIgPSBwLmRhdGE7XG5cbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gc291cmNlIGFuZCB0YXJnZXQgYXJlIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBtb3ZlID0gZmFsc2U7XG4gICAgICAgIHZhciBzcGVjID0ge307XG4gICAgICAgIHZhciBzcmMgPSBvYmouZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBvYmouZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYyAhPSBfZGF0YTIuc291cmNlKSB7XG4gICAgICAgICAgc3BlYy5zb3VyY2UgPSAnJyArIHNyYzsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRndCAhPSBudWxsICYmIHRndCAhPSBfZGF0YTIudGFyZ2V0KSB7XG4gICAgICAgICAgc3BlYy50YXJnZXQgPSAnJyArIHRndDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKChwYXJlbnQgIT0gbnVsbCB8fCBfZGF0YTIucGFyZW50ICE9IG51bGwpICYmIHBhcmVudCAhPSBfZGF0YTIucGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYW4ndCBzZXQgdW5kZWZpbmVkIGltcGVyYXRpdmVseSwgc28gdXNlIG51bGxcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSAnJyArIHBhcmVudDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGUgPSBlbGUubW92ZSh7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgfSAvLyBpZ25vcmUgZ3JvdXAgLS0gaW1tdXRhYmxlXG5cblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uIGNoZWNrU3dpdGNoKGssIHRydWVGbk5hbWUsIGZhbHNlRm5OYW1lKSB7XG4gICAgICB2YXIgb2JqX2sgPSBvYmpba107XG5cbiAgICAgIGlmIChvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwW2tdKSB7XG4gICAgICAgIGlmIChvYmpfaykge1xuICAgICAgICAgIGVsZVt0cnVlRm5OYW1lXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVtmYWxzZUZuTmFtZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja1N3aXRjaCgncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScpO1xuICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RlZCcsICdzZWxlY3QnLCAndW5zZWxlY3QnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknKTtcbiAgICBjaGVja1N3aXRjaCgnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyk7XG4gICAgY2hlY2tTd2l0Y2goJ2dyYWJiYWJsZScsICdncmFiaWZ5JywgJ3VuZ3JhYmlmeScpO1xuICAgIGNoZWNrU3dpdGNoKCdwYW5uYWJsZScsICdwYW5pZnknLCAndW5wYW5pZnknKTtcblxuICAgIGlmIChvYmouY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICBlbGUuY2xhc3NlcyhvYmouY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGdldFxuICAgIHZhciBqc29uID0ge1xuICAgICAgZGF0YTogY29weShwLmRhdGEpLFxuICAgICAgcG9zaXRpb246IGNvcHkocC5wb3NpdGlvbiksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBwYW5uYWJsZTogcC5wYW5uYWJsZSxcbiAgICAgIGNsYXNzZXM6IG51bGxcbiAgICB9O1xuICAgIGpzb24uY2xhc3NlcyA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICBwLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICByZXR1cm4ganNvbi5jbGFzc2VzICs9IGkrKyA9PT0gMCA/IGNscyA6ICcgJyArIGNscztcbiAgICB9KTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufTtcblxuZWxlc2ZuJHUuanNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBqc29ucyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICBqc29ucy5wdXNoKGpzb24pO1xuICB9XG5cbiAgcmV0dXJuIGpzb25zO1xufTtcblxuZWxlc2ZuJHUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGVsZXNBcnIgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgdmFyIGNsb25lID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgZWxlc0Fyci5wdXNoKGNsb25lKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlc0Fycik7XG59O1xuXG5lbGVzZm4kdS5jb3B5ID0gZWxlc2ZuJHUuY2xvbmU7XG5cbmVsZXNmbiR1LnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGFkZFRvUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7IC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG5cbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgZWxlbWVudHM7XG5cbiAgZm9yICh2YXIgX2kyID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBfaTIgPCBsOyBfaTIrKykge1xuICAgIHZhciBlbGUgPSBzZWxmW19pMl07XG5cbiAgICBpZiAoYWRkVG9Qb29sICYmICFlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcblxuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoZWRnZXMpO1xuICB2YXIgaTtcblxuICB2YXIgcmVtb3ZlRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUVsZW1lbnRzKCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICBpLS07XG4gIH07IC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZWxlID0gZWxlbWVudHNbaV07XG4gICAgdmFyIF9wcml2YXRlID0gX2VsZS5fcHJpdmF0ZTtcbiAgICB2YXIgX2RhdGEzID0gX3ByaXZhdGUuZGF0YTsgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcblxuICAgIF9lbGUuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG5cblxuICAgIGlmICghYWRkVG9Qb29sICYmICFfcHJpdmF0ZS5yZW1vdmVkKSA7IGVsc2UgaWYgKF9kYXRhMy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZGF0YTMuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoY3ksIF9lbGUpO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyKF9kYXRhMy5pZCkpIHtcbiAgICAgIF9kYXRhMy5pZCA9ICcnICsgX2RhdGEzLmlkOyAvLyBub3cgaXQncyBhIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAoZW1wdHlTdHJpbmcoX2RhdGEzLmlkKSB8fCAhc3RyaW5nKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlbGVtZW50IHdpdGggaW52YWxpZCBzdHJpbmcgSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcblxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEzLmlkKSkge1xuICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIHNlY29uZCBlbGVtZW50IHdpdGggSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuXG4gICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpZCA9IF9kYXRhMy5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYgKF9lbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3Igbm9kZXNcbiAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjsgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICBpZiAocG9zLnggPT0gbnVsbCkge1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MueSA9PSBudWxsKSB7XG4gICAgICAgIHBvcy55ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2VsZS5pc0VkZ2UoKSkge1xuICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuICAgICAgdmFyIGVkZ2UgPSBfZWxlO1xuICAgICAgdmFyIGZpZWxkcyA9IFsnc291cmNlJywgJ3RhcmdldCddO1xuICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHNMZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciB2YWwgPSBfZGF0YTNbZmllbGRdO1xuXG4gICAgICAgIGlmIChudW1iZXIodmFsKSkge1xuICAgICAgICAgIHZhbCA9IF9kYXRhM1tmaWVsZF0gPSAnJyArIF9kYXRhM1tmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghY3kuaGFzRWxlbWVudFdpdGhJZCh2YWwpKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWRTb3VyY2VPclRhcmdldCkge1xuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cblxuICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy5zb3VyY2UpO1xuICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy50YXJnZXQpOyAvLyBvbmx5IG9uZSBlZGdlIGluIG5vZGUgaWYgbG9vcFxuXG4gICAgICBpZiAoc3JjLnNhbWUodGd0KSkge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgIH0gLy8gaWYgaXMgZWRnZVxuICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG5cblxuICAgIF9wcml2YXRlLm1hcCA9IG5ldyBNYXAkMSgpO1xuXG4gICAgX3ByaXZhdGUubWFwLnNldChpZCwge1xuICAgICAgZWxlOiBfZWxlLFxuICAgICAgaW5kZXg6IDBcbiAgICB9KTtcblxuICAgIF9wcml2YXRlLnJlbW92ZWQgPSBmYWxzZTtcblxuICAgIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIGN5LmFkZFRvUG9vbChfZWxlKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVhY2ggZWxlbWVudFxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcblxuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAvLyBlYWNoIG5vZGVcbiAgICB2YXIgbm9kZSA9IG5vZGVzW19pM107XG4gICAgdmFyIF9kYXRhNCA9IG5vZGUuX3ByaXZhdGUuZGF0YTtcblxuICAgIGlmIChudW1iZXIoX2RhdGE0LnBhcmVudCkpIHtcbiAgICAgIC8vIHRoZW4gYXV0b21ha2Ugc3RyaW5nXG4gICAgICBfZGF0YTQucGFyZW50ID0gJycgKyBfZGF0YTQucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZCA9IF9kYXRhNC5wYXJlbnQ7XG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICBpZiAoc3BlY2lmaWVkUGFyZW50KSB7XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xuXG4gICAgICBpZiAocGFyZW50LmVtcHR5KCkpIHtcbiAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuXG4gICAgICAgIHdoaWxlICghYW5jZXN0b3IuZW1wdHkoKSkge1xuICAgICAgICAgIGlmIChub2RlLnNhbWUoYW5jZXN0b3IpKSB7XG4gICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNlbGZBc1BhcmVudCkge1xuICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07IC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuXG4gICAgICAgICAgY3lfcC5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbHNlXG5cbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcblxuICB9IC8vIGZvciBlYWNoIG5vZGVcblxuXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHJlc3RvcmVkID0gbmV3IENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHJlc3RvcmVkLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBfZWxlMiA9IHJlc3RvcmVkW19pNF07XG5cbiAgICAgIGlmIChfZWxlMi5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuXG5cbiAgICAgIF9lbGUyLnBhcmFsbGVsRWRnZXMoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIHRoZSBjb25uZWN0ZWQgbm9kZXNcblxuXG4gICAgICBfZWxlMi5zb3VyY2UoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAgIF9lbGUyLnRhcmdldCgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG5cbiAgICB2YXIgdG9VcGRhdGVTdHlsZTtcblxuICAgIGlmIChjeV9wLmhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSBjeS5jb2xsZWN0aW9uKCkubWVyZ2UocmVzdG9yZWQpLm1lcmdlKHJlc3RvcmVkLmNvbm5lY3RlZE5vZGVzKCkpLm1lcmdlKHJlc3RvcmVkLnBhcmVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkO1xuICAgIH1cblxuICAgIHRvVXBkYXRlU3R5bGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCkuZGlydHlCb3VuZGluZ0JveENhY2hlKCkudXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpO1xuXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZXN0b3JlZC5lbWl0QW5kTm90aWZ5KCdhZGQnKTtcbiAgICB9IGVsc2UgaWYgKGFkZFRvUG9vbCkge1xuICAgICAgcmVzdG9yZWQuZW1pdCgnYWRkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxufTtcblxuZWxlc2ZuJHUucmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4kdS5pbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbn07XG5cbmVsZXNmbiR1LnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICB2YXIgcmVtb3ZlRnJvbVBvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gIHZhciBjeSA9IHNlbGYuX3ByaXZhdGUuY3k7IC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcblxuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZChlZGdlc1tpXSk7XG4gICAgfVxuICB9IC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG5cblxuICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkKGVsZSkge1xuICAgIHZhciBhbHJlYWR5QWRkZWQgPSBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldO1xuXG4gICAgaWYgKHJlbW92ZUZyb21Qb29sICYmIGVsZS5yZW1vdmVkKCkgfHwgYWxyZWFkeUFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGVsZXNUb1JlbW92ZS5wdXNoKGVsZSk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoZWxlKTtcbiAgICAgIGFkZENoaWxkcmVuKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KGVsZSk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgfVxuICB9IC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICBhZGQoZWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYobm9kZSwgZWRnZSkge1xuICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNvbm5lY3RlZEVkZ2VzLCBlZGdlKTsgLy8gcmVtb3ZpbmcgYW4gZWRnZXMgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgaXRzIG5vZGVzXG5cbiAgICBub2RlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpIHtcbiAgICAvLyByZW1vdmluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICBwbGxFZGdlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuXG4gIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICBhbHRlcmVkUGFyZW50cy5pZHMgPSB7fTtcblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSkge1xuICAgIGVsZSA9IGVsZVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuICAgIHZhciBwaWQgPSBwYXJlbnQuaWQoKTtcbiAgICByZW1vdmVGcm9tQXJyYXkoY2hpbGRyZW4sIGVsZSk7IC8vIHJlbW92ZSBwYXJlbnQgPT4gY2hpbGQgcmVmXG5cbiAgICBlbGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDsgLy8gcmVtb3ZlIGNoaWxkID0+IHBhcmVudCByZWZcblxuICAgIGlmICghYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0pIHtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1twaWRdID0gdHJ1ZTtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBzZWxmLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuXG4gIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgIGN5LnJlbW92ZUZyb21Qb29sKGVsZXNUb1JlbW92ZSk7IC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICB9XG5cbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgX2k1KyspIHtcbiAgICB2YXIgX2VsZTMgPSBlbGVzVG9SZW1vdmVbX2k1XTtcblxuICAgIGlmIChfZWxlMy5pc0VkZ2UoKSkge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhpcyBlZGdlIGluIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIHZhciBzcmMgPSBfZWxlMy5zb3VyY2UoKVswXTtcblxuICAgICAgdmFyIHRndCA9IF9lbGUzLnRhcmdldCgpWzBdO1xuXG4gICAgICByZW1vdmVFZGdlUmVmKHNyYywgX2VsZTMpO1xuICAgICAgcmVtb3ZlRWRnZVJlZih0Z3QsIF9lbGUzKTtcblxuICAgICAgdmFyIHBsbEVkZ2VzID0gX2VsZTMucGFyYWxsZWxFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBsbEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwbGxFZGdlID0gcGxsRWRnZXNbal07XG4gICAgICAgIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpO1xuXG4gICAgICAgIGlmIChwbGxFZGdlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IF9lbGUzLnBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZW1vdmVDaGlsZFJlZihwYXJlbnQsIF9lbGUzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgX2VsZTMuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9IC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGggb3Igbm90XG5cblxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfZWxlNCA9IGVsZXNTdGlsbEluc2lkZVtfaTZdO1xuXG4gICAgaWYgKF9lbGU0LmlzUGFyZW50KCkpIHtcbiAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlc1RvUmVtb3ZlKTtcblxuICBpZiAocmVtb3ZlZEVsZW1lbnRzLnNpemUoKSA+IDApIHtcbiAgICAvLyBtdXN0IG1hbnVhbGx5IG5vdGlmeSBzaW5jZSB0cmlnZ2VyIHdvbid0IGRvIHRoaXMgYXV0b21hdGljYWxseSBvbmNlIHJlbW92ZWRcbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0QW5kTm90aWZ5KCdyZW1vdmUnKTtcbiAgICB9IGVsc2UgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdCgncmVtb3ZlJyk7XG4gICAgfVxuICB9IC8vIHRoZSBwYXJlbnRzIHdobyB3ZXJlIG1vZGlmaWVkIGJ5IHRoZSByZW1vdmFsIG5lZWQgdGhlaXIgc3R5bGUgdXBkYXRlZFxuXG5cbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgYWx0ZXJlZFBhcmVudHMubGVuZ3RoOyBfaTcrKykge1xuICAgIHZhciBfZWxlNSA9IGFsdGVyZWRQYXJlbnRzW19pN107XG5cbiAgICBpZiAoIXJlbW92ZUZyb21Qb29sIHx8ICFfZWxlNS5yZW1vdmVkKCkpIHtcbiAgICAgIF9lbGU1LnVwZGF0ZVN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWRFbGVtZW50cztcbn07XG5cbmVsZXNmbiR1Lm1vdmUgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gdGhpczsgLy8ganVzdCBjbGVhbiB1cCByZWZzLCBjYWNoZXMsIGV0Yy4gaW4gdGhlIHNhbWUgd2F5IGFzIHdoZW4gcmVtb3ZpbmcgYW5kIHRoZW4gcmVzdG9yaW5nXG4gIC8vIChvdXIgY2FsbHMgdG8gcmVtb3ZlL3Jlc3RvcmUgZG8gbm90IHJlbW92ZSBmcm9tIHRoZSBncmFwaCBvciBtYWtlIGV2ZW50cylcblxuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBmYWxzZTtcbiAgdmFyIG1vZGlmeVBvb2wgPSBmYWxzZTtcblxuICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhpZCkge1xuICAgIHJldHVybiBpZCA9PSBudWxsID8gaWQgOiAnJyArIGlkO1xuICB9OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG5cbiAgaWYgKHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3JjSWQgPSB0b1N0cmluZyhzdHJ1Y3Quc291cmNlKTtcbiAgICB2YXIgdGd0SWQgPSB0b1N0cmluZyhzdHJ1Y3QudGFyZ2V0KTtcbiAgICB2YXIgc3JjRXhpc3RzID0gc3JjSWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHNyY0lkKTtcbiAgICB2YXIgdGd0RXhpc3RzID0gdGd0SWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHRndElkKTtcblxuICAgIGlmIChzcmNFeGlzdHMgfHwgdGd0RXhpc3RzKSB7XG4gICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgIGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNSA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgaWYgKHNyY0V4aXN0cykge1xuICAgICAgICAgICAgICBfZGF0YTUuc291cmNlID0gc3JjSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0Z3RFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnRhcmdldCA9IHRndElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZXMucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgIHZhciBwYXJlbnRJZCA9IHRvU3RyaW5nKHN0cnVjdC5wYXJlbnQpO1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5oYXNFbGVtZW50V2l0aElkKHBhcmVudElkKTtcblxuICAgIGlmIChwYXJlbnRFeGlzdHMpIHtcbiAgICAgIHZhciBwaWRUb0Fzc2lnbiA9IHBhcmVudElkID09PSBudWxsID8gdW5kZWZpbmVkIDogcGFyZW50SWQ7XG4gICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgIHZhciB1cGRhdGVkID0gZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cblxuICAgICAgICB1cGRhdGVkLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgX2RhdGE2ID0gZWxlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICBfZGF0YTYucGFyZW50ID0gcGlkVG9Bc3NpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlZC5yZXN0b3JlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gbWFrZSBuZXcgcmVmcywgc3R5bGUsIGV0Yy5cbiAgICAgIH0pO1xuICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5bZWxlc2ZuJGMsIGVsZXNmbiRkLCBlbGVzZm4kZSwgZWxlc2ZuJGYsIGVsZXNmbiRnLCBkYXRhJDEsIGVsZXNmbiRpLCBkaW1lbnNpb25zLCBlbGVzZm4kbSwgZWxlc2ZuJG4sIGVsZXNmbiRvLCBlbGVzZm4kcCwgZWxlc2ZuJHEsIGVsZXNmbiRyLCBlbGVzZm4kcywgZWxlc2ZuJHRdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChlbGVzZm4kdSwgcHJvcHMpO1xufSk7XG5cbnZhciBjb3JlZm4gPSB7XG4gIGFkZDogZnVuY3Rpb24gYWRkKG9wdHMpIHtcbiAgICB2YXIgZWxlbWVudHM7XG4gICAgdmFyIGN5ID0gdGhpczsgLy8gYWRkIHRoZSBlbGVtZW50c1xuXG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykpIHtcbiAgICAgIHZhciBlbGVzID0gb3B0cztcblxuICAgICAgaWYgKGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5KSB7XG4gICAgICAgIC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIGpzb25zLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgfSAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICBlbHNlIGlmIChhcnJheShvcHRzKSkge1xuICAgICAgICB2YXIgX2pzb25zID0gb3B0cztcbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zKTtcbiAgICAgIH0gLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgICAgZWxzZSBpZiAocGxhaW5PYmplY3Qob3B0cykgJiYgKGFycmF5KG9wdHMubm9kZXMpIHx8IGFycmF5KG9wdHMuZWRnZXMpKSkge1xuICAgICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgICAgdmFyIF9qc29uczIgPSBbXTtcbiAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbCA9IGdycy5sZW5ndGg7IF9pIDwgaWw7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyc1tfaV07XG4gICAgICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbZ3JvdXBdO1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkoZWxlc0FycmF5KSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgICAgIH0sIGVsZXNBcnJheVtqXSk7XG5cbiAgICAgICAgICAgICAgICBfanNvbnMyLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBfanNvbnMyKTtcbiAgICAgICAgfSAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9qc29uID0gb3B0cztcbiAgICAgICAgICAgIGVsZW1lbnRzID0gbmV3IEVsZW1lbnQoY3ksIF9qc29uKS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikpIDsgZWxzZSBpZiAoc3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJChzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cblxuLyohIEJlemllciBjdXJ2ZSBmdW5jdGlvbiBnZW5lcmF0b3IuIENvcHlyaWdodCBHYWV0YW4gUmVuYXVkZWF1LiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNCxcbiAgICAgIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcbiAgICAgIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMSxcbiAgICAgIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTAsXG4gICAgICBrU3BsaW5lVGFibGVTaXplID0gMTEsXG4gICAgICBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCksXG4gICAgICBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJztcbiAgLyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqL1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZ3VtZW50c1tpXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyogWCB2YWx1ZXMgbXVzdCBiZSBpbiB0aGUgWzAsIDFdIHJhbmdlLiAqL1xuXG5cbiAgbVgxID0gTWF0aC5taW4obVgxLCAxKTtcbiAgbVgyID0gTWF0aC5taW4obVgyLCAxKTtcbiAgbVgxID0gTWF0aC5tYXgobVgxLCAwKTtcbiAgbVgyID0gTWF0aC5tYXgobVgyLCAwKTtcbiAgdmFyIG1TYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG4gIH1cblxuICBmdW5jdGlvbiBDKGFBMSkge1xuICAgIHJldHVybiAzLjAgKiBhQTE7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTkVXVE9OX0lURVJBVElPTlM7ICsrX2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjU2FtcGxlVmFsdWVzKCkge1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGtTcGxpbmVUYWJsZVNpemU7ICsrX2kyKSB7XG4gICAgICBtU2FtcGxlVmFsdWVzW19pMl0gPSBjYWxjQmV6aWVyKF9pMiAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCKSB7XG4gICAgdmFyIGN1cnJlbnRYLFxuICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wLFxuICAgICAgICBjdXJyZW50U2FtcGxlID0gMSxcbiAgICAgICAgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG5cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pLFxuICAgICAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZSxcbiAgICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiBmKGFYKSB7XG4gICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcbiAgICAgIHByZWNvbXB1dGUoKTtcbiAgICB9XG5cbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiBhWDtcbiAgICB9XG5cbiAgICBpZiAoYVggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhWCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gIH07XG5cbiAgZi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbe1xuICAgICAgeDogbVgxLFxuICAgICAgeTogbVkxXG4gICAgfSwge1xuICAgICAgeDogbVgyLFxuICAgICAgeTogbVkyXG4gICAgfV07XG4gIH07XG5cbiAgdmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuXG4gIGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gZjtcbn1cblxuLyohIFJ1bmdlLUt1dHRhIHNwcmluZyBwaHlzaWNzIGZ1bmN0aW9uIGdlbmVyYXRvci4gQWRhcHRlZCBmcm9tIEZyYW1lci5qcywgY29weXJpZ2h0IEtvZW4gQm9rLiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuXG4vKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgdGhlbiBhZGp1c3RzIHRoZSB0aW1lIGRlbHRhIC0tIHVzaW5nIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbCB0aW1lIGFuZCBkdXJhdGlvbiAtLSB0byBjYWxjdWxhdGUgdGhlIHBhdGggZm9yIHRoZSBkdXJhdGlvbi1jb25zdHJhaW5lZCBhbmltYXRpb24uICovXG52YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCAtIHN0YXRlLmZyaWN0aW9uICogc3RhdGUudjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgeDogaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQsXG4gICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgZnJpY3Rpb246IGluaXRpYWxTdGF0ZS5mcmljdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShzdGF0ZSwgZHQpIHtcbiAgICB2YXIgYSA9IHtcbiAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgIH0sXG4gICAgICAgIGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBhKSxcbiAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgICBkID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCwgYyksXG4gICAgICAgIGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcbiAgICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICB4OiAtMSxcbiAgICAgIHY6IDAsXG4gICAgICB0ZW5zaW9uOiBudWxsLFxuICAgICAgZnJpY3Rpb246IG51bGxcbiAgICB9LFxuICAgICAgICBwYXRoID0gWzBdLFxuICAgICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICAgIHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcbiAgICAgICAgRFQgPSAxNiAvIDEwMDAsXG4gICAgICAgIGhhdmVfZHVyYXRpb24sXG4gICAgICAgIGR0LFxuICAgICAgICBsYXN0X3N0YXRlO1xuICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcbiAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcbiAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgaW5pdFN0YXRlLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuICAgIC8qIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHRpbWUgaXQgdGFrZXMgZm9yIHRoaXMgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIHdpdGggdGhlIHByb3ZpZGVkIGNvbmRpdGlvbnMuICovXG5cbiAgICBpZiAoaGF2ZV9kdXJhdGlvbikge1xuICAgICAgLyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cbiAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAvKiBDb21wdXRlIHRoZSBhZGp1c3RlZCB0aW1lIGRlbHRhLiAqL1xuXG4gICAgICBkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHQgPSBEVDtcbiAgICB9XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICBsYXN0X3N0YXRlID0gc3ByaW5nSW50ZWdyYXRlU3RhdGUobGFzdF9zdGF0ZSB8fCBpbml0U3RhdGUsIGR0KTtcbiAgICAgIC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cblxuICAgICAgcGF0aC5wdXNoKDEgKyBsYXN0X3N0YXRlLngpO1xuICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cblxuICAgICAgaWYgKCEoTWF0aC5hYnMobGFzdF9zdGF0ZS54KSA+IHRvbGVyYW5jZSAmJiBNYXRoLmFicyhsYXN0X3N0YXRlLnYpID4gdG9sZXJhbmNlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuXG5cbiAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uIChwZXJjZW50Q29tcGxldGUpIHtcbiAgICAgIHJldHVybiBwYXRoW3BlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpIHwgMF07XG4gICAgfTtcbiAgfTtcbn0oKTtcblxudmFyIGN1YmljQmV6aWVyID0gZnVuY3Rpb24gY3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpIHtcbiAgdmFyIGJlemllciA9IGdlbmVyYXRlQ3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogYmV6aWVyKHBlcmNlbnQpO1xuICB9O1xufTtcblxudmFyIGVhc2luZ3MgPSB7XG4gICdsaW5lYXInOiBmdW5jdGlvbiBsaW5lYXIoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwZXJjZW50O1xuICB9LFxuICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgJ2Vhc2UnOiBjdWJpY0JlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpLFxuICAnZWFzZS1pbic6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDEsIDEpLFxuICAnZWFzZS1vdXQnOiBjdWJpY0JlemllcigwLCAwLCAwLjU4LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0JzogY3ViaWNCZXppZXIoMC40MiwgMCwgMC41OCwgMSksXG4gIC8vIHNpbmVcbiAgJ2Vhc2UtaW4tc2luZSc6IGN1YmljQmV6aWVyKDAuNDcsIDAsIDAuNzQ1LCAwLjcxNSksXG4gICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC4zOSwgMC41NzUsIDAuNTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjQ0NSwgMC4wNSwgMC41NSwgMC45NSksXG4gIC8vIHF1YWRcbiAgJ2Vhc2UtaW4tcXVhZCc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzKSxcbiAgJ2Vhc2Utb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KSxcbiAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjQ1NSwgMC4wMywgMC41MTUsIDAuOTU1KSxcbiAgLy8gY3ViaWNcbiAgJ2Vhc2UtaW4tY3ViaWMnOiBjdWJpY0JlemllcigwLjU1LCAwLjA1NSwgMC42NzUsIDAuMTkpLFxuICAnZWFzZS1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjIxNSwgMC42MSwgMC4zNTUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxKSxcbiAgLy8gcXVhcnRcbiAgJ2Vhc2UtaW4tcXVhcnQnOiBjdWJpY0JlemllcigwLjg5NSwgMC4wMywgMC42ODUsIDAuMjIpLFxuICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSksXG4gICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSxcbiAgLy8gcXVpbnRcbiAgJ2Vhc2UtaW4tcXVpbnQnOiBjdWJpY0JlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpLFxuICAnZWFzZS1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjIzLCAxLCAwLjMyLCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC44NiwgMCwgMC4wNywgMSksXG4gIC8vIGV4cG9cbiAgJ2Vhc2UtaW4tZXhwbyc6IGN1YmljQmV6aWVyKDAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNSksXG4gICdlYXNlLW91dC1leHBvJzogY3ViaWNCZXppZXIoMC4xOSwgMSwgMC4yMiwgMSksXG4gICdlYXNlLWluLW91dC1leHBvJzogY3ViaWNCZXppZXIoMSwgMCwgMCwgMSksXG4gIC8vIGNpcmNcbiAgJ2Vhc2UtaW4tY2lyYyc6IGN1YmljQmV6aWVyKDAuNiwgMC4wNCwgMC45OCwgMC4zMzUpLFxuICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSksXG4gICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2KSxcbiAgLy8gdXNlciBwYXJhbSBlYXNpbmdzLi4uXG4gICdzcHJpbmcnOiBmdW5jdGlvbiBzcHJpbmcodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAvLyBjYW4ndCBnZXQgYSBzcHJpbmcgdy8gZHVyYXRpb24gMFxuICAgICAgcmV0dXJuIGVhc2luZ3MubGluZWFyOyAvLyBkdXJhdGlvbiAwID0+IGp1bXAgdG8gZW5kIHNvIGltcGwgZG9lc24ndCBtYXR0ZXJcbiAgICB9XG5cbiAgICB2YXIgc3ByaW5nID0gZ2VuZXJhdGVTcHJpbmdSSzQodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBzcHJpbmcocGVyY2VudCk7XG4gICAgfTtcbiAgfSxcbiAgJ2N1YmljLWJlemllcic6IGN1YmljQmV6aWVyXG59O1xuXG5mdW5jdGlvbiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKSB7XG4gIGlmIChwZXJjZW50ID09PSAxKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuXG4gIHZhciB2YWwgPSBlYXNpbmdGbihzdGFydCwgZW5kLCBwZXJjZW50KTtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh0eXBlLnJvdW5kVmFsdWUgfHwgdHlwZS5jb2xvcikge1xuICAgIHZhbCA9IE1hdGgucm91bmQodmFsKTtcbiAgfVxuXG4gIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5tYXgodmFsLCB0eXBlLm1pbik7XG4gIH1cblxuICBpZiAodHlwZS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWluKHZhbCwgdHlwZS5tYXgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUocHJvcCwgc3BlYykge1xuICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgfHwgcHJvcC52YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsICYmIChzcGVjID09IG51bGwgfHwgc3BlYy50eXBlLnVuaXRzICE9PSAnJScpKSB7XG4gICAgICByZXR1cm4gcHJvcC5wZlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJvcC52YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQsIGVhc2luZ0ZuLCBwcm9wU3BlYykge1xuICB2YXIgdHlwZSA9IHByb3BTcGVjICE9IG51bGwgPyBwcm9wU3BlYy50eXBlIDogbnVsbDtcblxuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gZ2V0VmFsdWUoc3RhcnRQcm9wLCBwcm9wU3BlYyk7XG4gIHZhciBlbmQgPSBnZXRWYWx1ZShlbmRQcm9wLCBwcm9wU3BlYyk7XG5cbiAgaWYgKG51bWJlcihzdGFydCkgJiYgbnVtYmVyKGVuZCkpIHtcbiAgICByZXR1cm4gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3RhcnQpICYmIGFycmF5KGVuZCkpIHtcbiAgICB2YXIgZWFzZWRBcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgIHZhciBlaSA9IGVuZFtpXTtcblxuICAgICAgaWYgKHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsID0gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzaSwgZWksIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgICAgICAgZWFzZWRBcnIucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZWRBcnIucHVzaChlaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhc2VkQXJyO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc3RlcChzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuICB2YXIgY3kgPSBpc0NvcmUgPyBzZWxmIDogc2VsZi5jeSgpO1xuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gIGlmICghYW5pX3AuZWFzaW5nSW1wbCkge1xuICAgIGlmIChwRWFzaW5nID09IG51bGwpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0XG4gICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1snbGluZWFyJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgIHZhciBlYXNpbmdWYWxzO1xuXG4gICAgICBpZiAoc3RyaW5nKHBFYXNpbmcpKSB7XG4gICAgICAgIHZhciBlYXNpbmdQcm9wID0gc3R5bGUucGFyc2UoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgcEVhc2luZyk7XG4gICAgICAgIGVhc2luZ1ZhbHMgPSBlYXNpbmdQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBhc3N1bWUgcHJlcGFyc2VkIGFycmF5XG4gICAgICAgIGVhc2luZ1ZhbHMgPSBwRWFzaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSwgYXJncztcblxuICAgICAgaWYgKHN0cmluZyhlYXNpbmdWYWxzKSkge1xuICAgICAgICBuYW1lID0gZWFzaW5nVmFscztcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHNbMV07XG4gICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKDIpLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiArbjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gY3JlYXRlIHdpdGggYXJnc1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3NwcmluZycpIHtcbiAgICAgICAgICBhcmdzLnB1c2goYW5pX3AuZHVyYXRpb24pOyAvLyBuZWVkIGR1cmF0aW9uIHRvIGdlbmVyYXRlIHNwcmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICB2YXIgcGVyY2VudDtcblxuICBpZiAoYW5pX3AuZHVyYXRpb24gPT09IDApIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBwZXJjZW50ID0gKG5vdyAtIHN0YXJ0VGltZSkgLyBhbmlfcC5kdXJhdGlvbjtcbiAgfVxuXG4gIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgIHBlcmNlbnQgPSBhbmlfcC5wcm9ncmVzcztcbiAgfVxuXG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cblxuICBpZiAoYW5pX3AuZGVsYXkgPT0gbnVsbCkge1xuICAgIC8vIHRoZW4gdXBkYXRlXG4gICAgdmFyIHN0YXJ0UG9zID0gYW5pX3Auc3RhcnRQb3NpdGlvbjtcbiAgICB2YXIgZW5kUG9zID0gYW5pX3AucG9zaXRpb247XG5cbiAgICBpZiAoZW5kUG9zICYmIGlzRWxlcyAmJiAhc2VsZi5sb2NrZWQoKSkge1xuICAgICAgdmFyIG5ld1BvcyA9IHt9O1xuXG4gICAgICBpZiAodmFsaWQoc3RhcnRQb3MueCwgZW5kUG9zLngpKSB7XG4gICAgICAgIG5ld1Bvcy54ID0gZWFzZShzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLnksIGVuZFBvcy55KSkge1xuICAgICAgICBuZXdQb3MueSA9IGVhc2Uoc3RhcnRQb3MueSwgZW5kUG9zLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucG9zaXRpb24obmV3UG9zKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICB2YXIgZW5kUGFuID0gYW5pX3AucGFuO1xuICAgIHZhciBwYW4gPSBfcC5wYW47XG4gICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcblxuICAgIGlmIChhbmltYXRpbmdQYW4pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi54LCBlbmRQYW4ueCkpIHtcbiAgICAgICAgcGFuLnggPSBlYXNlKHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueSwgZW5kUGFuLnkpKSB7XG4gICAgICAgIHBhbi55ID0gZWFzZShzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KCdwYW4nKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG5cbiAgICBpZiAoYW5pbWF0aW5nWm9vbSkge1xuICAgICAgaWYgKHZhbGlkKHN0YXJ0Wm9vbSwgZW5kWm9vbSkpIHtcbiAgICAgICAgX3Auem9vbSA9IGJvdW5kKF9wLm1pblpvb20sIGVhc2Uoc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50LCBlYXNpbmcpLCBfcC5tYXhab29tKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5lbWl0KCd6b29tJyk7XG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tKSB7XG4gICAgICBzZWxmLmVtaXQoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gYW5pX3Auc3R5bGU7XG5cbiAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoID4gMCAmJiBpc0VsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgZW5kID0gcHJvcDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYW5pX3Auc3RhcnRTdHlsZVtfbmFtZV07XG4gICAgICAgIHZhciBwcm9wU3BlYyA9IHN0eWxlLnByb3BlcnRpZXNbc3RhcnQubmFtZV07XG4gICAgICAgIHZhciBlYXNlZFZhbCA9IGVhc2Uoc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nLCBwcm9wU3BlYyk7XG4gICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKHNlbGYsIF9uYW1lLCBlYXNlZFZhbCk7XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICAgIHNlbGYuZW1pdCgnc3R5bGUnKTtcbiAgICB9IC8vIGlmXG5cbiAgfVxuXG4gIGFuaV9wLnByb2dyZXNzID0gcGVyY2VudDtcbiAgcmV0dXJuIHBlcmNlbnQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobnVtYmVyKHN0YXJ0KSAmJiBudW1iZXIoZW5kKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gIGFuaV9wLnN0YXJ0VGltZSA9IG5vdyAtIGFuaV9wLnByb2dyZXNzICogYW5pX3AuZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIHN0ZXBBbGwobm93LCBjeSkge1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXBPbmUoZWxlLCBpc0NvcmUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgdmFyIHJhbkFuaXMgPSBmYWxzZTsgLy8gY2FuY2VsIGFsbCBhbmltYXRpb25zIG9uIGRpc3BsYXk6bm9uZSBlbGVcblxuICAgIGlmICghaXNDb3JlICYmIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAvLyBwdXQgYWxsIGN1cnJlbnQgYW5kIHF1ZXVlIGFuaW1hdGlvbnMgaW4gdGhpcyB0aWNrJ3MgY3VycmVudCBsaXN0XG4gICAgICAvLyBhbmQgZW1wdHkgdGhlIGxpc3RzIGZvciB0aGUgZWxlbWVudFxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc3BsaWNlKDAsIGN1cnJlbnQubGVuZ3RoKS5jb25jYXQocXVldWUuc3BsaWNlKDAsIHF1ZXVlLmxlbmd0aCkpOyAvLyBzdG9wIGFsbCBhbmltYXRpb25zXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50W2ldLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuXG5cbiAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiBjYWxsYmFja3MoX2NhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IF9jYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGNiID0gX2NhbGxiYWNrc1tqXTtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cblxuICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoMCwgX2NhbGxiYWNrcy5sZW5ndGgpO1xuICAgIH07IC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG5cblxuICAgIGZvciAodmFyIF9pID0gY3VycmVudC5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG4gICAgICB2YXIgYW5pID0gY3VycmVudFtfaV07XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChhbmlfcC5zdG9wcGVkKSB7XG4gICAgICAgIGN1cnJlbnQuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcblxuXG4gICAgICBpZiAoYW5pX3AucGxheWluZyAmJiBhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFuaV9wLnN0YXJ0ZWQpIHtcbiAgICAgICAgc3RhcnRBbmltYXRpb24oZWxlLCBhbmksIG5vdyk7XG4gICAgICB9XG5cbiAgICAgIHN0ZXAoZWxlLCBhbmksIG5vdywgaXNDb3JlKTtcblxuICAgICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuXG4gICAgICBpZiAoYW5pX3Auc3RlcCAhPSBudWxsKSB7XG4gICAgICAgIGFuaV9wLnN0ZXAobm93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaS5jb21wbGV0ZWQoKSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShfaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmNvbXBsZXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZG9uZUVsZXMucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJldHVybiByYW5BbmlzO1xuICB9IC8vIHN0ZXBFbGVtZW50XG4gIC8vIGhhbmRsZSBhbGwgZWxlc1xuXG5cbiAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IHN0ZXBPbmUoZWxlKTtcbiAgICByYW5FbGVBbmkgPSByYW5FbGVBbmkgfHwgaGFuZGxlZFRoaXNFbGU7XG4gIH0gLy8gZWFjaCBlbGVtZW50XG5cblxuICB2YXIgcmFuQ29yZUFuaSA9IHN0ZXBPbmUoY3ksIHRydWUpOyAvLyBub3RpZnkgcmVuZGVyZXJcblxuICBpZiAocmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkpIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnLCBlbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgfVxuICB9IC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuXG5cbiAgZWxlcy51bm1lcmdlKGRvbmVFbGVzKTtcbiAgY3kuZW1pdCgnc3RlcCcpO1xufSAvLyBzdGVwQWxsXG5cbnZhciBjb3JlZm4kMSA9IHtcbiAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gIGFuaW1hdGU6IGRlZmluZSQzLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUkMy5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZSQzLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZSQzLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZSQzLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUkMy5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUkMy5zdG9wKCksXG4gIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24gYWRkVG9BbmltYXRpb25Qb29sKGVsZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cblxuICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gIH0sXG4gIHN0b3BBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdG9wQW5pbWF0aW9uTG9vcCgpIHtcbiAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gIH0sXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RhcnRBbmltYXRpb25Mb29wKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG4gICAgLy8gTkIgdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgZXhlYyBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgaWYgc3R5bGUgZW5hYmxlZFxuICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuXG4gICAgZnVuY3Rpb24gaGVhZGxlc3NTdGVwKCkge1xuICAgICAgaWYgKCFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRpb25TdGVwKG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgICBoZWFkbGVzc1N0ZXAoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG5cbiAgICBpZiAocmVuZGVyZXIgJiYgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAvLyBsZXQgdGhlIHJlbmRlcmVyIHNjaGVkdWxlIGFuaW1hdGlvbnNcbiAgICAgIHJlbmRlcmVyLmJlZm9yZVJlbmRlcihmdW5jdGlvbiByZW5kZXJlckFuaW1hdGlvblN0ZXAod2lsbERyYXcsIG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgfSwgcmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5hbmltYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFuYWdlIHRoZSBhbmltYXRpb24gbG9vcCBvdXJzZWx2ZXNcbiAgICAgIGhlYWRsZXNzU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgfVxuICB9XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMkMSA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuXG4gICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjeSAhPT0gZXZlbnRPYmoudGFyZ2V0ICYmIGVsZW1lbnQoZXZlbnRPYmoudGFyZ2V0KSAmJiBzZWxlY3Rvci5tYXRjaGVzKGV2ZW50T2JqLnRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhjeSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gY3k7XG4gICAgZXZ0LnRhcmdldCA9IGN5O1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogY3k7XG4gIH1cbn07XG5cbnZhciBhcmdTZWxlY3RvciQxID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gIGlmIChzdHJpbmcoYXJnKSkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnO1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJHYgPSB7XG4gIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zJDEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZWxlcykge1xuICAgIHRoaXMuZW1pdChldmVudCk7XG4gICAgdGhpcy5ub3RpZnkoZXZlbnQsIGVsZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuZGVmaW5lJDMuZXZlbnRBbGlhc2VzT24oZWxlc2ZuJHYpO1xuXG52YXIgY29yZWZuJDIgPSB7XG4gIHBuZzogZnVuY3Rpb24gcG5nKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiByZW5kZXJlci5wbmcob3B0aW9ucyk7XG4gIH0sXG4gIGpwZzogZnVuY3Rpb24ganBnKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuYmcgPSBvcHRpb25zLmJnIHx8ICcjZmZmJztcbiAgICByZXR1cm4gcmVuZGVyZXIuanBnKG9wdGlvbnMpO1xuICB9XG59O1xuY29yZWZuJDIuanBlZyA9IGNvcmVmbiQyLmpwZztcblxudmFyIGNvcmVmbiQzID0ge1xuICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBgbmFtZWAgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHZhciBMYXlvdXQgPSBjeS5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuXG4gICAgaWYgKExheW91dCA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQuICBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0PycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVzO1xuXG4gICAgaWYgKHN0cmluZyhvcHRpb25zLmVsZXMpKSB7XG4gICAgICBlbGVzID0gY3kuJChvcHRpb25zLmVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gb3B0aW9ucy5lbGVzICE9IG51bGwgPyBvcHRpb25zLmVsZXMgOiBjeS4kKCk7XG4gICAgfVxuXG4gICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBjeTogY3ksXG4gICAgICBlbGVzOiBlbGVzXG4gICAgfSkpO1xuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cbn07XG5jb3JlZm4kMy5jcmVhdGVMYXlvdXQgPSBjb3JlZm4kMy5tYWtlTGF5b3V0ID0gY29yZWZuJDMubGF5b3V0O1xuXG52YXIgY29yZWZuJDQgPSB7XG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICh0aGlzLmJhdGNoaW5nKCkpIHtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IF9wLmJhdGNoTm90aWZpY2F0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXSB8fCB0aGlzLmNvbGxlY3Rpb24oKTtcblxuICAgICAgaWYgKGV2ZW50RWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGVsZXMubWVyZ2UoZXZlbnRFbGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICB9XG5cbiAgICBpZiAoIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTsgLy8gZXhpdCBpZiBkZXN0cm95KCkgY2FsbGVkIG9uIGNvcmUgb3IgcmVuZGVyZXIgaW4gYmV0d2VlbiBmcmFtZXMgIzE0OTkgIzE1MjhcblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCgpIHx8ICFyZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcyk7XG4gIH0sXG4gIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vdGlmaWNhdGlvbnMoYm9vbCkge1xuICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiBub05vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICB9LFxuICBiYXRjaGluZzogZnVuY3Rpb24gYmF0Y2hpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYmF0Y2hDb3VudCA+IDA7XG4gIH0sXG4gIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5iYXRjaENvdW50ID09IG51bGwpIHtcbiAgICAgIF9wLmJhdGNoQ291bnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgX3AuYmF0Y2hOb3RpZmljYXRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmRCYXRjaDogZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcC5iYXRjaENvdW50LS07XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG5cbiAgICAgIE9iamVjdC5rZXlzKF9wLmJhdGNoTm90aWZpY2F0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKGVsZXMuZW1wdHkoKSkge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGVsZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYmF0Y2g6IGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBiYXRjaERhdGE6IGZ1bmN0aW9uIGJhdGNoRGF0YShtYXApIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBkYXRhID0gbWFwW2lkXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgZWxlLmRhdGEoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciByZW5kZXJlckRlZmF1bHRzID0gZGVmYXVsdHMoe1xuICBoaWRlRWRnZXNPblZpZXdwb3J0OiBmYWxzZSxcbiAgdGV4dHVyZU9uVmlld3BvcnQ6IGZhbHNlLFxuICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgbW90aW9uQmx1ck9wYWNpdHk6IDAuMDUsXG4gIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgZGVza3RvcFRhcFRocmVzaG9sZDogNCxcbiAgdG91Y2hUYXBUaHJlc2hvbGQ6IDgsXG4gIHdoZWVsU2Vuc2l0aXZpdHk6IDEsXG4gIGRlYnVnOiBmYWxzZSxcbiAgc2hvd0ZwczogZmFsc2Vcbn0pO1xudmFyIGNvcmVmbiQ1ID0ge1xuICByZW5kZXJUbzogZnVuY3Rpb24gcmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gICAgdmFyIHIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIHIucmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVuZGVyZXI6IGZ1bmN0aW9uIHJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuICBmb3JjZVJlbmRlcjogZnVuY3Rpb24gZm9yY2VSZW5kZXIoKSB7XG4gICAgdGhpcy5ub3RpZnkoJ2RyYXcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgncmVzaXplJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGluaXRSZW5kZXJlcjogZnVuY3Rpb24gaW5pdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBSZW5kZXJlclByb3RvID0gY3kuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG5cbiAgICBpZiAoUmVuZGVyZXJQcm90byA9PSBudWxsKSB7XG4gICAgICBlcnJvcihcIkNhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgXCIuY29uY2F0KG9wdGlvbnMubmFtZSwgXCJgIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0P1wiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuKFwiWW91IGhhdmUgc2V0IGEgY3VzdG9tIHdoZWVsIHNlbnNpdGl2aXR5LiAgVGhpcyB3aWxsIG1ha2UgeW91ciBhcHAgem9vbSB1bm5hdHVyYWxseSB3aGVuIHVzaW5nIG1haW5zdHJlYW0gbWljZS4gIFlvdSBzaG91bGQgY2hhbmdlIHRoaXMgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBvbmx5IGlmIHlvdSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHlvdXIgdXNlcnMgd2lsbCB1c2UgdGhlIHNhbWUgaGFyZHdhcmUgYW5kIE9TIGNvbmZpZ3VyYXRpb24gYXMgeW91ciBjdXJyZW50IG1hY2hpbmUuXCIpO1xuICAgIH1cblxuICAgIHZhciByT3B0cyA9IHJlbmRlcmVyRGVmYXVsdHMob3B0aW9ucyk7XG4gICAgck9wdHMuY3kgPSBjeTtcbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKHJPcHRzKTtcbiAgICB0aGlzLm5vdGlmeSgnaW5pdCcpO1xuICB9LFxuICBkZXN0cm95UmVuZGVyZXI6IGZ1bmN0aW9uIGRlc3Ryb3lSZW5kZXJlcigpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Lm5vdGlmeSgnZGVzdHJveScpOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgdmFyIGRvbUVsZSA9IGN5LmNvbnRhaW5lcigpO1xuXG4gICAgaWYgKGRvbUVsZSkge1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBudWxsOyAvLyB0byBiZSBleHRyYSBzYWZlLCByZW1vdmUgdGhlIHJlZlxuXG4gICAgY3kubXV0YWJsZUVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5yc2NyYXRjaCA9IHt9O1xuICAgICAgX3AucnN0eWxlID0ge307XG4gICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgfSk7XG4gIH0sXG4gIG9uUmVuZGVyOiBmdW5jdGlvbiBvblJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG4gIG9mZlJlbmRlcjogZnVuY3Rpb24gb2ZmUmVuZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKCdyZW5kZXInLCBmbik7XG4gIH1cbn07XG5jb3JlZm4kNS5pbnZhbGlkYXRlRGltZW5zaW9ucyA9IGNvcmVmbiQ1LnJlc2l6ZTtcblxudmFyIGNvcmVmbiQ2ID0ge1xuICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uIGNvbGxlY3Rpb24oZWxlcywgb3B0cykge1xuICAgIGlmIChzdHJpbmcoZWxlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLiQoZWxlcyk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZXMpKSB7XG4gICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChhcnJheShlbGVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGVsZXMsIG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzKTtcbiAgfSxcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBlZGdlcztcbiAgfSxcbiAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAkOiBmdW5jdGlvbiAkKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICB9XG4gIH0sXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG59OyAvLyBhbGlhc2VzXG5cbmNvcmVmbiQ2LmVsZW1lbnRzID0gY29yZWZuJDYuZmlsdGVyID0gY29yZWZuJDYuJDtcblxudmFyIHN0eWZuID0ge307IC8vIGtleXMgZm9yIHN0eWxlIGJsb2NrcywgZS5nLiB0dGZmdHRcblxudmFyIFRSVUUgPSAndCc7XG52YXIgRkFMU0UgPSAnZic7IC8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4vLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbi8vIC0gaXRzIGJ5cGFzc1xuLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuXG5zdHlmbi5hcHBseSA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgdmFyIGN5ID0gX3AuY3k7XG4gIHZhciB1cGRhdGVkRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICBpZiAoX3AubmV3U3R5bGUpIHtcbiAgICAvLyBjbGVhciBzdHlsZSBjYWNoZXNcbiAgICBfcC5jb250ZXh0U3R5bGVzID0ge307XG4gICAgX3AucHJvcERpZmZzID0ge307XG4gICAgc2VsZi5jbGVhbkVsZW1lbnRzKGVsZXMsIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YShlbGUpO1xuXG4gICAgaWYgKGN4dE1ldGEuZW1wdHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuXG4gICAgaWYgKCFfcC5uZXdTdHlsZSkge1xuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGFwcC5kaWZmUHJvcHMpO1xuICAgIH1cblxuICAgIHZhciBoaW50c0RpZmYgPSBzZWxmLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcblxuICAgIGlmIChoaW50c0RpZmYpIHtcbiAgICAgIHVwZGF0ZWRFbGVzLm1lcmdlKGVsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVtZW50c1xuXG5cbiAgX3AubmV3U3R5bGUgPSBmYWxzZTtcbiAgcmV0dXJuIHVwZGF0ZWRFbGVzO1xufTtcblxuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiAob2xkQ3h0S2V5LCBuZXdDeHRLZXkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2R1YWxDeHRLZXldO1xuXG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSBUUlVFO1xuICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICB2YXIgY3h0SGFzTWFwcGVkUHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllcy5sZW5ndGggPiAwO1xuXG4gICAgaWYgKGN4dEhhc0RpZmZlZCB8fCBuZXdIYXNDeHQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgIHZhciBwcm9wcyA9IHZvaWQgMDtcblxuICAgICAgaWYgKGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc0RpZmZlZCkge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTsgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgLy8gaXMgY2FjaGVkKVxuXG4gICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgIHZhciBoYXNMYXRlckN4dCA9IG5ld0N4dEtleVtrXSA9PT0gVFJVRTtcblxuICAgICAgICAgIGlmICghaGFzTGF0ZXJDeHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG5cbiAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbcHJvcC5uYW1lXSAhPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IC8vIGV4aXQgZWFybHkgYXMgbG9uZyBhcyBvbmUgbGF0ZXIgY29udGV4dCBvdmVycmlkZXNcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgYWRkZWRQcm9wW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBkaWZmUHJvcHMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIH0gLy8gaWZcblxuICB9IC8vIGZvciBjb250ZXh0c1xuXG5cbiAgY2FjaGVbZHVhbEN4dEtleV0gPSBkaWZmUHJvcHM7XG4gIHJldHVybiBkaWZmUHJvcHM7XG59O1xuXG5zdHlmbi5nZXRDb250ZXh0TWV0YSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0S2V5ID0gJyc7XG4gIHZhciBkaWZmUHJvcHM7XG4gIHZhciBwcmV2S2V5ID0gZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5IHx8ICcnO1xuXG4gIGlmIChzZWxmLl9wcml2YXRlLm5ld1N0eWxlKSB7XG4gICAgcHJldktleSA9ICcnOyAvLyBzaW5jZSB3ZSBuZWVkIHRvIGFwcGx5IGFsbCBzdHlsZSBpZiBhIGZyZXNoIHN0eWxlc2hlZXRcbiAgfSAvLyBnZXQgdGhlIGN4dCBrZXlcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKGVsZSk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmIChjb250ZXh0U2VsZWN0b3JNYXRjaGVzKSB7XG4gICAgICBjeHRLZXkgKz0gVFJVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0S2V5ICs9IEZBTFNFO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG5cbiAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZihwcmV2S2V5LCBjeHRLZXkpO1xuICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG4gIHJldHVybiB7XG4gICAga2V5OiBjeHRLZXksXG4gICAgZGlmZlByb3BOYW1lczogZGlmZlByb3BzLFxuICAgIGVtcHR5OiBkaWZmUHJvcHMubGVuZ3RoID09PSAwXG4gIH07XG59OyAvLyBnZXRzIGEgY29tcHV0ZWQgZWxlIHN0eWxlIG9iamVjdCBiYXNlZCBvbiBtYXRjaGVkIGNvbnRleHRzXG5cblxuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEpIHtcbiAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307IC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG5cbiAgaWYgKGN4dFN0eWxlc1tjeHRLZXldKSB7XG4gICAgcmV0dXJuIGN4dFN0eWxlc1tjeHRLZXldO1xuICB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIF9wcml2YXRlOiB7XG4gICAgICBrZXk6IGN4dEtleVxuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSBUUlVFO1xuXG4gICAgaWYgKCFoYXNDeHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG5zdHlmbi5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlW2RpZmZQcm9wTmFtZV07XG4gICAgdmFyIGVsZVByb3AgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG5cbiAgICBpZiAoIWN4dFByb3ApIHtcbiAgICAgIC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmICghZWxlUHJvcCkge1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICBkZWxldGVCeXBhc3NlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgXCJkZWxldGVcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgIGlmIChlbGVQcm9wID09PSBjeHRQcm9wKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gYSBtYXBwZWQgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgIGlmIChjeHRQcm9wLm1hcHBlZCA9PT0gdHlwZXMuZm4gLy8gY29udGV4dCBwcm9wIGlzIGZ1bmN0aW9uIG1hcHBlclxuICAgICYmIGVsZVByb3AgIT0gbnVsbCAvLyBzb21lIHByb3BzIGNhbiBiZSBudWxsIGV2ZW4gYnkgZGVmYXVsdCAoZS5nLiBhIHByb3AgdGhhdCBvdmVycmlkZXMgYW5vdGhlciBvbmUpXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nICE9IG51bGwgLy8gZWxlIHByb3AgaXMgYSBjb25jcmV0ZSB2YWx1ZSBmcm9tIGZyb20gYSBtYXBwZXJcbiAgICAmJiBlbGVQcm9wLm1hcHBpbmcudmFsdWUgPT09IGN4dFByb3AudmFsdWUgLy8gdGhlIGN1cnJlbnQgcHJvcCBvbiB0aGUgZWxlIGlzIGEgZmxhdCBwcm9wIHZhbHVlIGZvciB0aGUgZnVuY3Rpb24gbWFwcGVyXG4gICAgKSB7XG4gICAgICAgIC8vIE5CIGRvbid0IHdyaXRlIHRvIGN4dFByb3AsIGFzIGl0J3Mgc2hhcmVkIGFtb25nIGVsZXMgKHN0b3JlZCBpbiBzdHlsZXNoZWV0KVxuICAgICAgICB2YXIgbWFwcGluZyA9IGVsZVByb3AubWFwcGluZzsgLy8gY2FuIHdyaXRlIHRvIG1hcHBpbmcsIGFzIGl0J3MgYSBwZXItZWxlIGNvcHlcblxuICAgICAgICB2YXIgZm5WYWx1ZSA9IG1hcHBpbmcuZm5WYWx1ZSA9IGN4dFByb3AudmFsdWUoZWxlKTsgLy8gdGVtcG9yYXJpbHkgY2FjaGUgdGhlIHZhbHVlIGluIGNhc2Ugb2YgYSBtaXNzXG5cbiAgICAgICAgaWYgKGZuVmFsdWUgPT09IG1hcHBpbmcucHJldkZuVmFsdWUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzW2RpZmZQcm9wTmFtZV0gPSB7XG4gICAgICBwcmV2OiBlbGVQcm9wXG4gICAgfTtcbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjeHRQcm9wKTtcbiAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuXG4gICAgaWYgKHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MpIHtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgfTtcbn07XG5cbnN0eWZuLnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcE5hbWVzID0gc2VsZi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG4gIHZhciBwcm9wR3JLZXlzID0gc2VsZi5wcm9wZXJ0eUdyb3VwS2V5cztcblxuICB2YXIgcHJvcEhhc2ggPSBmdW5jdGlvbiBwcm9wSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSkge1xuICAgIHJldHVybiBzZWxmLmdldFByb3BlcnRpZXNIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KTtcbiAgfTtcblxuICB2YXIgb2xkU3R5bGVLZXkgPSBfcC5zdHlsZUtleTtcblxuICBpZiAoZWxlLnJlbW92ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJzsgLy8gZ2V0IHRoZSBzdHlsZSBrZXkgaGFzaGVzIHBlciBwcm9wIGdyb3VwXG4gIC8vIGJ1dCBsYXppbHkgLS0gb25seSB1c2Ugbm9uLWRlZmF1bHQgcHJvcCB2YWx1ZXMgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgaGFzaGVzXG4gIC8vXG5cbiAgdmFyIG92ZXJyaWRkZW5TdHlsZXMgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG92ZXJyaWRkZW5TdHlsZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEdyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncktleSA9IHByb3BHcktleXNbaV07XG4gICAgX3Auc3R5bGVLZXlzW2dyS2V5XSA9IDA7XG4gIH1cblxuICB2YXIgdXBkYXRlR3JLZXkgPSBmdW5jdGlvbiB1cGRhdGVHcktleSh2YWwsIGdyS2V5KSB7XG4gICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV0gPSBoYXNoSW50KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUdyS2V5V1N0ciA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5V1N0cihzdHJWYWwsIGdyS2V5KSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgIHVwZGF0ZUdyS2V5KHN0clZhbC5jaGFyQ29kZUF0KGopLCBncktleSk7XG4gICAgfVxuICB9OyAvLyAtIGhhc2hpbmcgd29ya3Mgb24gMzIgYml0IGludHMgYi9jIHdlIHVzZSBiaXR3aXNlIG9wc1xuICAvLyAtIHNtYWxsIG51bWJlcnMgZ2V0IGN1dCBvZmYgKGUuZy4gMC4xMjMgaXMgc2VlbiBhcyAwIGJ5IHRoZSBoYXNoaW5nIGZ1bmN0aW9uKVxuICAvLyAtIHJhaXNlIHVwIHNtYWxsIG51bWJlcnMgc28gbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgYXJlIHNlZW4gYnkgaGFzaGluZ1xuICAvLyAtIG1ha2Ugc21hbGwgbnVtYmVycyBsYXJnZXIgdGhhbiBhIG5vcm1hbCB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zXG4gIC8vIC0gd29ya3MgaW4gcHJhY3RpY2UgYW5kIGl0J3MgcmVsYXRpdmVseSBjaGVhcFxuXG5cbiAgdmFyIE4gPSAyMDAwMDAwMDAwO1xuXG4gIHZhciBjbGVhbk51bSA9IGZ1bmN0aW9uIGNsZWFuTnVtKHZhbCkge1xuICAgIHJldHVybiAtMTI4IDwgdmFsICYmIHZhbCA8IDEyOCAmJiBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCA/IE4gLSAodmFsICogMTAyNCB8IDApIDogdmFsO1xuICB9O1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wTmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZXNbX2ldO1xuICAgIHZhciBwYXJzZWRQcm9wID0gb3ZlcnJpZGRlblN0eWxlc1tuYW1lXTtcblxuICAgIGlmIChwYXJzZWRQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wSW5mbyA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHByb3BJbmZvLnR5cGU7XG4gICAgdmFyIF9ncktleSA9IHByb3BJbmZvLmdyb3VwS2V5O1xuICAgIHZhciBub3JtYWxpemVkTnVtYmVyVmFsID0gdm9pZCAwO1xuXG4gICAgaWYgKHByb3BJbmZvLmhhc2hPdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcHJvcEluZm8uaGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWRQcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9IC8vIG1pZ2h0IG5vdCBiZSBhIG51bWJlciBpZiBpdCBhbGxvd3MgZW51bXNcblxuXG4gICAgdmFyIG51bWJlclZhbCA9IHByb3BJbmZvLmVudW1zID09IG51bGwgPyBwYXJzZWRQcm9wLnZhbHVlIDogbnVsbDtcbiAgICB2YXIgaGF2ZU5vcm1OdW0gPSBub3JtYWxpemVkTnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVVbml0ZWROdW0gPSBudW1iZXJWYWwgIT0gbnVsbDtcbiAgICB2YXIgaGF2ZU51bSA9IGhhdmVOb3JtTnVtIHx8IGhhdmVVbml0ZWROdW07XG4gICAgdmFyIHVuaXRzID0gcGFyc2VkUHJvcC51bml0czsgLy8gbnVtYmVycyBhcmUgY2hlYXBlciB0byBoYXNoIHRoYW4gc3RyaW5nc1xuICAgIC8vIDEgaGFzaCBvcCB2cyBuIGhhc2ggb3BzIChmb3IgbGVuZ3RoIG4gc3RyaW5nKVxuXG4gICAgaWYgKHR5cGUubnVtYmVyICYmIGhhdmVOdW0pIHtcbiAgICAgIHZhciB2ID0gaGF2ZU5vcm1OdW0gPyBub3JtYWxpemVkTnVtYmVyVmFsIDogbnVtYmVyVmFsO1xuXG4gICAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB2Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB1cGRhdGVHcktleShjbGVhbk51bSh2W19pMl0pLCBfZ3JLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVHcktleShjbGVhbk51bSh2KSwgX2dyS2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXZlTm9ybU51bSAmJiB1bml0cyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUdyS2V5V1N0cih1bml0cywgX2dyS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlR3JLZXlXU3RyKHBhcnNlZFByb3Auc3RyVmFsdWUsIF9ncktleSk7XG4gICAgfVxuICB9IC8vIG92ZXJhbGwgc3R5bGUga2V5XG4gIC8vXG5cblxuICB2YXIgaGFzaCA9IDA7XG5cbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcHJvcEdyS2V5cy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9ncktleTIgPSBwcm9wR3JLZXlzW19pM107XG4gICAgdmFyIGdySGFzaCA9IF9wLnN0eWxlS2V5c1tfZ3JLZXkyXTtcbiAgICBoYXNoID0gaGFzaEludChnckhhc2gsIGhhc2gpO1xuICB9XG5cbiAgX3Auc3R5bGVLZXkgPSBoYXNoOyAvLyBsYWJlbCBkaW1zXG4gIC8vXG5cbiAgdmFyIGxhYmVsRGltc0tleSA9IF9wLmxhYmVsRGltc0tleSA9IF9wLnN0eWxlS2V5cy5sYWJlbERpbWVuc2lvbnM7XG4gIF9wLmxhYmVsS2V5ID0gcHJvcEhhc2goZWxlLCBbJ2xhYmVsJ10sIGxhYmVsRGltc0tleSk7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBoYXNoSW50KF9wLnN0eWxlS2V5cy5jb21tb25MYWJlbCwgX3AubGFiZWxLZXkpO1xuXG4gIGlmICghaXNOb2RlKSB7XG4gICAgX3Auc291cmNlTGFiZWxLZXkgPSBwcm9wSGFzaChlbGUsIFsnc291cmNlLWxhYmVsJ10sIGxhYmVsRGltc0tleSk7XG4gICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IGhhc2hJbnQoX3Auc3R5bGVLZXlzLmNvbW1vbkxhYmVsLCBfcC5zb3VyY2VMYWJlbEtleSk7XG4gICAgX3AudGFyZ2V0TGFiZWxLZXkgPSBwcm9wSGFzaChlbGUsIFsndGFyZ2V0LWxhYmVsJ10sIGxhYmVsRGltc0tleSk7XG4gICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IGhhc2hJbnQoX3Auc3R5bGVLZXlzLmNvbW1vbkxhYmVsLCBfcC50YXJnZXRMYWJlbEtleSk7XG4gIH0gLy8gbm9kZVxuICAvL1xuXG5cbiAgaWYgKGlzTm9kZSkge1xuICAgIHZhciBfcCRzdHlsZUtleXMgPSBfcC5zdHlsZUtleXMsXG4gICAgICAgIG5vZGVCb2R5ID0gX3Akc3R5bGVLZXlzLm5vZGVCb2R5LFxuICAgICAgICBub2RlQm9yZGVyID0gX3Akc3R5bGVLZXlzLm5vZGVCb3JkZXIsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wJHN0eWxlS2V5cy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgIGNvbXBvdW5kID0gX3Akc3R5bGVLZXlzLmNvbXBvdW5kLFxuICAgICAgICBwaWUgPSBfcCRzdHlsZUtleXMucGllO1xuICAgIF9wLm5vZGVLZXkgPSBoYXNoSW50c0FycmF5KFtub2RlQm9yZGVyLCBiYWNrZ3JvdW5kSW1hZ2UsIGNvbXBvdW5kLCBwaWVdLCBub2RlQm9keSk7XG4gICAgX3AuaGFzUGllID0gcGllICE9IDA7XG4gIH1cblxuICByZXR1cm4gb2xkU3R5bGVLZXkgIT09IF9wLnN0eWxlS2V5O1xufTtcblxuc3R5Zm4uY2xlYXJTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIF9wLnN0eWxlS2V5cyA9IHt9O1xuICBfcC5zdHlsZUtleSA9IG51bGw7XG4gIF9wLmxhYmVsS2V5ID0gbnVsbDtcbiAgX3AubGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsS2V5ID0gbnVsbDtcbiAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsS2V5ID0gbnVsbDtcbiAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLm5vZGVLZXkgPSBudWxsO1xuICBfcC5oYXNQaWUgPSBudWxsO1xufTsgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5cblxuc3R5Zm4uYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGUsIHBhcnNlZFByb3ApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZsYXRQcm9wO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1twcm9wLm5hbWVdLnR5cGU7XG4gIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgdmFyIG9yaWdQcm9wID0gc3R5bGVbcHJvcC5uYW1lXTtcbiAgdmFyIG9yaWdQcm9wSXNCeXBhc3MgPSBvcmlnUHJvcCAmJiBvcmlnUHJvcC5ieXBhc3M7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGZsYXRQcm9wTWFwcGluZyA9ICdtYXBwaW5nJztcblxuICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24gZ2V0VmFsKHApIHtcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHAucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcC5wZlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiBjaGVja1RyaWdnZXJzKCkge1xuICAgIHZhciBmcm9tVmFsID0gZ2V0VmFsKG9yaWdQcm9wKTtcbiAgICB2YXIgdG9WYWwgPSBnZXRWYWwocHJvcCk7XG4gICAgc2VsZi5jaGVja1RyaWdnZXJzKGVsZSwgcHJvcC5uYW1lLCBmcm9tVmFsLCB0b1ZhbCk7XG4gIH07IC8vIGVkZ2Ugc2FuaXR5IGNoZWNrcyB0byBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSBtYWtpbmcgc2VyaW91cyBtaXN0YWtlc1xuXG5cbiAgaWYgKHBhcnNlZFByb3AubmFtZSA9PT0gJ2N1cnZlLXN0eWxlJyAmJiBlbGUuaXNFZGdlKCkgJiYgKCAvLyBsb29wcyBtdXN0IGJlIGJ1bmRsZWQgYmV6aWVyc1xuICBwYXJzZWRQcm9wLnZhbHVlICE9PSAnYmV6aWVyJyAmJiBlbGUuaXNMb29wKCkgfHwgLy8gZWRnZXMgY29ubmVjdGVkIHRvIGNvbXBvdW5kIG5vZGVzIGNhbiBub3QgYmUgaGF5c3RhY2tzXG4gIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaycgJiYgKGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpKSkpIHtcbiAgICBwcm9wID0gcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UocGFyc2VkUHJvcC5uYW1lLCAnYmV6aWVyJywgcHJvcElzQnlwYXNzKTtcbiAgfVxuXG4gIGlmIChwcm9wW1wiZGVsZXRlXCJdKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBhbmQgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGZhbHNleSB2YWx1ZVxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgY2hlY2tUcmlnZ2VycygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHByb3AuZGVsZXRlQnlwYXNzZWQpIHtcbiAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IHRoYXQgdGhlXG4gICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGNhbid0IGRlbGV0ZSBpZiBubyBwcm9wXG4gICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIGRlbGV0ZSBieXBhc3NlZFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSB1bmRlZmluZWQ7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgfVxuICB9IC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuXG5cbiAgaWYgKHByb3AuZGVsZXRlQnlwYXNzKSB7XG4gICAgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IG5vdCBkZWZpbmVkXG4gICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IG9yaWdQcm9wLmJ5cGFzc2VkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24gcHJpbnRNYXBwaW5nRXJyKCkge1xuICAgIHdhcm4oJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGkuZS4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBoYXMgbm8gbWFwcGluZyBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcpO1xuICB9OyAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG5cblxuICBzd2l0Y2ggKHByb3AubWFwcGVkKSB7XG4gICAgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gICAgY2FzZSB0eXBlcy5tYXBEYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBmaWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFtmaWVsZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmllbGRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZXJjZW50O1xuXG4gICAgICAgIGlmICghbnVtYmVyKGZpZWxkVmFsKSkge1xuICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGNvbnRpbnVvdXMgbWFwcGVycyB3aXRob3V0IHNwZWNpZnlpbmcgbnVtZXJpYyBkYXRhIChpLmUuIGAnICsgcHJvcC5maWVsZCArICc6ICcgKyBmaWVsZFZhbCArICdgIGZvciBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbm9uLW51bWVyaWMpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gcHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW47XG5cbiAgICAgICAgICBpZiAoZmllbGRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIC0tIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgYXMgbm8gcHJvcHMgb2YgemVybyByYW5nZSBzaG91bGQgYmUgcGFzc2VkIGhlcmVcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyBmaWVsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuXG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG4gICAgICAgICAgdmFyIGNsciA9IFtNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogcGVyY2VudCksIE1hdGgucm91bmQoZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGExICsgKGEyIC0gYTEpICogcGVyY2VudCldO1xuICAgICAgICAgIGZsYXRQcm9wID0ge1xuICAgICAgICAgICAgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcyxcbiAgICAgICAgICAgIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgdGhlIHByb3BlcnR5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gZGlyZWN0IG1hcHBpbmdcblxuICAgIGNhc2UgdHlwZXMuZGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgX2ZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcblxuICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBfZmllbGRzLmxlbmd0aCAmJiBfZmllbGRWYWw7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIF9maWVsZCA9IF9maWVsZHNbX2k0XTtcbiAgICAgICAgICBfZmllbGRWYWwgPSBfZmllbGRWYWxbX2ZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZmllbGRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIF9maWVsZFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICB7XG4gICAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICAgIHZhciBmblJldFZhbCA9IHByb3AuZm5WYWx1ZSAhPSBudWxsID8gcHJvcC5mblZhbHVlIDogZm4oZWxlKTsgLy8gY2hlY2sgZm9yIGNhY2hlZCB2YWx1ZSBiZWZvcmUgY2FsbGluZyBmdW5jdGlvblxuXG4gICAgICAgIHByb3AucHJldkZuVmFsdWUgPSBmblJldFZhbDtcblxuICAgICAgICBpZiAoZm5SZXRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIG51bGwgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBudWxsKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcblxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gaW52YWxpZCB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0eSB0eXBlIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgaW52YWxpZCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gY29weShwcm9wKTsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7XG4gICAgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfSAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcblxuXG4gIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiB0aGlzIGJ5cGFzcyBvdmVycmlkZXMgdGhlIGV4aXN0aW5nIG9uZVxuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgIH1cblxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrVHJpZ2dlcnMoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5zdHlmbi5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMsIGtlZXBCeXBhc3Nlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB0aGlzLmNsZWFyU3R5bGVIaW50cyhlbGUpO1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG5cbiAgICBpZiAoIWtlZXBCeXBhc3Nlcykge1xuICAgICAgZWxlLl9wcml2YXRlLnN0eWxlID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tqXTtcbiAgICAgICAgdmFyIGVsZVByb3AgPSBzdHlsZVtwcm9wTmFtZV07XG5cbiAgICAgICAgaWYgKGVsZVByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgICAgZWxlUHJvcC5ieXBhc3NlZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59OyAvLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG5cblxuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG59OyAvLyBkaWZmUHJvcHMgOiB7IG5hbWUgPT4geyBwcmV2LCBuZXh0IH0gfVxuXG5cbnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKGVsZSwgZGlmZlByb3BzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcHJvcHMgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXByb3BlcnR5JykudmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKS5wZlZhbHVlO1xuICB2YXIgZGVsYXkgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWRlbGF5JykucGZWYWx1ZTtcblxuICBpZiAocHJvcHMubGVuZ3RoID4gMCAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICB2YXIgc3R5bGUgPSB7fTsgLy8gYnVpbGQgdXAgdGhlIHN0eWxlIHRvIGFuaW1hdGUgdG93YXJkc1xuXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcF07XG5cbiAgICAgIGlmICghZGlmZlByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbCA9IHZvaWQgMDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYgKCFmcm9tUHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gY29uc2lkZXIgcHggdmFsdWVzXG5cblxuICAgICAgaWYgKG51bWJlcihmcm9tUHJvcC5wZlZhbHVlKSAmJiBudW1iZXIodG9Qcm9wLnBmVmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AucGZWYWx1ZSAtIGZyb21Qcm9wLnBmVmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG5cbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmOyAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKG51bWJlcihmcm9tUHJvcC52YWx1ZSkgJiYgbnVtYmVyKHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC52YWx1ZSArIGluaXREdCAqIGRpZmY7IC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkoZnJvbVByb3AudmFsdWUpICYmIGFycmF5KHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF0gfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXSB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdO1xuICAgICAgICBpbml0VmFsID0gZnJvbVByb3Auc3RyVmFsdWU7XG4gICAgICB9IC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuXG5cbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHN0eWxlW3Byb3BdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcblxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgaW5pdFZhbCk7IC8vIGZyb20gdmFsXG5cbiAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG4gICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG5cblxuICAgIGlmICghYW55UHJldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgZWxlLmRlbGF5QW5pbWF0aW9uKGRlbGF5KS5wbGF5KCkucHJvbWlzZSgpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWxlLmFuaW1hdGlvbih7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJykudmFsdWUsXG4gICAgICAgIHF1ZXVlOiBmYWxzZVxuICAgICAgfSkucGxheSgpLnByb21pc2UoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gfVxuXG4gICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoX3AudHJhbnNpdGlvbmluZykge1xuICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7XG4gICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICB9XG59O1xuXG5zdHlmbi5jaGVja1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGdldFRyaWdnZXIsIG9uVHJpZ2dlcikge1xuICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHRyaWdnZXJDaGVjayA9IGdldFRyaWdnZXIocHJvcCk7XG5cbiAgaWYgKHRyaWdnZXJDaGVjayAhPSBudWxsICYmIHRyaWdnZXJDaGVjayhmcm9tVmFsdWUsIHRvVmFsdWUpKSB7XG4gICAgb25UcmlnZ2VyKHByb3ApO1xuICB9XG59O1xuXG5zdHlmbi5jaGVja1pPcmRlclRyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc1pPcmRlcjtcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSgnem9yZGVyJywgZWxlKTtcbiAgfSk7XG59O1xuXG5zdHlmbi5jaGVja0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTsgLy8gaWYgdGhlIHByb3AgY2hhbmdlIG1ha2VzIHRoZSBiYiBvZiBwbGwgYmV6aWVyIGVkZ2VzIGludmFsaWQsXG4gICAgLy8gdGhlbiBkaXJ0eSB0aGUgcGxsIGVkZ2UgYmIgY2FjaGUgYXMgd2VsbFxuXG4gICAgaWYgKCAvLyBvbmx5IGZvciBiZXppZXJzIC0tIHNvIHBlcmZvcm1hbmNlIG9mIG90aGVyIGVkZ2VzIGlzbid0IGFmZmVjdGVkXG4gICAgKGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWUgPT09ICdiZXppZXInIC8vIGFscmVhZHkgYSBiZXppZXJcbiAgICAvLyB3YXMganVzdCBub3cgY2hhbmdlZCB0byBvciBmcm9tIGEgYmV6aWVyOlxuICAgIHx8IG5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgKGZyb21WYWx1ZSA9PT0gJ2JlemllcicgfHwgdG9WYWx1ZSA9PT0gJ2JlemllcicpKSAmJiBwcm9wLnRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnMpIHtcbiAgICAgIGVsZS5wYXJhbGxlbEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAocGxsRWRnZSkge1xuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5zdHlmbi5jaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIGVsZS5kaXJ0eVN0eWxlQ2FjaGUoKTtcbiAgdGhpcy5jaGVja1pPcmRlclRyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICB0aGlzLmNoZWNrQm91bmRzVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG59O1xuXG52YXIgc3R5Zm4kMSA9IHt9OyAvLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5cbnN0eWZuJDEuYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BzID0gW107XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7IC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cblxuICBpZiAobmFtZSA9PT0gJyonIHx8IG5hbWUgPT09ICcqKicpIHtcbiAgICAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKF9uYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHBhcnNlZFByb3ApIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHBhcnNlZFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgIHZhciBfcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgaWYgKF9wYXJzZWRQcm9wKSB7XG4gICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICB2YXIgc3BlY2lmaWVkUHJvcHMgPSBuYW1lO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3BlY2lmaWVkUHJvcHMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9uYW1lMiA9IG5hbWVzW19pXTtcbiAgICAgIHZhciBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tfbmFtZTJdO1xuXG4gICAgICBpZiAoX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbZGFzaDJjYW1lbChfbmFtZTIpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfcGFyc2VkUHJvcDIgPSB0aGlzLnBhcnNlKF9uYW1lMiwgX3ZhbHVlLCB0cnVlKTtcblxuICAgICAgICBpZiAoX3BhcnNlZFByb3AyKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG5cblxuICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuXG5cbiAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgLy8gZm9yIGVhY2ggZWxlXG4gICAgdmFyIGVsZSA9IGVsZXNbX2kyXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgdmFyIGRpZmZQcm9wID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIF9wcm9wID0gcHJvcHNbal07XG5cbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgICBkaWZmUHJvcCA9IGRpZmZQcm9wc1tfcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXQgPSB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBfcHJvcCkgfHwgcmV0O1xuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG5cblxuICByZXR1cm4gcmV0O1xufTsgLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cblxuXG5zdHlmbiQxLm92ZXJyaWRlQnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBwcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlW25hbWVdO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdLnR5cGU7XG4gICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuICAgIHZhciBvbGRWYWx1ZSA9ICFwcm9wID8gbnVsbCA6IHByb3AucGZWYWx1ZSAhPSBudWxsID8gcHJvcC5wZlZhbHVlIDogcHJvcC52YWx1ZTtcblxuICAgIGlmICghcHJvcCB8fCAhcHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb2xvcikge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgICAgfSBlbHNlIGlmIChpc011bHRpKSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSB2YWx1ZS5qb2luKCcgJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1RyaWdnZXJzKGVsZSwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcbiAgfVxufTtcblxuc3R5Zm4kMS5yZW1vdmVBbGxCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbn07XG5cbnN0eWZuJDEucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuXG4gICAgICBpZiAoIXByZXZQcm9wIHx8ICFwcmV2UHJvcC5ieXBhc3MpIHtcbiAgICAgICAgLy8gaWYgYSBieXBhc3MgZG9lc24ndCBleGlzdCBmb3IgdGhlIHByb3AsIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcblxuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wLm5hbWVdID0ge1xuICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcblxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG59O1xuXG52YXIgc3R5Zm4kMiA9IHt9OyAvLyBnZXRzIHdoYXQgYW4gZW0gc2l6ZSBjb3JyZXNwb25kcyB0byBpbiBwaXhlbHMgcmVsYXRpdmUgdG8gYSBkb20gZWxlbWVudFxuXG5zdHlmbiQyLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHggPSB0aGlzLmNvbnRhaW5lckNzcygnZm9udC1zaXplJyk7XG5cbiAgaWYgKHB4ICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChweCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7IC8vIGZvciBoZWFkbGVzc1xuICB9XG59OyAvLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuXG5cbnN0eWZuJDIuY29udGFpbmVyQ3NzID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgaWYgKHdpbmRvdyQxICYmIGRvbUVsZW1lbnQgJiYgd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHJldHVybiB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcE5hbWUpO1xuICB9XG59O1xuXG52YXIgc3R5Zm4kMyA9IHt9OyAvLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG5zdHlmbiQzLmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wKSB7XG4gIGlmIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoZWxlLCB0cnVlKTtcbiAgfVxufTsgLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5cblxuc3R5Zm4kMy5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiAoZWxlKSB7XG4gICAgdmFyIHJzdHlsZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcC5uYW1lLCBpc1JlbmRlcmVkVmFsKTtcblxuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHJzdHlsZVtwcm9wLm5hbWVdID0gdmFsO1xuICAgICAgICByc3R5bGVbZGFzaDJjYW1lbChwcm9wLm5hbWUpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9XG59O1xuXG5zdHlmbiQzLmdldEluZGV4ZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BlcnR5LCBzdWJwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpW3N1YnByb3BlcnR5XVtpbmRleF07XG4gIHJldHVybiBwc3R5bGUgIT0gbnVsbCA/IHBzdHlsZSA6IGVsZS5jeSgpLnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1bMF07XG59O1xuXG5zdHlmbiQzLmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgIGlmIChwcm9wLmFsaWFzKSB7XG4gICAgICBwcm9wID0gcHJvcC5wb2ludHNUbztcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuXG4gICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLnZhbHVlLFxuICAgICAgICAgIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzLFxuICAgICAgICAgIHN0clZhbHVlID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICBpZiAoaXNSZW5kZXJlZFZhbCAmJiB0eXBlLm51bWJlciAmJiB2YWx1ZSAhPSBudWxsICYmIG51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG5cbiAgICAgICAgdmFyIGdldFJlbmRlcmVkVmFsdWUgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKiB6b29tO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyA9IGZ1bmN0aW9uIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbCwgdW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpICsgdW5pdHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGlzQXJyYXlWYWx1ZSA9IGFycmF5KHZhbHVlKTtcbiAgICAgICAgdmFyIGhhdmVVbml0cyA9IGlzQXJyYXlWYWx1ZSA/IHVuaXRzLmV2ZXJ5KGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgcmV0dXJuIHUgIT0gbnVsbDtcbiAgICAgICAgfSkgOiB1bml0cyAhPSBudWxsO1xuXG4gICAgICAgIGlmIChoYXZlVW5pdHMpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2LCB1bml0c1tpXSk7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWx1ZSwgdW5pdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodikgPyB2IDogJycgKyBnZXRSZW5kZXJlZFZhbHVlKHYpO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBnZXRSZW5kZXJlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnN0eWZuJDMuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGFuaVByb3BzKSB7XG4gIHZhciByc3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1tpXTtcbiAgICB2YXIgbmFtZSA9IGFuaVByb3AubmFtZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShuYW1lKTtcblxuICAgIGlmIChzdHlsZVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGhlbiBtYWtlIGEgcHJvcCBvZiBpdFxuICAgICAgaWYgKHBsYWluT2JqZWN0KHN0eWxlUHJvcCkpIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3Auc3RyVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHJzdHlsZVtuYW1lXSA9IHN0eWxlUHJvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4kMy5nZXRQcm9wc0xpc3QgPSBmdW5jdGlvbiAocHJvcHNPYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnN0eWxlID0gW107XG4gIHZhciBzdHlsZSA9IHByb3BzT2JqO1xuICB2YXIgcHJvcHMgPSBzZWxmLnByb3BlcnRpZXM7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbY2FtZWwyZGFzaChuYW1lKV07XG4gICAgICB2YXIgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHZhbCk7XG5cbiAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgcnN0eWxlLnB1c2goc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4kMy5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2ggPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZXMsIHNlZWQpIHtcbiAgdmFyIGhhc2ggPSBzZWVkO1xuICB2YXIgbmFtZSwgdmFsLCBzdHJWYWwsIGNoVmFsO1xuICB2YXIgaSwgajtcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICB2YWwgPSBlbGUucHN0eWxlKG5hbWUsIGZhbHNlKTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICh2YWwucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBoYXNoID0gaGFzaEludChjaFZhbCwgaGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0clZhbCA9IHZhbC5zdHJWYWx1ZTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICBjaFZhbCA9IHN0clZhbC5jaGFyQ29kZUF0KGopO1xuICAgICAgICBoYXNoID0gaGFzaEludChjaFZhbCwgaGFzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG5zdHlmbiQzLmdldFByb3BlcnRpZXNIYXNoID0gc3R5Zm4kMy5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2g7XG5cbnZhciBzdHlmbiQ0ID0ge307XG5cbnN0eWZuJDQuYXBwZW5kRnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0ganNvbltpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQuc3R5bGUgfHwgY29udGV4dC5jc3M7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1tuYW1lXTtcbiAgICAgIHN0eWxlLmNzcyhuYW1lLCB2YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTsgLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG5cblxuc3R5Zm4kNC5mcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGVuZEZyb21Kc29uKGpzb24pO1xuICByZXR1cm4gc3R5bGU7XG59OyAvLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5cblxuc3R5Zm4kNC5qc29uID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbiA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSB0aGlzLmRlZmF1bHRMZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICBjc3NbcHJvcC5uYW1lXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgfVxuXG4gICAganNvbi5wdXNoKHtcbiAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgc3R5bGU6IGNzc1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59O1xuXG52YXIgc3R5Zm4kNSA9IHt9O1xuXG5zdHlmbiQ1LmFwcGVuZEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0eWxlID0gdGhpcztcbiAgdmFyIHJlbWFpbmluZyA9ICcnICsgc3RyaW5nO1xuICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gIHZhciBibG9ja1JlbTtcbiAgdmFyIHByb3BBbmRWYWxTdHI7IC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcblxuICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnKTtcblxuICBmdW5jdGlvbiByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGgpIHtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoc2VsQW5kQmxvY2tTdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgcHJvcGVydHkgYW5kIHZhbHVlIGZyb20gdGhlIHJlbWFpbmluZyBibG9jayB0ZXh0IHRvIHBhcnNlXG4gICAgaWYgKGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoKSB7XG4gICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0cihwcm9wQW5kVmFsU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgaWYgKG5vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgaWYgKCFzZWxBbmRCbG9jaykge1xuICAgICAgd2FybignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdOyAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcblxuICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuXG4gICAgaWYgKHNlbGVjdG9yU3RyICE9PSAnY29yZScpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG5cbiAgICAgIGlmIChzZWxlY3Rvci5pbnZhbGlkKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7IC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcblxuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSAvLyBwYXJzZSB0aGUgYmxvY2sgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG5cblxuICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIF9ub3RoaW5nTGVmdFRvUGFyc2UgPSBibG9ja1JlbS5tYXRjaCgvXlxccyokLyk7XG5cbiAgICAgIGlmIChfbm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPylcXHMqOy8pO1xuXG4gICAgICBpZiAoIXByb3BBbmRWYWwpIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BTdHJdO1xuXG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpOyAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG5cbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UocHJvcFN0ciwgdmFsU3RyKTtcblxuICAgICAgaWYgKCFwYXJzZWRQcm9wKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyKTsgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgIH0pO1xuICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZEJsb2NrKSB7XG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG5cblxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcHJvcCA9IHByb3BzW2ldO1xuICAgICAgc3R5bGUuY3NzKF9wcm9wLm5hbWUsIF9wcm9wLnZhbCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5zdHlmbiQ1LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGVuZEZyb21TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIHN0eWZuJDYgPSB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG51bWJlciA9IG51bWJlciQxO1xuICB2YXIgcmdiYSA9IHJnYmFOb0JhY2tSZWZzO1xuICB2YXIgaHNsYSA9IGhzbGFOb0JhY2tSZWZzO1xuICB2YXIgaGV4MyQxID0gaGV4MztcbiAgdmFyIGhleDYkMSA9IGhleDY7XG5cbiAgdmFyIGRhdGEgPSBmdW5jdGlvbiBkYXRhKHByZWZpeCkge1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXChcXFxccyooW1xcXFx3XFxcXC5dKylcXFxccypcXFxcKSQnO1xuICB9O1xuXG4gIHZhciBtYXBEYXRhID0gZnVuY3Rpb24gbWFwRGF0YShwcmVmaXgpIHtcbiAgICB2YXIgbWFwQXJnID0gbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyQxICsgJ3wnICsgaGV4NiQxO1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gIH07XG5cbiAgdmFyIHVybFJlZ2V4ZXMgPSBbJ151cmxcXFxccypcXFxcKFxcXFxzKltcXCdcIl0/KC4rPylbXFwnXCJdP1xcXFxzKlxcXFwpJCcsICdeKG5vbmUpJCcsICdeKC4rKSQnXTsgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuXG4gIHN0eWZuJDYudHlwZXMgPSB7XG4gICAgdGltZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdW5pdHM6ICdzfG1zJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdtcydcbiAgICB9LFxuICAgIHBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgdW5pdHM6ICclJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICclJ1xuICAgIH0sXG4gICAgcGVyY2VudGFnZXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgdW5pdHM6ICclJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICclJyxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICB6ZXJvT25lTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgemVyb09uZU51bWJlcnM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIG5PbmVPbmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgbm9uTmVnYXRpdmVJbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGludGVnZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpb246IHtcbiAgICAgIGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXVxuICAgIH0sXG4gICAgbm9kZVNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGVudW1zOiBbJ2xhYmVsJ11cbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aXZlTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHN0cmljdE1pbjogdHJ1ZVxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwXG4gICAgfSxcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlXG4gICAgfSxcbiAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBzaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICB9LFxuICAgIGF4aXNEaXJlY3Rpb246IHtcbiAgICAgIGVudW1zOiBbJ2hvcml6b250YWwnLCAnbGVmdHdhcmQnLCAncmlnaHR3YXJkJywgJ3ZlcnRpY2FsJywgJ3Vwd2FyZCcsICdkb3dud2FyZCcsICdhdXRvJ11cbiAgICB9LFxuICAgIHBhZGRpbmdSZWxhdGl2ZVRvOiB7XG4gICAgICBlbnVtczogWyd3aWR0aCcsICdoZWlnaHQnLCAnYXZlcmFnZScsICdtaW4nLCAnbWF4J11cbiAgICB9LFxuICAgIGJnV0g6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIGVudW1zOiBbJ2F1dG8nXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1Bvczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnaW5uZXInLCAnaW5jbHVkZS1wYWRkaW5nJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdSZXBlYXQ6IHtcbiAgICAgIGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0ZpdDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICdjb250YWluJywgJ2NvdmVyJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdDcm9zc09yaWdpbjoge1xuICAgICAgZW51bXM6IFsnYW5vbnltb3VzJywgJ3VzZS1jcmVkZW50aWFscyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ2xpcDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICdub2RlJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIGNvbG9yOiB0cnVlXG4gICAgfSxcbiAgICBjb2xvcnM6IHtcbiAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGZpbGw6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnXVxuICAgIH0sXG4gICAgYm9vbDoge1xuICAgICAgZW51bXM6IFsneWVzJywgJ25vJ11cbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddXG4gICAgfSxcbiAgICBsaW5lQ2FwOiB7XG4gICAgICBlbnVtczogWydidXR0JywgJ3JvdW5kJywgJ3NxdWFyZSddXG4gICAgfSxcbiAgICBib3JkZXJTdHlsZToge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXVxuICAgIH0sXG4gICAgY3VydmVTdHlsZToge1xuICAgICAgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snLCAnc2VnbWVudHMnLCAnc3RyYWlnaHQnLCAndGF4aSddXG4gICAgfSxcbiAgICBmb250RmFtaWx5OiB7XG4gICAgICByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCdcbiAgICB9LFxuICAgIGZvbnRTdHlsZToge1xuICAgICAgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ11cbiAgICB9LFxuICAgIGZvbnRXZWlnaHQ6IHtcbiAgICAgIGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXVxuICAgIH0sXG4gICAgdGV4dERlY29yYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddXG4gICAgfSxcbiAgICB0ZXh0VHJhbnNmb3JtOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXVxuICAgIH0sXG4gICAgdGV4dFdyYXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcyddXG4gICAgfSxcbiAgICB0ZXh0T3ZlcmZsb3dXcmFwOiB7XG4gICAgICBlbnVtczogWyd3aGl0ZXNwYWNlJywgJ2FueXdoZXJlJ11cbiAgICB9LFxuICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnXVxuICAgIH0sXG4gICAgbm9kZVNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2N1dHJlY3RhbmdsZScsICdjdXQtcmVjdGFuZ2xlJywgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLCAnYmFycmVsJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAncm91bmQtdHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ3JvdW5kLXBlbnRhZ29uJywgJ2hleGFnb24nLCAncm91bmQtaGV4YWdvbicsICdjb25jYXZlaGV4YWdvbicsICdjb25jYXZlLWhleGFnb24nLCAnaGVwdGFnb24nLCAncm91bmQtaGVwdGFnb24nLCAnb2N0YWdvbicsICdyb3VuZC1vY3RhZ29uJywgJ3RhZycsICdyb3VuZC10YWcnLCAnc3RhcicsICdkaWFtb25kJywgJ3JvdW5kLWRpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3BvbHlnb24nXVxuICAgIH0sXG4gICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7XG4gICAgICBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXVxuICAgIH0sXG4gICAgYXJyb3dTaGFwZToge1xuICAgICAgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1jcm9zcycsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdjaGV2cm9uJywgJ25vbmUnXVxuICAgIH0sXG4gICAgYXJyb3dGaWxsOiB7XG4gICAgICBlbnVtczogWydmaWxsZWQnLCAnaG9sbG93J11cbiAgICB9LFxuICAgIGRpc3BsYXk6IHtcbiAgICAgIGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddXG4gICAgfSxcbiAgICB2aXNpYmlsaXR5OiB7XG4gICAgICBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddXG4gICAgfSxcbiAgICB6Q29tcG91bmREZXB0aDoge1xuICAgICAgZW51bXM6IFsnYm90dG9tJywgJ29ycGhhbicsICdhdXRvJywgJ3RvcCddXG4gICAgfSxcbiAgICB6SW5kZXhDb21wYXJlOiB7XG4gICAgICBlbnVtczogWydhdXRvJywgJ21hbnVhbCddXG4gICAgfSxcbiAgICB2YWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJ11cbiAgICB9LFxuICAgIGhhbGlnbjoge1xuICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXVxuICAgIH0sXG4gICAganVzdGlmaWNhdGlvbjoge1xuICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnYXV0byddXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBzdHJpbmc6IHRydWVcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnZGF0YScpXG4gICAgfSxcbiAgICBsYXlvdXREYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKVxuICAgIH0sXG4gICAgc2NyYXRjaDoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdzY3JhdGNoJylcbiAgICB9LFxuICAgIG1hcERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwRGF0YScpXG4gICAgfSxcbiAgICBtYXBMYXlvdXREYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKVxuICAgIH0sXG4gICAgbWFwU2NyYXRjaDoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBTY3JhdGNoJylcbiAgICB9LFxuICAgIGZuOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgZm46IHRydWVcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgdXJsczoge1xuICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwcm9wTGlzdDoge1xuICAgICAgcHJvcExpc3Q6IHRydWVcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3JhZCdcbiAgICB9LFxuICAgIHRleHRSb3RhdGlvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnLFxuICAgICAgZW51bXM6IFsnbm9uZScsICdhdXRvcm90YXRlJ11cbiAgICB9LFxuICAgIHBvbHlnb25Qb2ludExpc3Q6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgZXZlbk11bHRpcGxlOiB0cnVlLFxuICAgICAgbWluOiAtMSxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBlZGdlRGlzdGFuY2VzOiB7XG4gICAgICBlbnVtczogWydpbnRlcnNlY3Rpb24nLCAnbm9kZS1wb3NpdGlvbiddXG4gICAgfSxcbiAgICBlZGdlRW5kcG9pbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgdW5pdHM6ICclfHB4fGVtfGRlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ2luc2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnLCAnb3V0c2lkZS10by1saW5lJywgJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCddLFxuICAgICAgc2luZ2xlRW51bTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSB7XG4gICAgICAgIHN3aXRjaCAodmFsQXJyLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIGNhbiBiZSAlIG9yIHB4IG9ubHlcbiAgICAgICAgICAgIHJldHVybiB1bml0c0FyclswXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMF0gIT09ICdyYWQnICYmIHVuaXRzQXJyWzFdICE9PSAnZGVnJyAmJiB1bml0c0FyclsxXSAhPT0gJ3JhZCc7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyBjYW4gYmUgZW51bSwgZGVnLCBvciByYWQgb25seVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyh2YWxBcnJbMF0pIHx8IHVuaXRzQXJyWzBdID09PSAnZGVnJyB8fCB1bml0c0FyclswXSA9PT0gJ3JhZCc7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlYXNpbmc6IHtcbiAgICAgIHJlZ2V4ZXM6IFsnXihzcHJpbmcpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSQnLCAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJ10sXG4gICAgICBlbnVtczogWydsaW5lYXInLCAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JywgJ2Vhc2UtaW4tc2luZScsICdlYXNlLW91dC1zaW5lJywgJ2Vhc2UtaW4tb3V0LXNpbmUnLCAnZWFzZS1pbi1xdWFkJywgJ2Vhc2Utb3V0LXF1YWQnLCAnZWFzZS1pbi1vdXQtcXVhZCcsICdlYXNlLWluLWN1YmljJywgJ2Vhc2Utb3V0LWN1YmljJywgJ2Vhc2UtaW4tb3V0LWN1YmljJywgJ2Vhc2UtaW4tcXVhcnQnLCAnZWFzZS1vdXQtcXVhcnQnLCAnZWFzZS1pbi1vdXQtcXVhcnQnLCAnZWFzZS1pbi1xdWludCcsICdlYXNlLW91dC1xdWludCcsICdlYXNlLWluLW91dC1xdWludCcsICdlYXNlLWluLWV4cG8nLCAnZWFzZS1vdXQtZXhwbycsICdlYXNlLWluLW91dC1leHBvJywgJ2Vhc2UtaW4tY2lyYycsICdlYXNlLW91dC1jaXJjJywgJ2Vhc2UtaW4tb3V0LWNpcmMnXVxuICAgIH0sXG4gICAgZ3JhZGllbnREaXJlY3Rpb246IHtcbiAgICAgIGVudW1zOiBbJ3RvLWJvdHRvbScsICd0by10b3AnLCAndG8tbGVmdCcsICd0by1yaWdodCcsICd0by1ib3R0b20tcmlnaHQnLCAndG8tYm90dG9tLWxlZnQnLCAndG8tdG9wLXJpZ2h0JywgJ3RvLXRvcC1sZWZ0JywgJ3RvLXJpZ2h0LWJvdHRvbScsICd0by1sZWZ0LWJvdHRvbScsICd0by1yaWdodC10b3AnLCAndG8tbGVmdC10b3AnXVxuICAgIH0sXG4gICAgYm91bmRzRXhwYW5zaW9uOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbEFyci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPT09IDEgfHwgbGVuZ3RoID09PSAyIHx8IGxlbmd0aCA9PT0gNDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkaWZmID0ge1xuICAgIHplcm9Ob25aZXJvOiBmdW5jdGlvbiB6ZXJvTm9uWmVybyh2YWwxLCB2YWwyKSB7XG4gICAgICBpZiAoKHZhbDEgPT0gbnVsbCB8fCB2YWwyID09IG51bGwpICYmIHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIG51bGwgY2FzZXMgY291bGQgcmVwcmVzZW50IGFueSB2YWx1ZVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsMSA9PSAwICYmIHZhbDIgIT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsMSAhPSAwICYmIHZhbDIgPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueTogZnVuY3Rpb24gYW55KHZhbDEsIHZhbDIpIHtcbiAgICAgIHJldHVybiB2YWwxICE9IHZhbDI7XG4gICAgfVxuICB9OyAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgLy9cbiAgLy8gLSBuLmIuIGFkZGluZyBhIG5ldyBncm91cCBvZiBwcm9wcyBtYXkgcmVxdWlyZSB1cGRhdGVzIHRvIHVwZGF0ZVN0eWxlSGludHMoKVxuICAvLyAtIGFkZGluZyBuZXcgcHJvcHMgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgZ2V0cyBoYW5kbGVkIGF1dG9tYXRpY2FsbHlcblxuICB2YXIgdCA9IHN0eWZuJDYudHlwZXM7XG4gIHZhciBtYWluTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBzb3VyY2VMYWJlbCA9IFt7XG4gICAgbmFtZTogJ3NvdXJjZS1sYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciB0YXJnZXRMYWJlbCA9IFt7XG4gICAgbmFtZTogJ3RhcmdldC1sYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBsYWJlbERpbWVuc2lvbnMgPSBbe1xuICAgIG5hbWU6ICdmb250LWZhbWlseScsXG4gICAgdHlwZTogdC5mb250RmFtaWx5LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtc3R5bGUnLFxuICAgIHR5cGU6IHQuZm9udFN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICB0eXBlOiB0LmZvbnRXZWlnaHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLFxuICAgIHR5cGU6IHQudGV4dFRyYW5zZm9ybSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXdyYXAnLFxuICAgIHR5cGU6IHQudGV4dFdyYXAsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdmVyZmxvdy13cmFwJyxcbiAgICB0eXBlOiB0LnRleHRPdmVyZmxvd1dyYXAsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXgtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWhlaWdodCcsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBjb21tb25MYWJlbCA9IFt7XG4gICAgbmFtZTogJ3RleHQtdmFsaWduJyxcbiAgICB0eXBlOiB0LnZhbGlnbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWhhbGlnbicsXG4gICAgdHlwZTogdC5oYWxpZ24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1zaGFwZScsXG4gICAgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtanVzdGlmaWNhdGlvbicsXG4gICAgdHlwZTogdC5qdXN0aWZpY2F0aW9uXG4gIH1dO1xuICB2YXIgYmVoYXZpb3IgPSBbe1xuICAgIG5hbWU6ICdldmVudHMnLFxuICAgIHR5cGU6IHQuYm9vbFxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2xcbiAgfV07XG4gIHZhciB2aXNpYmlsaXR5ID0gW3tcbiAgICBuYW1lOiAnZGlzcGxheScsXG4gICAgdHlwZTogdC5kaXNwbGF5LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVyczogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ3Zpc2liaWxpdHknLFxuICAgIHR5cGU6IHQudmlzaWJpbGl0eSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuemVyb05vblplcm9cbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICd6LWNvbXBvdW5kLWRlcHRoJyxcbiAgICB0eXBlOiB0LnpDb21wb3VuZERlcHRoLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgtY29tcGFyZScsXG4gICAgdHlwZTogdC56SW5kZXhDb21wYXJlLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3otaW5kZXgnLFxuICAgIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgb3ZlcmxheSA9IFt7XG4gICAgbmFtZTogJ292ZXJsYXktcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi56ZXJvTm9uWmVyb1xuICB9XTtcbiAgdmFyIHRyYW5zaXRpb24gPSBbe1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JyxcbiAgICB0eXBlOiB0LnByb3BMaXN0XG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsXG4gICAgdHlwZTogdC50aW1lXG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsXG4gICAgdHlwZTogdC50aW1lXG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAgIHR5cGU6IHQuZWFzaW5nXG4gIH1dO1xuXG4gIHZhciBub2RlU2l6ZUhhc2hPdmVycmlkZSA9IGZ1bmN0aW9uIG5vZGVTaXplSGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCkge1xuICAgIGlmIChwYXJzZWRQcm9wLnZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4gLWVsZS5wb29sSW5kZXgoKTsgLy8gbm8gaGFzaCBrZXkgaGl0cyBpcyB1c2luZyBsYWJlbCBzaXplIChoaXRyYXRlIGZvciBwZXJmIHByb2JhYmx5IGxvdyBhbnl3YXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBub2RlQm9keSA9IFt7XG4gICAgbmFtZTogJ2hlaWdodCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3dpZHRoJyxcbiAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gIH0sIHtcbiAgICBuYW1lOiAnc2hhcGUnLFxuICAgIHR5cGU6IHQubm9kZVNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlLXBvbHlnb24tcG9pbnRzJyxcbiAgICB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZmlsbCcsXG4gICAgdHlwZTogdC5maWxsXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWJsYWNrZW4nLFxuICAgIHR5cGU6IHQubk9uZU9uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnLFxuICAgIHR5cGU6IHQuY29sb3JzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycsXG4gICAgdHlwZTogdC5wZXJjZW50YWdlc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmdyYWRpZW50RGlyZWN0aW9uXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQucGFkZGluZ1JlbGF0aXZlVG8sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm91bmRzLWV4cGFuc2lvbicsXG4gICAgdHlwZTogdC5ib3VuZHNFeHBhbnNpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgbm9kZUJvcmRlciA9IFt7XG4gICAgbmFtZTogJ2JvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGVcbiAgfV07XG4gIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBbe1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICB0eXBlOiB0LnVybHNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJyxcbiAgICB0eXBlOiB0LmJnQ3Jvc3NPcmlnaW5cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcnNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgICB0eXBlOiB0LmJnUmVwZWF0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1maXQnLFxuICAgIHR5cGU6IHQuYmdGaXRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNsaXAnLFxuICAgIHR5cGU6IHQuYmdDbGlwXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsXG4gICAgdHlwZTogdC5iZ1dIXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXgnLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH1dO1xuICB2YXIgY29tcG91bmQgPSBbe1xuICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgdHlwZTogdC5wb3NpdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsXG4gICAgdHlwZTogdC5jb21wb3VuZEluY2x1ZGVMYWJlbHMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtbGVmdCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLXJpZ2h0JyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy10b3AnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZWRnZUxpbmUgPSBbe1xuICAgIG5hbWU6ICdsaW5lLXN0eWxlJyxcbiAgICB0eXBlOiB0LmxpbmVTdHlsZVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWZpbGwnLFxuICAgIHR5cGU6IHQuZmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtY2FwJyxcbiAgICB0eXBlOiB0LmxpbmVDYXBcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWRhc2gtcGF0dGVybicsXG4gICAgdHlwZTogdC5udW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLW9mZnNldCcsXG4gICAgdHlwZTogdC5udW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdjdXJ2ZS1zdHlsZScsXG4gICAgdHlwZTogdC5jdXJ2ZVN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZW5kcG9pbnQnLFxuICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4nLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuYXhpc0RpcmVjdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdlZGdlLWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5lZGdlRGlzdGFuY2VzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LXNjYWxlJyxcbiAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xvb3AtZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xvb3Atc3dlZXAnLFxuICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBnaG9zdCA9IFt7XG4gICAgbmFtZTogJ2dob3N0JyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH1dO1xuICB2YXIgY29yZSA9IFt7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTsgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuXG4gIHZhciBwaWUgPSBbXTtcbiAgc3R5Zm4kNi5waWVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBwaWUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcblxuICBwaWUucHVzaCh7XG4gICAgbmFtZTogJ3BpZS1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgfSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kNi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSk7XG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJyxcbiAgICAgIHR5cGU6IHQucGVyY2VudFxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9KTtcbiAgfSAvLyBlZGdlIGFycm93c1xuXG5cbiAgdmFyIGVkZ2VBcnJvdyA9IFtdO1xuICB2YXIgYXJyb3dQcmVmaXhlcyA9IHN0eWZuJDYuYXJyb3dQcmVmaXhlcyA9IFsnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnXTtcbiAgW3tcbiAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgIHR5cGU6IHQuYXJyb3dTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgIHR5cGU6IHQuYXJyb3dGaWxsXG4gIH1dLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZSxcbiAgICAgICAgICB0cmlnZ2Vyc0JvdW5kcyA9IHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gICAgICBlZGdlQXJyb3cucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRyaWdnZXJzQm91bmRzOiB0cmlnZ2Vyc0JvdW5kc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHt9KTtcbiAgdmFyIHByb3BzID0gc3R5Zm4kNi5wcm9wZXJ0aWVzID0gW10uY29uY2F0KGJlaGF2aW9yLCB0cmFuc2l0aW9uLCB2aXNpYmlsaXR5LCBvdmVybGF5LCBnaG9zdCwgY29tbW9uTGFiZWwsIGxhYmVsRGltZW5zaW9ucywgbWFpbkxhYmVsLCBzb3VyY2VMYWJlbCwgdGFyZ2V0TGFiZWwsIG5vZGVCb2R5LCBub2RlQm9yZGVyLCBiYWNrZ3JvdW5kSW1hZ2UsIHBpZSwgY29tcG91bmQsIGVkZ2VMaW5lLCBlZGdlQXJyb3csIGNvcmUpO1xuICB2YXIgcHJvcEdyb3VwcyA9IHN0eWZuJDYucHJvcGVydHlHcm91cHMgPSB7XG4gICAgLy8gY29tbW9uIHRvIGFsbCBlbGVzXG4gICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcbiAgICBvdmVybGF5OiBvdmVybGF5LFxuICAgIGdob3N0OiBnaG9zdCxcbiAgICAvLyBsYWJlbHNcbiAgICBjb21tb25MYWJlbDogY29tbW9uTGFiZWwsXG4gICAgbGFiZWxEaW1lbnNpb25zOiBsYWJlbERpbWVuc2lvbnMsXG4gICAgbWFpbkxhYmVsOiBtYWluTGFiZWwsXG4gICAgc291cmNlTGFiZWw6IHNvdXJjZUxhYmVsLFxuICAgIHRhcmdldExhYmVsOiB0YXJnZXRMYWJlbCxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgbm9kZUJvZHk6IG5vZGVCb2R5LFxuICAgIG5vZGVCb3JkZXI6IG5vZGVCb3JkZXIsXG4gICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcGllOiBwaWUsXG4gICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICBlZGdlTGluZTogZWRnZUxpbmUsXG4gICAgZWRnZUFycm93OiBlZGdlQXJyb3csXG4gICAgY29yZTogY29yZVxuICB9O1xuICB2YXIgcHJvcEdyb3VwTmFtZXMgPSBzdHlmbiQ2LnByb3BlcnR5R3JvdXBOYW1lcyA9IHt9O1xuICB2YXIgcHJvcEdyb3VwS2V5cyA9IHN0eWZuJDYucHJvcGVydHlHcm91cEtleXMgPSBPYmplY3Qua2V5cyhwcm9wR3JvdXBzKTtcbiAgcHJvcEdyb3VwS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBwcm9wR3JvdXBOYW1lc1trZXldID0gcHJvcEdyb3Vwc1trZXldLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AubmFtZTtcbiAgICB9KTtcbiAgICBwcm9wR3JvdXBzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AuZ3JvdXBLZXkgPSBrZXk7XG4gICAgfSk7XG4gIH0pOyAvLyBkZWZpbmUgYWxpYXNlc1xuXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4kNi5hbGlhc2VzID0gW3tcbiAgICBuYW1lOiAnY29udGVudCcsXG4gICAgcG9pbnRzVG86ICdsYWJlbCdcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cydcbiAgfSwge1xuICAgIG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLFxuICAgIHBvaW50c1RvOiAndGV4dC1yb3RhdGlvbidcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWxlZnQnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJpZ2h0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy10b3AnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9XTsgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuXG4gIHN0eWZuJDYucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLm5hbWU7XG4gIH0pOyAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbX2ldO1xuICAgIHByb3BzW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9IC8vIG1hcCBhbGlhc2VzXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhbGlhc2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW19pMl07XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzW2FsaWFzLnBvaW50c1RvXTtcbiAgICB2YXIgYWxpYXNQcm9wID0ge1xuICAgICAgbmFtZTogYWxpYXMubmFtZSxcbiAgICAgIGFsaWFzOiB0cnVlLFxuICAgICAgcG9pbnRzVG86IHBvaW50c1RvUHJvcFxuICAgIH07IC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG5cbiAgICBwcm9wcy5wdXNoKGFsaWFzUHJvcCk7XG4gICAgcHJvcHNbYWxpYXMubmFtZV0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5cbnN0eWZuJDYuZ2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoKVtuYW1lXTtcbn07XG5cbnN0eWZuJDYuZ2V0RGVmYXVsdFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgaWYgKF9wLmRlZmF1bHRQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gIH1cblxuICB2YXIgcmF3UHJvcHMgPSBleHRlbmQoe1xuICAgIC8vIGNvcmUgcHJvcHNcbiAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjUsXG4gICAgLy8gY29tbW9uIG5vZGUvZWRnZSBwcm9wc1xuICAgICdldmVudHMnOiAneWVzJyxcbiAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICd0ZXh0LWp1c3RpZmljYXRpb24nOiAnYXV0bycsXG4gICAgJ2xpbmUtaGVpZ2h0JzogMSxcbiAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgJ3RleHQtb3ZlcmZsb3ctd3JhcCc6ICd3aGl0ZXNwYWNlJyxcbiAgICAndGV4dC1tYXgtd2lkdGgnOiA5OTk5LFxuICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogMCxcbiAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICd0ZXh0LWJvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAnZm9udC1zaXplJzogMTYsXG4gICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAndGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAnc291cmNlLXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3RhcmdldC10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICdvcGFjaXR5JzogMSxcbiAgICAnei1jb21wb3VuZC1kZXB0aCc6ICdhdXRvJyxcbiAgICAnei1pbmRleC1jb21wYXJlJzogJ2F1dG8nLFxuICAgICd6LWluZGV4JzogMCxcbiAgICAnbGFiZWwnOiAnJyxcbiAgICAndGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RleHQtbWFyZ2luLXknOiAwLFxuICAgICdzb3VyY2UtbGFiZWwnOiAnJyxcbiAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3RhcmdldC1sYWJlbCc6ICcnLFxuICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nOiAnbGluZWFyJyxcbiAgICAvLyBub2RlIHByb3BzXG4gICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nOiAnYW5vbnltb3VzJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLW9mZnNldC14JzogMCxcbiAgICAnYmFja2dyb3VuZC1vZmZzZXQteSc6IDAsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnYXV0bycsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICdoZWlnaHQnOiAzMCxcbiAgICAnd2lkdGgnOiAzMCxcbiAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcbiAgICAnYm91bmRzLWV4cGFuc2lvbic6IDAsXG4gICAgLy8gbm9kZSBncmFkaWVudFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbic6ICd0by1ib3R0b20nLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAvLyBnaG9zdCBwcm9wc1xuICAgICdnaG9zdCc6ICdubycsXG4gICAgJ2dob3N0LW9mZnNldC15JzogMCxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXgnOiAwLFxuICAgICdnaG9zdC1vcGFjaXR5JzogMCxcbiAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICdwYWRkaW5nJzogMCxcbiAgICAncGFkZGluZy1yZWxhdGl2ZS10byc6ICd3aWR0aCcsXG4gICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnLFxuICAgICdtaW4td2lkdGgnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAwXG4gIH0sIHtcbiAgICAvLyBub2RlIHBpZSBiZ1xuICAgICdwaWUtc2l6ZSc6ICcxMDAlJ1xuICB9LCBbe1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdmFsdWU6ICdibGFjaydcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJyxcbiAgICB2YWx1ZTogJzAlJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHZhbHVlOiAxXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kNi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pLCB7XG4gICAgLy8gZWRnZSBwcm9wc1xuICAgICdsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnbGluZS1jb2xvcic6ICcjOTk5JyxcbiAgICAnbGluZS1maWxsJzogJ3NvbGlkJyxcbiAgICAnbGluZS1jYXAnOiAnYnV0dCcsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAndGF4aS10dXJuJzogJzUwJScsXG4gICAgJ3RheGktdHVybi1taW4tZGlzdGFuY2UnOiAxMCxcbiAgICAndGF4aS1kaXJlY3Rpb24nOiAnYXV0bycsXG4gICAgJ2VkZ2UtZGlzdGFuY2VzJzogJ2ludGVyc2VjdGlvbicsXG4gICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJyxcbiAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICdsb29wLWRpcmVjdGlvbic6ICctNDVkZWcnLFxuICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICdsaW5lLWRhc2gtcGF0dGVybic6IFs2LCAzXSxcbiAgICAnbGluZS1kYXNoLW9mZnNldCc6IDBcbiAgfSwgW3tcbiAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgIHZhbHVlOiAnbm9uZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgdmFsdWU6ICcjOTk5J1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgIHZhbHVlOiAnZmlsbGVkJ1xuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIHN0eWZuJDYuYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pKTtcbiAgdmFyIHBhcnNlZFByb3BzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tpXTtcblxuICAgIGlmIChwcm9wLnBvaW50c1RvKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICB2YXIgdmFsID0gcmF3UHJvcHNbbmFtZV07XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbCk7XG4gICAgcGFyc2VkUHJvcHNbbmFtZV0gPSBwYXJzZWRQcm9wO1xuICB9XG5cbiAgX3AuZGVmYXVsdFByb3BlcnRpZXMgPSBwYXJzZWRQcm9wcztcbiAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xufTtcblxuc3R5Zm4kNi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3RvcignOnBhcmVudCcpLmNzcyh7XG4gICAgJ3NoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3BhZGRpbmcnOiAxMCxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZWVlJyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyNjY2MnLFxuICAgICdib3JkZXItd2lkdGgnOiAxXG4gIH0pLnNlbGVjdG9yKCdlZGdlJykuY3NzKHtcbiAgICAnd2lkdGgnOiAzXG4gIH0pLnNlbGVjdG9yKCc6bG9vcCcpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcidcbiAgfSkuc2VsZWN0b3IoJ2VkZ2U6Y29tcG91bmQnKS5jc3Moe1xuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJyxcbiAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZSdcbiAgfSkuc2VsZWN0b3IoJzpzZWxlY3RlZCcpLmNzcyh7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ2xpbmUtY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknXG4gIH0pLnNlbGVjdG9yKCc6cGFyZW50OnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjQ0NFMUY5JyxcbiAgICAnYm9yZGVyLWNvbG9yJzogJyNhZWM4ZTUnXG4gIH0pLnNlbGVjdG9yKCc6YWN0aXZlJykuY3NzKHtcbiAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gIH0pO1xuICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbn07XG5cbnZhciBzdHlmbiQ3ID0ge307IC8vIGEgY2FjaGluZyBsYXllciBmb3IgcHJvcGVydHkgcGFyc2luZ1xuXG5zdHlmbiQ3LnBhcnNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmdW5jdGlvbiB2YWx1ZXMgY2FuJ3QgYmUgY2FjaGVkIGluIGFsbCBjYXNlcywgYW5kIHRoZXJlIGlzbid0IG11Y2ggYmVuZWZpdCBvZiBjYWNoaW5nIHRoZW0gYW55d2F5XG5cbiAgaWYgKGZuKHZhbHVlKSkge1xuICAgIHJldHVybiBzZWxmLnBhcnNlSW1wbFdhcm4obmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gIH1cblxuICB2YXIgZmxhdEtleSA9IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyB8fCBwcm9wSXNGbGF0ID09PSB0cnVlIHx8IHByb3BJc0ZsYXQgPT09IGZhbHNlIHx8IHByb3BJc0ZsYXQgPT0gbnVsbCA/ICdkb250Y2FyZScgOiBwcm9wSXNGbGF0O1xuICB2YXIgYnlwYXNzS2V5ID0gcHJvcElzQnlwYXNzID8gJ3QnIDogJ2YnO1xuICB2YXIgdmFsdWVLZXkgPSAnJyArIHZhbHVlO1xuICB2YXIgYXJnSGFzaCA9IGhhc2hTdHJpbmdzKG5hbWUsIHZhbHVlS2V5LCBieXBhc3NLZXksIGZsYXRLZXkpO1xuICB2YXIgcHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSB8fCBbXTtcbiAgdmFyIHJldDtcblxuICBpZiAoIShyZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0pKSB7XG4gICAgcmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdID0gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9IC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG5cblxuICBpZiAocHJvcElzQnlwYXNzIHx8IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJykge1xuICAgIC8vIG5lZWQgYSBjb3B5IHNpbmNlIHByb3BzIGFyZSBtdXRhdGVkIGxhdGVyIGluIHRoZWlyIGxpZmVjeWNsZXNcbiAgICByZXQgPSBjb3B5KHJldCk7XG5cbiAgICBpZiAocmV0KSB7XG4gICAgICByZXQudmFsdWUgPSBjb3B5KHJldC52YWx1ZSk7IC8vIGJlY2F1c2UgaXQgY291bGQgYmUgYW4gYXJyYXksIGUuZy4gY29sb3VyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbnN0eWZuJDcucGFyc2VJbXBsV2FybiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBwcm9wID0gdGhpcy5wYXJzZUltcGwobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG5cbiAgaWYgKCFwcm9wICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICB3YXJuKFwiVGhlIHN0eWxlIHByb3BlcnR5IGBcIi5jb25jYXQobmFtZSwgXCI6IFwiKS5jb25jYXQodmFsdWUsIFwiYCBpcyBpbnZhbGlkXCIpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wO1xufTsgLy8gcGFyc2UgYSBwcm9wZXJ0eTsgcmV0dXJuIG51bGwgb24gaW52YWxpZDsgcmV0dXJuIHBhcnNlZCBwcm9wZXJ0eSBvdGhlcndpc2Vcbi8vIGZpZWxkcyA6XG4vLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gdmFsdWUgOiB0aGUgcGFyc2VkLCBuYXRpdmUtdHlwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3Ncbi8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG5cblxuc3R5Zm4kNy5wYXJzZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IG5hbWUgaXMgaW4gZGFzaCBmb3JtIChlLmcuICdwcm9wZXJ0eS1uYW1lJyBub3QgJ3Byb3BlcnR5TmFtZScpXG5cbiAgdmFyIHByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0aWVzW25hbWVdO1xuICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBpZiAoIXByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gcmV0dXJuIG51bGwgb24gcHJvcGVydHkgb2YgdW5rbm93biBuYW1lXG5cblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGNhbid0IGFzc2lnbiB1bmRlZmluZWRcbiAgLy8gdGhlIHByb3BlcnR5IG1heSBiZSBhbiBhbGlhc1xuXG5cbiAgaWYgKHByb3BlcnR5LmFsaWFzKSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgfVxuXG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gc3RyaW5nKHZhbHVlKTtcblxuICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgIC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcblxuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyB0eXBlLCBubyBsdWNrXG4gIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG5cblxuICBpZiAocHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBieXBhc3M6IHRydWUsXG4gICAgICBkZWxldGVCeXBhc3M6IHRydWVcbiAgICB9O1xuICB9IC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuXG5cbiAgaWYgKGZuKHZhbHVlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICdmbicsXG4gICAgICBtYXBwZWQ6IHR5cGVzLmZuLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuXG5cbiAgdmFyIGRhdGEsIG1hcERhdGE7XG5cbiAgaWYgKCF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgfHwgdmFsdWUubGVuZ3RoIDwgNyB8fCB2YWx1ZVsxXSAhPT0gJ2EnKSA7IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSA3ICYmIHZhbHVlWzBdID09PSAnZCcgJiYgKGRhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLmRhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cblxuICAgIHZhciBtYXBwZWQgPSB0eXBlcy5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID49IDEwICYmIHZhbHVlWzBdID09PSAnbScgJiYgKG1hcERhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLm1hcERhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cblxuICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuXG4gICAgdmFyIF9tYXBwZWQgPSB0eXBlcy5tYXBEYXRhOyAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcblxuICAgIGlmICghKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgIGlmICghdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG5cbiAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNV0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuXG4gICAgaWYgKCF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG4gICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuXG5cbiAgICBpZiAodmFsdWVNaW4ucGZWYWx1ZSA9PT0gdmFsdWVNYXgucGZWYWx1ZSB8fCB2YWx1ZU1pbi5zdHJWYWx1ZSA9PT0gdmFsdWVNYXguc3RyVmFsdWUpIHtcbiAgICAgIHdhcm4oJ2AnICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICdgIGlzIG5vdCBhIHZhbGlkIG1hcHBlciBiZWNhdXNlIHRoZSBvdXRwdXQgcmFuZ2UgaXMgemVybzsgY29udmVydGluZyB0byBgJyArIG5hbWUgKyAnOiAnICsgdmFsdWVNaW4uc3RyVmFsdWUgKyAnYCcpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UobmFtZSwgdmFsdWVNaW4uc3RyVmFsdWUpOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAmJiAoIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICBjMVszXSA9PT0gYzJbM10gLy8gc2FtZSBhbHBoYSBvdXRyaWdodFxuICAgICAgfHwgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEpICYmICggLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgIGMyWzNdID09IG51bGwgfHwgYzJbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDI/XG4gICAgICApO1xuXG4gICAgICBpZiAoc2FtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG5cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBtYXBEYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IF9tYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KG1hcERhdGFbMl0pLFxuICAgICAgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICBmaWVsZE1heDogcGFyc2VGbG9hdChtYXBEYXRhWzNdKSxcbiAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScpIHtcbiAgICB2YXIgdmFscztcblxuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHZhbHVlKSkge1xuICAgICAgdmFscyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxzID0gW3ZhbHVlXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5ldmVuTXVsdGlwbGUgJiYgdmFscy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsQXJyID0gW107XG4gICAgdmFyIHVuaXRzQXJyID0gW107XG4gICAgdmFyIHBmVmFsQXJyID0gW107XG4gICAgdmFyIHN0clZhbCA9ICcnO1xuICAgIHZhciBoYXNFbnVtID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gc2VsZi5wYXJzZShuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScpO1xuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgc3RyaW5nKHAudmFsdWUpO1xuICAgICAgdmFsQXJyLnB1c2gocC52YWx1ZSk7XG4gICAgICBwZlZhbEFyci5wdXNoKHAucGZWYWx1ZSAhPSBudWxsID8gcC5wZlZhbHVlIDogcC52YWx1ZSk7XG4gICAgICB1bml0c0Fyci5wdXNoKHAudW5pdHMpO1xuICAgICAgc3RyVmFsICs9IChpID4gMCA/ICcgJyA6ICcnKSArIHAuc3RyVmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUudmFsaWRhdGUgJiYgIXR5cGUudmFsaWRhdGUodmFsQXJyLCB1bml0c0FycikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnNpbmdsZUVudW0gJiYgaGFzRW51bSkge1xuICAgICAgaWYgKHZhbEFyci5sZW5ndGggPT09IDEgJiYgc3RyaW5nKHZhbEFyclswXSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgc3RyVmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogc3RyVmFsLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9IC8vIHNldmVyYWwgdHlwZXMgYWxzbyBhbGxvdyBlbnVtc1xuXG5cbiAgdmFyIGNoZWNrRW51bXMgPSBmdW5jdGlvbiBjaGVja0VudW1zKCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlLmVudW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tfaV07XG5cbiAgICAgIGlmIChlbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9OyAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcblxuXG4gIGlmICh0eXBlLm51bWJlcikge1xuICAgIHZhciB1bml0cztcbiAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgIGlmICh0eXBlLnVuaXRzKSB7XG4gICAgICAvLyB1c2Ugc3BlY2lmaWVkIHVuaXRzIGlmIHNldFxuICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlLnVuaXRsZXNzKSB7XG4gICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcblxuICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICB1bml0c1JlZ2V4ID0gdW5pdHM7XG4gICAgICAgIH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcblxuXG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCdeKCcgKyBudW1iZXIkMSArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpOyAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG5cbiAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuXG5cbiAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcbiAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgfSAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcblxuXG4gICAgaWYgKHR5cGUuaW50ZWdlciAmJiAhaW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG5cblxuICAgIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA8IHR5cGUubWluIHx8IHR5cGUuc3RyaWN0TWluICYmIHZhbHVlID09PSB0eXBlLm1pbikgfHwgdHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPiB0eXBlLm1heCB8fCB0eXBlLnN0cmljdE1heCAmJiB2YWx1ZSA9PT0gdHlwZS5tYXgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICB1bml0czogdW5pdHMsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcblxuICAgIGlmICh0eXBlLnVuaXRsZXNzIHx8IHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncHgnIHx8ICF1bml0cyA/IHZhbHVlIDogdGhpcy5nZXRFbVNpemVJblBpeGVscygpICogdmFsdWU7XG4gICAgfSAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcblxuXG4gICAgaWYgKHVuaXRzID09PSAnbXMnIHx8IHVuaXRzID09PSAncycpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICB9IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiByYWRcblxuXG4gICAgaWYgKHVuaXRzID09PSAnZGVnJyB8fCB1bml0cyA9PT0gJ3JhZCcpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdyYWQnID8gdmFsdWUgOiBkZWcycmFkKHZhbHVlKTtcbiAgICB9IC8vIG5vcm1hbGl6ZSB2YWx1ZSBpbiAlXG5cblxuICAgIGlmICh1bml0cyA9PT0gJyUnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHZhbHVlIC8gMTAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSBpZiAodHlwZS5wcm9wTGlzdCkge1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiAocHJvcHNTdHIgPT09ICdub25lJykgOyBlbHNlIHtcbiAgICAgIC8vIGdvIG92ZXIgZWFjaCBwcm9wXG4gICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KC9cXHMqLFxccyp8XFxzKy8pO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcHNTcGxpdFtfaTJdLnRyaW0oKTtcblxuICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXSkge1xuICAgICAgICAgIHByb3BzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ2AnICsgcHJvcE5hbWUgKyAnYCBpcyBub3QgYSB2YWxpZCBwcm9wZXJ0eSBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcgJyksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgIHZhciB0dXBsZSA9IGNvbG9yMnR1cGxlKHZhbHVlKTtcblxuICAgIGlmICghdHVwbGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHR1cGxlLFxuICAgICAgcGZWYWx1ZTogdHVwbGUsXG4gICAgICBzdHJWYWx1ZTogJ3JnYignICsgdHVwbGVbMF0gKyAnLCcgKyB0dXBsZVsxXSArICcsJyArIHR1cGxlWzJdICsgJyknLFxuICAgICAgLy8gbi5iLiBubyBzcGFjZXMgYi9jIG9mIG11bHRpcGxlIHN1cHBvcnRcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLnJlZ2V4IHx8IHR5cGUucmVnZXhlcykge1xuICAgIC8vIGZpcnN0IGNoZWNrIGVudW1zXG4gICAgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAgIHZhciBlbnVtUHJvcCA9IGNoZWNrRW51bXMoKTtcblxuICAgICAgaWYgKGVudW1Qcm9wKSB7XG4gICAgICAgIHJldHVybiBlbnVtUHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFt0eXBlLnJlZ2V4XTtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJlZ2V4ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleGVzW19pM10pOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZSBzdHJpbmdcblxuICAgICAgdmFyIG0gPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgaWYgKG0pIHtcbiAgICAgICAgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHR5cGUuc2luZ2xlUmVnZXhNYXRjaFZhbHVlID8gbVsxXSA6IG0sXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuICB9IGVsc2UgaWYgKHR5cGUuc3RyaW5nKSB7XG4gICAgLy8ganVzdCByZXR1cm5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5lbnVtcykge1xuICAgIC8vIGNoZWNrIGVudW1zIGxhc3QgYmVjYXVzZSBpdCdzIGEgY29tYm8gdHlwZSBpbiBvdGhlcnNcbiAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsOyAvLyBub3QgYSB0eXBlIHdlIGNhbiBoYW5kbGVcbiAgfVxufTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gU3R5bGUoY3kpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlKSkge1xuICAgIHJldHVybiBuZXcgU3R5bGUoY3kpO1xuICB9XG5cbiAgaWYgKCFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgY29yZVN0eWxlOiB7fVxuICB9O1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucmVzZXRUb0RlZmF1bHQoKTtcbn07XG5cbnZhciBzdHlmbiQ4ID0gU3R5bGUucHJvdG90eXBlO1xuXG5zdHlmbiQ4Lmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlJztcbn07IC8vIHJlbW92ZSBhbGwgY29udGV4dHNcblxuXG5zdHlmbiQ4LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICBfcC5uZXdTdHlsZSA9IHRydWU7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4kOC5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5cblxuc3R5Zm4kOC5jb3JlID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wTmFtZV0gfHwgdGhpcy5nZXREZWZhdWx0UHJvcGVydHkocHJvcE5hbWUpO1xufTsgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuXG5cbnN0eWZuJDguc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JTdHIpIHtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuXG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdLFxuICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgIGluZGV4OiBpXG4gIH07XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTsgLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG5cblxuc3R5Zm4kOC5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW3Byb3AubmFtZV07XG5cbiAgICAgIGlmIChtYXBWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXBWYWwgPSBtYXBbZGFzaDJjYW1lbChwcm9wLm5hbWUpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY3NzUnVsZShwcm9wLm5hbWUsIG1hcFZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5jc3NSdWxlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9IC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuXG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbiQ4LnN0eWxlID0gc3R5Zm4kOC5jc3M7IC8vIGFkZCBhIHNpbmdsZSBjc3MgcnVsZSB0byB0aGUgY3VycmVudCBjb250ZXh0XG5cbnN0eWZuJDguY3NzUnVsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSk7IC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcblxuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7IC8vIGFsbG93IGFjY2VzcyBieSBuYW1lIGFzIHdlbGxcblxuICAgIGlmIChwcm9wZXJ0eS5uYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHByb3BlcnR5LnZhbHVlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmhhc1BpZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Lm1hcHBlZCkge1xuICAgICAgdGhpc1tpXS5tYXBwZWRQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIH0gLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG5cblxuICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcblxuICAgIGlmIChjdXJyZW50U2VsZWN0b3JJc0NvcmUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zdHlmbiQ4LmFwcGVuZCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICBzdHlsZS5hcHBlbmRUb1N0eWxlKHRoaXMpO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbUpzb24oc3R5bGUpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21TdHJpbmcoc3R5bGUpO1xuICB9IC8vIHlvdSBwcm9iYWJseSB3b3VsZG4ndCB3YW50IHRvIGFwcGVuZCBhIFN0eWxlLCBzaW5jZSB5b3UnZCBkdXBsaWNhdGUgdGhlIGRlZmF1bHQgcGFydHNcblxuXG4gIHJldHVybiB0aGlzO1xufTsgLy8gc3RhdGljIGZ1bmN0aW9uXG5cblxuU3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiAoY3ksIGpzb24pIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgc3R5bGUuZnJvbUpzb24oanNvbik7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY3ksIHN0cmluZykge1xuICByZXR1cm4gbmV3IFN0eWxlKGN5KS5mcm9tU3RyaW5nKHN0cmluZyk7XG59O1xuXG5bc3R5Zm4sIHN0eWZuJDEsIHN0eWZuJDIsIHN0eWZuJDMsIHN0eWZuJDQsIHN0eWZuJDUsIHN0eWZuJDYsIHN0eWZuJDddLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChzdHlmbiQ4LCBwcm9wcyk7XG59KTtcblN0eWxlLnR5cGVzID0gc3R5Zm4kOC50eXBlcztcblN0eWxlLnByb3BlcnRpZXMgPSBzdHlmbiQ4LnByb3BlcnRpZXM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwcyA9IHN0eWZuJDgucHJvcGVydHlHcm91cHM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwTmFtZXMgPSBzdHlmbiQ4LnByb3BlcnR5R3JvdXBOYW1lcztcblN0eWxlLnByb3BlcnR5R3JvdXBLZXlzID0gc3R5Zm4kOC5wcm9wZXJ0eUdyb3VwS2V5cztcblxudmFyIGNvcmVmbiQ3ID0ge1xuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmV3U3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGUpIHtcbiAgICAgIHZhciBzID0gdGhpcy5zZXRTdHlsZShuZXdTdHlsZSk7XG4gICAgICBzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICB9LFxuICBzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbUpzb24odGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tU3RyaW5nKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Auc3R5bGU7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0U2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xudmFyIGNvcmVmbiQ4ID0ge1xuICBhdXRvbG9jazogZnVuY3Rpb24gYXV0b2xvY2soYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24gYXV0b3VuZ3JhYmlmeShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbiBhdXRvdW5zZWxlY3RpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbiBzZWxlY3Rpb25UeXBlKHNlbFR5cGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKF9wLnNlbGVjdGlvblR5cGUgPT0gbnVsbCkge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IGRlZmF1bHRTZWxlY3Rpb25UeXBlO1xuICAgIH1cblxuICAgIGlmIChzZWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZWxUeXBlID09PSAnYWRkaXRpdmUnIHx8IHNlbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3Auc2VsZWN0aW9uVHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgem9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24gYm94U2VsZWN0aW9uRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcGFuOiBmdW5jdGlvbiBwYW4oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHN0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhbltkaW1dO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgaWYgKG51bWJlcih4KSkge1xuICAgICAgICAgICAgcGFuLnggPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChudW1iZXIoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlcih2YWwpKSB7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHBhbkJ5OiBmdW5jdGlvbiBwYW5CeShhcmcwLCBhcmcxKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAocGxhaW5PYmplY3QoYXJnMCkpIHtcbiAgICAgICAgICAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiAobnVtYmVyKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChudW1iZXIoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnMDtcbiAgICAgICAgdmFsID0gYXJnMTtcblxuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZml0OiBmdW5jdGlvbiBmaXQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpO1xuXG4gICAgaWYgKHZpZXdwb3J0U3RhdGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uIGdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgaWYgKG51bWJlcihlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHNlbCk7XG4gICAgfSBlbHNlIGlmIChib3VuZGluZ0JveChlbGVtZW50cykpIHtcbiAgICAgIC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICYmIGVsZW1lbnRzLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGNhbid0IGZpdCB0byBub3RoaW5nXG5cblxuICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgdmFyIHpvb207XG4gICAgcGFkZGluZyA9IG51bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgaWYgKCFpc05hTih3KSAmJiAhaXNOYU4oaCkgJiYgdyA+IDAgJiYgaCA+IDAgJiYgIWlzTmFOKGJiLncpICYmICFpc05hTihiYi5oKSAmJiBiYi53ID4gMCAmJiBiYi5oID4gMCkge1xuICAgICAgem9vbSA9IE1hdGgubWluKCh3IC0gMiAqIHBhZGRpbmcpIC8gYmIudywgKGggLSAyICogcGFkZGluZykgLyBiYi5oKTsgLy8gY3JvcCB6b29tXG5cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcbiAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgIC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogcGFuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcbiAgem9vbVJhbmdlOiBmdW5jdGlvbiB6b29tUmFuZ2UobWluLCBtYXgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICB2YXIgb3B0cyA9IG1pbjtcbiAgICAgIG1pbiA9IG9wdHMubWluO1xuICAgICAgbWF4ID0gb3B0cy5tYXg7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcihtaW4pICYmIG51bWJlcihtYXgpICYmIG1pbiA8PSBtYXgpIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgIH0gZWxzZSBpZiAobnVtYmVyKG1pbikgJiYgbWF4ID09PSB1bmRlZmluZWQgJiYgbWluIDw9IF9wLm1heFpvb20pIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgfSBlbHNlIGlmIChudW1iZXIobWF4KSAmJiBtaW4gPT09IHVuZGVmaW5lZCAmJiBtYXggPj0gX3AubWluWm9vbSkge1xuICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWluWm9vbTogZnVuY3Rpb24gbWluWm9vbSh6b29tKSB7XG4gICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgbWluOiB6b29tXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG1heFpvb206IGZ1bmN0aW9uIG1heFpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1heFpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1heDogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRab29tZWRWaWV3cG9ydDogZnVuY3Rpb24gZ2V0Wm9vbWVkVmlld3BvcnQocGFyYW1zKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3VycmVudFBhbiA9IF9wLnBhbjtcbiAgICB2YXIgY3VycmVudFpvb20gPSBfcC56b29tO1xuICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG5cbiAgICB2YXIgem9vbTtcbiAgICB2YXIgYmFpbCA9IGZhbHNlO1xuXG4gICAgaWYgKCFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgYmFpbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcihwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICBpZiAocGFyYW1zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocGFyYW1zLnBvc2l0aW9uLCBjdXJyZW50Wm9vbSwgY3VycmVudFBhbik7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgIT0gbnVsbCAmJiAhX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGNyb3Agem9vbVxuXG5cbiAgICB6b29tID0gem9vbSA+IF9wLm1heFpvb20gPyBfcC5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IF9wLm1pblpvb20gPyBfcC5taW5ab29tIDogem9vbTsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG5cbiAgICBpZiAoYmFpbCB8fCAhbnVtYmVyKHpvb20pIHx8IHpvb20gPT09IGN1cnJlbnRab29tIHx8IHBvcyAhPSBudWxsICYmICghbnVtYmVyKHBvcy54KSB8fCAhbnVtYmVyKHBvcy55KSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gY3VycmVudFBhbjtcbiAgICAgIHZhciB6b29tMSA9IGN1cnJlbnRab29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogdHJ1ZSxcbiAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgIHBhbjogcGFuMlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiBmYWxzZSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBjdXJyZW50UGFuXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgem9vbTogZnVuY3Rpb24gem9vbShwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGdldFxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0XG4gICAgICB2YXIgdnAgPSB0aGlzLmdldFpvb21lZFZpZXdwb3J0KHBhcmFtcyk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAodnAgPT0gbnVsbCB8fCAhdnAuem9vbWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBfcC56b29tID0gdnAuem9vbTtcblxuICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICBfcC5wYW4ueCA9IHZwLnBhbi54O1xuICAgICAgICBfcC5wYW4ueSA9IHZwLnBhbi55O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ3pvb20nICsgKHZwLnBhbm5lZCA/ICcgcGFuJyA6ICcnKSArICcgdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9LFxuICB2aWV3cG9ydDogZnVuY3Rpb24gdmlld3BvcnQob3B0cykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG5cbiAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFudW1iZXIob3B0cy56b29tKSkge1xuICAgICAgem9vbURlZmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdHMucGFuKSkge1xuICAgICAgcGFuRGVmZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghem9vbURlZmQgJiYgIXBhbkRlZmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh6b29tRGVmZCkge1xuICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgIGlmICh6IDwgX3AubWluWm9vbSB8fCB6ID4gX3AubWF4Wm9vbSB8fCAhX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC56b29tID0gejtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3pvb20nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFuRGVmZCAmJiAoIXpvb21GYWlsZWQgfHwgIW9wdHMuY2FuY2VsT25GYWlsZWRab29tKSAmJiBfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgaWYgKG51bWJlcihwLngpKSB7XG4gICAgICAgIF9wLnBhbi54ID0gcC54O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlcihwLnkpKSB7XG4gICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYW5GYWlsZWQpIHtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLmVtaXQoZXZlbnRzLmpvaW4oJyAnKSk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoZWxlbWVudHMpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oZWxlbWVudHMpO1xuXG4gICAgaWYgKHBhbikge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldENlbnRlclBhbjogZnVuY3Rpb24gZ2V0Q2VudGVyUGFuKGVsZW1lbnRzLCB6b29tKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBjZW50cmUgcGFuIHRvIG5vdGhpbmdcblxuXG4gICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG4gICAgdmFyIHBhbiA9IHtcbiAgICAgIC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgIH07XG4gICAgcmV0dXJuIHBhbjtcbiAgfSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIHpvb206IDFcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgaW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIGludmFsaWRhdGVTaXplKCkge1xuICAgIHRoaXMuX3ByaXZhdGUuc2l6ZUNhY2hlID0gbnVsbDtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG4gICAgcmV0dXJuIF9wLnNpemVDYWNoZSA9IF9wLnNpemVDYWNoZSB8fCAoY29udGFpbmVyID8gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuXG4gICAgICB2YXIgdmFsID0gZnVuY3Rpb24gdmFsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoIC0gdmFsKCdwYWRkaW5nLWxlZnQnKSAtIHZhbCgncGFkZGluZy1yaWdodCcpLFxuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSB2YWwoJ3BhZGRpbmctdG9wJykgLSB2YWwoJ3BhZGRpbmctYm90dG9tJylcbiAgICAgIH07XG4gICAgfSgpIDoge1xuICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfSk7XG4gIH0sXG4gIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkud2lkdGg7XG4gIH0sXG4gIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS5oZWlnaHQ7XG4gIH0sXG4gIGV4dGVudDogZnVuY3Rpb24gZXh0ZW50KCkge1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG4gICAgdmFyIGIgPSB7XG4gICAgICB4MTogKHJiLngxIC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHgyOiAocmIueDIgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTE6IChyYi55MSAtIHBhbi55KSAvIHpvb20sXG4gICAgICB5MjogKHJiLnkyIC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgYi5oID0gYi55MiAtIGIueTE7XG4gICAgcmV0dXJuIGI7XG4gIH0sXG4gIHJlbmRlcmVkRXh0ZW50OiBmdW5jdGlvbiByZW5kZXJlZEV4dGVudCgpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4Mjogd2lkdGgsXG4gICAgICB5MjogaGVpZ2h0LFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHRcbiAgICB9O1xuICB9XG59OyAvLyBhbGlhc2VzXG5cbmNvcmVmbiQ4LmNlbnRyZSA9IGNvcmVmbiQ4LmNlbnRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuY29yZWZuJDguYXV0b2xvY2tOb2RlcyA9IGNvcmVmbiQ4LmF1dG9sb2NrO1xuY29yZWZuJDguYXV0b3VuZ3JhYmlmeU5vZGVzID0gY29yZWZuJDguYXV0b3VuZ3JhYmlmeTtcblxudmFyIGZuJDYgPSB7XG4gIGRhdGE6IGRlZmluZSQzLmRhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVEYXRhOiBkZWZpbmUkMy5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGV2ZW50OiAnZGF0YScsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KSxcbiAgc2NyYXRjaDogZGVmaW5lJDMuZGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSksXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZSQzLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlXG4gIH0pXG59OyAvLyBhbGlhc2VzXG5cbmZuJDYuYXR0ciA9IGZuJDYuZGF0YTtcbmZuJDYucmVtb3ZlQXR0ciA9IGZuJDYucmVtb3ZlRGF0YTtcblxudmFyIENvcmUgPSBmdW5jdGlvbiBDb3JlKG9wdHMpIHtcbiAgdmFyIGN5ID0gdGhpcztcbiAgb3B0cyA9IGV4dGVuZCh7fSwgb3B0cyk7XG4gIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjsgLy8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cmFwcGVkIGpxdWVyeSBvYmplY3RcbiAgLy8gZS5nLiBjeXRvc2NhcGUoeyBjb250YWluZXI6ICQoJyNjeScpIH0pXG5cbiAgaWYgKGNvbnRhaW5lciAmJiAhaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG5cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuXG4gIHJlZyA9IHJlZyB8fCB7fTtcblxuICBpZiAocmVnICYmIHJlZy5jeSkge1xuICAgIHJlZy5jeS5kZXN0cm95KCk7XG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cblxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5fY3lyZWcgPSByZWc7XG4gIH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuXG5cbiAgcmVnLmN5ID0gY3k7XG4gIHZhciBoZWFkID0gd2luZG93JDEgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IGV4dGVuZCh7XG4gICAgbmFtZTogaGVhZCA/ICdncmlkJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLmxheW91dCk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLnJlbmRlcmVyKTtcblxuICB2YXIgZGVmVmFsID0gZnVuY3Rpb24gZGVmVmFsKGRlZiwgdmFsLCBhbHRWYWwpIHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIGlmIChhbHRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgcmVhZHk6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAvLyBjYWNoZWQgb3B0aW9uc1xuICAgIGVsZW1lbnRzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICBkYXRhOiB7fSxcbiAgICAvLyBkYXRhIGZvciB0aGUgY29yZVxuICAgIHNjcmF0Y2g6IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogbnVtYmVyKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlcihvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlXG4gIH07XG5cbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7IC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuXG4gIHRoaXMuc2VsZWN0aW9uVHlwZShvcHRpb25zLnNlbGVjdGlvblR5cGUpOyAvLyBpbml0IHpvb20gYm91bmRzXG5cbiAgdGhpcy56b29tUmFuZ2Uoe1xuICAgIG1pbjogb3B0aW9ucy5taW5ab29tLFxuICAgIG1heDogb3B0aW9ucy5tYXhab29tXG4gIH0pO1xuXG4gIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uIGxvYWRFeHREYXRhKGV4dERhdGEsIG5leHQpIHtcbiAgICB2YXIgYW55SXNQcm9taXNlID0gZXh0RGF0YS5zb21lKHByb21pc2UpO1xuXG4gICAgaWYgKGFueUlzUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UkMS5hbGwoZXh0RGF0YSkudGhlbihuZXh0KTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KGV4dERhdGEpOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9OyAvLyBzdGFydCB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgc28gd2UgaGF2ZSBzb21ldGhpbmcgYmVmb3JlIGxvYWRpbmcgYW4gZXh0ZXJuYWwgc3R5bGVzaGVldFxuXG5cbiAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgIGN5LnNldFN0eWxlKFtdKTtcbiAgfSAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG5cblxuICB2YXIgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyKTsgLy8gYWxsb3cgcmVuZGVyaW5nIGhpbnRzIGluIHRvcCBsZXZlbCBvcHRpb25zXG5cbiAgY3kuaW5pdFJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG5cbiAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpOyAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG5cbiAgICB2YXIgb2xkRWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCkge1xuICAgICAgaWYgKHBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgY3kuYWRkKGVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICBjeS5lbWl0KGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgIGN5Lm9uZSgnbG9hZCcsIG9ubG9hZCk7XG4gICAgICBjeS5lbWl0QW5kTm90aWZ5KCdsb2FkJyk7XG4gICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24gKCkge1xuICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgIGN5LmVtaXQoJ2RvbmUnKTtcbiAgICB9KTtcbiAgICB2YXIgbGF5b3V0T3B0cyA9IGV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgY3kubGF5b3V0KGxheW91dE9wdHMpLnJ1bigpO1xuICB9O1xuXG4gIGxvYWRFeHREYXRhKFtvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzXSwgZnVuY3Rpb24gKHRoZW5zKSB7XG4gICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdOyAvLyBpbml0IHN0eWxlXG5cbiAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICBjeS5zdHlsZSgpLmFwcGVuZChpbml0U3R5bGUpO1xuICAgIH0gLy8gaW5pdGlhbCBsb2FkXG5cblxuICAgIHNldEVsZXNBbmRMYXlvdXQoaW5pdEVsZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9ucmVhZHlcbiAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgX3AucmVhZHkgPSB0cnVlOyAvLyBpZiBhIHJlYWR5IGNhbGxiYWNrIGlzIHNwZWNpZmllZCBhcyBhbiBvcHRpb24sIHRoZSBiaW5kIGl0XG5cbiAgICAgIGlmIChmbihvcHRpb25zLnJlYWR5KSkge1xuICAgICAgICBjeS5vbigncmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIH0gLy8gYmluZCBhbGwgdGhlIHJlYWR5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgYmVmb3JlIGNyZWF0aW5nIHRoaXMgaW5zdGFuY2VcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuJDEgPSByZWFkaWVzW2ldO1xuICAgICAgICBjeS5vbigncmVhZHknLCBmbiQxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZykge1xuICAgICAgICByZWcucmVhZGllcyA9IFtdO1xuICAgICAgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuXG5cbiAgICAgIGN5LmVtaXQoJ3JlYWR5Jyk7XG4gICAgfSwgb3B0aW9ucy5kb25lKTtcbiAgfSk7XG59O1xuXG52YXIgY29yZWZuJDkgPSBDb3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuZXh0ZW5kKGNvcmVmbiQ5LCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2NvcmUnO1xuICB9LFxuICBpc1JlYWR5OiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICB9LFxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdCgncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKGN5LmRlc3Ryb3llZCgpKSByZXR1cm47XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0sXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcbiAgaGVhZGxlc3M6IGZ1bmN0aW9uIGhlYWRsZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyLmlzSGVhZGxlc3MoKTtcbiAgfSxcbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uIGFkZFRvUG9vbChlbGVzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZShlbGVzKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24gcmVtb3ZlRnJvbVBvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZShlbGVzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb250YWluZXI6IGZ1bmN0aW9uIGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIgfHwgbnVsbDtcbiAgfSxcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIG9wdGlvbnMgPSBfcC5vcHRpb25zO1xuXG4gICAgaWYgKCFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgICB9XG5cbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgIF9wLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBfcC5zdHlsZUVuYWJsZWQgPSB0cnVlO1xuICAgIGN5LmludmFsaWRhdGVTaXplKCk7XG4gICAgY3kuaW5pdFJlbmRlcmVyKGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlciwge1xuICAgICAgLy8gYWxsb3cgY3VzdG9tIHJlbmRlcmVyIG5hbWUgdG8gYmUgcmUtdXNlZCwgb3RoZXJ3aXNlIHVzZSBjYW52YXNcbiAgICAgIG5hbWU6IG9wdGlvbnMucmVuZGVyZXIubmFtZSA9PT0gJ251bGwnID8gJ2NhbnZhcycgOiBvcHRpb25zLnJlbmRlcmVyLm5hbWVcbiAgICB9KSk7XG4gICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuc3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgY3kuZW1pdCgnbW91bnQnKTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgIGN5LmluaXRSZW5kZXJlcih7XG4gICAgICBuYW1lOiAnbnVsbCdcbiAgICB9KTtcbiAgICBjeS5lbWl0KCd1bm1vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKCkge1xuICAgIHJldHVybiBjb3B5KHRoaXMuX3ByaXZhdGUub3B0aW9ucyk7XG4gIH0sXG4gIGpzb246IGZ1bmN0aW9uIGpzb24ob2JqKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgdmFyIGdldEZyZXNoUmVmID0gZnVuY3Rpb24gZ2V0RnJlc2hSZWYoZWxlKSB7XG4gICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQoZWxlLmlkKCkpO1xuICAgIH07XG5cbiAgICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgLy8gc2V0XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmIChvYmouZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGlkSW5Kc29uID0ge307XG5cbiAgICAgICAgdmFyIHVwZGF0ZUVsZXMgPSBmdW5jdGlvbiB1cGRhdGVFbGVzKGpzb25zLCBncikge1xuICAgICAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgICAgIHZhciB0b01vZCA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcbiAgICAgICAgICAgIHZhciBpZCA9ICcnICsganNvbi5kYXRhLmlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgaWRJbkpzb25baWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGVsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICB0b01vZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGU6IGVsZSxcbiAgICAgICAgICAgICAgICBqc29uOiBqc29uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiAoZ3IpIHtcbiAgICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3I7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kuYWRkKHRvQWRkKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b01vZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfdG9Nb2QkX2kgPSB0b01vZFtfaV0sXG4gICAgICAgICAgICAgICAgX2VsZSA9IF90b01vZCRfaS5lbGUsXG4gICAgICAgICAgICAgICAgX2pzb24gPSBfdG9Nb2QkX2kuanNvbjtcblxuICAgICAgICAgICAgX2VsZS5qc29uKF9qc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFycmF5KG9iai5lbGVtZW50cykpIHtcbiAgICAgICAgICAvLyBlbGVtZW50czogW11cbiAgICAgICAgICB1cGRhdGVFbGVzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyID0gZ3JzW2ldO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gb2JqLmVsZW1lbnRzW2dyXTtcblxuICAgICAgICAgICAgaWYgKGFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICB1cGRhdGVFbGVzKGVsZW1lbnRzLCBncik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudHNUb1JlbW92ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bZWxlLmlkKCldO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5tZXJnZShlbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gc28gdGhhdCBjaGlsZHJlbiBhcmUgbm90IHJlbW92ZWQgdy9wYXJlbnRcblxuICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5jaGlsZHJlbigpLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pOyAvLyBpbnRlcm1lZGlhdGUgcGFyZW50cyBtYXkgYmUgbW92ZWQgYnkgcHJpb3IgbGluZSwgc28gbWFrZSBzdXJlIHdlIHJlbW92ZSBieSBmcmVzaCByZWZzXG5cbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBnZXRGcmVzaFJlZihlbGUpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5zdHlsZSkge1xuICAgICAgICBjeS5zdHlsZShvYmouc3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqLnpvb20gIT0gbnVsbCAmJiBvYmouem9vbSAhPT0gX3Auem9vbSkge1xuICAgICAgICBjeS56b29tKG9iai56b29tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5wYW4pIHtcbiAgICAgICAgaWYgKG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSkge1xuICAgICAgICAgIGN5LnBhbihvYmoucGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgICAgY3kuZGF0YShvYmouZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZHMgPSBbJ21pblpvb20nLCAnbWF4Wm9vbScsICd6b29taW5nRW5hYmxlZCcsICd1c2VyWm9vbWluZ0VuYWJsZWQnLCAncGFubmluZ0VuYWJsZWQnLCAndXNlclBhbm5pbmdFbmFibGVkJywgJ2JveFNlbGVjdGlvbkVuYWJsZWQnLCAnYXV0b2xvY2snLCAnYXV0b3VuZ3JhYmlmeScsICdhdXRvdW5zZWxlY3RpZnknXTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmllbGRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbX2kyXTtcblxuICAgICAgICBpZiAob2JqW2ZdICE9IG51bGwpIHtcbiAgICAgICAgICBjeVtmXShvYmpbZl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0XG4gICAgICB2YXIgZmxhdCA9ICEhb2JqO1xuICAgICAgdmFyIGpzb24gPSB7fTtcblxuICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAganNvbi5lbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKS5tYXAoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuanNvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB7fTtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcblxuICAgICAgICAgIGlmICghanNvbi5lbGVtZW50c1tncm91cF0pIHtcbiAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCkge1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG5cbiAgICAgIGpzb24uZGF0YSA9IGNvcHkoY3kuZGF0YSgpKTtcbiAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBfcC56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gX3AudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gX3Auem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IF9wLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBfcC5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IF9wLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBfcC51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGNvcHkoX3AucGFuKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IF9wLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gY29weShvcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XG59KTtcbmNvcmVmbiQ5LiRpZCA9IGNvcmVmbiQ5LmdldEVsZW1lbnRCeUlkO1xuW2NvcmVmbiwgY29yZWZuJDEsIGVsZXNmbiR2LCBjb3JlZm4kMiwgY29yZWZuJDMsIGNvcmVmbiQ0LCBjb3JlZm4kNSwgY29yZWZuJDYsIGNvcmVmbiQ3LCBjb3JlZm4kOCwgZm4kNl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGNvcmVmbiQ5LCBwcm9wcyk7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxudmFyIGRlZmF1bHRzJDkgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsXG4gIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgZ3JpZDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gY3JlYXRlIGFuIGV2ZW4gZ3JpZCBpbnRvIHdoaWNoIHRoZSBEQUcgaXMgcGxhY2VkIChjaXJjbGU6ZmFsc2Ugb25seSlcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSxcbiAgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHJvb3RzOiB1bmRlZmluZWQsXG4gIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gc2hpZnQgbm9kZXMgZG93biB0aGVpciBuYXR1cmFsIEJGUyBkZXB0aHMgaW4gb3JkZXIgdG8gYXZvaWQgdXB3YXJkcyBlZGdlcyAoREFHUyBvbmx5KVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkLFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnKTtcbn07XG5cbnZhciBzZXRJbmZvID0gZnVuY3Rpb24gc2V0SW5mbyhlbGUsIG9iaikge1xuICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcsIG9iaik7XG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDksIG9wdGlvbnMpO1xufVxuXG5CcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gIW4uaXNQYXJlbnQoKTtcbiAgfSk7XG4gIHZhciBncmFwaCA9IGVsZXM7XG4gIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gIHZhciBtYXhpbWFsID0gb3B0aW9ucy5tYXhpbWFsIHx8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzID4gMDsgLy8gbWF4aW1hbEFkanVzdG1lbnRzIGZvciBjb21wYXQuIHcvIG9sZCBjb2RlXG5cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciByb290cztcblxuICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgfSBlbHNlIGlmIChhcnJheShvcHRpb25zLnJvb3RzKSkge1xuICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKHJvb3RzQXJyYXkpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gY3kuJChvcHRpb25zLnJvb3RzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIHJvb3RzID0gbm9kZXMucm9vdHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBlbGVzLmNvbXBvbmVudHMoKTtcbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoZmFsc2UpO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdHMgPSByb290cy5hZGQoY29tcFJvb3RzKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb21wb25lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcChfaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuXG4gIHZhciBhZGRUb0RlcHRoID0gZnVuY3Rpb24gYWRkVG9EZXB0aChlbGUsIGQpIHtcbiAgICBpZiAoZGVwdGhzW2RdID09IG51bGwpIHtcbiAgICAgIGRlcHRoc1tkXSA9IFtdO1xuICAgIH1cblxuICAgIHZhciBpID0gZGVwdGhzW2RdLmxlbmd0aDtcbiAgICBkZXB0aHNbZF0ucHVzaChlbGUpO1xuICAgIHNldEluZm8oZWxlLCB7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGRlcHRoOiBkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNoYW5nZURlcHRoID0gZnVuY3Rpb24gY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCkge1xuICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgZGVwdGggPSBfZ2V0SW5mby5kZXB0aCxcbiAgICAgICAgaW5kZXggPSBfZ2V0SW5mby5pbmRleDtcblxuICAgIGRlcHRoc1tkZXB0aF1baW5kZXhdID0gbnVsbDtcbiAgICBhZGRUb0RlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICB9OyAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG5cblxuICBncmFwaC5iZnMoe1xuICAgIHJvb3RzOiByb290cyxcbiAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQobm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoKSB7XG4gICAgICB2YXIgZWxlID0gbm9kZVswXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgYWRkVG9EZXB0aChlbGUsIGRlcHRoKTtcbiAgICAgIGZvdW5kQnlCZnNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0pOyAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuXG4gIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG5cbiAgICBpZiAoZm91bmRCeUJmc1tfZWxlLmlkKCldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JwaGFuTm9kZXMucHVzaChfZWxlKTtcbiAgICB9XG4gIH0gLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuXG5cbiAgdmFyIGFzc2lnbkRlcHRoc0F0ID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzQXQoaSkge1xuICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX2VsZTIgPSBlbGVzW2pdO1xuXG4gICAgICBpZiAoX2VsZTIgPT0gbnVsbCkge1xuICAgICAgICBlbGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgai0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc2V0SW5mbyhfZWxlMiwge1xuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgaW5kZXg6IGpcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXNzaWduRGVwdGhzID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzKCkge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGRlcHRocy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICBhc3NpZ25EZXB0aHNBdChfaTMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYWRqdXN0TWF4aW1hbGx5ID0gZnVuY3Rpb24gYWRqdXN0TWF4aW1hbGx5KGVsZSwgc2hpZnRlZCkge1xuICAgIHZhciBlSW5mbyA9IGdldEluZm8oZWxlKTtcbiAgICB2YXIgaW5jb21lcnMgPSBlbGUuaW5jb21lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgIH0pO1xuICAgIHZhciBtYXhEZXB0aCA9IC0xO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbmNvbWVycy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGluY21yID0gaW5jb21lcnNba107XG4gICAgICB2YXIgaUluZm8gPSBnZXRJbmZvKGluY21yKTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGlJbmZvLmRlcHRoKTtcbiAgICB9XG5cbiAgICBpZiAoZUluZm8uZGVwdGggPD0gbWF4RGVwdGgpIHtcbiAgICAgIGlmIChzaGlmdGVkW2lkXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY2hhbmdlRGVwdGgoZWxlLCBtYXhEZXB0aCArIDEpO1xuICAgICAgc2hpZnRlZFtpZF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyBmb3IgdGhlIGRpcmVjdGVkIGNhc2UsIHRyeSB0byBtYWtlIHRoZSBlZGdlcyBhbGwgZ28gZG93biAoaS5lLiBkZXB0aCBpID0+IGRlcHRoIGkgKyAxKVxuXG5cbiAgaWYgKGRpcmVjdGVkICYmIG1heGltYWwpIHtcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBzaGlmdGVkID0ge307XG5cbiAgICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUobikge1xuICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgcmV0dXJuIFEuc2hpZnQoKTtcbiAgICB9O1xuXG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICB9KTtcblxuICAgIHdoaWxlIChRLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfZWxlMyA9IGRlcXVldWUoKTtcblxuICAgICAgdmFyIGRpZFNoaWZ0ID0gYWRqdXN0TWF4aW1hbGx5KF9lbGUzLCBzaGlmdGVkKTtcblxuICAgICAgaWYgKGRpZFNoaWZ0KSB7XG4gICAgICAgIF9lbGUzLm91dGdvZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5pc05vZGUoKSAmJiBlbGVzLmhhcyhlbCk7XG4gICAgICAgIH0pLmZvckVhY2goZW5xdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGRpZFNoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgIHdhcm4oJ0RldGVjdGVkIGRvdWJsZSBtYXhpbWFsIHNoaWZ0IGZvciBub2RlIGAnICsgX2VsZTMuaWQoKSArICdgLiAgQmFpbGluZyBtYXhpbWFsIGFkanVzdG1lbnQgZHVlIHRvIGN5Y2xlLiAgVXNlIGBvcHRpb25zLm1heGltYWw6IHRydWVgIG9ubHkgb24gREFHcy4nKTtcbiAgICAgICAgYnJlYWs7IC8vIGV4aXQgb24gZmFpbHVyZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzc2lnbkRlcHRocygpOyAvLyBjbGVhciBob2xlc1xuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcblxuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuXG4gIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbX2k0XTtcbiAgICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cbiAgfSAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcblxuXG4gIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcblxuICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0V2VpZ2h0ZWRQZXJjZW50KGVsZSkge1xuICAgIGlmIChjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldKSB7XG4gICAgICByZXR1cm4gY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZWxlRGVwdGggPSBnZXRJbmZvKGVsZSkuZGVwdGg7XG4gICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbmVpZ2hib3JzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tfaTVdO1xuXG4gICAgICBpZiAobmVpZ2hib3IuaXNFZGdlKCkgfHwgbmVpZ2hib3IuaXNQYXJlbnQoKSB8fCAhbm9kZXMuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJmID0gZ2V0SW5mbyhuZWlnaGJvcik7XG4gICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgIHZhciBkZXB0aCA9IGJmLmRlcHRoOyAvLyB1bmFzc2lnbmVkIG5laWdoYm91cnMgc2hvdWxkbid0IGFmZmVjdCB0aGUgb3JkZXJpbmdcblxuICAgICAgaWYgKGluZGV4ID09IG51bGwgfHwgZGVwdGggPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuXG4gICAgICBpZiAoZGVwdGggPCBlbGVEZXB0aCkge1xuICAgICAgICAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgIHBlcmNlbnQgKz0gaW5kZXggLyBuRGVwdGg7XG4gICAgICAgIHNhbXBsZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzYW1wbGVzID0gTWF0aC5tYXgoMSwgc2FtcGxlcyk7XG4gICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuXG4gICAgaWYgKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIHB1dCBsb25lIG5vZGVzIGF0IHRoZSBzdGFydFxuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfVxuXG4gICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSA9IHBlcmNlbnQ7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH07IC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG5cbiAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uIHNvcnRGbihhLCBiKSB7XG4gICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYSk7XG4gICAgdmFyIGJwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYik7XG4gICAgdmFyIGRpZmYgPSBhcGN0IC0gYnBjdDtcblxuICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICByZXR1cm4gYXNjZW5kaW5nKGEuaWQoKSwgYi5pZCgpKTsgLy8gbWFrZSBzdXJlIHNvcnQgZG9lc24ndCBoYXZlIGRvbid0LWNhcmUgY29tcGFyaXNvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICB9OyAvLyBzb3J0IGVhY2ggbGV2ZWwgdG8gbWFrZSBjb25uZWN0ZWQgbm9kZXMgY2xvc2VyXG5cblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZXB0aHMubGVuZ3RoOyBfaTYrKykge1xuICAgIGRlcHRoc1tfaTZdLnNvcnQoc29ydEZuKTtcblxuICAgIGFzc2lnbkRlcHRoc0F0KF9pNik7XG4gIH0gLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0byBhIG5ldyB0b3AtbGV2ZWwgZGVwdGhcblxuXG4gIHZhciBvcnBoYW5EZXB0aCA9IFtdO1xuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG9ycGhhbk5vZGVzLmxlbmd0aDsgX2k3KyspIHtcbiAgICBvcnBoYW5EZXB0aC5wdXNoKG9ycGhhbk5vZGVzW19pN10pO1xuICB9XG5cbiAgZGVwdGhzLnVuc2hpZnQob3JwaGFuRGVwdGgpO1xuICBhc3NpZ25EZXB0aHMoKTtcbiAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGRlcHRocy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KGRlcHRoc1tfaThdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSk7XG4gIH1cblxuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueDEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgbWF4RGVwdGhTaXplID0gZGVwdGhzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBlbGVzKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZWxlcy5sZW5ndGgpO1xuICB9LCAwKTtcblxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGUpIHtcbiAgICB2YXIgX2dldEluZm8yID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgICBkZXB0aCA9IF9nZXRJbmZvMi5kZXB0aCxcbiAgICAgICAgaW5kZXggPSBfZ2V0SW5mbzIuaW5kZXg7XG5cbiAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KGJiLncgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoKTtcbiAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuY2lyY2xlKSB7XG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGVwb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzLmxlbmd0aCA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgIGlmIChkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvc2l0aW9uKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkYSA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLFxuICAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggYW5kIHJhZGl1cyBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgcmFkaXVzOiB1bmRlZmluZWQsXG4gIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIHNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGEsIG9wdGlvbnMpO1xufVxuXG5DaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuXG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSk7XG4gIHZhciByO1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHcgPSBuYmIudztcbiAgICB2YXIgaCA9IG5iYi5oO1xuICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICB9XG5cbiAgaWYgKG51bWJlcihvcHRpb25zLnJhZGl1cykpIHtcbiAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gIH0gZWxzZSBpZiAobm9kZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByID0gMDtcbiAgfSBlbHNlIHtcbiAgICByID0gTWF0aC5taW4oYmIuaCwgYmIudykgLyAyIC0gbWluRGlzdGFuY2U7XG4gIH0gLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcblxuXG4gIGlmIChub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgfVxuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlLCBpKSB7XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgaSAqIGRUaGV0YSAqIChjbG9ja3dpc2UgPyAxIDogLTEpO1xuICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuICAgIHJldHVybiBwb3M7XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJGIgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLFxuICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgZXF1aWRpc3RhbnQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICBtaW5Ob2RlU3BhY2luZzogMTAsXG4gIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmNlbnRyaWM6IGZ1bmN0aW9uIGNvbmNlbnRyaWMobm9kZSkge1xuICAgIC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gIH0sXG4gIGxldmVsV2lkdGg6IGZ1bmN0aW9uIGxldmVsV2lkdGgobm9kZXMpIHtcbiAgICAvLyB0aGUgbGV0aWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICB9LFxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcblxufTtcblxuZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkYiwgb3B0aW9ucyk7XG59XG5cbkNvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG5cbiAgdmFyIG1heE5vZGVTaXplID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB2b2lkIDA7IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuXG4gICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMobm9kZSk7XG4gICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIG5vZGU6IG5vZGVcbiAgICB9KTsgLy8gZm9yIHN0eWxlIG1hcHBpbmdcblxuICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gIH0gLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcblxuXG4gIG5vZGVzLnVwZGF0ZVN0eWxlKCk7IC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcblxuICAgIHZhciBuYmIgPSBfbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuXG4gICAgbWF4Tm9kZVNpemUgPSBNYXRoLm1heChtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oKTtcbiAgfSAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG5cblxuICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0pO1xuICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aChub2Rlcyk7IC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG5cbiAgdmFyIGxldmVscyA9IFtbXV07XG4gIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVZhbHVlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbX2kyXTtcblxuICAgIGlmIChjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUpO1xuXG4gICAgICBpZiAoZGlmZiA+PSBsZXZlbFdpZHRoKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICBsZXZlbHMucHVzaChjdXJyZW50TGV2ZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKHZhbCk7XG4gIH0gLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG5cbiAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICBpZiAoIW9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdDtcbiAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDApO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtaW5EaXN0LCByU3RlcCk7XG4gIH0gLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuXG5cbiAgdmFyIHIgPSAwO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldmVscy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW19pM107XG4gICAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbGV2ZWwubGVuZ3RoIC0gMSk7IC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG5cbiAgICBpZiAobGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3QgKiBtaW5EaXN0IC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gICAgfVxuXG4gICAgbGV2ZWwuciA9IHI7XG4gICAgciArPSBtaW5EaXN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXF1aWRpc3RhbnQpIHtcbiAgICB2YXIgckRlbHRhTWF4ID0gMDtcbiAgICB2YXIgX3IgPSAwO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGV2ZWxzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBfbGV2ZWwgPSBsZXZlbHNbX2k0XTtcbiAgICAgIHZhciByRGVsdGEgPSBfbGV2ZWwuciAtIF9yO1xuICAgICAgckRlbHRhTWF4ID0gTWF0aC5tYXgockRlbHRhTWF4LCByRGVsdGEpO1xuICAgIH1cblxuICAgIF9yID0gMDtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGxldmVscy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgX2xldmVsMiA9IGxldmVsc1tfaTVdO1xuXG4gICAgICBpZiAoX2k1ID09PSAwKSB7XG4gICAgICAgIF9yID0gX2xldmVsMi5yO1xuICAgICAgfVxuXG4gICAgICBfbGV2ZWwyLnIgPSBfcjtcbiAgICAgIF9yICs9IHJEZWx0YU1heDtcbiAgICB9XG4gIH0gLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuXG5cbiAgdmFyIHBvcyA9IHt9OyAvLyBpZCA9PiBwb3NpdGlvblxuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGxldmVscy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9sZXZlbDMgPSBsZXZlbHNbX2k2XTtcbiAgICB2YXIgX2RUaGV0YSA9IF9sZXZlbDMuZFRoZXRhO1xuICAgIHZhciBfcjIgPSBfbGV2ZWwzLnI7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9sZXZlbDMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBfdmFsID0gX2xldmVsM1tqXTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogX2RUaGV0YSAqIGo7XG4gICAgICB2YXIgcCA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyBfcjIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IGNlbnRlci55ICsgX3IyICogTWF0aC5zaW4odGhldGEpXG4gICAgICB9O1xuICAgICAgcG9zW192YWwubm9kZS5pZCgpXSA9IHA7XG4gICAgfVxuICB9IC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuXG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICByZXR1cm4gcG9zW2lkXTtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLypcblRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5odHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZ2VyYXJkb2h1Y2svXG5cbkJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZTpcbmh0dHA6Ly9kbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xNDk4MDQ3XG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xudmFyIERFQlVHO1xuLyoqXG4gKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICovXG5cbnZhciBkZWZhdWx0cyRjID0ge1xuICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30sXG4gIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgLy8gdHJ1ZSA6IEFuaW1hdGUgY29udGludW91c2x5IGFzIHRoZSBsYXlvdXQgaXMgcnVubmluZ1xuICAvLyBmYWxzZSA6IEp1c3Qgc2hvdyB0aGUgZW5kIHJlc3VsdFxuICAvLyAnZW5kJyA6IEFuaW1hdGUgd2l0aCB0aGUgZW5kIHJlc3VsdCwgZnJvbSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgdG8gdGhlIGVuZCBwb3NpdGlvbnNcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRWFzaW5nIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkXG4gIC8vIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZFxuICAvLyBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gVGhlIGxheW91dCBhbmltYXRlcyBvbmx5IGFmdGVyIHRoaXMgbWFueSBtaWxsaXNlY29uZHMgZm9yIGFuaW1hdGU6dHJ1ZVxuICAvLyAocHJldmVudHMgZmxhc2hpbmcgb24gZmFzdCBydW5zKVxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDI1MCxcbiAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZVxuICByZWZyZXNoOiAyMCxcbiAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIFJhbmRvbWl6ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzICh0cnVlKSBvciB1c2UgZXhpc3RpbmcgcG9zaXRpb25zIChmYWxzZSlcbiAgcmFuZG9taXplOiBmYWxzZSxcbiAgLy8gRXh0cmEgc3BhY2luZyBiZXR3ZWVuIGNvbXBvbmVudHMgaW4gbm9uLWNvbXBvdW5kIGdyYXBoc1xuICBjb21wb25lbnRTcGFjaW5nOiA0MCxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gMjA0ODtcbiAgfSxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwOiA0LFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiBpZGVhbEVkZ2VMZW5ndGgoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDEuMixcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDEsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAxMDAwLFxuICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICBpbml0aWFsVGVtcDogMTAwMCxcbiAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgY29vbGluZ0ZhY3RvcjogMC45OSxcbiAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gIG1pblRlbXA6IDEuMFxufTtcbi8qKlxuICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gQ29zZUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkYywgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucy5sYXlvdXQgPSB0aGlzO1xufVxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuXG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBsYXlvdXQgPSB0aGlzO1xuICBsYXlvdXQuc3RvcHBlZCA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICB9IC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuXG5cbiAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICBERUJVRyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgREVCVUcgPSBmYWxzZTtcbiAgfSAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG5cblxuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7IC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcblxuICBpZiAoREVCVUcpIHtcbiAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gIH0gLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuXG5cbiAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8pO1xuICB9XG5cbiAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpOyAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICBjeS5maXQob3B0aW9ucy5wYWRkaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24gbWFpbkxvb3AoaSkge1xuICAgIGlmIChsYXlvdXQuc3RvcHBlZCB8fCBpID49IG9wdGlvbnMubnVtSXRlcikge1xuICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cblxuXG4gICAgc3RlcCQxKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcblxuICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yOyAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICByZWZyZXNoKCk7IC8vIExheW91dCBoYXMgZmluaXNoZWRcblxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICAgIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZ2V0U2NhbGVkUG9zKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbG9vcFJldCA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICB3aGlsZSAobG9vcFJldCAmJiBmIDwgb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBmKys7XG4gICAgICB9XG5cbiAgICAgIGlmICghbG9vcFJldCkge1xuICAgICAgICAvLyBpdCdzIGRvbmVcbiAgICAgICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgICBpZiAobm93IC0gc3RhcnRUaW1lID49IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnJhbWUoKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobG9vcFJldCkge1xuICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICBkb25lKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5cblxuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG4vKipcbiAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICovXG5cblxudmFyIGNyZWF0ZUxheW91dEluZm8gPSBmdW5jdGlvbiBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgLy8gU2hvcnRjdXRcbiAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgbGF5b3V0SW5mbyA9IHtcbiAgICBpc0NvbXBvdW5kOiBjeS5oYXNDb21wb3VuZE5vZGVzKCksXG4gICAgbGF5b3V0Tm9kZXM6IFtdLFxuICAgIGlkVG9JbmRleDoge30sXG4gICAgbm9kZVNpemU6IG5vZGVzLnNpemUoKSxcbiAgICBncmFwaFNldDogW10sXG4gICAgaW5kZXhUb0dyYXBoOiBbXSxcbiAgICBsYXlvdXRFZGdlczogW10sXG4gICAgZWRnZVNpemU6IGVkZ2VzLnNpemUoKSxcbiAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICBjbGllbnRXaWR0aDogY3kud2lkdGgoKSxcbiAgICBjbGllbnRIZWlnaHQ6IGN5LndpZHRoKCksXG4gICAgYm91bmRpbmdCb3g6IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KVxuICB9O1xuICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gIHZhciBpZDJjbXB0SWQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcbiAgICAgIGlkMmNtcHRJZFtub2RlLmlkKCldID0gaTtcbiAgICB9XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdGVtcE5vZGUgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCA9IG4ubG9ja2VkKCk7XG4gICAgdGVtcE5vZGUuaWQgPSBuLmRhdGEoJ2lkJyk7XG4gICAgdGVtcE5vZGUucGFyZW50SWQgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgIHRlbXBOb2RlLmNtcHRJZCA9IGlkMmNtcHRJZFtuLmlkKCldO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuID0gW107XG4gICAgdGVtcE5vZGUucG9zaXRpb25YID0gbi5wb3NpdGlvbigneCcpO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSA9IG4ucG9zaXRpb24oJ3knKTtcbiAgICB0ZW1wTm9kZS5vZmZzZXRYID0gMDtcbiAgICB0ZW1wTm9kZS5vZmZzZXRZID0gMDtcbiAgICB0ZW1wTm9kZS5oZWlnaHQgPSBuYmIudztcbiAgICB0ZW1wTm9kZS53aWR0aCA9IG5iYi5oO1xuICAgIHRlbXBOb2RlLm1heFggPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWluWCA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFJpZ2h0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZFRvcCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7IC8vIGZvcmNlc1xuXG4gICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGZuKG9wdGlvbnMubm9kZVJlcHVsc2lvbikgPyBvcHRpb25zLm5vZGVSZXB1bHNpb24obikgOiBvcHRpb25zLm5vZGVSZXB1bHNpb247IC8vIEFkZCBuZXcgbm9kZVxuXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTsgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuXG4gICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgfSAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG5cblxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcblxuICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIHZhciB0ZW1wR3JhcGggPSBbXTsgLy8gU2Vjb25kIHBhc3MgdG8gYWRkIGNoaWxkIGluZm9ybWF0aW9uIGFuZFxuICAvLyBpbml0aWFsaXplIHF1ZXVlIGZvciBoaWVyYXJjaGljYWwgdHJhdmVyc2FsXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgdmFyIHBfaWQgPSBuLnBhcmVudElkOyAvLyBDaGVjayBpZiBub2RlIG4gaGFzIGEgcGFyZW50IG5vZGVcblxuICAgIGlmIChudWxsICE9IHBfaWQpIHtcbiAgICAgIC8vIEFkZCBub2RlIElkIHRvIHBhcmVudCdzIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcF9pZF1dLmNoaWxkcmVuLnB1c2gobi5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICAgIHRlbXBHcmFwaC5wdXNoKG4uaWQpO1xuICAgIH1cbiAgfSAvLyBBZGQgcm9vdCBncmFwaCB0byBncmFwaFNldFxuXG5cbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7IC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG5cbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlX2l4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTsgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENyZWF0ZSBpbmRleFRvR3JhcGggbWFwXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICB9XG4gIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgdGVtcEVkZ2UuaWQgPSBlLmRhdGEoJ2lkJyk7XG4gICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTsgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcblxuICAgIHZhciBpZGVhbExlbmd0aCA9IGZuKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKSA/IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKGUpIDogb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gICAgdmFyIGVsYXN0aWNpdHkgPSBmbihvcHRpb25zLmVkZ2VFbGFzdGljaXR5KSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkoZSkgOiBvcHRpb25zLmVkZ2VFbGFzdGljaXR5OyAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcblxuICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pOyAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG5cbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCA9IDA7IC8vIFNvdXJjZSBkZXB0aFxuXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcblxuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH0gLy8gVGFyZ2V0IGRlcHRoXG5cblxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH0gLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG5cblxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcbiAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICB9IC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuXG5cbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICpcbiAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKi9cblxuXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uIGZpbmRMQ0Eobm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuXG4gIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlcixcbiAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgfVxufTtcbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG5cblxudmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07IC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG5cbiAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudDogMixcbiAgICAgIGdyYXBoOiBncmFwaEl4XG4gICAgfTtcbiAgfSAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuXG5cbiAgdmFyIGMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZUlkID0gZ3JhcGhbaV07XG4gICAgdmFyIG5vZGVJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuOyAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcblxuICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG5cbiAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgYysrO1xuXG4gICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvdW50OiBjLFxuICAgIGdyYXBoOiBncmFwaEl4XG4gIH07XG59O1xuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cblxuXG5pZiAoZmFsc2UpIHtcbiAgdmFyIHByaW50TGF5b3V0SW5mbztcbn1cbi8qKlxuICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gKi9cblxuXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24gcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KSB7XG4gIHZhciB3aWR0aCA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTsgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG5cbiAgICBpZiAoMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxudmFyIGdldFNjYWxlSW5Cb3VuZHNGbiA9IGZ1bmN0aW9uIGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcykge1xuICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICB2YXIgY29zZUJCID0ge1xuICAgIHgxOiBJbmZpbml0eSxcbiAgICB4MjogLUluZmluaXR5LFxuICAgIHkxOiBJbmZpbml0eSxcbiAgICB5MjogLUluZmluaXR5XG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgIH0pO1xuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gIG5vZGVzLnBvc2l0aW9ucyhnZXRTY2FsZWRQb3MpOyAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuXG4gIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICBsYXlvdXQ6IHRoaXNcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAqL1xuLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuLy8gICBpZiAoREVCVUcpIHtcbi8vICAgICBjb25zb2xlLmRlYnVnKHRleHQpO1xuLy8gICB9XG4vLyB9O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgc3RlcCQxID0gZnVuY3Rpb24gc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zLCBfc3RlcCkge1xuICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcblxuICBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8pOyAvLyBDYWxjdWxhdGUgZ3Jhdml0eSBmb3JjZXNcblxuICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG5cbiAgcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8pOyAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG5cbiAgdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8pO1xufTtcbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICovXG5cblxudmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7IC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgdmFyIG5vZGUxID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuXG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcbiAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJhbmRvbURpc3RhbmNlID0gZnVuY3Rpb24gcmFuZG9tRGlzdGFuY2UobWF4KSB7XG4gIHJldHVybiAtbWF4ICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAqL1xuXG5cbnZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgdmFyIGNtcHRJZDIgPSBub2RlMi5jbXB0SWQ7XG5cbiAgaWYgKGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuXG5cbiAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICB2YXIgbWF4UmFuZERpc3QgPSAxOyAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcbiAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcblxuICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgZGlyZWN0aW9uWCA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgICBkaXJlY3Rpb25ZID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICB9XG5cbiAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcblxuICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgRE8gb3ZlcmxhcC5cIjtcbiAgICAvLyBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMubm9kZU92ZXJsYXAgKiBvdmVybGFwOyAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG4gICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7IC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuXG4gICAgdmFyIGRpc3RhbmNlWCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgdmFyIGRpc3RhbmNlWSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxcik7IC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuXG4gICAgdmFyIGZvcmNlID0gKG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uKSAvIGRpc3RhbmNlU3FyO1xuICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICB9IC8vIEFwcGx5IGZvcmNlXG5cblxuICBpZiAoIW5vZGUxLmlzTG9ja2VkKSB7XG4gICAgbm9kZTEub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gIH1cblxuICBpZiAoIW5vZGUyLmlzTG9ja2VkKSB7XG4gICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG4gIH0gLy8gcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybjtcbn07XG4vKipcbiAqIEBicmllZiAgOiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIG5vZGVzIG92ZXJsYXAgb3Igbm90XG4gKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gKi9cblxuXG52YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG4gIGlmIChkWCA+IDApIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgfVxuXG4gIGlmIChkWSA+IDApIHtcbiAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMi5tYXhZIC0gbm9kZTEubWluWTtcbiAgfVxuXG4gIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAqICAgICAgICAgIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3ggb2YgaXQncyBzb3VyY2UvdGFyZ2V0IG5vZGVcbiAqL1xuXG5cbnZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uIGZpbmRDbGlwcGluZ1BvaW50KG5vZGUsIGRYLCBkWSkge1xuICAvLyBTaG9yY3V0c1xuICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICB2YXIgZGlyU2xvcGUgPSBkWSAvIGRYO1xuICB2YXIgbm9kZVNsb3BlID0gSCAvIFc7IC8vIHZhciBzID0gJ0NvbXB1dGluZyBjbGlwcGluZyBwb2ludCBvZiBub2RlICcgKyBub2RlLmlkICtcbiAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7XG4gIC8vXG4gIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG5cbiAgdmFyIHJlcyA9IHt9OyAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuXG4gIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICByZXMueCA9IFg7IC8vIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcblxuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuXG5cbiAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgIHJlcy54ID0gWDtcbiAgICByZXMueSA9IFkgKyBIIC8gMjsgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuXG5cbiAgaWYgKDAgPCBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICByZXMueCA9IFggKyBXIC8gMjtcbiAgICByZXMueSA9IFkgKyBXICogZFkgLyAyIC8gZFg7IC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuXG5cbiAgaWYgKDAgPiBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICByZXMueCA9IFggLSBXIC8gMjtcbiAgICByZXMueSA9IFkgLSBXICogZFkgLyAyIC8gZFg7IC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcblxuXG4gIGlmICgwIDwgZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICByZXMueCA9IFggKyBIICogZFggLyAyIC8gZFk7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcblxuXG4gIGlmICgwID4gZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICByZXMueCA9IFggLSBIICogZFggLyAyIC8gZFk7XG4gICAgcmVzLnkgPSBZIC0gSCAvIDI7IC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgcmV0dXJuIHJlcztcbn07XG4vKipcbiAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gKi9cblxuXG52YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgIHZhciBlZGdlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgc291cmNlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHRhcmdldCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdOyAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuXG4gICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZOyAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG5cblxuICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCh0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuICAgIHZhciBmb3JjZSA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIGVkZ2UuZWxhc3RpY2l0eTtcblxuICAgIGlmICgwICE9PSBsKSB7XG4gICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBseSAvIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgdmFyIGZvcmNlWSA9IDA7XG4gICAgfSAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuXG5cbiAgICBpZiAoIXNvdXJjZS5pc0xvY2tlZCkge1xuICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0LmlzTG9ja2VkKSB7XG4gICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgfSAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgfVxufTtcbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICovXG5cblxudmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxOyAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7IC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG5cbiAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgdmFyIGNlbnRlclggPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICB2YXIgY2VudGVyWSA9IGxheW91dEluZm8uY2xpZW50V2lkdGggLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgdmFyIHRlbXAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoWzBdXV07XG4gICAgICB2YXIgcGFyZW50ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgfSAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG5cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07IC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcblxuICAgICAgaWYgKG5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgaWYgKGQgPiBkaXN0VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTsgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgfSAvLyBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xuXG5cbnZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbiBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcbiAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG5cbiAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDsgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcblxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlSWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuOyAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG5cbiAgICBpZiAoMCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5pc0xvY2tlZCkge1xuICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTsgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICtcbiAgICAgIC8vICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dOyAvLyBQcm9wYWdhdGUgb2Zmc2V0XG5cbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTsgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcblxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH0gLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcblxuXG4gICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uXG4gKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gKi9cblxuXG52YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24gdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCB8fCBuLmlzTG9ja2VkKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBvciBsb2NrZWQgbm9kZSBwb3NpdGlvblxuICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArXG4gICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcblxuXG4gICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54O1xuICAgIG4ucG9zaXRpb25ZICs9IHRlbXBGb3JjZS55O1xuICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgbi5vZmZzZXRZID0gMDtcbiAgICBuLm1pblggPSBuLnBvc2l0aW9uWCAtIG4ud2lkdGg7XG4gICAgbi5tYXhYID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgIG4ubWluWSA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7XG4gICAgbi5tYXhZID0gbi5wb3NpdGlvblkgKyBuLmhlaWdodDsgLy8gcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuXG4gICAgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG4sIGxheW91dEluZm8pO1xuICB9IC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICBuLndpZHRoID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgbi5oZWlnaHQgPSBuLm1heFkgLSBuLm1pblk7IC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAvLyBzICs9IFwiXFxuV2lkdGg6IFwiICsgbi53aWR0aCArIFwiLCBIZWlnaHQ6IFwiICsgbi5oZWlnaHQ7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gKiAgICAgICAgICBncmVhdGVyIChpbiBtb2R1bG8pIHRoYW4gbWF4LlxuIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgKi9cblxuXG52YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uIGxpbWl0Rm9yY2UoZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAvLyB2YXIgcyA9IFwiTGltaXRpbmcgZm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKS4gTWF4OiBcIiArIG1heDtcbiAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG5cbiAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHg6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgeTogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBmb3JjZVgsXG4gICAgICB5OiBmb3JjZVlcbiAgICB9O1xuICB9IC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgcmV0dXJuIHJlcztcbn07XG4vKipcbiAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZVxuICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAqL1xuXG5cbnZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobm9kZSwgbGF5b3V0SW5mbykge1xuICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG5cbiAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm47XG4gIH0gLy8gR2V0IFBhcmVudCBOb2RlXG5cblxuICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgdmFyIGZsYWcgPSBmYWxzZTsgLy8gTWF4WFxuXG4gIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gIH0gLy8gTWluWFxuXG5cbiAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gIH0gLy8gTWF4WVxuXG5cbiAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICB9IC8vIE1pbllcblxuXG4gIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgfSAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuXG5cbiAgaWYgKGZsYWcpIHtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm4gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKHAsIGxheW91dEluZm8pO1xuICB9IC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgcmV0dXJuO1xufTtcblxudmFyIHNlcGFyYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIHZhciBub2RlcyA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXM7XG4gIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gPSBjb21wb25lbnRzW2NpZF0gfHwgW107XG4gICAgY29tcG9uZW50LnB1c2gobm9kZSk7XG4gIH1cblxuICB2YXIgdG90YWxBID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG5cbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICBjLngyID0gLUluZmluaXR5O1xuICAgIGMueTEgPSBJbmZpbml0eTtcbiAgICBjLnkyID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG4gICAgICBjLngxID0gTWF0aC5taW4oYy54MSwgbi5wb3NpdGlvblggLSBuLndpZHRoIC8gMik7XG4gICAgICBjLngyID0gTWF0aC5tYXgoYy54Miwgbi5wb3NpdGlvblggKyBuLndpZHRoIC8gMik7XG4gICAgICBjLnkxID0gTWF0aC5taW4oYy55MSwgbi5wb3NpdGlvblkgLSBuLmhlaWdodCAvIDIpO1xuICAgICAgYy55MiA9IE1hdGgubWF4KGMueTIsIG4ucG9zaXRpb25ZICsgbi5oZWlnaHQgLyAyKTtcbiAgICB9XG5cbiAgICBjLncgPSBjLngyIC0gYy54MTtcbiAgICBjLmggPSBjLnkyIC0gYy55MTtcbiAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICB9XG5cbiAgY29tcG9uZW50cy5zb3J0KGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIudyAqIGMyLmggLSBjMS53ICogYzEuaDtcbiAgfSk7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICB2YXIgdXNlZFcgPSAwO1xuICB2YXIgcm93SCA9IDA7XG4gIHZhciBtYXhSb3dXID0gTWF0aC5zcXJ0KHRvdGFsQSkgKiBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuID0gY1tqXTtcblxuICAgICAgaWYgKCFuLmlzTG9ja2VkKSB7XG4gICAgICAgIG4ucG9zaXRpb25YICs9IHggLSBjLngxO1xuICAgICAgICBuLnBvc2l0aW9uWSArPSB5IC0gYy55MTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgcm93SCA9IE1hdGgubWF4KHJvd0gsIGMuaCk7XG5cbiAgICBpZiAodXNlZFcgPiBtYXhSb3dXKSB7XG4gICAgICB5ICs9IHJvd0ggKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICB4ID0gMDtcbiAgICAgIHVzZWRXID0gMDtcbiAgICAgIHJvd0ggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRlZmF1bHRzJGQgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIGF2b2lkT3ZlcmxhcFBhZGRpbmc6IDEwLFxuICAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2RlcyB3aGVuIGF2b2lkT3ZlcmxhcDogdHJ1ZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmRlbnNlOiBmYWxzZSxcbiAgLy8gdXNlcyBhbGwgYXZhaWxhYmxlIHNwYWNlIG9uIGZhbHNlLCB1c2VzIG1pbmltYWwgc3BhY2Ugb24gdHJ1ZVxuICByb3dzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiByb3dzIGluIHRoZSBncmlkXG4gIGNvbHM6IHVuZGVmaW5lZCxcbiAgLy8gZm9yY2UgbnVtIG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUpIHt9LFxuICAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxufTtcblxuZnVuY3Rpb24gR3JpZExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkZCwgb3B0aW9ucyk7XG59XG5cbkdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcblxuICBpZiAoYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKSB7XG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxLFxuICAgICAgICB5OiBiYi55MVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgdmFyIHNwbGl0cyA9IE1hdGguc3FydChjZWxscyAqIGJiLmggLyBiYi53KTtcbiAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoc3BsaXRzKTtcbiAgICB2YXIgY29scyA9IE1hdGgucm91bmQoYmIudyAvIGJiLmggKiBzcGxpdHMpO1xuXG4gICAgdmFyIHNtYWxsID0gZnVuY3Rpb24gc21hbGwodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuXG4gICAgICAgIGlmIChtaW4gPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbiBsYXJnZSh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG5cbiAgICAgICAgaWYgKG1heCA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvUm93cyA9IG9wdGlvbnMucm93cztcbiAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1uczsgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcblxuICAgIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbChjZWxscyAvIHJvd3MpO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgICByb3dzID0gTWF0aC5jZWlsKGNlbGxzIC8gY29scyk7XG4gICAgfSAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgIGVsc2UgaWYgKGNvbHMgKiByb3dzID4gY2VsbHMpIHtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTsgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG5cbiAgICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKChsZyAtIDEpICogc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgICB3aGlsZSAoY29scyAqIHJvd3MgPCBjZWxscykge1xuICAgICAgICAgIHZhciBfc20gPSBzbWFsbCgpO1xuXG4gICAgICAgICAgdmFyIF9sZyA9IGxhcmdlKCk7IC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcblxuXG4gICAgICAgICAgaWYgKChfbGcgKyAxKSAqIF9zbSA+PSBjZWxscykge1xuICAgICAgICAgICAgbGFyZ2UoX2xnICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNtYWxsKF9zbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgIHZhciBjZWxsSGVpZ2h0ID0gYmIuaCAvIHJvd3M7XG5cbiAgICBpZiAob3B0aW9ucy5jb25kZW5zZSkge1xuICAgICAgY2VsbFdpZHRoID0gMDtcbiAgICAgIGNlbGxIZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBpZiAocG9zLnggPT0gbnVsbCB8fCBwb3MueSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gZm9yIGJiXG4gICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgIHBvcy55ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYmIgPSBub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBwID0gb3B0aW9ucy5hdm9pZE92ZXJsYXBQYWRkaW5nO1xuICAgICAgICB2YXIgdyA9IG5iYi53ICsgcDtcbiAgICAgICAgdmFyIGggPSBuYmIuaCArIHA7XG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KGNlbGxXaWR0aCwgdyk7XG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heChjZWxsSGVpZ2h0LCBoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgIHZhciB1c2VkID0gZnVuY3Rpb24gdXNlZChyb3csIGNvbCkge1xuICAgICAgcmV0dXJuIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgdXNlID0gZnVuY3Rpb24gdXNlKHJvdywgY29sKSB7XG4gICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgfTsgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cblxuXG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIGNvbCA9IDA7XG5cbiAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbiBtb3ZlVG9OZXh0Q2VsbCgpIHtcbiAgICAgIGNvbCsrO1xuXG4gICAgICBpZiAoY29sID49IGNvbHMpIHtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTsgLy8gZ2V0IGEgY2FjaGUgb2YgYWxsIHRoZSBtYW51YWwgcG9zaXRpb25zXG5cblxuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgIHZhciByY1BvcyA9IG9wdGlvbnMucG9zaXRpb24oX25vZGUpO1xuXG4gICAgICBpZiAocmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgX3BvcyA9IHtcbiAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfcG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgX3Bvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgX3Bvcy5jb2wrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX3Bvcy5yb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgIF9wb3Mucm93ID0gMDtcblxuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWQybWFuUG9zW19ub2RlLmlkKCldID0gX3BvcztcbiAgICAgICAgdXNlKF9wb3Mucm93LCBfcG9zLmNvbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGVtZW50LCBpKSB7XG4gICAgICB2YXIgeCwgeTtcblxuICAgICAgaWYgKGVsZW1lbnQubG9ja2VkKCkgfHwgZWxlbWVudC5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG5cblxuICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zW2VsZW1lbnQuaWQoKV07XG5cbiAgICAgIGlmIChyY1Bvcykge1xuICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgd2hpbGUgKHVzZWQocm93LCBjb2wpKSB7XG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgdXNlKHJvdywgY29sKTtcbiAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRlID0ge1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3BcblxufTsgLy8gY29uc3RydWN0b3Jcbi8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuXG5mdW5jdGlvbiBOdWxsTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyRlLCBvcHRpb25zKTtcbn0gLy8gcnVucyB0aGUgbGF5b3V0XG5cblxuTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcblxuICB2YXIgbGF5b3V0ID0gdGhpczsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAvLyAoZGlzYWJsZSBlc2xpbnQgZm9yIG5leHQgbGluZSBhcyB0aGlzIHNlcnZlcyBhcyBleGFtcGxlIGxheW91dCBjb2RlIHRvIGV4dGVybmFsIGRldmVsb3BlcnMpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdGFydCcpOyAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgLy8gbi5iLiBtb3N0IGxheW91dHMgd291bGQgdXNlIGxheW91dFBvc2l0aW9ucygpLCBpbnN0ZWFkIG9mIHBvc2l0aW9ucygpIGFuZCBtYW51YWwgZXZlbnRzXG5cbiAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSk7IC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcblxuICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0cmVhZHknKTsgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcblxuICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59OyAvLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcblxuXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRmID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCxcbiAgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLFxuICAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLFxuICAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyBvbiBmaXRcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbn07XG5cbmZ1bmN0aW9uIFByZXNldExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkZiwgb3B0aW9ucyk7XG59XG5cblByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBvc0lzRm4gPSBmbihvcHRpb25zLnBvc2l0aW9ucyk7XG5cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgIGlmIChvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29weVBvc2l0aW9uKG5vZGUucG9zaXRpb24oKSk7XG4gICAgfVxuXG4gICAgaWYgKHBvc0lzRm4pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyhub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJGcgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIGZpdCBwYWRkaW5nXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbn07XG5cbmZ1bmN0aW9uIFJhbmRvbUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkZywgb3B0aW9ucyk7XG59XG5cblJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhub2RlLCBpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIudyksXG4gICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLmgpXG4gICAgfTtcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgbGF5b3V0ID0gW3tcbiAgbmFtZTogJ2JyZWFkdGhmaXJzdCcsXG4gIGltcGw6IEJyZWFkdGhGaXJzdExheW91dFxufSwge1xuICBuYW1lOiAnY2lyY2xlJyxcbiAgaW1wbDogQ2lyY2xlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdjb25jZW50cmljJyxcbiAgaW1wbDogQ29uY2VudHJpY0xheW91dFxufSwge1xuICBuYW1lOiAnY29zZScsXG4gIGltcGw6IENvc2VMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2dyaWQnLFxuICBpbXBsOiBHcmlkTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdudWxsJyxcbiAgaW1wbDogTnVsbExheW91dFxufSwge1xuICBuYW1lOiAncHJlc2V0JyxcbiAgaW1wbDogUHJlc2V0TGF5b3V0XG59LCB7XG4gIG5hbWU6ICdyYW5kb20nLFxuICBpbXBsOiBSYW5kb21MYXlvdXRcbn1dO1xuXG5mdW5jdGlvbiBOdWxsUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAwOyAvLyBmb3IgdGVzdGluZ1xufVxuXG52YXIgbm9vcCQxID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgdGhyb3dJbWdFcnIgPSBmdW5jdGlvbiB0aHJvd0ltZ0VycigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdBIGhlYWRsZXNzIGluc3RhbmNlIGNhbiBub3QgcmVuZGVyIGltYWdlcycpO1xufTtcblxuTnVsbFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBub29wJDEsXG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucysrO1xuICB9LFxuICBpbml0OiBub29wJDEsXG4gIGlzSGVhZGxlc3M6IGZ1bmN0aW9uIGlzSGVhZGxlc3MoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBuZzogdGhyb3dJbWdFcnIsXG4gIGpwZzogdGhyb3dJbWdFcnJcbn07XG5cbnZhciBCUnAgPSB7fTtcbkJScC5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5cbkJScC5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyb3dTaGFwZXMgPSB0aGlzLmFycm93U2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7IC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24gYmJDb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgdmFyIHgxID0gdHJhbnNsYXRpb24ueCAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgIHZhciB5MSA9IHRyYW5zbGF0aW9uLnkgLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gdHJhbnNsYXRpb24ueSArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgaW5zaWRlID0geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICByZXR1cm4gaW5zaWRlO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHlSb3RhdGVkID0geCAqIE1hdGguc2luKGFuZ2xlKSArIHkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHhTY2FsZWQgPSB4Um90YXRlZCAqIHNpemU7XG4gICAgdmFyIHlTY2FsZWQgPSB5Um90YXRlZCAqIHNpemU7XG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocHRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwdHNbaV07XG4gICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgICByZXRQdHMucHVzaCh0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFB0cztcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiBwb2ludHNUb0FycihwdHMpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwdHNbaV07XG4gICAgICByZXQucHVzaChwLngsIHAueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgc3RhbmRhcmRHYXAgPSBmdW5jdGlvbiBzdGFuZGFyZEdhcChlZGdlKSB7XG4gICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS5wZlZhbHVlICogMjtcbiAgfTtcblxuICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uIGRlZmluZUFycm93U2hhcGUobmFtZSwgZGVmbikge1xuICAgIGlmIChzdHJpbmcoZGVmbikpIHtcbiAgICAgIGRlZm4gPSBhcnJvd1NoYXBlc1tkZWZuXTtcbiAgICB9XG5cbiAgICBhcnJvd1NoYXBlc1tuYW1lXSA9IGV4dGVuZCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAuMTUsIC0wLjMsIDAuMTUsIDAuMywgLTAuMTUsIDAuM10sXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZykge1xuICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCgncG9seWdvbicpKGNvbnRleHQsIHBvaW50cyk7XG4gICAgICB9LFxuICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIGdhcDogc3RhbmRhcmRHYXBcbiAgICB9LCBkZWZuKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCdub25lJywge1xuICAgIGNvbGxpZGU6IGZhbHNpZnksXG4gICAgcm91Z2hDb2xsaWRlOiBmYWxzaWZ5LFxuICAgIGRyYXc6IG5vb3AsXG4gICAgc3BhY2luZzogemVyb2lmeSxcbiAgICBnYXA6IHplcm9pZnlcbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnYXJyb3cnLCAndHJpYW5nbGUnKTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgIHBvaW50czogYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuICAgIGNvbnRyb2xQb2ludDogWzAsIC0wLjE1XSxcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyk7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjg7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBwb2ludHNUZWU6IFstMC4xNSwgLTAuNCwgLTAuMTUsIC0wLjUsIDAuMTUsIC0wLjUsIDAuMTUsIC0wLjRdLFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRlZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgIGJhc2VDcm9zc0xpbmVQdHM6IFstMC4xNSwgLTAuNCwgLy8gZmlyc3QgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgLTAuMTUsIC0wLjQsIDAuMTUsIC0wLjQsIC8vIHNlY29uZCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAwLjE1LCAtMC40XSxcbiAgICBjcm9zc0xpbmVQdHM6IGZ1bmN0aW9uIGNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpIHtcbiAgICAgIC8vIHNoaWZ0IHBvaW50cyBzbyB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjcm9zcyBwb2ludHMgbWF0Y2hlcyBlZGdlIHdpZHRoXG4gICAgICB2YXIgcCA9IHRoaXMuYmFzZUNyb3NzTGluZVB0cy5zbGljZSgpO1xuICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gZWRnZVdpZHRoIC8gc2l6ZTtcbiAgICAgIHZhciB5MCA9IDM7XG4gICAgICB2YXIgeTEgPSA1O1xuICAgICAgcFt5MF0gPSBwW3kwXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcFt5MV0gPSBwW3kxXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzKTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd2ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjMsIDAsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjUyNTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgfSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RlZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMCwgLTAuMTUsIC0wLjEsIDAuMTUsIC0wLjEsIDAuMTUsIDBdLFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAuMDAsIDAuMTUsIDAuMDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMTUsIDAsIC0wLjMsIDAuMTUsIC0wLjE1LCAwLCAwXSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NoZXZyb24nLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgLTAuMTUsIC0wLjE1LCAtMC4xLCAtMC4yLCAwLCAtMC4xLCAwLjEsIC0wLjIsIDAuMTUsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMC45NSAqIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIEJScCQxID0ge307IC8vIFByb2plY3QgbW91c2VcblxuQlJwJDEucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciB4ID0gKChjbGllbnRYIC0gb2Zmc2V0TGVmdCkgLyBzY2FsZSAtIHBhbi54KSAvIHpvb207XG4gIHZhciB5ID0gKChjbGllbnRZIC0gb2Zmc2V0VG9wKSAvIHNjYWxlIC0gcGFuLnkpIC8gem9vbTtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbkJScCQxLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbnRhaW5lckJCKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkI7XG4gIH1cblxuICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc3R5bGUgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG5cbiAgdmFyIHN0eWxlVmFsdWUgPSBmdW5jdGlvbiBzdHlsZVZhbHVlKG5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgfTtcblxuICB2YXIgcGFkZGluZyA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgncGFkZGluZy1yaWdodCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJylcbiAgfTtcbiAgdmFyIGJvcmRlciA9IHtcbiAgICBsZWZ0OiBzdHlsZVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdib3JkZXItcmlnaHQtd2lkdGgnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICBib3R0b206IHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICB9O1xuICB2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gIHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICB2YXIgcGFkZGluZ0hvciA9IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gIHZhciBwYWRkaW5nVmVyID0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgdmFyIGJvcmRlckhvciA9IGJvcmRlci5sZWZ0ICsgYm9yZGVyLnJpZ2h0O1xuICB2YXIgc2NhbGUgPSByZWN0LndpZHRoIC8gKGNsaWVudFdpZHRoICsgYm9yZGVySG9yKTtcbiAgdmFyIHVuc2NhbGVkVyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0hvcjtcbiAgdmFyIHVuc2NhbGVkSCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdWZXI7XG4gIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgcGFkZGluZy5sZWZ0ICsgYm9yZGVyLmxlZnQ7XG4gIHZhciB0b3AgPSByZWN0LnRvcCArIHBhZGRpbmcudG9wICsgYm9yZGVyLnRvcDtcbiAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkIgPSBbbGVmdCwgdG9wLCB1bnNjYWxlZFcsIHVuc2NhbGVkSCwgc2NhbGVdO1xufTtcblxuQlJwJDEuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRhaW5lckJCID0gbnVsbDtcbn07XG5cbkJScCQxLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICByZXR1cm4gdGhpcy5maW5kTmVhcmVzdEVsZW1lbnRzKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKVswXTtcbn07XG5cbkJScCQxLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG5cbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IHIuY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjQgOiA4KSAvIHpvb207XG4gIHZhciBub2RlVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbGFiZWxUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBtaW5TcURpc3QgPSBJbmZpbml0eTtcbiAgdmFyIG5lYXJFZGdlO1xuICB2YXIgbmVhck5vZGU7XG5cbiAgaWYgKGludGVyYWN0aXZlRWxlbWVudHNPbmx5KSB7XG4gICAgZWxlcyA9IGVsZXMuaW50ZXJhY3RpdmU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFbGUoZWxlLCBzcURpc3QpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBpZiAobmVhck5vZGUpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCByZXBsYWNlIG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXJOb2RlID0gZWxlO1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzRWRnZSgpICYmIChzcURpc3QgPT0gbnVsbCB8fCBzcURpc3QgPCBtaW5TcURpc3QpKSB7XG4gICAgICBpZiAobmVhckVkZ2UpIHtcbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGV4aXN0aW5nIGVkZ2VcbiAgICAgICAgLy8gY2FuIHJlcGxhY2Ugb25seSBpZiBzYW1lIHotaW5kZXhcbiAgICAgICAgaWYgKG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgJiYgbmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVhci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lYXJbaV0uaXNFZGdlKCkpIHtcbiAgICAgICAgICAgICAgbmVhcltpXSA9IGVsZTtcbiAgICAgICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUpIHtcbiAgICB2YXIgd2lkdGggPSBub2RlLm91dGVyV2lkdGgoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBoZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgaWYgKHBvcy54IC0gaHcgPD0geCAmJiB4IDw9IHBvcy54ICsgaHcgLy8gYmIgY2hlY2sgeFxuICAgICYmIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICkge1xuICAgICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbc2VsZi5nZXROb2RlU2hhcGUobm9kZSldO1xuXG4gICAgICAgIGlmIChzaGFwZS5jaGVja1BvaW50KHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSkpIHtcbiAgICAgICAgICBhZGRFbGUobm9kZSwgMCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKSB7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgc3R5bGVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcblxuICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3FEaXN0O1xuXG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGlmIChpbkJlemllclZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBlZGdlIGJ1dCBkaWRuJ3QgaGl0IGl0LCBtYXliZSB3ZSBoaXQgaXRzIGFycm93c1xuXG5cbiAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcbiAgICB2YXIgYXJTaXplID0gc2VsZi5nZXRBcnJvd1dpZHRoKHN0eWxlV2lkdGgsIHNjYWxlKTtcbiAgICB2YXIgYXJyb3dzID0gW3tcbiAgICAgIG5hbWU6ICdzb3VyY2UnLFxuICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICB5OiBycy5hcnJvd1N0YXJ0WSxcbiAgICAgIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICB5OiBycy5hcnJvd0VuZFksXG4gICAgICBhbmdsZTogcnMudGd0QXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaWQtc291cmNlJyxcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZLFxuICAgICAgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXRhcmdldCcsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlXG4gICAgfV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyID0gYXJyb3dzW2ldO1xuICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1tlZGdlLnBzdHlsZShhci5uYW1lICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlXTtcbiAgICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuXG4gICAgICBpZiAoc2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgeDogYXIueCxcbiAgICAgICAgeTogYXIueVxuICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSAmJiBzaGFwZS5jb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgeDogYXIueCxcbiAgICAgICAgeTogYXIueVxuICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSkge1xuICAgICAgICBhZGRFbGUoZWRnZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG5cblxuICAgIGlmIChoYXNDb21wb3VuZHMgJiYgbmVhci5sZW5ndGggPiAwKSB7XG4gICAgICBjaGVja05vZGUoc3JjKTtcbiAgICAgIGNoZWNrTm9kZSh0Z3QpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXByb3Aob2JqLCBuYW1lLCBwcmUpIHtcbiAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIG5hbWUsIHByZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0xhYmVsKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciB0aCA9IGxhYmVsVGhyZXNob2xkO1xuICAgIHZhciBwcmVmaXhEYXNoO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4RGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciBiYiA9IF9wLmxhYmVsQm91bmRzW3ByZWZpeCB8fCAnbWFpbiddO1xuICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykudmFsdWU7XG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSBlbGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcblxuICAgIGlmICghZXZlbnRzRW5hYmxlZCB8fCAhdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIGx4ID0gcHJlcHJvcChyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBseSA9IHByZXByb3AocnN0eWxlLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgdGhldGEgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gICAgdmFyIGx4MSA9IGJiLngxIC0gdGg7XG4gICAgdmFyIGx4MiA9IGJiLngyICsgdGg7XG4gICAgdmFyIGx5MSA9IGJiLnkxIC0gdGg7XG4gICAgdmFyIGx5MiA9IGJiLnkyICsgdGg7XG5cbiAgICBpZiAodGhldGEpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICB2YXIgcG9pbnRzID0gW3B4MXkxLngsIHB4MXkxLnksIHB4MnkxLngsIHB4MnkxLnksIHB4MnkyLngsIHB4MnkyLnksIHB4MXkyLngsIHB4MXkyLnldO1xuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyBhIGNoZWFwZXIgYmIgY2hlY2tcbiAgICAgIGlmIChpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjaGVja05vZGUoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gZWRnZVxuICAgICAgY2hlY2tFZGdlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpIHx8IGNoZWNrTGFiZWwoZWxlLCAnc291cmNlJykgfHwgY2hlY2tMYWJlbChlbGUsICd0YXJnZXQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcjtcbn07IC8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcblxuXG5CUnAkMS5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5pbnRlcmFjdGl2ZTtcbiAgdmFyIGJveCA9IFtdO1xuICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTtcbiAgeDEgPSB4MWM7XG4gIHgyID0geDJjO1xuICB5MSA9IHkxYztcbiAgeTIgPSB5MmM7XG4gIHZhciBib3hCYiA9IG1ha2VCb3VuZGluZ0JveCh7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4MjogeDIsXG4gICAgeTI6IHkyXG4gIH0pO1xuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChib3hCYiwgbm9kZUJiKSAmJiAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KG5vZGVCYiwgYm94QmIpKSB7XG4gICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgIHZhciBwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzIHx8IF9wLnJzdHlsZS5saW5lUHRzIHx8IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXBvaW50SW5Cb3VuZGluZ0JveChib3hCYiwgcHRzW2ldKSkge1xuICAgICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxsSW5zaWRlKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJveDtcbn07XG5cbnZhciBCUnAkMiA9IHt9O1xuXG5CUnAkMi5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG4gIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7IC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcblxuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG5cbiAgbWlkWCA9IHJzLm1pZFg7XG4gIG1pZFkgPSBycy5taWRZOyAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEpO1xuICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICB9XG5cbiAgcnMuc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTsgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gIGlmIChpc0hheXN0YWNrKSB7XG4gICAgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7XG4gICAgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7XG4gIH1cblxuICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICB2YXIgYnAweCwgYnAweTtcbiAgICB2YXIgYnAxeCwgYnAxeTtcblxuICAgIGlmIChjcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgcDAgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIHN0YXJ0cHRcblxuICAgICAgdmFyIGljID0gcDAgKyAyO1xuICAgICAgdmFyIHAxID0gaWMgKyAyO1xuICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjApO1xuICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjApO1xuICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEpO1xuICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjAwMDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWMgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIGN0cnB0XG5cbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuXG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5KTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC40OTk5KTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC41KTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC41KTtcbiAgICB9XG5cbiAgICBkaXNwWCA9IGJwMXggLSBicDB4O1xuICAgIGRpc3BZID0gYnAxeSAtIGJwMHk7XG4gIH1cblxuICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZOyAvLyBtaWQgc291cmNlXG4gIC8vXG5cbiAgZGlzcFggKj0gLTE7XG4gIGRpc3BZICo9IC0xO1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIDsgZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IC0ocHRzW2kzXSAtIHB0c1tpMl0pO1xuICAgICAgZGlzcFkgPSAtKHB0c1tpMyArIDFdIC0gcHRzW2kyICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIHRhcmdldFxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzW2wgLSA2XSwgcHRzW2wgLSA0XSwgcHRzW2wgLSAyXSwgMC45KTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzW2wgLSA1XSwgcHRzW2wgLSAzXSwgcHRzW2wgLSAxXSwgMC45KTtcbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cblxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xufTtcblxuQlJwJDIuZ2V0QXJyb3dXaWR0aCA9IEJScCQyLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24gKGVkZ2VXaWR0aCwgc2NhbGUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV07XG5cbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cblxuICBjYWNoZWRWYWwgPSBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpICogc2NhbGU7XG4gIGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV0gPSBjYWNoZWRWYWw7XG4gIHJldHVybiBjYWNoZWRWYWw7XG59O1xuXG52YXIgQlJwJDMgPSB7fTtcblxuQlJwJDMuZmluZEhheXN0YWNrUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICBpZiAoIXJzLmhheXN0YWNrKSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy5zb3VyY2UgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgICAgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy50YXJnZXQgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gZWRnZS5wc3R5bGUoJ2hheXN0YWNrLXJhZGl1cycpLnZhbHVlO1xuICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW3JzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueCwgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LCBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueV07XG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pIC8gMjtcbiAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyOyAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuXG4gICAgcnMuZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgIHJzLmhheXN0YWNrID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoZWRnZSk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoZWRnZSk7XG4gIH1cbn07XG5cbkJScCQzLmZpbmRTZWdtZW50c1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBTZWdtZW50cyAobXVsdGlwbGUgc3RyYWlnaHQgbGluZXMpXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMsXG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICB2YXIgc2VnbWVudFdzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtd2VpZ2h0cycpO1xuICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgcnMuc2VncHRzID0gW107XG5cbiAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKykge1xuICAgIHZhciB3ID0gc2VnbWVudFdzLnBmVmFsdWVbc107XG4gICAgdmFyIGQgPSBzZWdtZW50RHMucGZWYWx1ZVtzXTtcbiAgICB2YXIgdzEgPSAxIC0gdztcbiAgICB2YXIgdzIgPSB3O1xuICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLnNlZ3B0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZCk7XG4gIH1cbn07XG5cbkJScCQzLmZpbmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gU2VsZi1lZGdlXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBkaXJDb3VudHMgPSBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3M7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGxvb3BEaXIgPSBlZGdlLnBzdHlsZSgnbG9vcC1kaXJlY3Rpb24nKS5wZlZhbHVlO1xuICB2YXIgbG9vcFN3cCA9IGVkZ2UucHN0eWxlKCdsb29wLXN3ZWVwJykucGZWYWx1ZTtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuXG4gIHZhciBsb29wQW5nbGUgPSBsb29wRGlyIC0gTWF0aC5QSSAvIDI7XG4gIHZhciBvdXRBbmdsZSA9IGxvb3BBbmdsZSAtIGxvb3BTd3AgLyAyO1xuICB2YXIgaW5BbmdsZSA9IGxvb3BBbmdsZSArIGxvb3BTd3AgLyAyOyAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuXG4gIHZhciBkYyA9IFN0cmluZyhsb29wRGlyICsgJ18nICsgbG9vcFN3cCk7XG4gIGogPSBkaXJDb3VudHNbZGNdID09PSB1bmRlZmluZWQgPyBkaXJDb3VudHNbZGNdID0gMCA6ICsrZGlyQ291bnRzW2RjXTtcbiAgcnMuY3RybHB0cyA9IFtzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4ob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnggKyBNYXRoLmNvcyhpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXTtcbn07XG5cbkJScCQzLmZpbmRDb21wb3VuZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAvLyBDb21wb3VuZCBlZGdlXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcbiAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuXG4gIHZhciBsb29wVyA9IDUwO1xuICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgeDogc3JjUG9zLnggLSBzcmNXIC8gMixcbiAgICB5OiBzcmNQb3MueSAtIHNyY0ggLyAyXG4gIH07XG4gIHZhciBsb29wYlBvcyA9IHtcbiAgICB4OiB0Z3RQb3MueCAtIHRndFcgLyAyLFxuICAgIHk6IHRndFBvcy55IC0gdGd0SCAvIDJcbiAgfTtcbiAgdmFyIGxvb3BQb3MgPSB7XG4gICAgeDogTWF0aC5taW4obG9vcGFQb3MueCwgbG9vcGJQb3MueCksXG4gICAgeTogTWF0aC5taW4obG9vcGFQb3MueSwgbG9vcGJQb3MueSlcbiAgfTsgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG5cbiAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDAuNTtcbiAgdmFyIGNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHNyY1cgKiAwLjAxKSk7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkpO1xuICBycy5jdHJscHRzID0gW2xvb3BQb3MueCwgbG9vcFBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsIGxvb3BQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLCBsb29wUG9zLnldO1xufTtcblxuQlJwJDMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIC8vIFN0cmFpZ2h0IGVkZ2Ugd2l0aGluIGJ1bmRsZVxuICBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0Jztcbn07XG5cbkJScCQzLmZpbmRCZXppZXJQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSxcbiAgICAgIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICAgIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cztcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXdlaWdodHMnKTtcbiAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKGN0cmxwdERpc3RzLnZhbHVlLmxlbmd0aCwgY3RybHB0V3MudmFsdWUubGVuZ3RoKSA6IDE7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07IC8vIChNdWx0aSliZXppZXJcblxuICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG4gIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gIHJzLmN0cmxwdHMgPSBbXTtcblxuICBmb3IgKHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKykge1xuICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplICogKGVkZ2VJc1N3YXBwZWQgPyAtMSA6IDEpO1xuICAgIHZhciBtYW5jdHJscHREaXN0ID0gdm9pZCAwO1xuICAgIHZhciBzaWduID0gc2lnbnVtKG5vcm1jdHJscHREaXN0KTtcblxuICAgIGlmIChtdWx0aSkge1xuICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG5cbiAgICAgIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlW2JdO1xuICAgIH1cblxuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciBtaWRwdFB0cyA9IGVkZ2VEaXN0YW5jZXMgPT09ICdub2RlLXBvc2l0aW9uJyA/IHBvc1B0cyA6IGludGVyc2VjdGlvblB0cztcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLmN0cmxwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gIH1cbn07XG5cbkJScCQzLmZpbmRUYXhpUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFRheGljYWIgZ2VvbWV0cnkgd2l0aCB0d28gdHVybnMgbWF4aW11bVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG4gIHZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xuICB2YXIgTEVGVFdBUkQgPSAnbGVmdHdhcmQnO1xuICB2YXIgUklHSFRXQVJEID0gJ3JpZ2h0d2FyZCc7XG4gIHZhciBET1dOV0FSRCA9ICdkb3dud2FyZCc7XG4gIHZhciBVUFdBUkQgPSAndXB3YXJkJztcbiAgdmFyIEFVVE8gPSAnYXV0byc7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIGRJbmNsdWRlc05vZGVCb2R5ID0gZWRnZURpc3RhbmNlcyAhPT0gJ25vZGUtcG9zaXRpb24nO1xuICB2YXIgdGF4aURpciA9IGVkZ2UucHN0eWxlKCd0YXhpLWRpcmVjdGlvbicpLnZhbHVlO1xuICB2YXIgcmF3VGF4aURpciA9IHRheGlEaXI7IC8vIHVucHJvY2Vzc2VkIHZhbHVlXG5cbiAgdmFyIHRheGlUdXJuID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybicpO1xuICB2YXIgdGF4aVR1cm5QZlZhbCA9IHRheGlUdXJuLnBmVmFsdWU7XG4gIHZhciBtaW5EID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybi1taW4tZGlzdGFuY2UnKS5wZlZhbHVlO1xuICB2YXIgdHVybklzUGVyY2VudCA9IHRheGlUdXJuLnVuaXRzID09PSAnJSc7XG4gIHZhciBkdyA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY1cgKyB0Z3RXKSAvIDIgOiAwO1xuICB2YXIgZGggPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNIICsgdGd0SCkgLyAyIDogMDtcbiAgdmFyIHBkeCA9IHBvc1B0cy54MiAtIHBvc1B0cy54MTtcbiAgdmFyIHBkeSA9IHBvc1B0cy55MiAtIHBvc1B0cy55MTsgLy8gdGFrZSBhd2F5IHRoZSBlZmZlY3RpdmUgdy9oIGZyb20gdGhlIG1hZ25pdHVkZSBvZiB0aGUgZGVsdGEgdmFsdWVcblxuICB2YXIgc3ViRFdIID0gZnVuY3Rpb24gc3ViRFdIKGR4eSwgZHdoKSB7XG4gICAgaWYgKGR4eSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkeHkgLSBkd2gsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZHh5ICsgZHdoLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGR4ID0gc3ViRFdIKHBkeCwgZHcpO1xuICB2YXIgZHkgPSBzdWJEV0gocGR5LCBkaCk7XG4gIHZhciBpc0V4cGxpY2l0RGlyID0gZmFsc2U7XG5cbiAgaWYgKHRheGlEaXIgPT09IEFVVE8pIHtcbiAgICB0YXhpRGlyID0gTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpID8gSE9SSVpPTlRBTCA6IFZFUlRJQ0FMO1xuICB9IGVsc2UgaWYgKHRheGlEaXIgPT09IFVQV0FSRCB8fCB0YXhpRGlyID09PSBET1dOV0FSRCkge1xuICAgIHRheGlEaXIgPSBWRVJUSUNBTDtcbiAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0YXhpRGlyID09PSBMRUZUV0FSRCB8fCB0YXhpRGlyID09PSBSSUdIVFdBUkQpIHtcbiAgICB0YXhpRGlyID0gSE9SSVpPTlRBTDtcbiAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc1ZlcnQgPSB0YXhpRGlyID09PSBWRVJUSUNBTDtcbiAgdmFyIGwgPSBpc1ZlcnQgPyBkeSA6IGR4O1xuICB2YXIgcGwgPSBpc1ZlcnQgPyBwZHkgOiBwZHg7XG4gIHZhciBzZ25MID0gc2lnbnVtKHBsKTtcbiAgdmFyIGZvcmNlZERpciA9IGZhbHNlO1xuXG4gIGlmICghKGlzRXhwbGljaXREaXIgJiYgdHVybklzUGVyY2VudCkgLy8gZm9yY2luZyBpbiB0aGlzIGNhc2Ugd291bGQgY2F1c2Ugd2VpcmQgZ3Jvd2luZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICYmIChyYXdUYXhpRGlyID09PSBET1dOV0FSRCAmJiBwbCA8IDAgfHwgcmF3VGF4aURpciA9PT0gVVBXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBMRUZUV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEICYmIHBsIDwgMCkpIHtcbiAgICBzZ25MICo9IC0xO1xuICAgIGwgPSBzZ25MICogTWF0aC5hYnMobCk7XG4gICAgZm9yY2VkRGlyID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBkID0gdHVybklzUGVyY2VudCA/IHRheGlUdXJuUGZWYWwgKiBsIDogdGF4aVR1cm5QZlZhbCAqIHNnbkw7XG5cbiAgdmFyIGdldElzVG9vQ2xvc2UgPSBmdW5jdGlvbiBnZXRJc1Rvb0Nsb3NlKGQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZCkgPCBtaW5EIHx8IE1hdGguYWJzKGQpID49IE1hdGguYWJzKGwpO1xuICB9O1xuXG4gIHZhciBpc1Rvb0Nsb3NlU3JjID0gZ2V0SXNUb29DbG9zZShkKTtcbiAgdmFyIGlzVG9vQ2xvc2VUZ3QgPSBnZXRJc1Rvb0Nsb3NlKGwgLSBkKTtcbiAgdmFyIGlzVG9vQ2xvc2UgPSBpc1Rvb0Nsb3NlU3JjIHx8IGlzVG9vQ2xvc2VUZ3Q7XG5cbiAgaWYgKGlzVG9vQ2xvc2UgJiYgIWZvcmNlZERpcikge1xuICAgIC8vIG5vbi1pZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgLy8gdmVydGljYWwgZmFsbGJhY2tzXG4gICAgICB2YXIgbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY0ggLyAyO1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeCkgPD0gdGd0VyAvIDI7XG5cbiAgICAgIGlmIChsU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIHggPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG4gICAgICAgIHZhciB5MSA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgIHkyID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbeCwgeTEsIHgsIHkyXTtcbiAgICAgIH0gZWxzZSBpZiAobFNoYXBlSW5zaWRlVGd0KSB7XG4gICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB5ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuICAgICAgICB2YXIgeDEgPSBwb3NQdHMueDEsXG4gICAgICAgICAgICB4MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gxLCB5LCB4MiwgeV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlIGZhbGxiYWNrICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIHdpdGggdHJlZSBzaWJsaW5ncylcbiAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MSwgcG9zUHRzLnkyXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbCBmYWxsYmFja3NcbiAgICAgIHZhciBfbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY1cgLyAyO1xuXG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeSkgPD0gdGd0SCAvIDI7XG5cbiAgICAgIGlmIChfbFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpcmVjdGlvbiBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgX3kgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG5cbiAgICAgICAgdmFyIF94ID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgX3gyID0gcG9zUHRzLngyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3gsIF95LCBfeDIsIF95XTtcbiAgICAgIH0gZWxzZSBpZiAoX2xTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyBob3Jpem9udGFsIFotc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF94MyA9IChwb3NQdHMueDEgKyBwb3NQdHMueDIpIC8gMjtcblxuICAgICAgICB2YXIgX3kyID0gcG9zUHRzLnkxLFxuICAgICAgICAgICAgX3kzID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3gzLCBfeTIsIF94MywgX3kzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEwtc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgZm9yIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDIsIHBvc1B0cy55MV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlkZWFsIHJvdXRpbmdcbiAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICB2YXIgX3k0ID0gcG9zUHRzLnkxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY0ggLyAyICogc2duTCA6IDApO1xuXG4gICAgICB2YXIgX3g0ID0gcG9zUHRzLngxLFxuICAgICAgICAgIF94NSA9IHBvc1B0cy54MjtcbiAgICAgIHJzLnNlZ3B0cyA9IFtfeDQsIF95NCwgX3g1LCBfeTRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3Jpem9udGFsXG4gICAgICB2YXIgX3g2ID0gcG9zUHRzLngxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY1cgLyAyICogc2duTCA6IDApO1xuXG4gICAgICB2YXIgX3k1ID0gcG9zUHRzLnkxLFxuICAgICAgICAgIF95NiA9IHBvc1B0cy55MjtcbiAgICAgIHJzLnNlZ3B0cyA9IFtfeDYsIF95NSwgX3g2LCBfeTZdO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoOyAvLyBjYW4gb25seSBjb3JyZWN0IGJlemllcnMgZm9yIG5vdy4uLlxuXG4gIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zLFxuICAgICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICAgIHRndEggPSBwYWlySW5mby50Z3RILFxuICAgICAgICBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlLFxuICAgICAgICB0Z3RTaGFwZSA9IHBhaXJJbmZvLnRndFNoYXBlO1xuICAgIHZhciBiYWRTdGFydCA9ICFudW1iZXIocnMuc3RhcnRYKSB8fCAhbnVtYmVyKHJzLnN0YXJ0WSk7XG4gICAgdmFyIGJhZEFTdGFydCA9ICFudW1iZXIocnMuYXJyb3dTdGFydFgpIHx8ICFudW1iZXIocnMuYXJyb3dTdGFydFkpO1xuICAgIHZhciBiYWRFbmQgPSAhbnVtYmVyKHJzLmVuZFgpIHx8ICFudW1iZXIocnMuZW5kWSk7XG4gICAgdmFyIGJhZEFFbmQgPSAhbnVtYmVyKHJzLmFycm93RW5kWCkgfHwgIW51bWJlcihycy5hcnJvd0VuZFkpO1xuICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xuICAgIHZhciBtaW5DcEFEaXN0ID0gbWluQ3BBRGlzdEZhY3RvciAqIGFycm93VztcbiAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IHJzLnN0YXJ0WCxcbiAgICAgIHk6IHJzLnN0YXJ0WVxuICAgIH0pO1xuICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICB2YXIgZW5kQUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBycy5lbmRYLFxuICAgICAgeTogcnMuZW5kWVxuICAgIH0pO1xuICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICBvdmVybGFwcGluZyA9IHRydWU7IC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcblxuICAgICAgdmFyIGNwRCA9IHtcbiAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gc3JjUG9zLnlcbiAgICAgIH07XG4gICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcblxuICAgICAgdmFyIGNwTSA9IHtcbiAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgIH07XG4gICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICB2YXIgY3BQcm9qID0ge1xuICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCBjcFByb2oueCwgY3BQcm9qLnksIDApO1xuXG4gICAgICBpZiAoY2xvc2VTdGFydEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCkge1xuICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlOyAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG5cbiAgICAgIHZhciBfY3BEID0ge1xuICAgICAgICAvLyBkZWx0YVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSB0Z3RQb3MueVxuICAgICAgfTtcblxuICAgICAgdmFyIF9jcEwgPSBNYXRoLnNxcnQoX2NwRC54ICogX2NwRC54ICsgX2NwRC55ICogX2NwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcblxuXG4gICAgICB2YXIgX2NwTSA9IHtcbiAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICB4OiBfY3BELnggLyBfY3BMLFxuICAgICAgICB5OiBfY3BELnkgLyBfY3BMXG4gICAgICB9O1xuXG4gICAgICB2YXIgX3JhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuXG4gICAgICB2YXIgX2NwUHJvaiA9IHtcbiAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgX2NwTS54ICogMiAqIF9yYWRpdXMsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAyICogX3JhZGl1c1xuICAgICAgfTtcbiAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIF9jcFByb2oueCwgX2NwUHJvai55LCAwKTtcblxuICAgICAgaWYgKGNsb3NlRW5kQUNwKSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgX2NwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHRndEN0cmxQdEludG5bMF0gKyBfY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICBycy5jdHJscHRzWzFdID0gdGd0Q3RybFB0SW50blsxXSArIF9jcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJsYXBwaW5nKSB7XG4gICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgfVxuICB9XG59O1xuXG5CUnAkMy5zdG9yZUFsbHB0cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgaWYgKHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgcnMuYWxscHRzID0gW107XG4gICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgKyAxIDwgcnMuY3RybHB0cy5sZW5ndGg7IGIgKz0gMikge1xuICAgICAgLy8gY3RybCBwdCBpdHNlbGZcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmN0cmxwdHNbYl0sIHJzLmN0cmxwdHNbYiArIDFdKTsgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG5cbiAgICAgIGlmIChiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoKSB7XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKChycy5jdHJscHRzW2JdICsgcnMuY3RybHB0c1tiICsgMl0pIC8gMiwgKHJzLmN0cmxwdHNbYiArIDFdICsgcnMuY3RybHB0c1tiICsgM10pIC8gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG4gICAgdmFyIG0sIG10O1xuXG4gICAgaWYgKHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICBycy5taWRYID0gcnMuYWxscHRzW21dO1xuICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1ttICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICBtdCA9IDAuNTtcbiAgICAgIHJzLm1pZFggPSBxYmV6aWVyQXQocnMuYWxscHRzW21dLCBycy5hbGxwdHNbbSArIDJdLCBycy5hbGxwdHNbbSArIDRdLCBtdCk7XG4gICAgICBycy5taWRZID0gcWJlemllckF0KHJzLmFsbHB0c1ttICsgMV0sIHJzLmFsbHB0c1ttICsgM10sIHJzLmFsbHB0c1ttICsgNV0sIG10KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAvLyBuZWVkIHRvIGNhbGMgdGhlc2UgYWZ0ZXIgZW5kcHRzXG4gICAgcnMuYWxscHRzID0gW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZXTsgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuXG4gICAgcnMubWlkWCA9IChycy5zdGFydFggKyBycy5lbmRYICsgcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFgpIC8gNDtcbiAgICBycy5taWRZID0gKHJzLnN0YXJ0WSArIHJzLmVuZFkgKyBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSkgLyA0O1xuICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgcnMuYWxscHRzID0gW107XG4gICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuICAgIHJzLmFsbHB0cy5wdXNoLmFwcGx5KHJzLmFsbHB0cywgcnMuc2VncHRzKTtcbiAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcblxuICAgIGlmIChycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcnMuc2VncHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBycy5taWRYID0gKHJzLnNlZ3B0c1tpMV0gKyBycy5zZWdwdHNbaTJdKSAvIDI7XG4gICAgICBycy5taWRZID0gKHJzLnNlZ3B0c1tpMSArIDFdICsgcnMuc2VncHRzW2kyICsgMV0pIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9pID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICBycy5taWRYID0gcnMuc2VncHRzW19pXTtcbiAgICAgIHJzLm1pZFkgPSBycy5zZWdwdHNbX2kgKyAxXTtcbiAgICB9XG4gIH1cbn07XG5cbkJScCQzLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICBpZiAocnMubm9kZXNPdmVybGFwIHx8IG51bWJlcihycy5zdGFydFgpICYmIG51bWJlcihycy5zdGFydFkpICYmIG51bWJlcihycy5lbmRYKSAmJiBudW1iZXIocnMuZW5kWSkpIHtcbiAgICBycy5sb2dnZWRFcnIgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXJzLmxvZ2dlZEVycikge1xuICAgICAgcnMubG9nZ2VkRXJyID0gdHJ1ZTtcbiAgICAgIHdhcm4oJ0VkZ2UgYCcgKyBlZGdlLmlkKCkgKyAnYCBoYXMgaW52YWxpZCBlbmRwb2ludHMgYW5kIHNvIGl0IGlzIGltcG9zc2libGUgdG8gZHJhdy4gIEFkanVzdCB5b3VyIGVkZ2Ugc3R5bGUgKGUuZy4gY29udHJvbCBwb2ludHMpIGFjY29yZGluZ2x5IG9yIHVzZSBhbiBhbHRlcm5hdGl2ZSBlZGdlIHR5cGUuICBUaGlzIGlzIGV4cGVjdGVkIGJlaGF2aW91ciB3aGVuIHRoZSBzb3VyY2Ugbm9kZSBhbmQgdGhlIHRhcmdldCBub2RlIG92ZXJsYXAuJyk7XG4gICAgfVxuICB9XG59O1xuXG5CUnAkMy5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAoIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGhhc2hUYWJsZSA9IHtcbiAgICBtYXA6IG5ldyBNYXAkMSgpLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KHBhaXJJZCkge1xuICAgICAgdmFyIG1hcDIgPSB0aGlzLm1hcC5nZXQocGFpcklkWzBdKTtcblxuICAgICAgaWYgKG1hcDIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWFwMi5nZXQocGFpcklkWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocGFpcklkLCB2YWwpIHtcbiAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgIGlmIChtYXAyID09IG51bGwpIHtcbiAgICAgICAgbWFwMiA9IG5ldyBNYXAkMSgpO1xuICAgICAgICB0aGlzLm1hcC5zZXQocGFpcklkWzBdLCBtYXAyKTtcbiAgICAgIH1cblxuICAgICAgbWFwMi5zZXQocGFpcklkWzFdLCB2YWwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTsgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlOyAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuXG4gICAgaWYgKGVkZ2UucmVtb3ZlZCgpIHx8ICFlZGdlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgY3VydmVTdHlsZSA9PT0gJ3RheGknO1xuICAgIHZhciBlZGdlSXNCZXppZXIgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ2Jlemllcic7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNJbmRleCA9IHNyYy5wb29sSW5kZXgoKTtcbiAgICB2YXIgdGd0SW5kZXggPSB0Z3QucG9vbEluZGV4KCk7XG4gICAgdmFyIHBhaXJJZCA9IFtzcmNJbmRleCwgdGd0SW5kZXhdLnNvcnQoKTtcbiAgICB2YXIgdGFibGVFbnRyeSA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcblxuICAgIGlmICh0YWJsZUVudHJ5ID09IG51bGwpIHtcbiAgICAgIHRhYmxlRW50cnkgPSB7XG4gICAgICAgIGVsZXM6IFtdXG4gICAgICB9O1xuICAgICAgaGFzaFRhYmxlLnNldChwYWlySWQsIHRhYmxlRW50cnkpO1xuICAgICAgcGFpcklkcy5wdXNoKHBhaXJJZCk7XG4gICAgfVxuXG4gICAgdGFibGVFbnRyeS5lbGVzLnB1c2goZWRnZSk7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICB0YWJsZUVudHJ5Lmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgdGFibGVFbnRyeS5oYXNCZXppZXIgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuXG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocCkge1xuICAgIHZhciBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgIHZhciBwYWlySW5mbyA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcbiAgICB2YXIgc3dhcHBlZHBhaXJJbmZvID0gdm9pZCAwO1xuXG4gICAgaWYgKCFwYWlySW5mby5oYXNVbmJ1bmRsZWQpIHtcbiAgICAgIHZhciBwbGxFZGdlcyA9IHBhaXJJbmZvLmVsZXNbMF0ucGFyYWxsZWxFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5pc0J1bmRsZWRCZXppZXIoKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYXJBcnJheShwYWlySW5mby5lbGVzKTtcbiAgICAgIHBsbEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJJbmZvLmVsZXMucHVzaChlZGdlKTtcbiAgICAgIH0pOyAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuXG4gICAgICBwYWlySW5mby5lbGVzLnNvcnQoZnVuY3Rpb24gKGVkZ2UxLCBlZGdlMikge1xuICAgICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBmaXJzdEVkZ2UgPSBwYWlySW5mby5lbGVzWzBdO1xuICAgIHZhciBzcmMgPSBmaXJzdEVkZ2Uuc291cmNlKCk7XG4gICAgdmFyIHRndCA9IGZpcnN0RWRnZS50YXJnZXQoKTsgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudCB3LnIudC4gcGFpcklkXG5cbiAgICBpZiAoc3JjLnBvb2xJbmRleCgpID4gdGd0LnBvb2xJbmRleCgpKSB7XG4gICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgIHNyYyA9IHRndDtcbiAgICAgIHRndCA9IHRlbXA7XG4gICAgfVxuXG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHBhaXJJbmZvLnNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBzcmNIID0gcGFpckluZm8uc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuICAgIHZhciB0Z3RXID0gcGFpckluZm8udGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdmFyIHRndEggPSBwYWlySW5mby50Z3RIID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICB2YXIgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUoc3JjKV07XG5cbiAgICB2YXIgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG5cbiAgICBwYWlySW5mby5kaXJDb3VudHMgPSB7XG4gICAgICAnbm9ydGgnOiAwLFxuICAgICAgJ3dlc3QnOiAwLFxuICAgICAgJ3NvdXRoJzogMCxcbiAgICAgICdlYXN0JzogMCxcbiAgICAgICdub3J0aHdlc3QnOiAwLFxuICAgICAgJ3NvdXRod2VzdCc6IDAsXG4gICAgICAnbm9ydGhlYXN0JzogMCxcbiAgICAgICdzb3V0aGVhc3QnOiAwXG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhaXJJbmZvLmVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9lZGdlID0gcGFpckluZm8uZWxlc1tfaTJdO1xuICAgICAgdmFyIHJzID0gX2VkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIHZhciBfY3VydmVTdHlsZSA9IF9lZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcblxuICAgICAgdmFyIF9lZGdlSXNVbmJ1bmRsZWQgPSBfY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IF9jdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IF9jdXJ2ZVN0eWxlID09PSAndGF4aSc7IC8vIHdoZXRoZXIgdGhlIG5vcm1hbGlzZWQgcGFpciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgZWRnZSdzIHNyYy10Z3Qgb3JkZXJcblxuXG4gICAgICB2YXIgZWRnZUlzU3dhcHBlZCA9ICFzcmMuc2FtZShfZWRnZS5zb3VyY2UoKSk7XG5cbiAgICAgIGlmICghcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiAmJiBzcmMgIT09IHRndCAmJiAocGFpckluZm8uaGFzQmV6aWVyIHx8IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCkpIHtcbiAgICAgICAgcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiA9IHRydWU7IC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIHRndFBvcy54LCB0Z3RQb3MueSwgMCk7XG4gICAgICAgIHZhciBzcmNJbnRuID0gcGFpckluZm8uc3JjSW50biA9IHNyY091dHNpZGU7IC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIHNyY1Bvcy54LCBzcmNQb3MueSwgMCk7XG4gICAgICAgIHZhciB0Z3RJbnRuID0gcGFpckluZm8udGd0SW50biA9IHRndE91dHNpZGU7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyA9IHtcbiAgICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgICAgeDI6IHRndFBvcy54LFxuICAgICAgICAgIHkxOiBzcmNQb3MueSxcbiAgICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGR5ID0gdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV07XG4gICAgICAgIHZhciBkeCA9IHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdO1xuICAgICAgICB2YXIgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIHZhciB2ZWN0b3IgPSBwYWlySW5mby52ZWN0b3IgPSB7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSBwYWlySW5mby52ZWN0b3JOb3JtID0ge1xuICAgICAgICAgIHg6IHZlY3Rvci54IC8gbCxcbiAgICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07IC8vIGlmIG5vZGUgc2hhcGVzIG92ZXJsYXAsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuXG4gICAgICAgIHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCA9ICFudW1iZXIobCkgfHwgdGd0U2hhcGUuY2hlY2tQb2ludChzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkpIHx8IHNyY1NoYXBlLmNoZWNrUG9pbnQodGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55KTtcbiAgICAgICAgcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UgPSB2ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICAgICAgc3dhcHBlZHBhaXJJbmZvID0ge1xuICAgICAgICAgIG5vZGVzT3ZlcmxhcDogcGFpckluZm8ubm9kZXNPdmVybGFwLFxuICAgICAgICAgIGRpckNvdW50czogcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgICAgIGNhbGN1bGF0ZWRJbnRlcnNlY3Rpb246IHRydWUsXG4gICAgICAgICAgaGFzQmV6aWVyOiBwYWlySW5mby5oYXNCZXppZXIsXG4gICAgICAgICAgaGFzVW5idW5kbGVkOiBwYWlySW5mby5oYXNVbmJ1bmRsZWQsXG4gICAgICAgICAgZWxlczogcGFpckluZm8uZWxlcyxcbiAgICAgICAgICBzcmNQb3M6IHRndFBvcyxcbiAgICAgICAgICB0Z3RQb3M6IHNyY1BvcyxcbiAgICAgICAgICBzcmNXOiB0Z3RXLFxuICAgICAgICAgIHNyY0g6IHRndEgsXG4gICAgICAgICAgdGd0Vzogc3JjVyxcbiAgICAgICAgICB0Z3RIOiBzcmNILFxuICAgICAgICAgIHNyY0ludG46IHRndEludG4sXG4gICAgICAgICAgdGd0SW50bjogc3JjSW50bixcbiAgICAgICAgICBzcmNTaGFwZTogdGd0U2hhcGUsXG4gICAgICAgICAgdGd0U2hhcGU6IHNyY1NoYXBlLFxuICAgICAgICAgIHBvc1B0czoge1xuICAgICAgICAgICAgeDE6IHBvc1B0cy54MixcbiAgICAgICAgICAgIHkxOiBwb3NQdHMueTIsXG4gICAgICAgICAgICB4MjogcG9zUHRzLngxLFxuICAgICAgICAgICAgeTI6IHBvc1B0cy55MVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZXJzZWN0aW9uUHRzOiB7XG4gICAgICAgICAgICB4MTogaW50ZXJzZWN0aW9uUHRzLngyLFxuICAgICAgICAgICAgeTE6IGludGVyc2VjdGlvblB0cy55MixcbiAgICAgICAgICAgIHgyOiBpbnRlcnNlY3Rpb25QdHMueDEsXG4gICAgICAgICAgICB5MjogaW50ZXJzZWN0aW9uUHRzLnkxXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3I6IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3IueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3IueVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yTm9ybToge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm0ueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybUludmVyc2UueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtSW52ZXJzZS55XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFzc2VkUGFpckluZm8gPSBlZGdlSXNTd2FwcGVkID8gc3dhcHBlZHBhaXJJbmZvIDogcGFpckluZm87XG4gICAgICBycy5ub2Rlc092ZXJsYXAgPSBwYXNzZWRQYWlySW5mby5ub2Rlc092ZXJsYXA7XG4gICAgICBycy5zcmNJbnRuID0gcGFzc2VkUGFpckluZm8uc3JjSW50bjtcbiAgICAgIHJzLnRndEludG4gPSBwYXNzZWRQYWlySW5mby50Z3RJbnRuO1xuXG4gICAgICBpZiAoaGFzQ29tcG91bmRzICYmIChzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkpICYmIChzcmMucGFyZW50cygpLmFueVNhbWUodGd0KSB8fCB0Z3QucGFyZW50cygpLmFueVNhbWUoc3JjKSB8fCBzcmMuc2FtZSh0Z3QpICYmIHNyYy5pc1BhcmVudCgpKSkge1xuICAgICAgICBfdGhpcy5maW5kQ29tcG91bmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgX3RoaXMuZmluZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgICBfdGhpcy5maW5kU2VnbWVudHNQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICBfdGhpcy5maW5kVGF4aVBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCAhX2VkZ2VJc1VuYnVuZGxlZCAmJiBwYWlySW5mby5lbGVzLmxlbmd0aCAlIDIgPT09IDEgJiYgX2kyID09PSBNYXRoLmZsb29yKHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgX3RoaXMuZmluZFN0cmFpZ2h0RWRnZVBvaW50cyhfZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5maW5kQmV6aWVyUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuZmluZEVuZHBvaW50cyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcblxuICAgICAgX3RoaXMuY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmcoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5zdG9yZUFsbHB0cyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKF9lZGdlKTtcblxuICAgICAgX3RoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKF9lZGdlKTtcblxuICAgICAgX3RoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoX2VkZ2UpO1xuICAgIH0gLy8gZm9yIHBhaXIgZWRnZXNcblxuICB9O1xuXG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgIF9sb29wKHApO1xuICB9IC8vIGZvciBwYWlyIGlkc1xuICAvLyBoYXlzdGFja3MgYXZvaWQgdGhlIGV4cGVuc2Ugb2YgcGFpckluZm8gc3R1ZmYgKGludGVyc2VjdGlvbnMgZXRjLilcblxuXG4gIHRoaXMuZmluZEhheXN0YWNrUG9pbnRzKGhheXN0YWNrRWRnZXMpO1xufTtcblxuZnVuY3Rpb24gZ2V0UHRzKHB0cykge1xuICB2YXIgcmV0UHRzID0gW107XG5cbiAgaWYgKHB0cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgcmV0UHRzLnB1c2goe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXRQdHM7XG59XG5cbkJScCQzLmdldFNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gICAgcmV0dXJuIGdldFB0cyhycy5zZWdwdHMpO1xuICB9XG59O1xuXG5CUnAkMy5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ2JlemllcicgfHwgdHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCB0eXBlID09PSAnc2VsZicgfHwgdHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgIHJldHVybiBnZXRQdHMocnMuY3RybHB0cyk7XG4gIH1cbn07XG5cbkJScCQzLmdldEVkZ2VNaWRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICByZXR1cm4ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xufTtcblxudmFyIEJScCQ0ID0ge307XG5cbkJScCQ0Lm1hbnVhbEVuZHB0VG9QeCA9IGZ1bmN0aW9uIChub2RlLCBwcm9wKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5wb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuXG4gIGlmIChwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwID0gW3Byb3AucGZWYWx1ZVswXSwgcHJvcC5wZlZhbHVlWzFdXTtcblxuICAgIGlmIChwcm9wLnVuaXRzWzBdID09PSAnJScpIHtcbiAgICAgIHBbMF0gPSBwWzBdICogdztcbiAgICB9XG5cbiAgICBpZiAocHJvcC51bml0c1sxXSA9PT0gJyUnKSB7XG4gICAgICBwWzFdID0gcFsxXSAqIGg7XG4gICAgfVxuXG4gICAgcFswXSArPSBucG9zLng7XG4gICAgcFsxXSArPSBucG9zLnk7XG4gICAgcmV0dXJuIHA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuZ2xlID0gcHJvcC5wZlZhbHVlWzBdO1xuICAgIGFuZ2xlID0gLU1hdGguUEkgLyAyICsgYW5nbGU7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2tcblxuICAgIHZhciBsID0gMiAqIE1hdGgubWF4KHcsIGgpO1xuICAgIHZhciBfcCA9IFtucG9zLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBsLCBucG9zLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBsXTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5pbnRlcnNlY3RMaW5lKG5wb3MueCwgbnBvcy55LCB3LCBoLCBfcFswXSwgX3BbMV0sIDApO1xuICB9XG59O1xuXG5CUnAkNC5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW50ZXJzZWN0O1xuICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gIHZhciBzcmNQb3MgPSBzb3VyY2UucG9zaXRpb24oKTtcbiAgdmFyIHRndFBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHNyY0FyU2hhcGUgPSBlZGdlLnBzdHlsZSgnc291cmNlLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICB2YXIgc3JjRGlzdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG4gIHZhciB0YXhpID0gY3VydmVTdHlsZSA9PT0gJ3RheGknO1xuICB2YXIgc2VsZiA9IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCc7XG4gIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgc2VsZjtcbiAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBoYXNFbmRwdHMgPSBiZXppZXIgfHwgbXVsdGkgfHwgbGluZXM7XG4gIHZhciBvdmVycmlkZUVuZHB0cyA9IHNlbGYgfHwgdGF4aTtcbiAgdmFyIHNyY01hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1lbmRwb2ludCcpO1xuICB2YXIgc3JjTWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogc3JjTWFuRW5kcHQudmFsdWU7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHRndE1hbkVuZHB0LnZhbHVlO1xuICBycy5zcmNNYW5FbmRwdCA9IHNyY01hbkVuZHB0O1xuICBycy50Z3RNYW5FbmRwdCA9IHRndE1hbkVuZHB0O1xuICB2YXIgcDE7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiB0YXJnZXQgc2lkZVxuXG4gIHZhciBwMjsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHNvdXJjZSBzaWRlXG5cbiAgdmFyIHAxX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHRhcmdldCBzaGFwZVxuXG4gIHZhciBwMl9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCBzb3VyY2Ugc2hhcGVcblxuICBpZiAoYmV6aWVyKSB7XG4gICAgdmFyIGNwU3RhcnQgPSBbcnMuY3RybHB0c1swXSwgcnMuY3RybHB0c1sxXV07XG4gICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDJdLCBycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMV1dIDogY3BTdGFydDtcbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmIChsaW5lcykge1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFt0Z3RQb3MueCwgdGd0UG9zLnldIDogcnMuc2VncHRzLnNsaWNlKDAsIDIpO1xuICAgIHZhciB0Z3RBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFtzcmNQb3MueCwgc3JjUG9zLnldIDogcnMuc2VncHRzLnNsaWNlKHJzLnNlZ3B0cy5sZW5ndGggLSAyKTtcbiAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gIH1cblxuICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHRhcmdldCwgdGd0TWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnRndEludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMV9pID0gcDE7XG4gICAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMV9pID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0YXJnZXQub3V0ZXJXaWR0aCgpLCB0YXJnZXQub3V0ZXJIZWlnaHQoKSwgcDFfaVswXSwgcDFfaVsxXSwgMCk7XG5cbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHRycyA9IHRhcmdldC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBsdyA9IHRycy5sYWJlbFdpZHRoO1xuICAgICAgdmFyIGxoID0gdHJzLmxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIGx4ID0gdHJzLmxhYmVsWDtcbiAgICAgIHZhciBseSA9IHRycy5sYWJlbFk7XG4gICAgICB2YXIgdmEgPSB0YXJnZXQucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgICBpZiAodmEgPT09ICd0b3AnKSB7XG4gICAgICAgIGx5IC09IGxoIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAodmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGx5ICs9IGxoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKGhhID09PSAnbGVmdCcpIHtcbiAgICAgICAgbHggLT0gbHcgLyAyO1xuICAgICAgfSBlbHNlIGlmIChoYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBseCArPSBsdyAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYWJlbEludGVyc2VjdCA9IHIubm9kZVNoYXBlc1sncmVjdGFuZ2xlJ10uaW50ZXJzZWN0TGluZShseCwgbHksIGx3LCBsaCwgcDFfaVswXSwgcDFfaVsxXSwgMCk7XG4gICAgICB2YXIgcmVmUHQgPSBzcmNQb3M7XG4gICAgICB2YXIgaW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgIHZhciBsYWJJbnRTcWRpc3QgPSBzcWRpc3QocmVmUHQsIGFycmF5MnBvaW50KGxhYmVsSW50ZXJzZWN0KSk7XG5cbiAgICAgIGlmIChsYWJJbnRTcWRpc3QgPCBpbnRTcWRpc3QpIHtcbiAgICAgICAgaW50ZXJzZWN0ID0gbGFiZWxJbnRlcnNlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGFycm93RW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyB0Z3REaXN0KTtcbiAgdmFyIGVkZ2VFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuXG4gIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgIGludGVyc2VjdCA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0LnVuaXRzKSB7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoc291cmNlLCBzcmNNYW5FbmRwdCk7XG4gIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgaW50ZXJzZWN0ID0gcnMuc3JjSW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBwMjtcbiAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICB9XG5cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNvdXJjZS5vdXRlcldpZHRoKCksIHNvdXJjZS5vdXRlckhlaWdodCgpLCBwMl9pWzBdLCBwMl9pWzFdLCAwKTtcblxuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICB2YXIgc3JzID0gc291cmNlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIF9sdyA9IHNycy5sYWJlbFdpZHRoO1xuICAgICAgdmFyIF9saCA9IHNycy5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBfbHggPSBzcnMubGFiZWxYO1xuICAgICAgdmFyIF9seSA9IHNycy5sYWJlbFk7XG4gICAgICB2YXIgX3ZhID0gc291cmNlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKF92YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgX2x5IC09IF9saCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKF92YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgX2x5ICs9IF9saCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaGEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuXG4gICAgICBpZiAoX2hhID09PSAnbGVmdCcpIHtcbiAgICAgICAgX2x4IC09IF9sdyAvIDI7XG4gICAgICB9IGVsc2UgaWYgKF9oYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBfbHggKz0gX2x3IC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sYWJlbEludGVyc2VjdCA9IHIubm9kZVNoYXBlc1sncmVjdGFuZ2xlJ10uaW50ZXJzZWN0TGluZShfbHgsIF9seSwgX2x3LCBfbGgsIHAyX2lbMF0sIHAyX2lbMV0sIDApO1xuXG4gICAgICB2YXIgX3JlZlB0ID0gdGd0UG9zO1xuXG4gICAgICB2YXIgX2ludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuXG4gICAgICB2YXIgX2xhYkludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KF9sYWJlbEludGVyc2VjdCkpO1xuXG4gICAgICBpZiAoX2xhYkludFNxZGlzdCA8IF9pbnRTcWRpc3QpIHtcbiAgICAgICAgaW50ZXJzZWN0ID0gX2xhYmVsSW50ZXJzZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJvd1N0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyBzcmNEaXN0KTtcbiAgdmFyIGVkZ2VTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkgKyBzcmNEaXN0KTtcbiAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuXG4gIGlmIChoYXNFbmRwdHMpIHtcbiAgICBpZiAoIW51bWJlcihycy5zdGFydFgpIHx8ICFudW1iZXIocnMuc3RhcnRZKSB8fCAhbnVtYmVyKHJzLmVuZFgpIHx8ICFudW1iZXIocnMuZW5kWSkpIHtcbiAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5CUnAkNC5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1swXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbMV1cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dTdGFydFgsXG4gICAgICAgIHk6IHJzLmFycm93U3RhcnRZXG4gICAgICB9O1xuICB9XG59O1xuXG5CUnAkNC5nZXRUYXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1syXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbM11cbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgICB5OiBycy5hcnJvd0VuZFlcbiAgICAgIH07XG4gIH1cbn07XG5cbnZhciBCUnAkNSA9IHt9O1xuXG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHIsIGVkZ2UsIHB0cykge1xuICB2YXIgcWJlemllckF0JDEgPSBmdW5jdGlvbiBxYmV6aWVyQXQkMShwMSwgcDIsIHAzLCB0KSB7XG4gICAgcmV0dXJuIHFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgfTtcblxuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuICAgIGJwdHMucHVzaCh7XG4gICAgICB4OiBxYmV6aWVyQXQkMShwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCBwKSxcbiAgICAgIHk6IHFiZXppZXJBdCQxKHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIHApXG4gICAgfSk7XG4gIH1cbn1cblxuQlJwJDUuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7IC8vIGNsZWFyIHRoZSBjYWNoZWQgcG9pbnRzIHN0YXRlXG5cbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcblxuICBpZiAoZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCcpIHtcbiAgICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHB1c2hCZXppZXJQdHModGhpcywgZWRnZSwgcnMuYWxscHRzLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV0ID09PSAnc2VnbWVudHMnKSB7XG4gICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBscHRzLnB1c2goe1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW3tcbiAgICAgIHg6IGhwdHNbMF0sXG4gICAgICB5OiBocHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogaHB0c1syXSxcbiAgICAgIHk6IGhwdHNbM11cbiAgICB9XTtcbiAgfVxuXG4gIF9wLnJzdHlsZS5hcnJvd1dpZHRoID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xufTtcblxuQlJwJDUucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xufTtcblxudmFyIEJScCQ2ID0ge307XG5cbkJScCQ2LnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWU7XG5cbiAgaWYgKGVtcHR5U3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICB2YXIgbm9kZVBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHRleHRIYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRWYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC12YWxpZ24nKS5zdHJWYWx1ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBjZW50ZXJcbiAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICB9XG5cbiAgc3dpdGNoICh0ZXh0VmFsaWduKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlLmcuIG1pZGRsZVxuICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gIH1cblxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKG5vZGUpO1xufTtcblxudmFyIGxpbmVBbmdsZUZyb21EZWx0YSA9IGZ1bmN0aW9uIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGR5IC8gZHgpO1xuXG4gIGlmIChkeCA9PT0gMCAmJiBhbmdsZSA8IDApIHtcbiAgICBhbmdsZSA9IGFuZ2xlICogLTE7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59O1xuXG52YXIgbGluZUFuZ2xlID0gZnVuY3Rpb24gbGluZUFuZ2xlKHAwLCBwMSkge1xuICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gIHJldHVybiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KTtcbn07XG5cbnZhciBiZXppZXJBbmdsZSA9IGZ1bmN0aW9uIGJlemllckFuZ2xlKHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIHQwID0gYm91bmQoMCwgdCAtIDAuMDAxLCAxKTtcbiAgdmFyIHQxID0gYm91bmQoMCwgdCArIDAuMDAxLCAxKTtcbiAgdmFyIGxwMCA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQwKTtcbiAgdmFyIGxwMSA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQxKTtcbiAgcmV0dXJuIGxpbmVBbmdsZShscDAsIGxwMSk7XG59O1xuXG5CUnAkNi5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHA7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgfTtcblxuICBpZiAoY29udGVudC5taWQgfHwgY29udGVudC5zb3VyY2UgfHwgY29udGVudC50YXJnZXQpIDsgZWxzZSB7XG4gICAgICByZXR1cm47IC8vIG5vIGxhYmVscyA9PiBubyBjYWxjc1xuICAgIH0gLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgLy9cblxuXG4gIHAgPSB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG5cbiAgdmFyIHNldFJzID0gZnVuY3Rpb24gc2V0UnMocHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgfTtcblxuICBzZXRScygnbGFiZWxYJywgbnVsbCwgcC54KTtcbiAgc2V0UnMoJ2xhYmVsWScsIG51bGwsIHAueSk7XG4gIHZhciBtaWRBbmdsZSA9IGxpbmVBbmdsZUZyb21EZWx0YShycy5taWREaXNwWCwgcnMubWlkRGlzcFkpO1xuICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBudWxsLCBtaWRBbmdsZSk7XG5cbiAgdmFyIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8gPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCkge1xuICAgIGlmIChjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZTtcbiAgICB9IC8vIHVzZSBjYWNoZSBzbyBvbmx5IDF4IHBlciBlZGdlXG5cblxuICAgIHZhciBjdHJscHRzID0gW107IC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2YXIgcDAgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgfTtcbiAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyAyXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgfTsgLy8gY3RybHB0XG5cbiAgICAgIHZhciBwMiA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyA0XSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyA1XVxuICAgICAgfTtcbiAgICAgIGN0cmxwdHMucHVzaCh7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICBwMjogcDIsXG4gICAgICAgIHN0YXJ0RGlzdDogMCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBzZWdtZW50czogW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiBhZGRTZWdtZW50KGNwLCBwMCwgcDEsIHQwLCB0MSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGRpc3QocDAsIHAxKTtcbiAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzW2NwLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQxOiB0MSxcbiAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuICAgICAgY3Auc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgIGNwLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSAvLyB1cGRhdGUgZWFjaCBjdHJscHQgd2l0aCBzZWdtZW50IGluZm9cblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN0cmxwdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY3AgPSBjdHJscHRzW19pXTtcbiAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW19pIC0gMV07XG5cbiAgICAgIGlmIChwcmV2Q3ApIHtcbiAgICAgICAgY3Auc3RhcnREaXN0ID0gcHJldkNwLnN0YXJ0RGlzdCArIHByZXZDcC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGNwLnAwLCBicHRzW19pICogblByb2pzXSwgMCwgci5iZXppZXJQcm9qUGN0c1swXSk7IC8vIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrKSB7XG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBqXSwgYnB0c1tfaSAqIG5Qcm9qcyArIGogKyAxXSwgci5iZXppZXJQcm9qUGN0c1tqXSwgci5iZXppZXJQcm9qUGN0c1tqICsgMV0pO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgblByb2pzIC0gMV0sIGNwLnAyLCByLmJlemllclByb2pQY3RzW25Qcm9qcyAtIDFdLCAxKTsgLy8gbGFzdFxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlID0gY3RybHB0cztcbiAgfTtcblxuICB2YXIgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGFuZ2xlO1xuICAgIHZhciBpc1NyYyA9IHByZWZpeCA9PT0gJ3NvdXJjZSc7XG5cbiAgICBpZiAoIWNvbnRlbnRbcHJlZml4XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLXRleHQtb2Zmc2V0JykucGZWYWx1ZTtcblxuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjcHMgPSBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIHZhciBzdGFydERpc3QgPSAwO1xuICAgICAgICAgIHZhciB0b3RhbERpc3QgPSAwOyAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jcCA9IGNwc1tpc1NyYyA/IGkgOiBjcHMubGVuZ3RoIC0gMSAtIGldO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9jcC5zZWdtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgX3NlZyA9IF9jcC5zZWdtZW50c1tpc1NyYyA/IGogOiBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMSAtIGpdO1xuICAgICAgICAgICAgICB2YXIgbGFzdFNlZyA9IGkgPT09IGNwcy5sZW5ndGggLSAxICYmIGogPT09IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICBzdGFydERpc3QgPSB0b3RhbERpc3Q7XG4gICAgICAgICAgICAgIHRvdGFsRGlzdCArPSBfc2VnLmxlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICBjcDogX2NwLFxuICAgICAgICAgICAgICAgICAgc2VnbWVudDogX3NlZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjcCA9IHNlbGVjdGVkLmNwO1xuICAgICAgICAgIHZhciBzZWcgPSBzZWxlY3RlZC5zZWdtZW50O1xuICAgICAgICAgIHZhciB0U2VnbWVudCA9IChvZmZzZXQgLSBzdGFydERpc3QpIC8gc2VnLmxlbmd0aDtcbiAgICAgICAgICB2YXIgc2VnRHQgPSBzZWcudDEgLSBzZWcudDA7XG4gICAgICAgICAgdmFyIHQgPSBpc1NyYyA/IHNlZy50MCArIHNlZ0R0ICogdFNlZ21lbnQgOiBzZWcudDEgLSBzZWdEdCAqIHRTZWdtZW50O1xuICAgICAgICAgIHQgPSBib3VuZCgwLCB0LCAxKTtcbiAgICAgICAgICBwID0gcWJlemllclB0QXQoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYW5nbGUgPSBiZXppZXJBbmdsZShjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICAgIGRpLFxuICAgICAgICAgICAgICBkMDtcbiAgICAgICAgICB2YXIgcDAsIHAxO1xuICAgICAgICAgIHZhciBsID0gcnMuYWxscHRzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiArIDMgPCBsOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgaWYgKGlzU3JjKSB7XG4gICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyICsgMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDNdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDIgLSBfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMSAtIF9pMl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSA0IC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDMgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpID0gZGlzdChwMCwgcDEpO1xuICAgICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgICAgZCArPSBkaTtcblxuICAgICAgICAgICAgaWYgKGQgPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuXG4gICAgICAgICAgdmFyIF90ID0gcEQgLyBkaTtcblxuICAgICAgICAgIF90ID0gYm91bmQoMCwgX3QsIDEpO1xuICAgICAgICAgIHAgPSBsaW5lQXQocDAsIHAxLCBfdCk7XG4gICAgICAgICAgYW5nbGUgPSBsaW5lQW5nbGUocDAsIHAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgfTtcblxuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCdzb3VyY2UnKTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbigndGFyZ2V0Jyk7XG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoZWRnZSk7XG59O1xuXG5CUnAkNi5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSk7XG5cbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5cbkJScCQ2LmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCk7XG4gIHZhciBsaW5lSGVpZ2h0ID0gZWxlLnBzdHlsZSgnbGluZS1oZWlnaHQnKS5wZlZhbHVlO1xuICB2YXIgdGV4dFdyYXAgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS5zdHJWYWx1ZTtcbiAgdmFyIGxpbmVzID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KSB8fCBbXTtcbiAgdmFyIG51bUxpbmVzID0gdGV4dFdyYXAgIT09ICd3cmFwJyA/IDEgOiBNYXRoLm1heChsaW5lcy5sZW5ndGgsIDEpO1xuICB2YXIgbm9ybVBlckxpbmVIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0IC8gbnVtTGluZXM7XG4gIHZhciBsYWJlbExpbmVIZWlnaHQgPSBub3JtUGVyTGluZUhlaWdodCAqIGxpbmVIZWlnaHQ7XG4gIHZhciB3aWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgdmFyIGhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgKyAobnVtTGluZXMgLSAxKSAqIChsaW5lSGVpZ2h0IC0gMSkgKiBub3JtUGVyTGluZUhlaWdodDtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCwgbGFiZWxMaW5lSGVpZ2h0KTtcbn07XG5cbkJScCQ2LmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHBmZCArICdsYWJlbCcpLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykudmFsdWU7XG5cbiAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24gcnNjcmF0Y2gocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4KTtcbiAgICB9XG4gIH07IC8vIGZvciBlbXB0eSB0ZXh0LCBza2lwIGFsbCBwcm9jZXNzaW5nXG5cblxuICBpZiAoIXRleHQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIDsgZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWU7XG5cbiAgaWYgKHdyYXBTdHlsZSA9PT0gJ3dyYXAnKSB7XG4gICAgdmFyIGxhYmVsS2V5ID0gcnNjcmF0Y2goJ2xhYmVsS2V5Jyk7IC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcblxuICAgIGlmIChsYWJlbEtleSAhPSBudWxsICYmIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknKSA9PT0gbGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgIH1cblxuICAgIHZhciB6d3NwID0gXCJcXHUyMDBCXCI7XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIG92ZXJmbG93ID0gZWxlLnBzdHlsZSgndGV4dC1vdmVyZmxvdy13cmFwJykudmFsdWU7XG4gICAgdmFyIG92ZXJmbG93QW55ID0gb3ZlcmZsb3cgPT09ICdhbnl3aGVyZSc7XG4gICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuICAgIHZhciB3b3Jkc1JlZ2V4ID0gL1tcXHNcXHUyMDBiXSsvO1xuICAgIHZhciB3b3JkU2VwYXJhdG9yID0gb3ZlcmZsb3dBbnkgPyAnJyA6ICcgJztcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgIHZhciBsaW5lID0gbGluZXNbbF07XG4gICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG5cbiAgICAgIGlmIChvdmVyZmxvd0FueSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZSA9IGxpbmUuc3BsaXQoJycpLmpvaW4oendzcCk7XG4gICAgICAgIGxpbmUgPSBwcm9jZXNzZWRMaW5lO1xuICAgICAgfVxuXG4gICAgICBpZiAobGluZVcgPiBtYXhXKSB7XG4gICAgICAgIC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCh3b3Jkc1JlZ2V4KTtcbiAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcblxuICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSB3b3Jkc1t3XTtcbiAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgd29yZFNlcGFyYXRvciArIHdvcmQ7XG4gICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXN0TGluZSk7XG4gICAgICAgICAgdmFyIHRlc3RXID0gdGVzdERpbXMud2lkdGg7XG5cbiAgICAgICAgICBpZiAodGVzdFcgPD0gbWF4Vykge1xuICAgICAgICAgICAgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgIGlmIChzdWJsaW5lKSB7XG4gICAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJsaW5lID0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuXG5cbiAgICAgICAgaWYgKCFzdWJsaW5lLm1hdGNoKC9eW1xcc1xcdTIwMGJdKyQvKSkge1xuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cblxuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyk7XG4gICAgdGV4dCA9IHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkpO1xuICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgIHZhciBfbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgIHZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcykud2lkdGg7XG5cbiAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBfbWF4Vykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZWxsaXBzaXplZCArPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoaSA9PT0gdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGluY0xhc3RDaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbmNMYXN0Q2gpIHtcbiAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsbGlwc2l6ZWQ7XG4gIH0gLy8gaWYgZWxsaXBzaXplXG5cblxuICByZXR1cm4gdGV4dDtcbn07XG5cbkJScCQ2LmdldExhYmVsSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIGp1c3RpZmljYXRpb24gPSBlbGUucHN0eWxlKCd0ZXh0LWp1c3RpZmljYXRpb24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuXG4gIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmV0dXJuICdyaWdodCc7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJldHVybiAnbGVmdCc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGp1c3RpZmljYXRpb247XG4gIH1cbn07XG5cbkJScCQ2LmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHRleHQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY2FjaGVLZXkgPSBoYXNoU3RyaW5nKHRleHQsIGVsZS5fcHJpdmF0ZS5sYWJlbERpbXNLZXkpO1xuICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IFtdKTtcbiAgdmFyIGV4aXN0aW5nVmFsID0gY2FjaGVbY2FjaGVLZXldO1xuXG4gIGlmIChleGlzdGluZ1ZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nVmFsO1xuICB9XG5cbiAgdmFyIHNpemVNdWx0ID0gMTsgLy8gaW5jcmVhc2UgdGhlIHNjYWxlIHRvIGluY3JlYXNlIGFjY3VyYWN5IHcuci50LiB6b29tZWQgdGV4dFxuXG4gIHZhciBmU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBzaXplID0gc2l6ZU11bHQgKiBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICB2YXIgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXY7XG5cbiAgaWYgKCFkaXYpIHtcbiAgICBkaXYgPSB0aGlzLmxhYmVsQ2FsY0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuXG4gIHZhciBkcyA9IGRpdi5zdHlsZTsgLy8gZnJvbSBlbGUgc3R5bGVcblxuICBkcy5mb250RmFtaWx5ID0gZmFtaWx5O1xuICBkcy5mb250U3R5bGUgPSBmU3R5bGU7XG4gIGRzLmZvbnRTaXplID0gc2l6ZTtcbiAgZHMuZm9udFdlaWdodCA9IHdlaWdodDsgLy8gZm9yY2VkIHN0eWxlXG5cbiAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICBkcy50b3AgPSAnLTk5OTlweCc7XG4gIGRzLnpJbmRleCA9ICctMSc7XG4gIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgZHMucGFkZGluZyA9ICcwJztcbiAgZHMubGluZUhlaWdodCA9ICcxJztcblxuICBpZiAoZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWUgPT09ICd3cmFwJykge1xuICAgIGRzLndoaXRlU3BhY2UgPSAncHJlJzsgLy8gc28gbmV3bGluZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICB9IGVsc2Uge1xuICAgIGRzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgfSAvLyBwdXQgbGFiZWwgY29udGVudCBpbiBkaXZcblxuXG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgd2lkdGg6IE1hdGguY2VpbChkaXYuY2xpZW50V2lkdGggLyBzaXplTXVsdCksXG4gICAgaGVpZ2h0OiBNYXRoLmNlaWwoZGl2LmNsaWVudEhlaWdodCAvIHNpemVNdWx0KVxuICB9O1xufTtcblxuQlJwJDYuY2FsY3VsYXRlTGFiZWxBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgcHJlZml4RGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgcm90ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcblxuICBpZiAocm90U3RyID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgcm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gcnMubGFiZWxBdXRvQW5nbGU7XG4gIH0gZWxzZSBpZiAocm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm90LnBmVmFsdWU7XG4gIH1cbn07XG5cbkJScCQ2LmNhbGN1bGF0ZUxhYmVsQW5nbGVzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHJzLmxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlKTtcblxuICBpZiAoaXNFZGdlKSB7XG4gICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG52YXIgQlJwJDcgPSB7fTtcbnZhciBUT09fU01BTExfQ1VUX1JFQ1QgPSAyODtcbnZhciB3YXJuZWRDdXRSZWN0ID0gZmFsc2U7XG5cbkJScCQ3LmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykudmFsdWU7XG5cbiAgaWYgKHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyAmJiAobm9kZS53aWR0aCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUIHx8IG5vZGUuaGVpZ2h0KCkgPCBUT09fU01BTExfQ1VUX1JFQ1QpKSB7XG4gICAgaWYgKCF3YXJuZWRDdXRSZWN0KSB7XG4gICAgICB3YXJuKCdUaGUgYGN1dHJlY3RhbmdsZWAgbm9kZSBzaGFwZSBjYW4gbm90IGJlIHVzZWQgYXQgc21hbGwgc2l6ZXMgc28gYHJlY3RhbmdsZWAgaXMgdXNlZCBpbnN0ZWFkJyk7XG4gICAgICB3YXJuZWRDdXRSZWN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gIH1cblxuICBpZiAobm9kZS5pc1BhcmVudCgpKSB7XG4gICAgaWYgKHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdiYXJyZWwnKSB7XG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICB9XG4gIH1cblxuICBpZiAoc2hhcGUgPT09ICdwb2x5Z29uJykge1xuICAgIHZhciBwb2ludHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS52YWx1ZTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKHBvaW50cykubmFtZTtcbiAgfVxuXG4gIHJldHVybiBzaGFwZTtcbn07XG5cbnZhciBCUnAkOCA9IHt9O1xuXG5CUnAkOC5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGVsZXMpIHtcbiAgICB2YXIgZGlydHlTdHlsZUNhY2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoZWxlcyk7XG5cbiAgICBpZiAoZGlydHlTdHlsZUNhY2hlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgci5iaW5kZXIoY3kpLm9uKCdib3VuZHMuKiBkaXJ0eS4qJywgZnVuY3Rpb24gb25EaXJ0eUJvdW5kcyhlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlKTtcbiAgfSkub24oJ3N0eWxlLiogYmFja2dyb3VuZC4qJywgZnVuY3Rpb24gb25EaXJ0eVN0eWxlKGUpIHtcbiAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgZW5xdWV1ZShlbGUsIGZhbHNlKTtcbiAgfSk7XG5cbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gdXBkYXRlRWxlQ2FsY3Mod2lsbERyYXcpIHtcbiAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzVG9VcGRhdGVbaV07XG4gICAgICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkgJiYgIXJzdHlsZS5jbGVhbkNvbm5lY3RlZCkge1xuICAgICAgICAgIGVucXVldWUoZWxlLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZucykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBmbiA9IGZuc1tpXTtcbiAgICAgICAgICBmbih3aWxsRHJhdywgZWxlc1RvVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlbGVzVG9VcGRhdGUpO1xuICAgICAgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZUVsZUNhbGNzKHRydWUpO1xuICB9O1xuXG4gIHIuYmVmb3JlUmVuZGVyKHVwZGF0ZUVsZUNhbGNzLCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlQ2FsY3MpO1xufTtcblxuQlJwJDgub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuICBmbnMucHVzaChmbik7XG59O1xuXG5CUnAkOC5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlcywgdXNlQ2FjaGUpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdOyAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgdXNlZCBmb3IgY2FsY3Mgd2hlbiBkZXN0cm95ZWQsIGUuZy4gZWxlLmJvdW5kaW5nQm94KClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gdXNlIGNhY2hlIGJ5IGRlZmF1bHQgZm9yIHBlcmZcblxuXG4gIGlmICh1c2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXNlQ2FjaGUgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7IC8vIG9ubHkgdXBkYXRlIGlmIGRpcnR5IGFuZCBpbiBncmFwaFxuXG4gICAgaWYgKHVzZUNhY2hlICYmIHJzdHlsZS5jbGVhbiB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG5cblxuICAgIGlmIChlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKF9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuXG4gICAgcnN0eWxlLmNsZWFuID0gdHJ1ZTtcbiAgfSAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKGVsZSk7XG4gICAgcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgcnN0eWxlLm5vZGVZID0gcG9zLnk7XG4gICAgcnN0eWxlLm5vZGVXID0gZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHJzdHlsZS5ub2RlSCA9IGVsZS5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWU7XG4gIH1cblxuICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKGVkZ2VzKTsgLy8gdXBkYXRlIGVkZ2UgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDsgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcblxuICAgIHJzdHlsZS5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgcnN0eWxlLnNyY1kgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICByc3R5bGUudGd0WCA9IHJzLmFycm93RW5kWDtcbiAgICByc3R5bGUudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICByc3R5bGUubWlkWCA9IHJzLm1pZFg7XG4gICAgcnN0eWxlLm1pZFkgPSBycy5taWRZO1xuICAgIHJzdHlsZS5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICByc3R5bGUuc291cmNlTGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnRhcmdldExhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlO1xuICB9XG59O1xuXG52YXIgQlJwJDkgPSB7fTtcblxuQlJwJDkudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcblxuICBpZiAoIWVsZXMpIHtcbiAgICAvLyBqdXN0IGxldCB0aGlzIGJlIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCB6IHNvcnQgdGlja1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZXMuZHJhZyA9IFtdO1xuICBlbGVzLm5vbmRyYWcgPSBbXTtcbiAgdmFyIGdyYWJUYXJnZXRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgaWYgKGVsZS5ncmFiYmVkKCkgJiYgIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICBncmFiVGFyZ2V0cy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChycy5pbkRyYWdMYXllcikge1xuICAgICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5ub25kcmFnLnB1c2goZWxlKTtcbiAgICB9XG4gIH0gLy8gcHV0IHRoZSBncmFiIHRhcmdldCBub2RlcyBsYXN0IHNvIGl0J3Mgb24gdG9wIG9mIGl0cyBuZWlnaGJvdXJob29kXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYWJUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGdyYWJUYXJnZXRzW2ldO1xuICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gIH1cbn07XG5cbkJScCQ5LmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IG51bGw7XG59O1xuXG5CUnAkOS5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uIChmb3JjZVJlY2FsYykge1xuICBpZiAoZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuY3kubXV0YWJsZUVsZW1lbnRzKCkudG9BcnJheSgpO1xuICAgIGVsZXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgICBlbGVzLmludGVyYWN0aXZlID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pbnRlcmFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgfVxuXG4gIHJldHVybiBlbGVzO1xufTtcblxudmFyIEJScCRhID0ge307XG5bQlJwJDEsIEJScCQyLCBCUnAkMywgQlJwJDQsIEJScCQ1LCBCUnAkNiwgQlJwJDcsIEJScCQ4LCBCUnAkOV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKEJScCRhLCBwcm9wcyk7XG59KTtcblxudmFyIEJScCRiID0ge307XG5cbkJScCRiLmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NPcmlnaW4sIG9uTG9hZCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF07XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgaWYgKCFjYWNoZS5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgaW1hZ2UuZXJyb3IgPSB0cnVlO1xuICAgIH0pOyAvLyAjMTU4MiBzYWZhcmkgZG9lc24ndCBsb2FkIGRhdGEgdXJpcyB3aXRoIGNyb3NzT3JpZ2luIHByb3Blcmx5XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyMzk3OFxuXG4gICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKDAsIGRhdGFVcmlQcmVmaXgubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBkYXRhVXJpUHJlZml4O1xuXG4gICAgaWYgKCFpc0RhdGFVcmkpIHtcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47IC8vIHByZXZlbnQgdGFpbnRlZCBjYW52YXNcbiAgICB9XG5cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG59O1xuXG52YXIgQlJwJGMgPSB7fTtcbi8qIGdsb2JhbCBkb2N1bWVudCwgd2luZG93LCBSZXNpemVPYnNlcnZlciwgTXV0YXRpb25PYnNlcnZlciAqL1xuXG5CUnAkYy5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTsgLy8gY29weVxuXG4gIHZhciBiID0gdGhpcy5iaW5kZXIodGFyZ2V0KTtcbiAgcmV0dXJuIGIub24uYXBwbHkoYiwgYXJncyk7XG59O1xuXG5CUnAkYy5iaW5kZXIgPSBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHRndElzRG9tID0gdGd0ID09PSB3aW5kb3cgfHwgdGd0ID09PSBkb2N1bWVudCB8fCB0Z3QgPT09IGRvY3VtZW50LmJvZHkgfHwgZG9tRWxlbWVudCh0Z3QpO1xuXG4gIGlmIChyLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9PSBudWxsKSB7XG4gICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHsvLyBub3Qgc3VwcG9ydGVkXG4gICAgfVxuXG4gICAgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSBzdXBwb3J0c1Bhc3NpdmU7XG4gIH1cblxuICB2YXIgb24gPSBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmICh0Z3RJc0RvbSAmJiByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cykge1xuICAgICAgLy8gcmVwbGFjZSB1c2VDYXB0dXJlIHcvIG9wdHMgb2JqXG4gICAgICBhcmdzWzJdID0ge1xuICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlICE9IG51bGwgPyB1c2VDYXB0dXJlIDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gICAgKHRndC5hZGRFdmVudExpc3RlbmVyIHx8IHRndC5vbikuYXBwbHkodGd0LCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBvbixcbiAgICBhZGRFdmVudExpc3RlbmVyOiBvbixcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgYmluZDogb25cbiAgfTtcbn07XG5cbkJScCRjLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUuaXNOb2RlKCkgJiYgIW5vZGUubG9ja2VkKCkgJiYgbm9kZS5ncmFiYmFibGUoKTtcbn07XG5cbkJScCRjLm5vZGVJc0dyYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0aGlzLm5vZGVJc0RyYWdnYWJsZShub2RlKSAmJiBub2RlLmludGVyYWN0aXZlKCk7XG59O1xuXG5CUnAkYy5sb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfTtcblxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uIHRyaWdnZXJFdmVudHModGFyZ2V0LCBuYW1lcywgZSwgcG9zaXRpb24pIHtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHRhcmdldC5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzTXVsdFNlbEtleURvd24gPSBmdW5jdGlvbiBpc011bHRTZWxLZXlEb3duKGUpIHtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuXG4gIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIGRvd25zKSB7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgaWYgKHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAvLyBhIGdyYWJiYWJsZSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlbGUgPT4gbm8gcGFzc3Rocm91Z2ggcGFubmluZ1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGRvd25zICYmIGkgPCBkb3ducy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZG93biA9IGRvd25zW2ldO1xuXG4gICAgICAgIGlmIChkb3duLmlzTm9kZSgpICYmIGRvd24uaXNQYXJlbnQoKSkge1xuICAgICAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsb3dQYXNzdGhyb3VnaDtcbiAgfTtcblxuICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uIHNldEdyYWJiZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzZXRGcmVlZCA9IGZ1bmN0aW9uIHNldEZyZWVkKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHNldEluRHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0SW5EcmFnTGF5ZXIoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgc2V0T3V0RHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0T3V0RHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBzZXRHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gc2V0R3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlR3JhYlRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZUdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhZGRUb0RyYWdMaXN0ID0gZnVuY3Rpb24gYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpIHtcbiAgICB2YXIgbGlzdCA9IG9wdHMuYWRkVG9MaXN0O1xuICAgIHZhciBsaXN0SGFzRWxlID0gbGlzdC5oYXMoZWxlKTtcblxuICAgIGlmICghbGlzdEhhc0VsZSkge1xuICAgICAgbGlzdC5tZXJnZShlbGUpO1xuICAgICAgc2V0R3JhYmJlZChlbGUpO1xuICAgIH1cbiAgfTsgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcblxuXG4gIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGUsIG9wdHMpIHtcbiAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuXG4gICAgdmFyIGlubmVyTm9kZXMgPSBub2RlLmRlc2NlbmRhbnRzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG9wdHMuYWRkVG9MaXN0LnVubWVyZ2UoaW5uZXJOb2Rlcyk7XG4gICAgfVxuICB9OyAvLyBhZGRzIHRoZSBnaXZlbiBub2RlcyBhbmQgaXRzIG5laWdoYm91cmhvb2QgdG8gdGhlIGRyYWcgbGF5ZXJcblxuXG4gIHZhciBhZGROb2Rlc1RvRHJhZyA9IGZ1bmN0aW9uIGFkZE5vZGVzVG9EcmFnKG5vZGVzLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBub2Rlcy5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLm5laWdoYm9yaG9vZCgpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBlbGUuaXNFZGdlKCk7XG4gICAgICB9KS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGREZXNjZW5kYW50c1RvRHJhZyhub2Rlcywgb3B0cyk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuICAgIC8vIGFsc28gYWRkIG5vZGVzIGFuZCBlZGdlcyByZWxhdGVkIHRvIHRoZSB0b3Btb3N0IGFuY2VzdG9yXG5cbiAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2Rlcywge1xuICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICB9KTtcbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG5cbiAgdmFyIGFkZE5vZGVUb0RyYWcgPSBhZGROb2Rlc1RvRHJhZztcblxuICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uIGZyZWVEcmFnZ2VkRWxlbWVudHMoZ3JhYmJlZEVsZXMpIHtcbiAgICBpZiAoIWdyYWJiZWRFbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBqdXN0IGdvIG92ZXIgYWxsIGVsZW1lbnRzIHJhdGhlciB0aGFuIGRvaW5nIGEgYnVuY2ggb2YgKHBvc3NpYmx5IGV4cGVuc2l2ZSkgdHJhdmVyc2Fsc1xuXG5cbiAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBzZXRGcmVlZChlbGUpO1xuICAgICAgc2V0T3V0RHJhZ0xheWVyKGVsZSk7XG4gICAgICByZW1vdmVHcmFiVGFyZ2V0KGVsZSk7XG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9OyAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG5cblxuICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2RlLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cblxuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG5cblxuICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTsgLy8gbm8gcGFyZW50IG5vZGU6IG5vIG5vZGVzIHRvIGFkZCB0byB0aGUgZHJhZyBsYXllclxuXG4gICAgaWYgKHBhcmVudC5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gcGFyZW50LmRlc2NlbmRhbnRzKCkuc3Bhd25TZWxmKCkubWVyZ2UocGFyZW50KS51bm1lcmdlKG5vZGUpLnVubWVyZ2Uobm9kZS5kZXNjZW5kYW50cygpKTtcbiAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVkZ2VzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBibHVyQWN0aXZlRG9tRWxlbWVudCA9IGZ1bmN0aW9uIGJsdXJBY3RpdmVEb21FbGVtZW50KCkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICE9IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGF2ZU11dGF0aW9uc0FwaSA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGhhdmVSZXNpemVPYnNlcnZlckFwaSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7IC8vIHdhdGNoIGZvciB3aGVuIHRoZSBjeSBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb21cblxuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0bnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgIGlmIChyTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAock5vZGUgPT09IHIuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIucGFyZW50Tm9kZSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG9uUmVzaXplID0gdXRpbChmdW5jdGlvbiAoKSB7XG4gICAgci5jeS5yZXNpemUoKTtcbiAgfSwgMTAwKTtcblxuICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgIHIuc3R5bGVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5zdHlsZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgfSAvLyBhdXRvIHJlc2l6ZVxuXG5cbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgb25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgaWYgKGhhdmVSZXNpemVPYnNlcnZlckFwaSkge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIpO1xuICB9XG5cbiAgdmFyIGZvckVhY2hVcCA9IGZ1bmN0aW9uIGZvckVhY2hVcChkb21FbGUsIGZuKSB7XG4gICAgd2hpbGUgKGRvbUVsZSAhPSBudWxsKSB7XG4gICAgICBmbihkb21FbGUpO1xuICAgICAgZG9tRWxlID0gZG9tRWxlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbnZhbGlkYXRlQ29vcmRzID0gZnVuY3Rpb24gaW52YWxpZGF0ZUNvb3JkcygpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICB9O1xuXG4gIGZvckVhY2hVcChyLmNvbnRhaW5lciwgZnVuY3Rpb24gKGRvbUVsZSkge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3RyYW5zaXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdhbmltYXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdzY3JvbGwnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgfSk7IC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG5cbiAgdmFyIGluQm94U2VsZWN0aW9uID0gZnVuY3Rpb24gaW5Cb3hTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICB9O1xuXG4gIHZhciBldmVudEluQ29udGFpbmVyID0gZnVuY3Rpb24gZXZlbnRJbkNvbnRhaW5lcihlKSB7XG4gICAgLy8gc2F2ZSBjeWNsZXMgaWYgbW91c2UgZXZlbnRzIGFyZW4ndCB0byBiZSBjYXB0dXJlZFxuICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIHggPSBjb250YWluZXJQYWdlQ29vcmRzWzBdO1xuICAgIHZhciB5ID0gY29udGFpbmVyUGFnZUNvb3Jkc1sxXTtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXJQYWdlQ29vcmRzWzJdO1xuICAgIHZhciBoZWlnaHQgPSBjb250YWluZXJQYWdlQ29vcmRzWzNdO1xuICAgIHZhciBwb3NpdGlvbnMgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXMgOiBbZV07XG4gICAgdmFyIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcblxuICAgICAgaWYgKHggPD0gcC5jbGllbnRYICYmIHAuY2xpZW50WCA8PSB4ICsgd2lkdGggJiYgeSA8PSBwLmNsaWVudFkgJiYgcC5jbGllbnRZIDw9IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgYXRMZWFzdE9uZVBvc0luc2lkZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYXRMZWFzdE9uZVBvc0luc2lkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByLmNvbnRhaW5lcjtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0UGFyZW50KSB7XG4gICAgICBpZiAodFBhcmVudCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lcklzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRQYXJlbnQgPSB0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKCFjb250YWluZXJJc1RhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gUHJpbWFyeSBrZXlcblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gbW91c2Vkb3duSGFuZGxlcihlKSB7XG4gICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gZ3BvcztcblxuICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbiBjaGVja0ZvclRhcGhvbGQoKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQoci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfTsgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG5cblxuICAgIGlmIChlLndoaWNoID09IDMpIHtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgbmVhci5lbWl0KGN4dEV2dCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlOyAvLyBQcmltYXJ5IGJ1dHRvblxuICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAxKSB7XG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICB9IC8vIEVsZW1lbnQgZHJhZ2dpbmdcblxuXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0cmlnZ2VyR3JhYiA9IGZ1bmN0aW9uIHRyaWdnZXJHcmFiKGVsZSkge1xuICAgICAgICAgICAgICBlbGUuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgICBpZiAoIW5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHRyaWdnZXJHcmFiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93bnMgPSBuZWFycztcbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZWRvd24nLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9KTtcblxuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSBlbHNlIGlmIChuZWFyLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgIH1cblxuICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG4gICAgfSAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcblxuXG4gICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZW1vdmUnLCBmdW5jdGlvbiBtb3VzZW1vdmVIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgZ3BvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChncG9zWzBdLCBncG9zWzFdKTtcbiAgICB2YXIgbWRvd25Qb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICB2YXIgbWRvd25HUG9zID0gci5ob3ZlckRhdGEubWRvd25HUG9zO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IG51bGw7XG5cbiAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiAobWRvd25HUG9zKSB7XG4gICAgICB2YXIgZHggPSBncG9zWzBdIC0gbWRvd25HUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBncG9zWzFdIC0gbWRvd25HUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIuZGVza3RvcFRhcFRocmVzaG9sZDI7XG4gICAgfVxuXG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcblxuICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24gdXBkYXRlRHJhZ0RlbHRhKCkge1xuICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgeDogcG9zWzBdLFxuICAgICAgeTogcG9zWzFdXG4gICAgfSk7XG5cbiAgICB2YXIgZ29JbnRvQm94TW9kZSA9IGZ1bmN0aW9uIGdvSW50b0JveE1vZGUoKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2JveHN0YXJ0JyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9OyAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuXG5cbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG92ZXIgdGhyZXNob2xkXG4gICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuXG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICB2YXIgZGVsdGFQO1xuXG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbikge1xuICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IChwb3NbMF0gLSBtZFBvc1swXSkgKiB6b29tLFxuICAgICAgICAgICAgeTogKHBvc1sxXSAtIG1kUG9zWzFdKSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjeS5wYW5CeShkZWx0YVApO1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIH0gLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcblxuXG4gICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpOyAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICB9IGVsc2UgaWYgKHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5wYW5uYWJsZSgpKSkge1xuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgKG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkpIHtcbiAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCByLmhvdmVyRGF0YS5kb3ducyk7XG5cbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KG1kb3duUG9zKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoIWRvd24gfHwgIWRvd24uZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlciddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHRha2UgYWN0aW9uXG4gICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikpIHtcbiAgICAgICAgICAgIC8vIGRyYWcgbm9kZVxuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IGN5LmNvbGxlY3Rpb24oKTsgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcblxuICAgICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZW1lbnRzLCB7XG4gICAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyKGRpc3BbMF0pICYmIG51bWJlcihkaXNwWzFdKSkge1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlcihkcmFnRGVsdGFbMF0pICYmIG51bWJlcihkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGRFbGUgPSBkcmFnZ2VkRWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKHIubm9kZUlzRHJhZ2dhYmxlKGRFbGUpICYmIGRFbGUuZ3JhYmJlZCgpKSB7XG4gICAgICAgICAgICAgICAgdG9UcmlnZ2VyLm1lcmdlKGRFbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgICB0b1RyaWdnZXIuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdCgncG9zaXRpb24gZHJhZycpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHByZXZlbnQgdGhlIGRyYWdnaW5nIGZyb20gdHJpZ2dlcmluZyB0ZXh0IHNlbGVjdGlvbiBvbiB0aGUgcGFnZVxuXG5cbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gbW91c2V1cEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiAoIWNhcHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuXG4gICAgaWYgKHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuXG4gICAgaWYgKGRvd24pIHtcbiAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMykge1xuICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgIHZhciBjeHRUYXAgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRUYXApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxKSB7XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnIC8vIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG4gICAgICApIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFsnY2xpY2snLCAndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuXG5cbiAgICAgIGlmIChkb3duID09IG51bGwgJiYgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgJiYgIWlzTXVsdFNlbEtleURvd24oZSkpIHtcbiAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIH0gLy8gU2luZ2xlIHNlbGVjdGlvblxuXG5cbiAgICAgIGlmIChuZWFyID09IGRvd24gJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGlmIChuZWFyICE9IG51bGwgJiYgbmVhci5fcHJpdmF0ZS5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSA7IGVsc2UgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UobmVhcikudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgIGlmIChib3gubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnKSB7XG4gICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShib3gpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICB9IC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG5cblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSAvLyBDYW5jZWwgZHJhZyBwYW5cblxuXG4gICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZWN0WzRdKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgdmFyIGRvd25XYXNHcmFiYmVkID0gZG93biAmJiBkb3duLmdyYWJiZWQoKTtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuXG4gICAgICAgIGlmIChkb3duV2FzR3JhYmJlZCkge1xuICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG5cbiAgICBzZWxlY3RbNF0gPSAwO1xuICAgIHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gZmFsc2U7XG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBudWxsO1xuICB9LCBmYWxzZSk7XG5cbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uIHdoZWVsSGFuZGxlcihlKSB7XG4gICAgaWYgKHIuc2Nyb2xsaW5nUGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBycG9zID0gW3Bvc1swXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLngsIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnldO1xuXG4gICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkpIHtcbiAgICAgIC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChyLmRhdGEud2hlZWxUaW1lb3V0KTtcbiAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgICB2YXIgZGlmZjtcblxuICAgICAgaWYgKGUuZGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MDtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGVlbERlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGFZIC8gMTAwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgfVxuXG4gICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG5cbiAgICAgIGlmIChuZWVkc1doZWVsRml4KSB7XG4gICAgICAgIC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICB9XG5cbiAgICAgIGN5Lnpvb20oe1xuICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcnBvc1swXSxcbiAgICAgICAgICB5OiBycG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTsgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuICAgIGNsZWFyVGltZW91dChyLnNjcm9sbGluZ1BhZ2VUaW1lb3V0KTtcbiAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICB9LCAyNTApO1xuICB9LCB0cnVlKTsgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3V0JywgZnVuY3Rpb24gbW91c2VPdXRIYW5kbGVyKGUpIHtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICByLmN5LmVtaXQoe1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcbiAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuXG4gIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG5cbiAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cblxuICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfTtcblxuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uIGRpc3RhbmNlU3EoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpO1xuICB9O1xuXG4gIHZhciB0b3VjaHN0YXJ0SGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihlKSB7XG4gICAgaWYgKCFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH0gLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuXG5cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoci5kcmFnRGF0YS50b3VjaERyYWdFbGVzKTtcbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHQgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGNlbnRlcjEgPSBbKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyXTtcbiAgICAgIG1vZGVsQ2VudGVyMSA9IFsoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbV07IC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG5cbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkID0gMjAwO1xuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuXG4gICAgICBpZiAoZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgbmVhcjEgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiAobmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG4gICAgICAgIH0gZWxzZSBpZiAobmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgICAgLy8gc2FmYXJpIG9uIGlvcyBwYW5zIHRoZSBwYWdlIG90aGVyd2lzZSAobm9ybWFsbHkgeW91IHNob3VsZCBiZSBhYmxlIHRvIHByZXZlbnRkZWZhdWx0IG9uIHRvdWNobW92ZS4uLilcbiAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG5cbiAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0cyA9IG5lYXJzO1xuXG4gICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IG51bGw7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKHNlbGVjdGVkTm9kZXMsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcobmVhciwge1xuICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICBuLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgIHk6IG5vd1sxXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gLy8gVGFwLCB0YXBob2xkXG4gICAgICAvLyAtLS0tLVxuXG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICBjbGVhclRpbWVvdXQoci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICB2YXIgc1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc1Bvc1tpXSA9IGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3VjaDAgPSBlLnRvdWNoZXNbMF07XG4gICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFt0b3VjaDAuY2xpZW50WCwgdG91Y2gwLmNsaWVudFldO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgdG91Y2htb3ZlSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNobW92ZUhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIHZhciBzdGFydEdQb3MgPSByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbjtcbiAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcblxuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1swXSAmJiBzdGFydEdQb3MpIHtcbiAgICAgIHZhciBkaXNwID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHN0YXJ0R1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydEdQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMjtcbiAgICB9IC8vIGNvbnRleHQgc3dpcGUgY2FuY2VsbGluZ1xuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDsgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG5cbiAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkOyAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG5cbiAgICAgIGlmIChmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EpIHtcbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBjb250ZXh0IHN3aXBlXG5cblxuICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIGJveCBzZWxlY3Rpb25cblxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGlmICghci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2JveHN0YXJ0JyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IHRydWU7XG4gICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICBpZiAoIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDMgKyAxO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDMgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpOyAvLyBwaW5jaCB0byB6b29tXG4gICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBwaW5jaC10by16b29tXG4gICAgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiAoZHJhZ2dlZEVsZXMpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICAgICAgZGVfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgZGVfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDsgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuXG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7IC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG5cbiAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG5cbiAgICAgIGlmICh0d29GaW5nZXJzU3RhcnRJbnNpZGUpIHtcbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxOyAvLyBkZWx0YSBmaW5nZXIgMlxuXG4gICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7IC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcblxuICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpIC8gMjtcbiAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KSAvIDI7IC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cblxuICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpOyAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcblxuICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICB9OyAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG5cbiAgICAgICAgaWYgKF9zdGFydCAmJiBfc3RhcnQuYWN0aXZlKCkpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgICBfc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoJ2ZyZWVvbicpO1xuXG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgX3N0YXJ0LmVtaXQoJ2RyYWdmcmVlb24nKTtcblxuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICBmMnkxID0gZjJ5MjtcbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9IC8vIFJlLXByb2plY3RcblxuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHNpbmdsZSBmaW5nZXIgZXZlbnRzIGxpa2UgcGFubmluZ1xuICAgICkge1xuICAgICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgICB2YXIgbmVhcjtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSAvLyBkcmFnZ2luZyBub2Rlc1xuXG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkpIHtcbiAgICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlcywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIoZGlzcFswXSkgJiYgbnVtYmVyKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcblxuICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdCgncG9zaXRpb24gZHJhZycpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcmlzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHRvdWNobW92ZVxuXG5cbiAgICAgICAge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQgfHwgbmVhciwgWyd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCghc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICBsYXN0LmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdXQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfSAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuXG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwYW5uaW5nXG5cblxuICAgICAgICBpZiAoY2FwdHVyZSAmJiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5wYW5uYWJsZSgpKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChzdGFydCwgci50b3VjaERhdGEuc3RhcnRzKTtcblxuICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICghci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBSZS1wcm9qZWN0XG5cblxuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICB9IC8vIHRoZSBhY3RpdmUgYmcgaW5kaWNhdG9yIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gbWFraW5nIGEgc3dpcGUgdGhhdCBpcyBuZWl0aGVyIGZvciBkcmFnZ2luZyBub2RlcyBvciBwYW5uaW5nXG5cblxuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlcy5sZW5ndGggPiAwICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nICYmIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAhPSBudWxsKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGNhbmNlbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgdG91Y2hlbmRIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3R4VGFwZW5kO1xuXG4gICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgY3R4VGFwZW5kID0ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydC5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3R4VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjdHhUYXApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcblxuXG4gICAgaWYgKCFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICBjeS5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgfTtcblxuICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuXG4gICAgICBpZiAoYm94Lm5vbmVtcHR5KCkpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkgOyBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICBpZiAoc3RhcnRXYXNHcmFiYmVkKSB7XG4gICAgICAgICAgc3RhcnQuZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgc3RhcnQuZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tOyAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcblxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkKSB7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG5cblxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuICAgICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2Uoc3RhcnQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuXG4gICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IHRvdWNoc3RhcnRcblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBudWxsO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGUgb2xkIHN0YXJ0IGdsb2JhbCBwb3MnbiBtYXkgbm90IGJlIHRoZSBzYW1lIGZpbmdlciB0aGF0IHJlbWFpbnNcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXTtcbiAgICAgIH1cblxuICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH0gLy9yLnJlZHJhdygpO1xuXG4gIH0sIGZhbHNlKTsgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcblxuICBpZiAodHlwZW9mIFRvdWNoRXZlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHBvaW50ZXJzID0gW107XG5cbiAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24gbWFrZVRvdWNoKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgcmFkaXVzWDogZS53aWR0aCAvIDIsXG4gICAgICAgIHJhZGl1c1k6IGUuaGVpZ2h0IC8gMixcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uIG1ha2VQb2ludGVyKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYWRkUG9pbnRlciA9IGZ1bmN0aW9uIGFkZFBvaW50ZXIoZSkge1xuICAgICAgcG9pbnRlcnMucHVzaChtYWtlUG9pbnRlcihlKSk7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVQb2ludGVyID0gZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnNbaV07XG5cbiAgICAgICAgaWYgKHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGUpIHtcbiAgICAgIHZhciBwID0gcG9pbnRlcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQ7XG4gICAgICB9KVswXTtcbiAgICAgIHAuZXZlbnQgPSBlO1xuICAgICAgcC50b3VjaCA9IG1ha2VUb3VjaChlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRvdWNoZXNUb0V2ZW50ID0gZnVuY3Rpb24gYWRkVG91Y2hlc1RvRXZlbnQoZSkge1xuICAgICAgZS50b3VjaGVzID0gcG9pbnRlcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnRvdWNoO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBwb2ludGVySXNNb3VzZSA9IGZ1bmN0aW9uIHBvaW50ZXJJc01vdXNlKGUpIHtcbiAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09IDQ7XG4gICAgfTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYWRkUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hzdGFydEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hlbmRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICByZW1vdmVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaGNhbmNlbEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVybW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB1cGRhdGVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaG1vdmVIYW5kbGVyKGUpO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQlJwJGQgPSB7fTtcblxuQlJwJGQuZ2VuZXJhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3BvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlRWxsaXBzZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdlbGxpcHNlJyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiArIHBhZGRpbmcsIGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIGNoZWNrSW5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICAvLyBQcmUtY29tcHV0ZSBjb250cm9sIHBvaW50c1xuICAvLyBTaW5jZSB0aGVzZSBwb2ludHMgZGVwZW5kIG9uIHRoZSByYWRpdXMgbGVuZ3RoICh3aGljaCBpbiB0dXJucyBkZXBlbmQgb24gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSkgd2Ugd2lsbCBvbmx5IHByZS1jb21wdXRlXG4gIC8vIHRoZSB1bml0IHZlY3RvcnMuXG4gIC8vIEZvciBzaW1wbGljaXR5IHRoZSBsYXlvdXQgd2lsbCBiZTpcbiAgLy8gWyBwMCwgVW5pdFZlY3RvclAwUDEsIHAxLCBVbmlWZWN0b3JQMVAyLCAuLi4sIHBuLCBVbml0VmVjdG9yUG5QMCBdXG4gIHZhciBhbGxQb2ludHMgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHZhciBzb3VyY2VJbmRleCA9IGkgKiAyO1xuICAgIHZhciBkZXN0SW5kZXggPSB2b2lkIDA7XG5cbiAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgZGVzdEluZGV4ID0gKGkgKyAxKSAqIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgYWxsUG9pbnRzW2kgKiA0XSA9IHBvaW50c1tzb3VyY2VJbmRleF07XG4gICAgYWxsUG9pbnRzW2kgKiA0ICsgMV0gPSBwb2ludHNbc291cmNlSW5kZXggKyAxXTtcbiAgICB2YXIgeERlc3QgPSBwb2ludHNbZGVzdEluZGV4XSAtIHBvaW50c1tzb3VyY2VJbmRleF07XG4gICAgdmFyIHlEZXN0ID0gcG9pbnRzW2Rlc3RJbmRleCArIDFdIC0gcG9pbnRzW3NvdXJjZUluZGV4ICsgMV07XG4gICAgdmFyIG5vcm0gPSBNYXRoLnNxcnQoeERlc3QgKiB4RGVzdCArIHlEZXN0ICogeURlc3QpO1xuICAgIGFsbFBvaW50c1tpICogNCArIDJdID0geERlc3QgLyBub3JtO1xuICAgIGFsbFBvaW50c1tpICogNCArIDNdID0geURlc3QgLyBub3JtO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBvaW50czogYWxsUG9pbnRzLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdyb3VuZC1wb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgZGlhbSA9IGNvcm5lclJhZGl1cyAqIDI7IC8vIENoZWNrIGhCb3hcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydjdXQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2N1dHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdjdXQtcmVjdGFuZ2xlJyxcbiAgICBjb3JuZXJMZW5ndGg6IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBjbCA9IHRoaXMuY29ybmVyTGVuZ3RoO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDsgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIHRyaWFuZ2xlIHB0IG9uIFs0LCA1XVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBjbCwgeEJlZ2luICsgY2wsIHlCZWdpbiwgeEJlZ2luICsgY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gY2wsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgY2wsIHhFbmQgLSBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBjbCwgeEVuZCAtIGNsLCB5RW5kLCB4RW5kIC0gY2wsIHlFbmQgLSBjbF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyBjbCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gY2wsIHhCZWdpbiArIGNsLCB5RW5kIC0gY2xdXG4gICAgICB9O1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHZhciBjUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdC5hcHBseShbXSwgW2NQdHMudG9wTGVmdC5zcGxpY2UoMCwgNCksIGNQdHMudG9wUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbVJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21MZWZ0LnNwbGljZSgwLCA0KV0pO1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiB0aGlzLmNvcm5lckxlbmd0aCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB0aGlzLmNvcm5lckxlbmd0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1dFRyaWFuZ2xlUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BMZWZ0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21SaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbUxlZnQpO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlQmFycmVsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydiYXJyZWwnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYmFycmVsJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIC8vIHVzZSB0d28gZml4ZWQgdCB2YWx1ZXMgZm9yIHRoZSBiZXppZXIgY3VydmUgYXBwcm94aW1hdGlvblxuICAgICAgdmFyIHQwID0gMC4xNTtcbiAgICAgIHZhciB0MSA9IDAuNTtcbiAgICAgIHZhciB0MiA9IDAuODU7XG4gICAgICB2YXIgYlB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG5cbiAgICAgIHZhciBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzID0gZnVuY3Rpb24gYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhwdHMpIHtcbiAgICAgICAgLy8gYXBwcm94aW1hdGUgY3VydmUgcHRzIGJhc2VkIG9uIHRoZSB0d28gdCB2YWx1ZXNcbiAgICAgICAgdmFyIG0wID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDApO1xuICAgICAgICB2YXIgbTEgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0MSk7XG4gICAgICAgIHZhciBtMiA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQyKTtcbiAgICAgICAgcmV0dXJuIFtwdHNbMF0sIHB0c1sxXSwgbTAueCwgbTAueSwgbTEueCwgbTEueSwgbTIueCwgbTIueSwgcHRzWzRdLCBwdHNbNV1dO1xuICAgICAgfTtcblxuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdChhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wTGVmdCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BSaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21SaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21MZWZ0KSk7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7XG4gICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgICAgIHZhciBjdHJsUHRYT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd2lkdGg7IC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSBjb250cm9sIHB0IG9uIFs0LCA1XVxuXG4gICAgICB2YXIgcHRzID0ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0LCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbl0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIHdPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgaE9mZnNldF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGhPZmZzZXQsIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kIC0gd09mZnNldCwgeUVuZF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0XVxuICAgICAgfTtcbiAgICAgIHB0cy50b3BMZWZ0LmlzVG9wID0gdHJ1ZTtcbiAgICAgIHB0cy50b3BSaWdodC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tTGVmdC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tUmlnaHQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcmV0dXJuIHB0cztcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7IC8vIENoZWNrIGhCb3hcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBoT2Zmc2V0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHdPZmZzZXQsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXJyZWxDdXJ2ZVB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIHZhciBnZXRDdXJ2ZVQgPSBmdW5jdGlvbiBnZXRDdXJ2ZVQoeCwgeSwgY3VydmVQdHMpIHtcbiAgICAgICAgdmFyIHgwID0gY3VydmVQdHNbNF07XG4gICAgICAgIHZhciB4MSA9IGN1cnZlUHRzWzJdO1xuICAgICAgICB2YXIgeDIgPSBjdXJ2ZVB0c1swXTtcbiAgICAgICAgdmFyIHkwID0gY3VydmVQdHNbNV07IC8vIHZhciB5MSA9IGN1cnZlUHRzWyAzIF07XG5cbiAgICAgICAgdmFyIHkyID0gY3VydmVQdHNbMV07XG4gICAgICAgIHZhciB4TWluID0gTWF0aC5taW4oeDAsIHgyKTtcbiAgICAgICAgdmFyIHhNYXggPSBNYXRoLm1heCh4MCwgeDIpO1xuICAgICAgICB2YXIgeU1pbiA9IE1hdGgubWluKHkwLCB5Mik7XG4gICAgICAgIHZhciB5TWF4ID0gTWF0aC5tYXgoeTAsIHkyKTtcblxuICAgICAgICBpZiAoeE1pbiA8PSB4ICYmIHggPD0geE1heCAmJiB5TWluIDw9IHkgJiYgeSA8PSB5TWF4KSB7XG4gICAgICAgICAgdmFyIGNvZWZmID0gYmV6aWVyUHRzVG9RdWFkQ29lZmYoeDAsIHgxLCB4Mik7XG4gICAgICAgICAgdmFyIHJvb3RzID0gc29sdmVRdWFkcmF0aWMoY29lZmZbMF0sIGNvZWZmWzFdLCBjb2VmZlsyXSwgeCk7XG4gICAgICAgICAgdmFyIHZhbGlkUm9vdHMgPSByb290cy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHZhbGlkUm9vdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkUm9vdHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY3VydmVSZWdpb25zID0gT2JqZWN0LmtleXMoYmFycmVsQ3VydmVQdHMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlUmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29ybmVyID0gY3VydmVSZWdpb25zW2ldO1xuICAgICAgICB2YXIgY29ybmVyUHRzID0gYmFycmVsQ3VydmVQdHNbY29ybmVyXTtcbiAgICAgICAgdmFyIHQgPSBnZXRDdXJ2ZVQoeCwgeSwgY29ybmVyUHRzKTtcblxuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeTAgPSBjb3JuZXJQdHNbNV07XG4gICAgICAgIHZhciB5MSA9IGNvcm5lclB0c1szXTtcbiAgICAgICAgdmFyIHkyID0gY29ybmVyUHRzWzFdO1xuICAgICAgICB2YXIgYmV6WSA9IHFiZXppZXJBdCh5MCwgeTEsIHkyLCB0KTtcblxuICAgICAgICBpZiAoY29ybmVyUHRzLmlzVG9wICYmIGJlelkgPD0geSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc0JvdHRvbSAmJiB5IDw9IGJlelkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJGQuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYm90dG9tLXJvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydib3R0b21yb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcblxuICAgICAgaWYgKHRvcEludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdG9wSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgZGlhbSA9IDIgKiBjb3JuZXJSYWRpdXM7IC8vIENoZWNrIGhCb3hcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIGRpYW0sIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBjaGVjayBub24tcm91bmRlZCB0b3Agc2lkZVxuXG5cbiAgICAgIHZhciBvdXRlcldpZHRoID0gd2lkdGggLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQgLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgcG9pbnRzID0gW2NlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHQsIGNlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodF07XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuQlJwJGQucmVnaXN0ZXJOb2RlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICB0aGlzLmdlbmVyYXRlRWxsaXBzZSgpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyZWN0YW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkpO1xuICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddO1xuICB0aGlzLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUN1dFJlY3RhbmdsZSgpO1xuICB0aGlzLmdlbmVyYXRlQmFycmVsKCk7XG4gIHRoaXMuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSgpO1xuICB7XG4gICAgdmFyIGRpYW1vbmRQb2ludHMgPSBbMCwgMSwgMSwgMCwgMCwgLTEsIC0xLCAwXTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWRpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgfVxuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1wZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ29jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1vY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7IC8vIE91dGVyIHJhZGl1cyBpcyAxOyBpbm5lciByYWRpdXMgb2Ygc3RhciBpcyBzbWFsbGVyXG5cbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCg1KSk7XG4gICAgaW5uZXJSYWRpdXMgKj0gMS41NztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpbm5lclBvaW50c1tpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1tpICogMiArIDFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjAgLyA0OyBpKyspIHtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0XSA9IG91dGVyUG9pbnRzW2kgKiAyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMV0gPSBvdXRlclBvaW50c1tpICogMiArIDFdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAyXSA9IGlubmVyUG9pbnRzW2kgKiAyXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgM10gPSBpbm5lclBvaW50c1tpICogMiArIDFdO1xuICAgIH1cbiAgfVxuICBzdGFyNVBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShzdGFyNVBvaW50cyk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdzdGFyJywgc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndmVlJywgWy0xLCAtMSwgMCwgLTAuMzMzLCAxLCAtMSwgMCwgMV0pO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmhvbWJvaWQnLCBbLTEsIC0xLCAwLjMzMywgLTEsIDEsIDEsIC0wLjMzMywgMV0pO1xuICB0aGlzLm5vZGVTaGFwZXNbJ2NvbmNhdmVoZXhhZ29uJ10gPSB0aGlzLmdlbmVyYXRlUG9seWdvbignY29uY2F2ZS1oZXhhZ29uJywgWy0xLCAtMC45NSwgLTAuNzUsIDAsIC0xLCAwLjk1LCAxLCAwLjk1LCAwLjc1LCAwLCAxLCAtMC45NV0pO1xuICB7XG4gICAgdmFyIHRhZ1BvaW50cyA9IFstMSwgLTEsIDAuMjUsIC0xLCAxLCAwLCAwLjI1LCAxLCAtMSwgMV07XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RhZycsIHRhZ1BvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdGFnJywgdGFnUG9pbnRzKTtcbiAgfVxuXG4gIG5vZGVTaGFwZXMubWFrZVBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgLy8gdXNlIGNhY2hpbmcgb24gdXNlci1zcGVjaWZpZWQgcG9seWdvbnMgc28gdGhleSBhcmUgYXMgZmFzdCBhcyBuYXRpdmUgc2hhcGVzXG4gICAgdmFyIGtleSA9IHBvaW50cy5qb2luKCckJyk7XG4gICAgdmFyIG5hbWUgPSAncG9seWdvbi0nICsga2V5O1xuICAgIHZhciBzaGFwZTtcblxuICAgIGlmIChzaGFwZSA9IHRoaXNbbmFtZV0pIHtcbiAgICAgIC8vIGdvdCBjYWNoZWQgc2hhcGVcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG5cblxuICAgIHJldHVybiByZW5kZXJlci5nZW5lcmF0ZVBvbHlnb24obmFtZSwgcG9pbnRzKTtcbiAgfTtcbn07XG5cbnZhciBCUnAkZSA9IHt9O1xuXG5CUnAkZS50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG59O1xuXG5CUnAkZS5yZWRyYXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSAwO1xuICB9XG5cbiAgaWYgKHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdFJlZHJhd1RpbWUgPSAwO1xuICB9XG5cbiAgaWYgKHIubGFzdERyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3REcmF3VGltZSA9IDA7XG4gIH1cblxuICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbkJScCRlLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChmbiwgcHJpb3JpdHkpIHtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJpb3JpdHkgPT0gbnVsbCkge1xuICAgIGVycm9yKCdQcmlvcml0eSBpcyBub3Qgb3B0aW9uYWwgZm9yIGJlZm9yZVJlbmRlcicpO1xuICB9XG5cbiAgdmFyIGNicyA9IHRoaXMuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuICBjYnMucHVzaCh7XG4gICAgZm46IGZuLFxuICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICB9KTsgLy8gaGlnaGVyIHByaW9yaXR5IGNhbGxiYWNrcyBleGVjdXRlZCBmaXJzdFxuXG4gIGNicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5O1xuICB9KTtcbn07XG5cbnZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBiZWZvcmVSZW5kZXJDYWxsYmFja3Mociwgd2lsbERyYXcsIHN0YXJ0VGltZSkge1xuICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICBjYnNbaV0uZm4od2lsbERyYXcsIHN0YXJ0VGltZSk7XG4gIH1cbn07XG5cbkJScCRlLnN0YXJ0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuXG4gIGlmIChyLnJlbmRlckxvb3BTdGFydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHIucmVuZGVyTG9vcFN0YXJ0ZWQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHJlbmRlckZuID0gZnVuY3Rpb24gcmVuZGVyRm4ocmVxdWVzdFRpbWUpIHtcbiAgICBpZiAoci5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkgOyBlbHNlIGlmIChyLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSkge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHRydWUsIHJlcXVlc3RUaW1lKTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgci5yZW5kZXIoci5yZW5kZXJPcHRpb25zKTtcbiAgICAgIHZhciBlbmRUaW1lID0gci5sYXN0RHJhd1RpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgIGlmIChyLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGR1cmF0aW9uO1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGR1cmF0aW9uOyAvLyB1c2UgYSB3ZWlnaHRlZCBhdmVyYWdlIHdpdGggYSBiaWFzIGZyb20gdGhlIHByZXZpb3VzIGF2ZXJhZ2Ugc28gd2UgZG9uJ3Qgc3Bpa2Ugc28gZWFzaWx5XG5cbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lIC8gMiArIGR1cmF0aW9uIC8gMjtcbiAgICAgIHIucmVxdWVzdGVkRnJhbWUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIGZhbHNlLCByZXF1ZXN0VGltZSk7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xuICB9O1xuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGbik7XG59O1xuXG52YXIgQmFzZVJlbmRlcmVyID0gZnVuY3Rpb24gQmFzZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5pbml0KG9wdGlvbnMpO1xufTtcblxudmFyIEJSID0gQmFzZVJlbmRlcmVyO1xudmFyIEJScCRmID0gQlIucHJvdG90eXBlO1xuQlJwJGYuY2xpZW50RnVuY3Rpb25zID0gWydyZWRyYXdIaW50JywgJ3JlbmRlcicsICdyZW5kZXJUbycsICdtYXRjaENhbnZhc1NpemUnLCAnbm9kZVNoYXBlSW1wbCcsICdhcnJvd1NoYXBlSW1wbCddO1xuXG5CUnAkZi5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLm9wdGlvbnMgPSBvcHRpb25zO1xuICByLmN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGN0ciA9IHIuY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTsgLy8gcHJlcGVuZCBhIHN0eWxlc2hlZXQgaW4gdGhlIGhlYWQgc3VjaCB0aGF0XG5cbiAgaWYgKHdpbmRvdyQxKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93JDEuZG9jdW1lbnQ7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgIHZhciBzdHlsZXNoZWV0SWQgPSAnX19fX19fX19fX2N5dG9zY2FwZV9zdHlsZXNoZWV0JztcbiAgICB2YXIgY2xhc3NOYW1lID0gJ19fX19fX19fX19jeXRvc2NhcGVfY29udGFpbmVyJztcbiAgICB2YXIgc3R5bGVzaGVldEFscmVhZHlFeGlzdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZXNoZWV0SWQpICE9IG51bGw7XG5cbiAgICBpZiAoY3RyLmNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgPCAwKSB7XG4gICAgICBjdHIuY2xhc3NOYW1lID0gKGN0ci5jbGFzc05hbWUgfHwgJycpICsgJyAnICsgY2xhc3NOYW1lO1xuICAgIH1cblxuICAgIGlmICghc3R5bGVzaGVldEFscmVhZHlFeGlzdHMpIHtcbiAgICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlc2hlZXQuaWQgPSBzdHlsZXNoZWV0SWQ7XG4gICAgICBzdHlsZXNoZWV0LmlubmVySFRNTCA9ICcuJyArIGNsYXNzTmFtZSArICcgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0nO1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVzaGVldCwgaGVhZC5jaGlsZHJlblswXSk7IC8vIGZpcnN0IHNvIGxvd2VzdCBwcmlvcml0eVxuICAgIH1cblxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjdHIpO1xuICAgIHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHdhcm4oJ0EgQ3l0b3NjYXBlIGNvbnRhaW5lciBoYXMgc3R5bGUgcG9zaXRpb246c3RhdGljIGFuZCBzbyBjYW4gbm90IHVzZSBVSSBleHRlbnNpb25zIHByb3Blcmx5Jyk7XG4gICAgfVxuICB9XG5cbiAgci5zZWxlY3Rpb24gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwXTsgLy8gQ29vcmRpbmF0ZXMgZm9yIHNlbGVjdGlvbiBib3gsIHBsdXMgZW5hYmxlZCBmbGFnXG5cbiAgci5iZXppZXJQcm9qUGN0cyA9IFswLjA1LCAwLjIyNSwgMC40LCAwLjUsIDAuNiwgMC43NzUsIDAuOTVdOyAvLy0tUG9pbnRlci1yZWxhdGVkIGRhdGFcblxuICByLmhvdmVyRGF0YSA9IHtcbiAgICBkb3duOiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgZG93blRpbWU6IG51bGwsXG4gICAgdHJpZ2dlck1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSxcbiAgICBjYXB0dXJlOiBmYWxzZVxuICB9O1xuICByLmRyYWdEYXRhID0ge1xuICAgIHBvc3NpYmxlRHJhZ0VsZW1lbnRzOiBbXVxuICB9O1xuICByLnRvdWNoRGF0YSA9IHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAvLyBUaGVzZSAzIGZpZWxkcyByZWxhdGVkIHRvIHRhcCwgdGFwaG9sZCBldmVudHNcbiAgICBzdGFydFBvc2l0aW9uOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgc2luZ2xlVG91Y2hNb3ZlZDogdHJ1ZSxcbiAgICBub3c6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgfTtcbiAgci5yZWRyYXdzID0gMDtcbiAgci5zaG93RnBzID0gb3B0aW9ucy5zaG93RnBzO1xuICByLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgci5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG5cbiAgci5mb3JjZWRQaXhlbFJhdGlvID0gbnVtYmVyKG9wdGlvbnMucGl4ZWxSYXRpbykgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiBudWxsO1xuICByLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG5cbiAgci5tb3Rpb25CbHVyT3BhY2l0eSA9IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSByLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgci5tYlB4UkJsdXJyeSA9IDE7IC8vMC44O1xuXG4gIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzID0ge1xuICAgIC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgYW5pbWF0aW9uczogNDAwLFxuICAgIGVsZUNhbGNzOiAzMDAsXG4gICAgZWxlVHhyRGVxOiAyMDAsXG4gICAgbHlyVHhyRGVxOiAxNTAsXG4gICAgbHlyVHhyU2tpcDogMTAwXG4gIH07XG4gIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbn07XG5cbkJScCRmLm5vdGlmeSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsZXMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5OyAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgbm90aWZpZWQgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnaW5pdCcpIHtcbiAgICByLmxvYWQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnZGVzdHJveScpIHtcbiAgICByLmRlc3Ryb3koKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnYWRkJyB8fCBldmVudE5hbWUgPT09ICdyZW1vdmUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdmUnICYmIGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSB8fCBldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICd6b3JkZXInIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgIHIuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICdyZXNpemUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICB9XG5cbiAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICB0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuQlJwJGYuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLmRlc3Ryb3llZCA9IHRydWU7XG4gIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbaV07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcbiAgICAodGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikuYXBwbHkodGd0LCBiLmFyZ3MpO1xuICB9XG5cbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcblxuICBpZiAoci5yZW1vdmVPYnNlcnZlcikge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIuc3R5bGVPYnNlcnZlcikge1xuICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBpZiAoci5yZXNpemVPYnNlcnZlcikge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIubGFiZWxDYWxjRGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoci5sYWJlbENhbGNEaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfSBjYXRjaCAoZSkgey8vIGllMTAgaXNzdWUgIzEwMTRcbiAgICB9XG4gIH1cbn07XG5cbkJScCRmLmlzSGVhZGxlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbltCUnAsIEJScCRhLCBCUnAkYiwgQlJwJGMsIEJScCRkLCBCUnAkZV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKEJScCRmLCBwcm9wcyk7XG59KTtcblxudmFyIGZ1bGxGcHNUaW1lID0gMTAwMCAvIDYwOyAvLyBhc3N1bWUgNjAgZnJhbWVzIHBlciBzZWNvbmRcblxudmFyIGRlZnMgPSB7XG4gIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nKG9wdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcblxuICAgICAgaWYgKHNlbGYuZGVxdWV1ZWluZ1NldHVwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZGVxdWV1ZWluZ1NldHVwID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHF1ZXVlUmVkcmF3ID0gdXRpbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIG9wdHMuZGVxUmVkcmF3VGhyZXNob2xkKTtcblxuICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpOyAvLyBpZiB3ZSBhcmVuJ3QgaW4gYSB0aWNrIHRoYXQgY2F1c2VzIGEgZHJhdywgdGhlbiB0aGUgcmVuZGVyZWQgc3R5bGVcbiAgICAgICAgLy8gcXVldWUgd29uJ3QgYXV0b21hdGljYWxseSBiZSBmbHVzaGVkIGJlZm9yZSBkZXF1ZXVlaW5nIHN0YXJ0c1xuXG4gICAgICAgIGlmICghd2lsbERyYXcpIHtcbiAgICAgICAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gbm93IC0gZnJhbWVTdGFydFRpbWU7XG5cbiAgICAgICAgICBpZiAocmVuZGVyVGltZSA8IGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSByZW5kZXJpbmcgZmFzdGVyIHRoYW4gdGhlIGlkZWFsIGZwcywgdGhlbiBkbyBkZXF1ZXVlaW5nXG4gICAgICAgICAgICAvLyBkdXJpbmcgYWxsIG9mIHRoZSByZW1haW5pbmcgZnJhbWUgdGltZVxuICAgICAgICAgICAgdmFyIHRpbWVBdmFpbGFibGUgPSBmdWxsRnBzVGltZSAtICh3aWxsRHJhdyA/IGF2Z1JlbmRlclRpbWUgOiAwKTtcblxuICAgICAgICAgICAgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFGYXN0Q29zdCAqIHRpbWVBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gb3B0cy5kZXFDb3N0ICogcmVuZGVyVGltZSB8fCBkdXJhdGlvbiA+PSBvcHRzLmRlcUF2Z0Nvc3QgKiBhdmdSZW5kZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcU5vRHJhd0Nvc3QgKiBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcShzZWxmLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuXG4gICAgICAgICAgaWYgKHRoaXNEZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGVxZC5wdXNoKHRoaXNEZXFkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG5cblxuICAgICAgICBpZiAoZGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0cy5vbkRlcWQoc2VsZiwgZGVxZCk7XG5cbiAgICAgICAgICBpZiAoIXdpbGxEcmF3ICYmIG9wdHMuc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCkpIHtcbiAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJpb3JpdHkgPSBvcHRzLnByaW9yaXR5IHx8IG5vb3A7XG4gICAgICByLmJlZm9yZVJlbmRlcihkZXF1ZXVlLCBwcmlvcml0eShzZWxmKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLy8gVXNlcyBrZXlzIHNvIGVsZW1lbnRzIG1heSBzaGFyZSB0aGUgc2FtZSBjYWNoZS5cblxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKGdldEtleSkge1xuICAgIHZhciBkb2VzRWxlSW52YWxpZGF0ZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2lmeTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKTtcblxuICAgIHRoaXMuaWRzQnlLZXkgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmtleUZvcklkID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5jYWNoZXNCeUx2bCA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMubHZscyA9IFtdO1xuICAgIHRoaXMuZ2V0S2V5ID0gZ2V0S2V5O1xuICAgIHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkgPSBkb2VzRWxlSW52YWxpZGF0ZUtleTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwLCBbe1xuICAgIGtleTogXCJnZXRJZHNGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzRm9yKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKFwiQ2FuIG5vdCBnZXQgaWQgbGlzdCBmb3IgbnVsbCBrZXlcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHNCeUtleSA9IHRoaXMuaWRzQnlLZXk7XG4gICAgICB2YXIgaWRzID0gdGhpcy5pZHNCeUtleS5nZXQoa2V5KTtcblxuICAgICAgaWYgKCFpZHMpIHtcbiAgICAgICAgaWRzID0gbmV3IFNldCQxKCk7XG4gICAgICAgIGlkc0J5S2V5LnNldChrZXksIGlkcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZElkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpLmFkZChpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUlkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUlkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyT2ZJZHNGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJZHNGb3Ioa2V5KS5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICB0aGlzLmFkZElkRm9yS2V5KGN1cnJLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWQuc2V0KGlkLCBjdXJyS2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5rZXlGb3JJZFtcImRlbGV0ZVwiXShpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleUhhc0NoYW5nZWRGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5SGFzQ2hhbmdlZEZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB2YXIgbmV3S2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiBwcmV2S2V5ICE9PSBuZXdLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW52YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludmFsaWQoZWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlIYXNDaGFuZ2VkRm9yKGVsZSkgfHwgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZXNBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZXNBdChsdmwpIHtcbiAgICAgIHZhciBjYWNoZXNCeUx2bCA9IHRoaXMuY2FjaGVzQnlMdmwsXG4gICAgICAgICAgbHZscyA9IHRoaXMubHZscztcbiAgICAgIHZhciBjYWNoZXMgPSBjYWNoZXNCeUx2bC5nZXQobHZsKTtcblxuICAgICAgaWYgKCFjYWNoZXMpIHtcbiAgICAgICAgY2FjaGVzID0gbmV3IE1hcCQxKCk7XG4gICAgICAgIGNhY2hlc0J5THZsLnNldChsdmwsIGNhY2hlcyk7XG4gICAgICAgIGx2bHMucHVzaChsdmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZShrZXksIGx2bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5nZXQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTsgLy8gZ2V0dGluZyBmb3IgYW4gZWxlbWVudCBtYXkgbmVlZCB0byBhZGQgdG8gdGhlIGlkIGxpc3QgYi9jIGVsZXMgY2FuIHNoYXJlIGtleXNcblxuICAgICAgaWYgKGNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9yQ2FjaGVkS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvckNhY2hlZEtleShlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGVsZS5pZCgpKTsgLy8gbi5iLiB1c2UgY2FjaGVkIGtleSwgbm90IG5ld2x5IGNvbXB1dGVkIGtleVxuXG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuaGFzKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFzQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpIHtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5zZXQoa2V5LCBjYWNoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoZWxlLCBsdmwsIGNhY2hlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKTtcbiAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDYWNoZShrZXksIGx2bCkge1xuICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmx2bHMuZm9yRWFjaChmdW5jdGlvbiAobHZsKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgICB9KTtcbiAgICB9IC8vIHJldHVybnMgdHJ1ZSBpZiBubyBvdGhlciBlbGVzIHJlZmVyZW5jZSB0aGUgaW52YWxpZGF0ZWQgY2FjaGUgKG4uYi4gb3RoZXIgZWxlcyBtYXkgbmVlZCB0aGUgY2FjaGUgd2l0aCB0aGUgc2FtZSBrZXkpXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7IC8vIG4uYi4gdXNlIHN0b3JlZCBrZXkgcmF0aGVyIHRoYW4gY3VycmVudCAocG90ZW50aWFsIGtleSlcblxuICAgICAgdGhpcy5kZWxldGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB2YXIgZW50aXJlS2V5SW52YWxpZGF0ZWQgPSB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG5cbiAgICAgIGlmIChlbnRpcmVLZXlJbnZhbGlkYXRlZCkge1xuICAgICAgICAvLyBjbGVhciBtYXBwaW5nIGZvciBjdXJyZW50IGtleVxuICAgICAgICB0aGlzLmludmFsaWRhdGVLZXkoa2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudGlyZUtleUludmFsaWRhdGVkIHx8IHRoaXMuZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSA9PT0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cDtcbn0oKTtcblxudmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG5cbnZhciB0eHJTdGVwSCA9IDUwOyAvLyB0aGUgbWluIHNpemUgb2YgdGhlIHJlZ3VsYXIgY2FjaGUsIGFuZCB0aGUgc2l6ZSBpdCBpbmNyZWFzZXMgd2l0aCBlYWNoIHN0ZXAgdXBcblxudmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcblxudmFyIG1heEx2bCA9IDM7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxudmFyIG1heFpvb20gPSA3Ljk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxuXG52YXIgZWxlVHhyU3BhY2luZyA9IDg7IC8vIHNwYWNpbmcgYmV0d2VlbiBlbGVtZW50cyBvbiB0ZXh0dXJlcyB0byBhdm9pZCBibGl0dGluZyBvdmVybGFwc1xuXG52YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxuXG52YXIgbWF4VHhyVyA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgdGV4dHVyZVxuXG52YXIgbWF4VHhySCA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHRleHR1cmVcblxudmFyIG1pblV0aWxpdHkgPSAwLjI7IC8vIGlmIHVzYWdlIG9mIHRleHR1cmUgaXMgbGVzcyB0aGFuIHRoaXMsIGl0IGlzIHJldGlyZWRcblxudmFyIG1heEZ1bGxuZXNzID0gMC44OyAvLyBmdWxsbmVzcyBvZiB0ZXh0dXJlIGFmdGVyIHdoaWNoIHF1ZXVlIHJlbW92YWwgaXMgY2hlY2tlZFxuXG52YXIgbWF4RnVsbG5lc3NDaGVja3MgPSAxMDsgLy8gZGVxdWV1ZWQgYWZ0ZXIgdGhpcyBtYW55IGNoZWNrc1xuXG52YXIgZGVxQ29zdCA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxuXG52YXIgZGVxQXZnQ29zdCA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG5cbnZhciBkZXFGYXN0Q29zdCA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcblxudmFyIGRlcVJlZHJhd1RocmVzaG9sZCA9IDEwMDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcblxudmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgZ2V0VHhyUmVhc29ucyA9IHtcbiAgZGVxdWV1ZTogJ2RlcXVldWUnLFxuICBkb3duc2NhbGU6ICdkb3duc2NhbGUnLFxuICBoaWdoUXVhbGl0eTogJ2hpZ2hRdWFsaXR5J1xufTtcbnZhciBpbml0RGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIGdldEtleTogbnVsbCxcbiAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGZhbHNpZnksXG4gIGRyYXdFbGVtZW50OiBudWxsLFxuICBnZXRCb3VuZGluZ0JveDogbnVsbCxcbiAgZ2V0Um90YXRpb25Qb2ludDogbnVsbCxcbiAgZ2V0Um90YXRpb25PZmZzZXQ6IG51bGwsXG4gIGlzVmlzaWJsZTogdHJ1ZWlmeSxcbiAgYWxsb3dFZGdlVHhyQ2FjaGluZzogdHJ1ZSxcbiAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiB0cnVlXG59KTtcblxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlKHJlbmRlcmVyLCBpbml0T3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgc2VsZi5vbkRlcXVldWVzID0gW107XG4gIHZhciBvcHRzID0gaW5pdERlZmF1bHRzKGluaXRPcHRpb25zKTtcbiAgZXh0ZW5kKHNlbGYsIG9wdHMpO1xuICBzZWxmLmxvb2t1cCA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKG9wdHMuZ2V0S2V5LCBvcHRzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KTtcbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG5cbnZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5FVENwLnJlYXNvbnMgPSBnZXRUeHJSZWFzb25zOyAvLyB0aGUgbGlzdCBvZiB0ZXh0dXJlcyBpbiB3aGljaCBuZXcgc3VidGV4dHVyZXMgZm9yIGVsZW1lbnRzIGNhbiBiZSBwbGFjZWRcblxuRVRDcC5nZXRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiAodHhySCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWxlSW1nQ2FjaGVzID0gc2VsZi5lbGVJbWdDYWNoZXMgfHwge307XG4gIHJldHVybiBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSA9IHNlbGYuZWxlSW1nQ2FjaGVzW3R4ckhdIHx8IFtdO1xufTsgLy8gdGhlIGxpc3Qgb2YgdXN1c2VkIHRleHR1cmVzIHdoaWNoIGNhbiBiZSByZWN5Y2xlZCAoaW4gdXNlIGluIHRleHR1cmUgcXVldWUpXG5cblxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnR4dHJRcyA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkIHx8IHt9O1xuICB2YXIgcnR4dHJRID0gcnR4dHJRc1t0eHJIXSA9IHJ0eHRyUXNbdHhySF0gfHwgW107XG4gIHJldHVybiBydHh0clE7XG59OyAvLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVsc1xuXG5cbkVUQ3AuZ2V0RWxlbWVudFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5lbGVDYWNoZVF1ZXVlID0gc2VsZi5lbGVDYWNoZVF1ZXVlIHx8IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfSk7XG4gIHJldHVybiBxO1xufTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHMgKGVsZW1lbnQgaWQgbG9va3VwKVxuXG5cbkVUQ3AuZ2V0RWxlbWVudEtleVRvUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGsycSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgfHwge307XG4gIHJldHVybiBrMnE7XG59O1xuXG5FVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDtcblxuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8IGlzTmFOKGJiLncpIHx8IGlzTmFOKGJiLmgpIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXNlbGYuYWxsb3dFZGdlVHhyQ2FjaGluZyAmJiBlbGUuaXNFZGdlKCkgfHwgIXNlbGYuYWxsb3dQYXJlbnRUeHJDYWNoaW5nICYmIGVsZS5pc1BhcmVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuICB9XG5cbiAgaWYgKGx2bCA8IG1pbkx2bCkge1xuICAgIGx2bCA9IG1pbkx2bDtcbiAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20gfHwgbHZsID4gbWF4THZsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUsIHNjYWxlKTtcblxuICBpZiAoIXRoaXMuaXNWaXNpYmxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlbGVDYWNoZSA9IGxvb2t1cC5nZXQoZWxlLCBsdmwpOyAvLyBpZiB0aGlzIGdldCB3YXMgb24gYW4gdW51c2VkL2ludmFsaWRhdGVkIGNhY2hlLCB0aGVuIHJlc3RvcmUgdGhlIHRleHR1cmUgdXNhZ2UgbWV0cmljXG5cbiAgaWYgKGVsZUNhY2hlICYmIGVsZUNhY2hlLmludmFsaWRhdGVkKSB7XG4gICAgZWxlQ2FjaGUuaW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICBlbGVDYWNoZS50ZXh0dXJlLmludmFsaWRhdGVkV2lkdGggLT0gZWxlQ2FjaGUud2lkdGg7XG4gIH1cblxuICBpZiAoZWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gZWxlQ2FjaGU7XG4gIH1cblxuICB2YXIgdHhySDsgLy8gd2hpY2ggdGV4dHVyZSBoZWlnaHQgdGhpcyBlbGUgYmVsb25ncyB0b1xuXG4gIGlmIChlbGVTY2FsZWRIIDw9IG1pblR4ckgpIHtcbiAgICB0eHJIID0gbWluVHhySDtcbiAgfSBlbHNlIGlmIChlbGVTY2FsZWRIIDw9IHR4clN0ZXBIKSB7XG4gICAgdHhySCA9IHR4clN0ZXBIO1xuICB9IGVsc2Uge1xuICAgIHR4ckggPSBNYXRoLmNlaWwoZWxlU2NhbGVkSCAvIHR4clN0ZXBIKSAqIHR4clN0ZXBIO1xuICB9XG5cbiAgaWYgKGVsZVNjYWxlZEggPiBtYXhUeHJIIHx8IGVsZVNjYWxlZFcgPiBtYXhUeHJXKSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIGNhY2hpbmcgbGFyZ2UgZWxlbWVudHMgaXMgbm90IGVmZmljaWVudFxuICB9XG5cbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTsgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuXG4gIHZhciB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMl07XG5cbiAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uIGFkZE5ld1R4cigpIHtcbiAgICByZXR1cm4gc2VsZi5yZWN5Y2xlVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKSB8fCBzZWxmLmFkZFRleHR1cmUodHhySCwgZWxlU2NhbGVkVyk7XG4gIH07IC8vIHRyeSB0aGUgbGFzdCBvbmUgaWYgdGhlcmUgaXMgbm8gc2Vjb25kIGxhc3Qgb25lXG5cblxuICBpZiAoIXR4cikge1xuICAgIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAxXTtcbiAgfSAvLyBpZiB0aGUgbGFzdCBvbmUgZG9lc24ndCBleGlzdCwgd2UgbmVlZCBhIGZpcnN0IG9uZVxuXG5cbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfSAvLyBpZiB0aGVyZSdzIG5vIHJvb20gaW4gdGhlIGN1cnJlbnQgdGV4dHVyZSwgd2UgbmVlZCBhIG5ldyBvbmVcblxuXG4gIGlmICh0eHIud2lkdGggLSB0eHIudXNlZFdpZHRoIDwgZWxlU2NhbGVkVykge1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG5cbiAgdmFyIHNjYWxhYmxlRnJvbSA9IGZ1bmN0aW9uIHNjYWxhYmxlRnJvbShvdGhlckNhY2hlKSB7XG4gICAgcmV0dXJuIG90aGVyQ2FjaGUgJiYgb3RoZXJDYWNoZS5zY2FsZWRMYWJlbFNob3duID09PSBzY2FsZWRMYWJlbFNob3duO1xuICB9O1xuXG4gIHZhciBkZXFpbmcgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRlcXVldWU7XG4gIHZhciBoaWdoUXVhbGl0eVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuaGlnaFF1YWxpdHk7XG4gIHZhciBkb3duc2NhbGVSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRvd25zY2FsZTtcbiAgdmFyIGhpZ2hlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgaGlnaGVyIGxldmVsXG5cbiAgZm9yICh2YXIgbCA9IGx2bCArIDE7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICB2YXIgYyA9IGxvb2t1cC5nZXQoZWxlLCBsKTtcblxuICAgIGlmIChjKSB7XG4gICAgICBoaWdoZXJDYWNoZSA9IGM7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb25lVXBDYWNoZSA9IGhpZ2hlckNhY2hlICYmIGhpZ2hlckNhY2hlLmxldmVsID09PSBsdmwgKyAxID8gaGlnaGVyQ2FjaGUgOiBudWxsO1xuXG4gIHZhciBkb3duc2NhbGUgPSBmdW5jdGlvbiBkb3duc2NhbGUoKSB7XG4gICAgdHhyLmNvbnRleHQuZHJhd0ltYWdlKG9uZVVwQ2FjaGUudGV4dHVyZS5jYW52YXMsIG9uZVVwQ2FjaGUueCwgMCwgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsIHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIGVsZVNjYWxlZEgpO1xuICB9OyAvLyByZXNldCBlbGUgYXJlYSBpbiB0ZXh0dXJlXG5cblxuICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIHR4ci5jb250ZXh0LmNsZWFyUmVjdCh0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCB0eHJIKTtcblxuICBpZiAoc2NhbGFibGVGcm9tKG9uZVVwQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVsYXRpdmVseSBjaGVhcGx5IHJlc2NhbGUgdGhlIGV4aXN0aW5nIGltYWdlIHcvbyByZXJlbmRlcmluZ1xuICAgIGRvd25zY2FsZSgpO1xuICB9IGVsc2UgaWYgKHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkpIHtcbiAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAvLyB0byBjaGVhcGx5IHNjYWxlIHRvd2FyZHMgdGhlIHNtYWxsZXIgbGV2ZWxcbiAgICBpZiAoaGlnaFF1YWxpdHlSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sID0gaGlnaGVyQ2FjaGUubGV2ZWw7IF9sID4gbHZsOyBfbC0tKSB7XG4gICAgICAgIG9uZVVwQ2FjaGUgPSBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgX2wsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgZG93bnNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxKTtcbiAgICAgIHJldHVybiBoaWdoZXJDYWNoZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuXG4gICAgaWYgKCFkZXFpbmcgJiYgIWhpZ2hRdWFsaXR5UmVxICYmICFkb3duc2NhbGVSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sMiA9IGx2bCAtIDE7IF9sMiA+PSBtaW5Mdmw7IF9sMi0tKSB7XG4gICAgICAgIHZhciBfYyA9IGxvb2t1cC5nZXQoZWxlLCBfbDIpO1xuXG4gICAgICAgIGlmIChfYykge1xuICAgICAgICAgIGxvd2VyQ2FjaGUgPSBfYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoZWxlLCBsdmwpO1xuICAgICAgcmV0dXJuIGxvd2VyQ2FjaGU7XG4gICAgfVxuXG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKHR4ci51c2VkV2lkdGgsIDApO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgdGhpcy5kcmF3RWxlbWVudCh0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgZmFsc2UpO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoLXR4ci51c2VkV2lkdGgsIDApO1xuICB9XG5cbiAgZWxlQ2FjaGUgPSB7XG4gICAgeDogdHhyLnVzZWRXaWR0aCxcbiAgICB0ZXh0dXJlOiB0eHIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgd2lkdGg6IGVsZVNjYWxlZFcsXG4gICAgaGVpZ2h0OiBlbGVTY2FsZWRILFxuICAgIHNjYWxlZExhYmVsU2hvd246IHNjYWxlZExhYmVsU2hvd25cbiAgfTtcbiAgdHhyLnVzZWRXaWR0aCArPSBNYXRoLmNlaWwoZWxlU2NhbGVkVyArIGVsZVR4clNwYWNpbmcpO1xuICB0eHIuZWxlQ2FjaGVzLnB1c2goZWxlQ2FjaGUpO1xuICBsb29rdXAuc2V0KGVsZSwgbHZsLCBlbGVDYWNoZSk7XG4gIHNlbGYuY2hlY2tUZXh0dXJlRnVsbG5lc3ModHhyKTtcbiAgcmV0dXJuIGVsZUNhY2hlO1xufTtcblxuRVRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmludmFsaWRhdGVFbGVtZW50KGVsZXNbaV0pO1xuICB9XG59O1xuXG5FVENwLmludmFsaWRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcbiAgdmFyIGNhY2hlcyA9IFtdO1xuICB2YXIgaW52YWxpZCA9IGxvb2t1cC5pc0ludmFsaWQoZWxlKTtcblxuICBpZiAoIWludmFsaWQpIHtcbiAgICByZXR1cm47IC8vIG92ZXJyaWRlIHRoZSBpbnZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgZWxlbWVudCBrZXkgaGFzIG5vdCBjaGFuZ2VkXG4gIH1cblxuICBmb3IgKHZhciBsdmwgPSBtaW5Mdmw7IGx2bCA8PSBtYXhMdmw7IGx2bCsrKSB7XG4gICAgdmFyIGNhY2hlID0gbG9va3VwLmdldEZvckNhY2hlZEtleShlbGUsIGx2bCk7XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9PdGhlckVsZXNVc2VDYWNoZSA9IGxvb2t1cC5pbnZhbGlkYXRlKGVsZSk7XG5cbiAgaWYgKG5vT3RoZXJFbGVzVXNlQ2FjaGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9jYWNoZSA9IGNhY2hlc1tpXTtcbiAgICAgIHZhciB0eHIgPSBfY2FjaGUudGV4dHVyZTsgLy8gcmVtb3ZlIHNwYWNlIGZyb20gdGhlIHRleHR1cmUgaXQgYmVsb25ncyB0b1xuXG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCArPSBfY2FjaGUud2lkdGg7IC8vIG1hcmsgdGhlIGNhY2hlIGFzIGludmFsaWRhdGVkXG5cbiAgICAgIF9jYWNoZS5pbnZhbGlkYXRlZCA9IHRydWU7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBpZiBpdHMgdXRpbGl0eSBpcyBsb3dcblxuICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KHR4cik7XG4gICAgfVxuICB9IC8vIHJlbW92ZSBmcm9tIHF1ZXVlIHNpbmNlIHRoZSBvbGQgcmVxIHdhcyBmb3IgdGhlIG9sZCBzdGF0ZVxuXG5cbiAgc2VsZi5yZW1vdmVGcm9tUXVldWUoZWxlKTtcbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYgKHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGgpIHtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUodHhyKTtcbiAgfVxufTtcblxuRVRDcC5jaGVja1RleHR1cmVGdWxsbmVzcyA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaWYgdGV4dHVyZSBoYXMgYmVlbiBtb3N0bHkgZmlsbGVkIGFuZCBwYXNzZWQgb3ZlciBzZXZlcmFsIHRpbWVzLCByZW1vdmVcbiAgLy8gaXQgZnJvbSB0aGUgcXVldWUgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZSB0aW1lIGxvb2tpbmcgYXQgaXQgdG8gcHV0IG5ldyB0aGluZ3NcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ci5oZWlnaHQpO1xuXG4gIGlmICh0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzKSB7XG4gICAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIH0gZWxzZSB7XG4gICAgdHhyLmZ1bGxuZXNzQ2hlY2tzKys7XG4gIH1cbn07XG5cbkVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDsgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIHR4ci5yZXRpcmVkID0gdHJ1ZTsgLy8gcmVtb3ZlIHRoZSByZWZzIGZyb20gdGhlIGVsZXMgdG8gdGhlIGNhY2hlczpcblxuICB2YXIgZWxlQ2FjaGVzID0gdHhyLmVsZUNhY2hlcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZUNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVDYWNoZSA9IGVsZUNhY2hlc1tpXTtcbiAgICBsb29rdXAuZGVsZXRlQ2FjaGUoZWxlQ2FjaGUua2V5LCBlbGVDYWNoZS5sZXZlbCk7XG4gIH1cblxuICBjbGVhckFycmF5KGVsZUNhY2hlcyk7IC8vIGFkZCB0aGUgdGV4dHVyZSB0byBhIHJldGlyZWQgcXVldWUgc28gaXQgY2FuIGJlIHJlY3ljbGVkIGluIGZ1dHVyZTpcblxuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuICBydHh0clEucHVzaCh0eHIpO1xufTtcblxuRVRDcC5hZGRUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgdHhyID0ge307XG4gIHR4clEucHVzaCh0eHIpO1xuICB0eHIuZWxlQ2FjaGVzID0gW107XG4gIHR4ci5oZWlnaHQgPSB0eHJIO1xuICB0eHIud2lkdGggPSBNYXRoLm1heChkZWZUeHJXaWR0aCwgbWluVyk7XG4gIHR4ci51c2VkV2lkdGggPSAwO1xuICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gIHR4ci5jYW52YXMgPSBzZWxmLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgdHhyLmNvbnRleHQgPSB0eHIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHJldHVybiB0eHI7XG59O1xuXG5FVENwLnJlY3ljbGVUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcblxuICAgIGlmICh0eHIud2lkdGggPj0gbWluVykge1xuICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcbiAgICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICAgIGNsZWFyQXJyYXkodHhyLmVsZUNhY2hlcyk7XG4gICAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICAgIHJlbW92ZUZyb21BcnJheShydHh0clEsIHR4cik7XG4gICAgICB0eHJRLnB1c2godHhyKTtcbiAgICAgIHJldHVybiB0eHI7XG4gICAgfVxuICB9XG59O1xuXG5FVENwLnF1ZXVlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGx2bCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gIHZhciBleGlzdGluZ1JlcSA9IGsycVtrZXldO1xuXG4gIGlmIChleGlzdGluZ1JlcSkge1xuICAgIC8vIHVzZSB0aGUgbWF4IGx2bCBiL2MgaW4gYmV0d2VlbiBsdmxzIGFyZSBjaGVhcCB0byBtYWtlXG4gICAgZXhpc3RpbmdSZXEubGV2ZWwgPSBNYXRoLm1heChleGlzdGluZ1JlcS5sZXZlbCwgbHZsKTtcbiAgICBleGlzdGluZ1JlcS5lbGVzLm1lcmdlKGVsZSk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShleGlzdGluZ1JlcSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgIGVsZXM6IGVsZS5zcGF3bigpLm1lcmdlKGVsZSksXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgcmVxczogMSxcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICBxLnB1c2gocmVxKTtcbiAgICBrMnFba2V5XSA9IHJlcTtcbiAgfVxufTtcblxuRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW9cbi8qLCBleHRlbnQqL1xuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIgZGVxdWV1ZWQgPSBbXTtcbiAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZTsgaSsrKSB7XG4gICAgaWYgKHEuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIHJlcSA9IHEucG9wKCk7XG4gICAgICB2YXIga2V5ID0gcmVxLmtleTtcbiAgICAgIHZhciBlbGUgPSByZXEuZWxlc1swXTsgLy8gYWxsIGVsZXMgaGF2ZSB0aGUgc2FtZSBrZXlcblxuICAgICAgdmFyIGNhY2hlRXhpc3RzID0gbG9va3VwLmhhc0NhY2hlKGVsZSwgcmVxLmxldmVsKTsgLy8gY2xlYXIgb3V0IHRoZSBrZXkgdG8gcmVxIGxvb2t1cFxuXG4gICAgICBrMnFba2V5XSA9IG51bGw7IC8vIGRlcXVldWVpbmcgaXNuJ3QgbmVjZXNzYXJ5IHdpdGggYW4gZXhpc3RpbmcgY2FjaGVcblxuICAgICAgaWYgKGNhY2hlRXhpc3RzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZXF1ZXVlZC5wdXNoKHJlcSk7XG4gICAgICB2YXIgYmIgPSBzZWxmLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gICAgICBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgcmVxLmxldmVsLCBnZXRUeHJSZWFzb25zLmRlcXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxdWV1ZWQ7XG59O1xuXG5FVENwLnJlbW92ZUZyb21RdWV1ZSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgcmVxID0gazJxW2tleV07XG5cbiAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgaWYgKHJlcS5lbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gcmVtb3ZlIGlmIGxhc3QgZWxlIGluIHRoZSByZXFcbiAgICAgIC8vIGJyaW5nIHRvIGZyb250IG9mIHF1ZXVlXG4gICAgICByZXEucmVxcyA9IE1BWF9JTlQ7XG4gICAgICBxLnVwZGF0ZUl0ZW0ocmVxKTtcbiAgICAgIHEucG9wKCk7IC8vIHJlbW92ZSBmcm9tIHF1ZXVlXG5cbiAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gcmVtb3ZlIGZyb20gbG9va3VwIG1hcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCByZW1vdmUgZWxlIGZyb20gcmVxXG4gICAgICByZXEuZWxlcy51bm1lcmdlKGVsZSk7XG4gICAgfVxuICB9XG59O1xuXG5FVENwLm9uRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLm9uRGVxdWV1ZXMucHVzaChmbik7XG59O1xuXG5FVENwLm9mZkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVtb3ZlRnJvbUFycmF5KHRoaXMub25EZXF1ZXVlcywgZm4pO1xufTtcblxuRVRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICBkZXFDb3N0OiBkZXFDb3N0LFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbywgZXh0ZW50KTtcbiAgfSxcbiAgb25EZXFkOiBmdW5jdGlvbiBvbkRlcWQoc2VsZiwgZGVxZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5vbkRlcXVldWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSBzZWxmLm9uRGVxdWV1ZXNbaV07XG4gICAgICBmbihkZXFkKTtcbiAgICB9XG4gIH0sXG4gIHNob3VsZFJlZHJhdzogZnVuY3Rpb24gc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZXMgPSBkZXFkW2ldLmVsZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgYmIgPSBlbGVzW2pdLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZVR4ckRlcTtcbiAgfVxufSk7XG5cbnZhciBkZWZOdW1MYXllcnMgPSAxOyAvLyBkZWZhdWx0IG51bWJlciBvZiBsYXllcnMgdG8gdXNlXG5cbnZhciBtaW5MdmwkMSA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcblxudmFyIG1heEx2bCQxID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxuXG52YXIgbWF4Wm9vbSQxID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcblxudmFyIGRlcVJlZHJhd1RocmVzaG9sZCQxID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbnZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcblxudmFyIGRlcUNvc3QkMSA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxuXG52YXIgZGVxQXZnQ29zdCQxID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxuXG52YXIgZGVxTm9EcmF3Q29zdCQxID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG52YXIgZGVxRmFzdENvc3QkMSA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcblxudmFyIG1heERlcVNpemUkMSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbnZhciBpbnZhbGlkVGhyZXNob2xkID0gMjUwOyAvLyB0aW1lIHRocmVzaG9sZCBmb3IgZGlzYWJsaW5nIGIvYyBvZiBpbnZhbGlkYXRpb25zXG5cbnZhciBtYXhMYXllckFyZWEgPSA0MDAwICogNDAwMDsgLy8gbGF5ZXJzIGNhbid0IGJlIGJpZ2dlciB0aGFuIHRoaXNcblxudmFyIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGhpZ2ggcXVhbGl0eSBlbGUgdHhyIHJlcXVlc3RzIChnZW5lcmFsbHkgZmFzdGVyIGFuZCBjaGVhcGVyIGluIHRoZSBsb25ndGVybSlcbi8vIHZhciBsb2cgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7IH07XG5cbnZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gTGF5ZXJlZFRleHR1cmVDYWNoZShyZW5kZXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB2YXIgY3kgPSByLmN5O1xuICBzZWxmLmxheWVyc0J5TGV2ZWwgPSB7fTsgLy8gZS5nLiAyID0+IFsgbGF5ZXIxLCBsYXllcjIsIC4uLiwgbGF5ZXJOIF1cblxuICBzZWxmLmZpcnN0R2V0ID0gdHJ1ZTtcbiAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSAyICogaW52YWxpZFRocmVzaG9sZDtcbiAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICBzZWxmLmVsZVR4ckRlcXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIHNlbGYuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKHNlbGYuZWxlVHhyRGVxcyk7XG4gICAgc2VsZi5lbGVUeHJEZXFzLnVubWVyZ2Uoc2VsZi5lbGVUeHJEZXFzKTtcbiAgfSwgcmVmaW5lRWxlRGVib3VuY2VUaW1lKTtcbiAgci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gKHdpbGxEcmF3LCBub3cpIHtcbiAgICBpZiAobm93IC0gc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA8PSBpbnZhbGlkVGhyZXNob2xkKSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4clNraXApO1xuXG4gIHZhciBxU29ydCA9IGZ1bmN0aW9uIHFTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9O1xuXG4gIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgSGVhcChxU29ydCk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xuXG52YXIgTFRDcCA9IExheWVyZWRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xudmFyIGxheWVySWRQb29sID0gMDtcbnZhciBNQVhfSU5UJDEgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG5MVENwLm1ha2VMYXllciA9IGZ1bmN0aW9uIChiYiwgbHZsKSB7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gIHZhciBjYW52YXMgPSB0aGlzLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModywgaCk7XG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCQxLFxuICAgIGJiOiBiYixcbiAgICBsZXZlbDogbHZsLFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICBlbGVzOiBbXSxcbiAgICBlbGVzUXVldWU6IFtdLFxuICAgIHJlcXM6IDBcbiAgfTsgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7IC8vIGRvIHRoZSB0cmFuc2Zvcm0gb24gY3JlYXRpb24gdG8gc2F2ZSBjeWNsZXMgKGl0J3MgdGhlIHNhbWUgZm9yIGFsbCBlbGVzKVxuXG4gIGN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICBjeHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gIHJldHVybiBsYXllcjtcbn07XG5cbkxUQ3AuZ2V0TGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHB4UmF0aW8sIGx2bCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBmaXJzdEdldCA9IHNlbGYuZmlyc3RHZXQ7XG4gIHNlbGYuZmlyc3RHZXQgPSBmYWxzZTsgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuXG4gICAgaWYgKGx2bCA8IG1pbkx2bCQxKSB7XG4gICAgICBsdmwgPSBtaW5MdmwkMTtcbiAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSQxIHx8IGx2bCA+IG1heEx2bCQxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGx2bCwgZWxlcyk7XG4gIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGxheWVycyA9IGxheWVyc0J5THZsW2x2bF0gPSBsYXllcnNCeUx2bFtsdmxdIHx8IFtdO1xuICB2YXIgYmI7XG4gIHZhciBsdmxDb21wbGV0ZSA9IHNlbGYubGV2ZWxJc0NvbXBsZXRlKGx2bCwgZWxlcyk7XG4gIHZhciB0bXBMYXllcnM7XG5cbiAgdmFyIGNoZWNrVGVtcExldmVscyA9IGZ1bmN0aW9uIGNoZWNrVGVtcExldmVscygpIHtcbiAgICB2YXIgY2FuVXNlQXNUbXBMdmwgPSBmdW5jdGlvbiBjYW5Vc2VBc1RtcEx2bChsKSB7XG4gICAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGwsIGVsZXMpO1xuXG4gICAgICBpZiAoc2VsZi5sZXZlbElzQ29tcGxldGUobCwgZWxlcykpIHtcbiAgICAgICAgdG1wTGF5ZXJzID0gbGF5ZXJzQnlMdmxbbF07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2hlY2tMdmxzID0gZnVuY3Rpb24gY2hlY2tMdmxzKGRpcikge1xuICAgICAgaWYgKHRtcExheWVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGwgPSBsdmwgKyBkaXI7IG1pbkx2bCQxIDw9IGwgJiYgbCA8PSBtYXhMdmwkMTsgbCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGNhblVzZUFzVG1wTHZsKGwpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tMdmxzKCsxKTtcbiAgICBjaGVja0x2bHMoLTEpOyAvLyByZW1vdmUgdGhlIGludmFsaWQgbGF5ZXJzOyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYXMgbmVlZGVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb25cblxuICAgIGZvciAodmFyIGkgPSBsYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoIWx2bENvbXBsZXRlKSB7XG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgaW5jb21wbGV0ZSwgdGhlbiB1c2UgdGhlIGNsb3Nlc3QsIGJlc3QgcXVhbGl0eSBsYXllcnNldCB0ZW1wb3JhcmlseVxuICAgIC8vIGFuZCBsYXRlciBxdWV1ZSB0aGUgY3VycmVudCBsYXllcnNldCBzbyB3ZSBjYW4gZ2V0IHRoZSBwcm9wZXIgcXVhbGl0eSBsZXZlbCBzb29uXG4gICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9nKCdsZXZlbCBjb21wbGV0ZSwgdXNpbmcgZXhpc3RpbmcgbGF5ZXJzXFxuLS0nKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgdmFyIGdldEJiID0gZnVuY3Rpb24gZ2V0QmIoKSB7XG4gICAgaWYgKCFiYikge1xuICAgICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYjtcbiAgfTtcblxuICB2YXIgbWFrZUxheWVyID0gZnVuY3Rpb24gbWFrZUxheWVyKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuICAgIGdldEJiKCk7XG4gICAgdmFyIGFyZWEgPSBiYi53ICogc2NhbGUgKiAoYmIuaCAqIHNjYWxlKTtcblxuICAgIGlmIChhcmVhID4gbWF4TGF5ZXJBcmVhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSBzZWxmLm1ha2VMYXllcihiYiwgbHZsKTtcblxuICAgIGlmIChhZnRlciAhPSBudWxsKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXllcnMuaW5kZXhPZihhZnRlcikgKyAxO1xuICAgICAgbGF5ZXJzLnNwbGljZShpbmRleCwgMCwgbGF5ZXIpO1xuICAgIH0gZWxzZSBpZiAob3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCkge1xuICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICBsYXllcnMudW5zaGlmdChsYXllcik7XG4gICAgfSAvLyBpZiggdG1wTGF5ZXJzICl7XG4gICAgLy9zZWxmLnF1ZXVlTGF5ZXIoIGxheWVyICk7XG4gICAgLy8gfVxuXG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH07XG5cbiAgaWYgKHNlbGYuc2tpcHBpbmcgJiYgIWZpcnN0R2V0KSB7XG4gICAgLy8gbG9nKCdza2lwIGxheWVycycpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGxvZygnZG8gbGF5ZXJzJyk7XG5cblxuICB2YXIgbGF5ZXIgPSBudWxsO1xuICB2YXIgbWF4RWxlc1BlckxheWVyID0gZWxlcy5sZW5ndGggLyBkZWZOdW1MYXllcnM7XG4gIHZhciBhbGxvd0xhenlRdWV1ZWluZyA9ICAhZmlyc3RHZXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9OyAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbbHZsXTtcblxuICAgIGlmIChleGlzdGluZ0xheWVyKSB7XG4gICAgICAvLyByZXVzZSBsYXllciBmb3IgbGF0ZXIgZWxlc1xuICAgICAgLy8gbG9nKCdyZXVzZSBsYXllciBmb3InLCBlbGUuaWQoKSk7XG4gICAgICBsYXllciA9IGV4aXN0aW5nTGF5ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWxheWVyIHx8IGxheWVyLmVsZXMubGVuZ3RoID49IG1heEVsZXNQZXJMYXllciB8fCAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGxheWVyLmJiLCBlbGUuYm91bmRpbmdCb3goKSkpIHtcbiAgICAgIC8vIGxvZygnbWFrZSBuZXcgbGF5ZXIgZm9yIGVsZSAlcycsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gbWFrZUxheWVyKHtcbiAgICAgICAgaW5zZXJ0OiB0cnVlLFxuICAgICAgICBhZnRlcjogbGF5ZXJcbiAgICAgIH0pOyAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG5cbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG5cbiAgICB9XG5cbiAgICBpZiAodG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLnF1ZXVlTGF5ZXIobGF5ZXIsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pO1xuICAgIH1cblxuICAgIGxheWVyLmVsZXMucHVzaChlbGUpO1xuICAgIGNhY2hlc1tsdmxdID0gbGF5ZXI7XG4gIH0gLy8gbG9nKCctLScpO1xuXG5cbiAgaWYgKHRtcExheWVycykge1xuICAgIC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuXG4gIGlmIChhbGxvd0xhenlRdWV1ZWluZykge1xuICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufTsgLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuXG5cbkxUQ3AuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsID0gZnVuY3Rpb24gKGx2bCwgcHhSYXRpbykge1xuICByZXR1cm4gbHZsO1xufTtcblxuTFRDcC5kcmF3RWxlSW5MYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGx2bCA9IHNlbGYuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsKGx2bCwgcHhSYXRpbyk7XG5cbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgbnVsbCwgbnVsbCwgbHZsLCB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMpO1xuICB9XG5cbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICB9XG59O1xuXG5MVENwLmxldmVsSXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgaWYgKCFsYXllcnMgfHwgbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBudW1FbGVzSW5MYXllcnMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldOyAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG4gICAgaWYgKGxheWVyLnJlcXMgPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpZiB0aGUgbGF5ZXIgaXMgaW52YWxpZCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG5cbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgfSAvLyB3ZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBudW1iZXIgb2YgZWxlcyBwYXNzZWQgaW4gdG8gYmUgY29tcGxldGVcblxuXG4gIGlmIChudW1FbGVzSW5MYXllcnMgIT09IGVsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgaWYgKCFsYXllcnMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgaW4gYSBsYXllciB0aGUgZWxlcyBhcmUgbm90IGluIHRoZSBzYW1lIG9yZGVyLCB0aGVuIHRoZSBsYXllciBpcyBpbnZhbGlkXG4gIC8vIChpLmUuIHRoZXJlIGlzIGFuIGVsZSBpbiBiZXR3ZWVuIHRoZSBlbGVzIGluIHRoZSBsYXllcilcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAtMTsgLy8gZmluZCB0aGUgb2Zmc2V0XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzWzBdID09PSBlbGVzW2pdKSB7XG4gICAgICAgIG9mZnNldCA9IGo7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyB0aGVuIHRoZSBsYXllciBoYXMgbm9uZXhpc3RhbnQgZWxlbWVudHMgYW5kIGlzIGludmFsaWRcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gdGhlIGVsZXMgaW4gdGhlIGxheWVyIG11c3QgYmUgaW4gdGhlIHNhbWUgY29udGludW91cyBvcmRlciwgZWxzZSB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxheWVyLmVsZXNbal0gIT09IGVsZXNbbyArIGpdKSB7XG4gICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AudXBkYXRlRWxlbWVudHNJbkxheWVycyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaXNFbGVzID0gZWxlbWVudChlbGVzWzBdKTsgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXEgPSBpc0VsZXMgPyBudWxsIDogZWxlc1tpXTtcbiAgICB2YXIgZWxlID0gaXNFbGVzID8gZWxlc1tpXSA6IGVsZXNbaV0uZWxlO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGZvciAodmFyIGwgPSBtaW5MdmwkMTsgbCA8PSBtYXhMdmwkMTsgbCsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBjYWNoZXNbbF07XG5cbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGlmIHVwZGF0ZSBpcyBhIHJlcXVlc3QgZnJvbSB0aGUgZWxlIGNhY2hlLCB0aGVuIGl0IGFmZmVjdHMgb25seVxuICAgICAgLy8gdGhlIG1hdGNoaW5nIGxldmVsXG5cblxuICAgICAgaWYgKHJlcSAmJiBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsYXllci5sZXZlbCkgIT09IHJlcS5sZXZlbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKGxheWVyLCBlbGUsIHJlcSk7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLmhhdmVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcblxuICBmb3IgKHZhciBsID0gbWluTHZsJDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbF07XG5cbiAgICBpZiAobGF5ZXJzICYmIGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICBoYXZlTGF5ZXJzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXZlTGF5ZXJzO1xufTtcblxuTFRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7IC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICBpZiAoZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIGludmFsQXNzb2NMYXllcnMobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICB9KTtcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuICB0aGlzLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBzYXZlIGN5Y2xlc1xuXG5cbiAgdmFyIGx2bCA9IGxheWVyLmxldmVsO1xuICB2YXIgZWxlcyA9IGxheWVyLmVsZXM7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTsgLy8gbG9nKCdpbnZhbGlkYXRlIGxheWVyJywgbGF5ZXIuaWQgKTtcblxuICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7IC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcbiAgbGF5ZXIuaW52YWxpZCA9IHRydWU7XG5cbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgbGF5ZXIucmVwbGFjZW1lbnQuaW52YWxpZCA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2FjaGVzID0gZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdMYXllckNhY2hlcztcblxuICAgIGlmIChjYWNoZXMpIHtcbiAgICAgIGNhY2hlc1tsdmxdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbkxUQ3AucmVmaW5lRWxlbWVudFRleHR1cmVzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzOyAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gcmVmaW5lRWFjaEVsZShsYXllciwgZWxlLCByZXEpIHtcbiAgICB2YXIgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50O1xuXG4gICAgaWYgKCFyTHlyKSB7XG4gICAgICByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQgPSBzZWxmLm1ha2VMYXllcihsYXllci5iYiwgbGF5ZXIubGV2ZWwpO1xuICAgICAgckx5ci5yZXBsYWNlcyA9IGxheWVyO1xuICAgICAgckx5ci5lbGVzID0gbGF5ZXIuZWxlczsgLy8gbG9nKCdtYWtlIHJlcGxhY2VtZW50IGxheWVyICVzIGZvciAlcyB3aXRoIGxldmVsICVzJywgckx5ci5pZCwgbGF5ZXIuaWQsIHJMeXIubGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghckx5ci5yZXFzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJMeXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnF1ZXVlTGF5ZXIockx5ciwgckx5ci5lbGVzW2ldKTtcbiAgICAgIH0gLy8gbG9nKCdxdWV1ZSByZXBsYWNlbWVudCBsYXllciByZWZpbmVtZW50Jywgckx5ci5pZCk7XG5cbiAgICB9XG4gIH0pO1xufTtcblxuTFRDcC5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG5cbiAgdGhpcy5lbGVUeHJEZXFzLm1lcmdlKGVsZSk7XG4gIHRoaXMuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCgpO1xufTtcblxuTFRDcC5xdWV1ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyLCBlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBlbGVzUSA9IGxheWVyLmVsZXNRdWV1ZTtcbiAgdmFyIGhhc0lkID0gZWxlc1EuaGFzSWQgPSBlbGVzUS5oYXNJZCB8fCB7fTsgLy8gaWYgYSBsYXllciBpcyBnb2luZyB0byBiZSByZXBsYWNlZCwgcXVldWluZyBpcyBhIHdhc3RlIG9mIHRpbWVcblxuICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWxlKSB7XG4gICAgaWYgKGhhc0lkW2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZXNRLnB1c2goZWxlKTtcbiAgICBoYXNJZFtlbGUuaWQoKV0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKGxheWVyLnJlcXMpIHtcbiAgICBsYXllci5yZXFzKys7XG4gICAgcS51cGRhdGVJdGVtKGxheWVyKTtcbiAgfSBlbHNlIHtcbiAgICBsYXllci5yZXFzID0gMTtcbiAgICBxLnB1c2gobGF5ZXIpO1xuICB9XG59O1xuXG5MVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpbykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGRlcWQgPSBbXTtcbiAgdmFyIGVsZURlcXMgPSAwO1xuXG4gIHdoaWxlIChlbGVEZXFzIDwgbWF4RGVxU2l6ZSQxKSB7XG4gICAgaWYgKHEuc2l6ZSgpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSBxLnBlZWsoKTsgLy8gaWYgYSBsYXllciBoYXMgYmVlbiBvciB3aWxsIGJlIHJlcGxhY2VkLCB0aGVuIGRvbid0IHdhc3RlIHRpbWUgd2l0aCBpdFxuXG4gICAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgICAvLyBsb2coJ2xheWVyICVzIGluIHF1ZXVlIHNraXBwZWQgYi9jIGl0IGFscmVhZHkgaGFzIGEgcmVwbGFjZW1lbnQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBpZiB0aGlzIGlzIGEgcmVwbGFjZW1lbnQgbGF5ZXIgdGhhdCBoYXMgYmVlbiBzdXBlcmNlZGVkLCB0aGVuIGZvcmdldCBpdFxuXG5cbiAgICBpZiAobGF5ZXIucmVwbGFjZXMgJiYgbGF5ZXIgIT09IGxheWVyLnJlcGxhY2VzLnJlcGxhY2VtZW50KSB7XG4gICAgICAvLyBsb2coJ2xheWVyIGlzIG5vIGxvbmdlciB0aGUgbW9zdCB1cHRvZGF0ZSByZXBsYWNlbWVudDsgZGVxdWV1ZWQnLCBsYXllci5pZClcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciAlcyBpcyBpbnZhbGlkOyBkZXF1ZXVlZCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gbGF5ZXIuZWxlc1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICAvLyBsb2coJ2RlcXVldWUgbGF5ZXIgJXMnLCBsYXllci5pZCk7XG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGxheWVyLmxldmVsLCBweFJhdGlvKTtcbiAgICAgIGVsZURlcXMrKztcbiAgICB9XG5cbiAgICBpZiAoZGVxZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgZW50cnkgaW4gZGVxZCB0byBxdWV1ZSByZWRyYXdpbmcgZXRjXG4gICAgICBkZXFkLnB1c2godHJ1ZSk7XG4gICAgfSAvLyBpZiB0aGUgbGF5ZXIgaGFzIGFsbCBpdHMgZWxlcyBkb25lLCB0aGVuIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZVxuXG5cbiAgICBpZiAobGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGxheWVyLnJlcXMgPSAwOyAvLyBsb2coJ2RlcXVldWUgb2YgbGF5ZXIgJXMgY29tcGxldGUnLCBsYXllci5pZCk7XG4gICAgICAvLyB3aGVuIGEgcmVwbGFjZW1lbnQgbGF5ZXIgaXMgZGVxdWV1ZWQsIGl0IHJlcGxhY2VzIHRoZSBvbGQgbGF5ZXIgaW4gdGhlIGxldmVsXG5cbiAgICAgIGlmIChsYXllci5yZXBsYWNlcykge1xuICAgICAgICBzZWxmLmFwcGx5TGF5ZXJSZXBsYWNlbWVudChsYXllcik7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmVxdWVzdFJlZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXFkO1xufTtcblxuTFRDcC5hcHBseUxheWVyUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzSW5MZXZlbCA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsYXllci5sZXZlbF07XG4gIHZhciByZXBsYWNlZCA9IGxheWVyLnJlcGxhY2VzO1xuICB2YXIgaW5kZXggPSBsYXllcnNJbkxldmVsLmluZGV4T2YocmVwbGFjZWQpOyAvLyBpZiB0aGUgcmVwbGFjZWQgbGF5ZXIgaXMgbm90IGluIHRoZSBhY3RpdmUgbGlzdCBmb3IgdGhlIGxldmVsLCB0aGVuIHJlcGxhY2luZ1xuICAvLyByZWZzIHdvdWxkIGJlIGEgbWlzdGFrZSAoaS5lLiBvdmVyd3JpdGluZyB0aGUgdHJ1ZSBhY3RpdmUgbGF5ZXIpXG5cbiAgaWYgKGluZGV4IDwgMCB8fCByZXBsYWNlZC5pbnZhbGlkKSB7XG4gICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciB3b3VsZCBoYXZlIG5vIGVmZmVjdCcsIGxheWVyLmlkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsYXllcnNJbkxldmVsW2luZGV4XSA9IGxheWVyOyAvLyByZXBsYWNlIGxldmVsIHJlZlxuICAvLyByZXBsYWNlIHJlZnMgaW4gZWxlc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcCA9IGxheWVyLmVsZXNbaV0uX3ByaXZhdGU7XG4gICAgdmFyIGNhY2hlID0gX3AuaW1nTGF5ZXJDYWNoZXMgPSBfcC5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVbbGF5ZXIubGV2ZWxdID0gbGF5ZXI7XG4gICAgfVxuICB9IC8vIGxvZygnYXBwbHkgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgb3ZlciAlcycsIGxheWVyLmlkLCByZXBsYWNlZC5pZCk7XG5cblxuICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbn07XG5cbkxUQ3AucmVxdWVzdFJlZHJhdyA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgci5yZWRyYXcoKTtcbn0sIDEwMCk7XG5MVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQkMSxcbiAgZGVxQ29zdDogZGVxQ29zdCQxLFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0JDEsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QkMSxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0JDEsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8pIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8pO1xuICB9LFxuICBvbkRlcWQ6IG5vb3AsXG4gIHNob3VsZFJlZHJhdzogdHJ1ZWlmeSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4ckRlcTtcbiAgfVxufSk7XG5cbnZhciBDUnAgPSB7fTtcbnZhciBpbXBsO1xuXG5mdW5jdGlvbiBwb2x5Z29uKGNvbnRleHQsIHBvaW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlhbmdsZUJhY2tjdXJ2ZShjb250ZXh0LCBwb2ludHMsIGNvbnRyb2xQb2ludCkge1xuICB2YXIgZmlyc3RQdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgfVxuXG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cblxuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSk7XG59XG5cbmZ1bmN0aW9uIHRyaWFuZ2xlVGVlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuXG4gIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gIHZhciBmaXJzdFRlZVB0ID0gdGVlUG9pbnRzWzBdO1xuICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cblxuICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNpcmNsZShjb250ZXh0LCByeCwgcnksIHIpIHtcbiAgY29udGV4dC5hcmMocngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xufVxuXG5DUnAuYXJyb3dTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gKGltcGwgfHwgKGltcGwgPSB7XG4gICAgJ3BvbHlnb24nOiBwb2x5Z29uLFxuICAgICd0cmlhbmdsZS1iYWNrY3VydmUnOiB0cmlhbmdsZUJhY2tjdXJ2ZSxcbiAgICAndHJpYW5nbGUtdGVlJzogdHJpYW5nbGVUZWUsXG4gICAgJ3RyaWFuZ2xlLWNyb3NzJzogdHJpYW5nbGVUZWUsXG4gICAgJ2NpcmNsZSc6IGNpcmNsZVxuICB9KSlbbmFtZV07XG59O1xuXG52YXIgQ1JwJDEgPSB7fTtcblxuQ1JwJDEuZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgfVxufTtcblxuQ1JwJDEuZHJhd0VsZW1lbnRPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcblxuQ1JwJDEuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRSb3RhdGlvbiwgZ2V0T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBiYiA9IGVsZVR4ckNhY2hlLmdldEJvdW5kaW5nQm94KGVsZSk7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBpZ25vcmUgemVybyBzaXplIGNhc2VcblxuXG4gIHZhciBlbGVDYWNoZSA9IGVsZVR4ckNhY2hlLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pO1xuXG4gIGlmIChlbGVDYWNoZSAhPSBudWxsKSB7XG4gICAgdmFyIG9wYWNpdHkgPSBnZXRPcGFjaXR5KHIsIGVsZSk7XG5cbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aGV0YSA9IGdldFJvdGF0aW9uKHIsIGVsZSk7XG4gICAgdmFyIHgxID0gYmIueDEsXG4gICAgICAgIHkxID0gYmIueTEsXG4gICAgICAgIHcgPSBiYi53LFxuICAgICAgICBoID0gYmIuaDtcbiAgICB2YXIgeCwgeSwgc3gsIHN5LCBzbW9vdGg7XG5cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIHZhciByb3RQdCA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uUG9pbnQoZWxlKTtcbiAgICAgIHN4ID0gcm90UHQueDtcbiAgICAgIHN5ID0gcm90UHQueTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN4LCBzeSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICBzbW9vdGggPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcblxuICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmYgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvbk9mZnNldChlbGUpO1xuICAgICAgeCA9IG9mZi54O1xuICAgICAgeSA9IG9mZi55O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geDE7XG4gICAgICB5ID0geTE7XG4gICAgfVxuXG4gICAgdmFyIG9sZEdsb2JhbEFscGhhO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgIG9sZEdsb2JhbEFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYSAqIG9wYWNpdHk7XG4gICAgfVxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoZWxlQ2FjaGUudGV4dHVyZS5jYW52YXMsIGVsZUNhY2hlLngsIDAsIGVsZUNhY2hlLndpZHRoLCBlbGVDYWNoZS5oZWlnaHQsIHgsIHksIHcsIGgpO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYTtcbiAgICB9XG5cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtc3gsIC1zeSk7XG5cbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlVHhyQ2FjaGUuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTsgLy8gZGlyZWN0IGRyYXcgZmFsbGJhY2tcbiAgfVxufTtcblxudmFyIGdldFplcm9Sb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFplcm9Sb3RhdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG52YXIgZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsIG51bGwpO1xufTtcblxudmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAnc291cmNlJyk7XG59O1xuXG52YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICd0YXJnZXQnKTtcbn07XG5cbnZhciBnZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eShyLCBlbGUpIHtcbiAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG59O1xuXG52YXIgZ2V0VGV4dE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRUZXh0T3BhY2l0eShlLCBlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnBmVmFsdWUgKiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xufTtcblxuQ1JwJDEuZHJhd0NhY2hlZEVsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQsIGx2bCwgcmVxdWVzdEhpZ2hRdWFsaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIF9yJGRhdGEgPSByLmRhdGEsXG4gICAgICBlbGVUeHJDYWNoZSA9IF9yJGRhdGEuZWxlVHhyQ2FjaGUsXG4gICAgICBsYmxUeHJDYWNoZSA9IF9yJGRhdGEubGJsVHhyQ2FjaGUsXG4gICAgICBzbGJUeHJDYWNoZSA9IF9yJGRhdGEuc2xiVHhyQ2FjaGUsXG4gICAgICB0bGJUeHJDYWNoZSA9IF9yJGRhdGEudGxiVHhyQ2FjaGU7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICB2YXIgcmVhc29uID0gcmVxdWVzdEhpZ2hRdWFsaXR5ID09PSB0cnVlID8gZWxlVHhyQ2FjaGUucmVhc29ucy5oaWdoUXVhbGl0eSA6IG51bGw7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghZXh0ZW50IHx8IGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuXG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG5cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0WmVyb1JvdGF0aW9uLCBnZXRPcGFjaXR5KTtcblxuICAgIGlmICghaXNFZGdlIHx8ICFiYWRMaW5lKSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGxibFR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgIH1cblxuICAgIGlmIChpc0VkZ2UgJiYgIWJhZExpbmUpIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgc2xiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHRsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgIH1cblxuICAgIHIuZHJhd0VsZW1lbnRPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG5DUnAkMS5kcmF3Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxuQ1JwJDEuZHJhd0xheWVyZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gci5kYXRhLmx5clR4ckNhY2hlLmdldExheWVycyhlbGVzLCBweFJhdGlvKTtcblxuICBpZiAobGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBiYiA9IGxheWVyLmJiO1xuXG4gICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShsYXllci5jYW52YXMsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGZhbGwgYmFjayBvbiBwbGFpbiBjYWNoaW5nIGlmIG5vIGxheWVyc1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBQYXRoMkQgKi9cbnZhciBDUnAkMiA9IHt9O1xuXG5DUnAkMi5kcmF3RWRnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFlZGdlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuXG5cbiAgaWYgKHJzLmJhZExpbmUgfHwgcnMuYWxscHRzID09IG51bGwgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSkge1xuICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBiYjtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBsaW5lU3R5bGUgPSBlZGdlLnBzdHlsZSgnbGluZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVDYXAgPSBlZGdlLnBzdHlsZSgnbGluZS1jYXAnKS52YWx1ZTtcblxuICB2YXIgZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZSgpIHtcbiAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3BhY2l0eTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgIHIuZWxlU3Ryb2tlU3R5bGUoY29udGV4dCwgZWRnZSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCBsaW5lU3R5bGUpO1xuICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gIH07XG5cbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICB9O1xuXG4gIHZhciBkcmF3QXJyb3dzID0gZnVuY3Rpb24gZHJhd0Fycm93cygpIHtcbiAgICB2YXIgYXJyb3dPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBvcGFjaXR5O1xuICAgIHIuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgYXJyb3dPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlZGdlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuICB2YXIgZ2hvc3QgPSBlZGdlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZlY3RpdmVHaG9zdE9wYWNpdHkgPSBvcGFjaXR5ICogZ2hvc3RPcGFjaXR5O1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZHJhd0xpbmUoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3QXJyb3dzKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICB9XG5cbiAgZHJhd0xpbmUoKTtcbiAgZHJhd0Fycm93cygpO1xuICBkcmF3T3ZlcmxheSgpO1xuICBkcmF3VGV4dCgpO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcblxuQ1JwJDIuZHJhd0VkZ2VPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UpIHtcbiAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcblxuICBpZiAob3ZlcmxheU9wYWNpdHkgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gZWRnZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5V2lkdGggPSAyICogb3ZlcmxheVBhZGRpbmc7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBlZGdlLnBzdHlsZSgnb3ZlcmxheS1jb2xvcicpLnZhbHVlO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IG92ZXJsYXlXaWR0aDtcblxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJyAmJiAhdXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgfVxuXG4gIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG4gIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgJ3NvbGlkJyk7XG59O1xuXG5DUnAkMi5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBsaW5lRGFzaFBhdHRlcm4gPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICB2YXIgbGluZURhc2hPZmZzZXQgPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIHBhdGhDYWNoZUtleSA9IHB0cy5qb2luKCckJyk7XG4gICAgdmFyIGtleU1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXk7XG5cbiAgICBpZiAoa2V5TWF0Y2hlcykge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhbnZhc0N4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2gobGluZURhc2hQYXR0ZXJuKTtcbiAgICAgICAgY2FudmFzQ3h0LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGF0aENhY2hlSGl0ICYmICFycy5iYWRMaW5lKSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQubW92ZVRvKHB0c1swXSwgcHRzWzFdKTtcblxuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pICsgMSA8IHB0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbX2ldLCBwdHNbX2kgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH0gLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG5cblxuICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICB9XG59O1xuXG5DUnAkMi5kcmF3QXJyb3doZWFkcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBvcGFjaXR5KSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgaWYgKCFpc0hheXN0YWNrKSB7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdzb3VyY2UnLCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHJzLnNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuICB9XG5cbiAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB9XG59O1xuXG5DUnAkMi5kcmF3QXJyb3doZWFkID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHByZWZpeCwgeCwgeSwgYW5nbGUsIG9wYWNpdHkpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IHggPT0gbnVsbCB8fCBpc05hTih5KSB8fCB5ID09IG51bGwgfHwgaXNOYU4oYW5nbGUpIHx8IGFuZ2xlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuXG4gIGlmIChhcnJvd1NoYXBlID09PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXJyb3dDbGVhckZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgdmFyIGFycm93RmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGVkZ2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcblxuICBpZiAob3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3BhY2l0eSA9IGVkZ2VPcGFjaXR5O1xuICB9XG5cbiAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gIGlmIChvcGFjaXR5ICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycpIHtcbiAgICAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0NsZWFyRmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG5cbiAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1jb2xvcicpLnZhbHVlO1xuICBzZWxmLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIHgsIHksIGFuZ2xlKTtcbn07XG5cbkNScCQyLmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIGZpbGwsIGVkZ2VXaWR0aCwgc2hhcGUsIHgsIHksIGFuZ2xlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpICYmIHNoYXBlICE9PSAndHJpYW5nbGUtY3Jvc3MnO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYXRoO1xuICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbiAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2VXaWR0aCwgc2NhbGUpO1xuICB2YXIgc2hhcGVJbXBsID0gci5hcnJvd1NoYXBlc1tzaGFwZV07XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIGNhY2hlID0gci5hcnJvd1BhdGhDYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmcoc2hhcGUpO1xuICAgIHZhciBjYWNoZWRQYXRoID0gY2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gY2FjaGVkUGF0aDtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2FjaGVba2V5XSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAvLyBzdG9yZSBpbiB0aGUgcGF0aCBjYWNoZSB3aXRoIHZhbHVlcyBlYXNpbHkgbWFuaXB1bGF0ZWQgbGF0ZXJcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIDEsIDAsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgLy8gc2V0IHRyYW5zZm9ybSB0byBhcnJvdyBwb3NpdGlvbi9vcmllbnRhdGlvblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICBjb250ZXh0LnNjYWxlKHNpemUsIHNpemUpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gJ2hvbGxvdycgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAoc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSkgLyAodXNlUGF0aHMgPyBzaXplIDogMSk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHJlc2V0IHRyYW5zZm9ybSBieSBhcHBseWluZyBpbnZlcnNlXG4gICAgY29udGV4dC5zY2FsZSgxIC8gc2l6ZSwgMSAvIHNpemUpO1xuICAgIGNvbnRleHQucm90YXRlKC1hbmdsZSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufTtcblxudmFyIENScCQzID0ge307XG5cbkNScCQzLnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCkge1xuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgY2FzZXMgZm9yIG9sZCBicm93c2VycyB3aXRoIGJhZCBpbWFnZXMgKGNoZWFwZXIgdGhhbiB0cnktY2F0Y2gpXG4gIGlmIChpdyA8PSAwIHx8IGloIDw9IDAgfHwgdyA8PSAwIHx8IGggPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRleHQuZHJhd0ltYWdlKGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpO1xufTtcblxuQ1JwJDMuZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgbm9kZSwgaW5kZXgsIG5vZGVPcGFjaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIG5vZGVYID0gcG9zLng7XG4gIHZhciBub2RlWSA9IHBvcy55O1xuICB2YXIgc3R5bGVPYmogPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIGdldEluZGV4ZWRTdHlsZSA9IHN0eWxlT2JqLmdldEluZGV4ZWRTdHlsZS5iaW5kKHN0eWxlT2JqKTtcbiAgdmFyIGZpdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1maXQnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciByZXBlYXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcmVwZWF0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBwYWRkaW5nWDIgPSBub2RlLnBhZGRpbmcoKSAqIDI7XG4gIHZhciBub2RlVFcgPSBub2RlVyArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIG5vZGVUSCA9IG5vZGVIICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNsaXAgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtY2xpcCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCAndmFsdWUnLCBpbmRleCkgKiBub2RlT3BhY2l0eTtcbiAgdmFyIGltZ1cgPSBpbWcud2lkdGggfHwgaW1nLmNhY2hlZFc7XG4gIHZhciBpbWdIID0gaW1nLmhlaWdodCB8fCBpbWcuY2FjaGVkSDsgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcblxuICBpZiAobnVsbCA9PSBpbWdXIHx8IG51bGwgPT0gaW1nSCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaW1nVyA9IGltZy5jYWNoZWRXID0gaW1nLndpZHRoIHx8IGltZy5vZmZzZXRXaWR0aDtcbiAgICBpbWdIID0gaW1nLmNhY2hlZEggPSBpbWcuaGVpZ2h0IHx8IGltZy5vZmZzZXRIZWlnaHQ7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cblxuICB2YXIgdyA9IGltZ1c7XG4gIHZhciBoID0gaW1nSDtcblxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUVztcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRIO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3ID09PSAwIHx8IGggPT09IDApIHtcbiAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgfVxuXG4gIGlmIChmaXQgPT09ICdjb250YWluJykge1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG5vZGVUVyAvIHcsIG5vZGVUSCAvIGgpO1xuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfSBlbHNlIGlmIChmaXQgPT09ICdjb3ZlcicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH1cblxuICB2YXIgeCA9IG5vZGVYIC0gbm9kZVRXIC8gMjsgLy8gbGVmdFxuXG4gIHZhciBwb3NYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1hQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKHBvc1hVbml0cyA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBwb3NYUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBwb3NYUGZWYWw7XG4gIH1cblxuICB2YXIgb2ZmWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWFBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKG9mZlhVbml0cyA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBvZmZYUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBvZmZYUGZWYWw7XG4gIH1cblxuICB2YXIgeSA9IG5vZGVZIC0gbm9kZVRIIC8gMjsgLy8gdG9wXG5cbiAgdmFyIHBvc1lVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgcG9zWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICBpZiAocG9zWVVuaXRzID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIHBvc1lQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IHBvc1lQZlZhbDtcbiAgfVxuXG4gIHZhciBvZmZZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBvZmZZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICBpZiAob2ZmWVVuaXRzID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIG9mZllQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IG9mZllQZlZhbDtcbiAgfVxuXG4gIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICB4IC09IG5vZGVYO1xuICAgIHkgLT0gbm9kZVk7XG4gICAgbm9kZVggPSAwO1xuICAgIG5vZGVZID0gMDtcbiAgfVxuXG4gIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICBpZiAocmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgICAgICBjb250ZXh0LmNsaXAocnMucGF0aENhY2hlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRIKTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgci5zYWZlRHJhd0ltYWdlKGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCk7XG5cbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGltZywgcmVwZWF0KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xufTtcblxudmFyIENScCQ0ID0ge307XG5cbkNScCQ0LmVsZVRleHRCaWdnZXJUaGFuTWluID0gZnVuY3Rpb24gKGVsZSwgc2NhbGUpIHtcbiAgaWYgKCFzY2FsZSkge1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7IC8vIHRoZSBlZmZlY3RpdmUgdGV4dHVyZSBsZXZlbFxuXG4gICAgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG5cbiAgaWYgKGNvbXB1dGVkU2l6ZSA8IG1pblNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNScCQ0LmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGZvcmNlLCBwcmVmaXgpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoZm9yY2UgPT0gbnVsbCkge1xuICAgIGlmICh1c2VFbGVPcGFjaXR5ICYmICFyLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG5cbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBqdXN0aWZpY2F0aW9uID0gci5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IGp1c3RpZmljYXRpb247XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcblxuICAgIHZhciBfbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG5cbiAgICBpZiAoYmFkTGluZSB8fCAoIV9sYWJlbCB8fCAhX2xhYmVsLnZhbHVlKSAmJiAoIXNyY0xhYmVsIHx8ICFzcmNMYWJlbC52YWx1ZSkgJiYgKCF0Z3RMYWJlbCB8fCAhdGd0TGFiZWwudmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICB9XG5cbiAgdmFyIGFwcGx5Um90YXRpb24gPSAhc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgdmFyIGJiO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuXG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBudWxsLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcblxuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgcHJlZml4LCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgfVxuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcblxuQ1JwJDQuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlO1xuICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUgPSB7XG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xuICB0aGlzLmZvbnRDYWNoZXMucHVzaChjYWNoZSk7XG4gIHJldHVybiBjYWNoZTtcbn07IC8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcblxuXG5DUnAkNC5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIC8vIEZvbnQgc3R5bGVcbiAgdmFyIGxhYmVsU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGxhYmVsRmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsV2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIG9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSAqIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIG9wYWNpdHk7XG4gIHZhciBjb2xvciA9IGVsZS5wc3R5bGUoJ2NvbG9yJykudmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnOyAvLyBzbyB0ZXh0IG91dGxpbmVzIGFyZW4ndCBqYWdnZWRcblxuICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xufTsgLy8gVE9ETyBlbnN1cmUgcmUtdXNlZFxuXG5cbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogNTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufVxuXG5DUnAkNC5nZXRUZXh0QW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIHRoZXRhO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciB0ZXh0QW5nbGUgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG5cbiAgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICB0aGV0YSA9IGVsZS5pc0VkZ2UoKSA/IHRleHRBbmdsZSA6IDA7XG4gIH0gZWxzZSBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdub25lJykge1xuICAgIHRoZXRhID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGV0YSA9IHJvdGF0aW9uLnBmVmFsdWU7XG4gIH1cblxuICByZXR1cm4gdGhldGE7XG59O1xuXG5DUnAkNC5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICB2YXIgYXBwbHlSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuXG4gIGlmICh1c2VFbGVPcGFjaXR5ICYmIChwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlID09PSAwKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyB1c2UgJ21haW4nIGFzIGFuIGFsaWFzIGZvciB0aGUgbWFpbiBsYWJlbCAoaS5lLiBudWxsIHByZWZpeClcblxuXG4gIGlmIChwcmVmaXggPT09ICdtYWluJykge1xuICAgIHByZWZpeCA9IG51bGw7XG4gIH1cblxuICB2YXIgdGV4dFggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgdmFyIHRleHRZID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gIHZhciBvcmdUZXh0WCwgb3JnVGV4dFk7IC8vIHVzZWQgZm9yIHJvdGF0aW9uXG5cbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG5cbiAgaWYgKHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICB0aGlzLnNldHVwVGV4dFN0eWxlKGNvbnRleHQsIGVsZSwgdXNlRWxlT3BhY2l0eSk7XG4gICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHRleHRXID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgIHZhciB0ZXh0SCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICB0ZXh0WCArPSBtYXJnaW5YO1xuICAgIHRleHRZICs9IG1hcmdpblk7XG4gICAgdmFyIHRoZXRhO1xuXG4gICAgaWYgKCFhcHBseVJvdGF0aW9uKSB7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZXRhID0gdGhpcy5nZXRUZXh0QW5nbGUoZWxlLCBwcmVmaXgpO1xuICAgIH1cblxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgIG9yZ1RleHRZID0gdGV4dFk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmdUZXh0WCwgb3JnVGV4dFkpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgdGV4dFggPSAwO1xuICAgICAgdGV4dFkgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYmFja2dyb3VuZFBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG5cbiAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGJnWSA9IHRleHRZIC0gdGV4dEggLSBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ1cgPSB0ZXh0VyArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgIHZhciBiZ0ggPSB0ZXh0SCArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCkge1xuICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1zaGFwZScpLnN0clZhbHVlO1xuXG4gICAgICAgIGlmIChzdHlsZVNoYXBlLmluZGV4T2YoJ3JvdW5kJykgPT09IDApIHtcbiAgICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYLCBiZ1ksIGJnVywgYmdILCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkge1xuICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1jb2xvcicpLnZhbHVlO1xuICAgICAgICB2YXIgdGV4dEJvcmRlclN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMF0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMV0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMl0gKyAnLCcgKyBib3JkZXJPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG5cbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBzd2l0Y2ggKHRleHRCb3JkZXJTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNCwgMl0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyA0OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG5cbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcblxuICAgICAgICBpZiAodGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gMjtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYICsgd2hpdGVXaWR0aCwgYmdZICsgd2hpdGVXaWR0aCwgYmdXIC0gd2hpdGVXaWR0aCAqIDIsIGJnSCAtIHdoaXRlV2lkdGggKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRMaW5lV2lkdGg7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaW5lV2lkdGggPSAyICogZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCk7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgdmFyIGhhbGZUZXh0VyA9IHRleHRXIC8gMjtcbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gdGhpcy5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcblxuICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdhdXRvJykgOyBlbHNlIGlmIChoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiByaWdodFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gLXRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0ZmljYXRpb24gOiBjZW50ZXJcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiBsZWZ0XG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gdGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICB9XG5cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb3JnVGV4dFgsIC1vcmdUZXh0WSk7XG4gICAgfVxuICB9XG59O1xuXG4vKiBnbG9iYWwgUGF0aDJEICovXG52YXIgQ1JwJDUgPSB7fTtcblxuQ1JwJDUuZHJhd05vZGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICBpZiAoIW51bWJlcihwb3MueCkgfHwgIW51bWJlcihwb3MueSkpIHtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG5cbiAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFub2RlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG4gIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7IC8vXG4gIC8vIHNldHVwIHNoaWZ0XG5cbiAgdmFyIGJiO1xuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfSAvL1xuICAvLyBsb2FkIGJnIGltYWdlXG5cblxuICB2YXIgYmdJbWdQcm9wID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgdmFyIHVybHMgPSBiZ0ltZ1Byb3AudmFsdWU7XG4gIHZhciB1cmxEZWZpbmVkID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIGltYWdlID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIG51bUltYWdlcyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVybCA9IHVybHNbaV07XG4gICAgdmFyIGRlZmQgPSB1cmxEZWZpbmVkW2ldID0gdXJsICE9IG51bGwgJiYgdXJsICE9PSAnbm9uZSc7XG5cbiAgICBpZiAoZGVmZCkge1xuICAgICAgdmFyIGJnSW1nQ3Jvc3NPcmlnaW4gPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCAndmFsdWUnLCBpKTtcbiAgICAgIG51bUltYWdlcysrOyAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuXG4gICAgICBpbWFnZVtpXSA9IHIuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBiZ0ltZ0Nyb3NzT3JpZ2luLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9wLmJhY2tncm91bmRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBub2RlLmVtaXRBbmROb3RpZnkoJ2JhY2tncm91bmQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvL1xuICAvLyBzZXR1cCBzdHlsZXNcblxuXG4gIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWJsYWNrZW4nKS52YWx1ZTtcbiAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBiZ09wYWNpdHkgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gIHZhciBzZXR1cFNoYXBlQ29sb3IgPSBmdW5jdGlvbiBzZXR1cFNoYXBlQ29sb3IoKSB7XG4gICAgdmFyIGJnT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBiZ09wYWNpdHk7XG4gICAgci5lbGVGaWxsU3R5bGUoY29udGV4dCwgbm9kZSwgYmdPcHkpO1xuICB9O1xuXG4gIHZhciBzZXR1cEJvcmRlckNvbG9yID0gZnVuY3Rpb24gc2V0dXBCb3JkZXJDb2xvcigpIHtcbiAgICB2YXIgYmRyT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBib3JkZXJPcGFjaXR5O1xuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBiZHJPcHkpO1xuICB9OyAvL1xuICAvLyBzZXR1cCBzaGFwZVxuXG5cbiAgdmFyIHN0eWxlU2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNoYXBlUHRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykucGZWYWx1ZTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgIHZhciBwYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmdzKHN0eWxlU2hhcGUgPT09ICdwb2x5Z29uJyA/IHN0eWxlU2hhcGUgKyAnLCcgKyBzaGFwZVB0cy5qb2luKCcsJykgOiBzdHlsZVNoYXBlLCAnJyArIG5vZGVIZWlnaHQsICcnICsgbm9kZVdpZHRoKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IHBhdGhDYWNoZVtrZXldO1xuXG4gICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgcGF0aCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGhDYWNoZVtrZXldID0gcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKCkge1xuICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgICB2YXIgbnBvcyA9IHBvcztcblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhwYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdJbWFnZXMgPSBmdW5jdGlvbiBkcmF3SW1hZ2VzKCkge1xuICAgIHZhciBub2RlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgICB2YXIgdG90YWxDb21wbGV0ZWQgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGltYWdlLmxlbmd0aDsgX2krKykge1xuICAgICAgaWYgKHVybERlZmluZWRbX2ldICYmIGltYWdlW19pXS5jb21wbGV0ZSAmJiAhaW1hZ2VbX2ldLmVycm9yKSB7XG4gICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgIHIuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlW19pXSwgbm9kZSwgX2ksIG5vZGVPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcC5iYWNrZ3JvdW5kaW5nID0gISh0b3RhbENvbXBsZXRlZCA9PT0gbnVtSW1hZ2VzKTtcblxuICAgIGlmIChwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgbm9kZS51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3UGllID0gZnVuY3Rpb24gZHJhd1BpZSgpIHtcbiAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBwaWVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuXG4gICAgaWYgKHIuaGFzUGllKG5vZGUpKSB7XG4gICAgICByLmRyYXdQaWUoY29udGV4dCwgbm9kZSwgcGllT3BhY2l0eSk7IC8vIHJlZHJhdy9yZXN0b3JlIHBhdGggaWYgc3RlcHMgYWZ0ZXIgcGllIG5lZWQgaXRcblxuICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG4gICAgICAgIGlmICghdXNlUGF0aHMpIHtcbiAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkYXJrZW4gPSBmdW5jdGlvbiBkYXJrZW4oKSB7XG4gICAgdmFyIGRhcmtlbk9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIG9wYWNpdHkgPSAoZGFya25lc3MgPiAwID8gZGFya25lc3MgOiAtZGFya25lc3MpICogZGFya2VuT3BhY2l0eTtcbiAgICB2YXIgYyA9IGRhcmtuZXNzID4gMCA/IDAgOiAyNTU7XG5cbiAgICBpZiAoZGFya25lc3MgIT09IDApIHtcbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYywgYywgYywgb3BhY2l0eSk7XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2ggKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAvIDM7XG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9IC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG5cblxuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgbm9kZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgfTtcblxuICB2YXIgZ2hvc3QgPSBub2RlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZHaG9zdE9wYWNpdHkgPSBnaG9zdE9wYWNpdHkgKiBlbGVPcGFjaXR5O1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgc2V0dXBTaGFwZUNvbG9yKGdob3N0T3BhY2l0eSAqIGJnT3BhY2l0eSk7XG4gICAgZHJhd1NoYXBlKCk7XG4gICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHkpO1xuICAgIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICAgIGRhcmtlbihlZmZHaG9zdE9wYWNpdHkpO1xuICAgIHNldHVwQm9yZGVyQ29sb3IoZ2hvc3RPcGFjaXR5ICogYm9yZGVyT3BhY2l0eSk7XG4gICAgZHJhd0JvcmRlcigpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIHNldHVwU2hhcGVDb2xvcigpO1xuICBkcmF3U2hhcGUoKTtcbiAgZHJhd0ltYWdlcygpO1xuICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgZGFya2VuKCk7XG4gIHNldHVwQm9yZGVyQ29sb3IoKTtcbiAgZHJhd0JvcmRlcigpO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuXG4gIGRyYXdUZXh0KCk7XG4gIGRyYXdPdmVybGF5KCk7IC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xuXG5DUnAkNS5kcmF3Tm9kZU92ZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmICghbm9kZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBub2RlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gbm9kZS5wc3R5bGUoJ292ZXJsYXktY29sb3InKS52YWx1ZTtcblxuICBpZiAob3ZlcmxheU9wYWNpdHkgPiAwKSB7XG4gICAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcblxuICAgIGlmIChub2RlV2lkdGggPT0gbnVsbCB8fCBub2RlSGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gICAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogcGFkZGluZztcbiAgICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7XG4gICAgfVxuXG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG4gICAgci5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGggKyBvdmVybGF5UGFkZGluZyAqIDIsIG5vZGVIZWlnaHQgKyBvdmVybGF5UGFkZGluZyAqIDIpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG59OyAvLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cblxuXG5DUnAkNS5oYXNQaWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuXG5DUnAkNS5kcmF3UGllID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5LCBwb3MpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIGN5U3R5bGUgPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIHBpZVNpemUgPSBub2RlLnBzdHlsZSgncGllLXNpemUnKTtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcmFkaXVzID0gTWF0aC5taW4obm9kZVcsIG5vZGVIKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcblxuICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG5cbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHggPSAwO1xuICAgIHkgPSAwO1xuICB9XG5cbiAgaWYgKHBpZVNpemUudW5pdHMgPT09ICclJykge1xuICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUucGZWYWx1ZTtcbiAgfSBlbHNlIGlmIChwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAvLyAxLi5OXG4gICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnKS52YWx1ZTtcbiAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG5cbiAgICBpZiAocGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSkge1xuICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcblxuICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhOyAvLyBpZ25vcmUgaWZcbiAgICAvLyAtIHplcm8gc2l6ZVxuICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuXG4gICAgaWYgKHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICB9XG59O1xuXG52YXIgQ1JwJDYgPSB7fTtcbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7IC8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAkNi5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZGF0YS5jb250ZXh0c1swXTtcblxuICBpZiAodGhpcy5mb3JjZWRQaXhlbFJhdGlvICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JjZWRQaXhlbFJhdGlvO1xuICB9XG5cbiAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn07XG5cbkNScCQ2LnBhaW50Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gIHZhciBjYWNoZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuXG4gICAgaWYgKGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAobmVlZFRvQ3JlYXRlQ2FjaGUpIHtcbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbkNScCQ2LmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IgPSBmdW5jdGlvbiAoY29udGV4dCwgc2hhcGVTdHlsZU5hbWUsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICB2YXIgZ3JhZGllbnRTdHlsZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgY29sb3JzID0gZWxlLnBzdHlsZShzaGFwZVN0eWxlTmFtZSArICctZ3JhZGllbnQtc3RvcC1jb2xvcnMnKS52YWx1ZSxcbiAgICAgIHBvc2l0aW9ucyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJykucGZWYWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgICBlbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKSxcbiAgICAgICAgICBtaWQgPSBlbGUubWlkcG9pbnQoKTtcbiAgICAgIHZhciBkMSA9IGRpc3Qoc3RhcnQsIG1pZCk7XG4gICAgICB2YXIgZDIgPSBkaXN0KGVuZCwgbWlkKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG1pZC54LCBtaWQueSwgMCwgbWlkLngsIG1pZC55LCBNYXRoLm1heChkMSwgZDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgICAgd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChwb3MueCwgcG9zLnksIDAsIHBvcy54LCBwb3MueSwgTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgX3N0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgX2VuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpO1xuXG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfc3RhcnQueCwgX3N0YXJ0LnksIF9lbmQueCwgX2VuZC55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgIF93aWR0aCA9IGVsZS5wYWRkZWRXaWR0aCgpLFxuICAgICAgICAgIF9oZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCksXG4gICAgICAgICAgaGFsZldpZHRoID0gX3dpZHRoIC8gMixcbiAgICAgICAgICBoYWxmSGVpZ2h0ID0gX2hlaWdodCAvIDI7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicpLnZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlICd0by1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1sZWZ0JzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0JzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1yaWdodCc6XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0LWJvdHRvbSc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvLXRvcC1yaWdodCc6XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1sZWZ0JzpcbiAgICAgICAgY2FzZSAndG8tbGVmdC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by10b3AtbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCBncmFkaWVudCBzdHlsZVxuXG4gIHZhciBoYXNQb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoID09PSBjb2xvcnMubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gY29sb3JzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZ3JhZGllbnRTdHlsZS5hZGRDb2xvclN0b3AoaGFzUG9zaXRpb25zID8gcG9zaXRpb25zW2ldIDogaSAvIChsZW5ndGggLSAxKSwgJ3JnYmEoJyArIGNvbG9yc1tpXVswXSArICcsJyArIGNvbG9yc1tpXVsxXSArICcsJyArIGNvbG9yc1tpXVsyXSArICcsJyArIG9wYWNpdHkgKyAnKScpO1xuICB9XG5cbiAgcmV0dXJuIGdyYWRpZW50U3R5bGU7XG59O1xuXG5DUnAkNi5ncmFkaWVudEZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2JhY2tncm91bmQnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5cbkNScCQ2LmNvbG9yRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJzsgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gaWYoIGNhY2hlLmZpbGxTdHlsZSAhPT0gZmlsbFN0eWxlICl7XG4gIC8vICAgY29udGV4dC5maWxsU3R5bGUgPSBjYWNoZS5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gIC8vIH1cbn07XG5cbkNScCQ2LmVsZUZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGJhY2tncm91bmRGaWxsID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1maWxsJykudmFsdWU7XG5cbiAgaWYgKGJhY2tncm91bmRGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBiYWNrZ3JvdW5kRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50RmlsbFN0eWxlKGNvbnRleHQsIGVsZSwgYmFja2dyb3VuZEZpbGwsIG9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBiYWNrZ3JvdW5kQ29sb3JbMF0sIGJhY2tncm91bmRDb2xvclsxXSwgYmFja2dyb3VuZENvbG9yWzJdLCBvcGFjaXR5KTtcbiAgfVxufTtcblxuQ1JwJDYuZ3JhZGllbnRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2xpbmUnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBncmFkaWVudFN0eWxlO1xufTtcblxuQ1JwJDYuY29sb3JTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJzsgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG4gIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gIC8vIH1cbn07XG5cbkNScCQ2LmVsZVN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICB2YXIgbGluZUZpbGwgPSBlbGUucHN0eWxlKCdsaW5lLWZpbGwnKS52YWx1ZTtcblxuICBpZiAobGluZUZpbGwgPT09ICdsaW5lYXItZ3JhZGllbnQnIHx8IGxpbmVGaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgIHRoaXMuZ3JhZGllbnRTdHJva2VTdHlsZShjb250ZXh0LCBlbGUsIGxpbmVGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGluZUNvbG9yID0gZWxlLnBzdHlsZSgnbGluZS1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgfVxufTsgLy8gUmVzaXplIGNhbnZhc1xuXG5cbkNScCQ2Lm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIGJiID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IGJiWzJdO1xuICB2YXIgaGVpZ2h0ID0gYmJbM107XG4gIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuXG4gIGlmIChjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pIHtcbiAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICB9XG5cbiAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhcztcblxuICBpZiAoY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCkge1xuICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICB9XG5cbiAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgY2FudmFzID0gZGF0YS5jYW52YXNlc1tpXTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICByLnRleHR1cmVNdWx0ID0gMTtcblxuICBpZiAocGl4ZWxSYXRpbyA8PSAxKSB7XG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gIH1cblxuICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xufTtcblxuQ1JwJDYucmVuZGVyVG8gPSBmdW5jdGlvbiAoY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgdGhpcy5yZW5kZXIoe1xuICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICBmb3JjZWRab29tOiB6b29tLFxuICAgIGZvcmNlZFBhbjogcGFuLFxuICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICB9KTtcbn07XG5cbkNScCQ2LnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG5cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgaWYgKHIucHJldlB4UmF0aW8gIT09IHBpeGVsUmF0aW8pIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgIH1cblxuICAgIHIucHJldlB4UmF0aW8gPSBwaXhlbFJhdGlvO1xuICB9XG5cbiAgaWYgKCFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQoci5tb3Rpb25CbHVyVGltZW91dCk7XG4gIH1cblxuICBpZiAobW90aW9uQmx1cikge1xuICAgIGlmIChyLm1iRnJhbWVzID09IG51bGwpIHtcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgIH1cblxuICAgIHIubWJGcmFtZXMrKztcblxuICAgIGlmIChyLm1iRnJhbWVzIDwgMykge1xuICAgICAgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICB9IC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcblxuXG4gICAgaWYgKHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcykge1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgIH1cbiAgfVxuXG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9IC8vIGIvYyBkcmF3VG9Db250ZXh0KCkgbWF5IGJlIGFzeW5jIHcuci50LiByZWRyYXcoKSwga2VlcCB0cmFjayBvZiBsYXN0IHRleHR1cmUgZnJhbWVcbiAgLy8gYmVjYXVzZSBhIHJvZ3VlIGFzeW5jIHRleHR1cmUgZnJhbWUgd291bGQgY2xlYXIgbmVlZERyYXdcblxuXG4gIGlmIChyLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdykge1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICB4OiBwYW4ueCxcbiAgICB5OiBwYW4ueVxuICB9O1xuICB2YXIgdnAgPSB7XG4gICAgem9vbTogem9vbSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9XG4gIH07XG4gIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55OyAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuXG4gIGlmICghdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfVxuXG4gIGlmIChmb3JjZWRQYW4pIHtcbiAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gIH0gLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuXG4gIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgZnVuY3Rpb24gbWJjbGVhcihjb250ZXh0LCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKSB7XG4gICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgaWYgKCFyLmNsZWFyaW5nTW90aW9uQmx1ciAmJiAoY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkpIHtcbiAgICAgIGVQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgfTtcbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoICogbWJQeFJhdGlvO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0ICogbWJQeFJhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBlUGFuID0gZWZmZWN0aXZlUGFuO1xuICAgICAgZVpvb20gPSBlZmZlY3RpdmVab29tO1xuICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgfVxuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiAoY2xlYXIgPT09ICdtb3Rpb25CbHVyJykge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB3LCBoKTtcbiAgICB9IGVsc2UgaWYgKCFmb3JjZWRDb250ZXh0ICYmIChjbGVhciA9PT0gdW5kZWZpbmVkIHx8IGNsZWFyKSkge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShlUGFuLngsIGVQYW4ueSk7XG4gICAgICBjb250ZXh0LnNjYWxlKGVab29tLCBlWm9vbSk7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlZFBhbikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55KTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VkWm9vbSkge1xuICAgICAgY29udGV4dC5zY2FsZShmb3JjZWRab29tLCBmb3JjZWRab29tKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG5cbiAgICBpZiAoIXIudGV4dHVyZUNhY2hlKSB7XG4gICAgICByLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgICAgci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcbiAgICAgIHIucmVuZGVyKHtcbiAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgZm9yY2VkUHhSYXRpbzogcGl4ZWxSYXRpbyAqIHIudGV4dHVyZU11bHRcbiAgICAgIH0pO1xuICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgcGFuOiBjeS5wYW4oKSxcbiAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgIH07XG4gICAgICB2cC5tcGFuID0ge1xuICAgICAgICB4OiAoMCAtIHZwLnBhbi54KSAvIHZwLnpvb20sXG4gICAgICAgIHk6ICgwIC0gdnAucGFuLnkpIC8gdnAuem9vbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydDtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IHN0eWxlLmNvcmUoJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JykudmFsdWU7XG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgZmFsc2UpO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgfSBlbHNlIGlmIChyLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0KSB7XG4gICAgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG4gIHZhciB2cE1hbmlwID0gci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmN5LmFuaW1hdGVkKCk7XG4gIHZhciBoaWRlRWRnZXMgPSByLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcbiAgdmFyIG5lZWRNYkNsZWFyID0gW107XG4gIG5lZWRNYkNsZWFyW3IuTk9ERV0gPSAhbmVlZERyYXdbci5OT0RFXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgaWYgKG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSB0cnVlO1xuICB9XG5cbiAgbmVlZE1iQ2xlYXJbci5EUkFHXSA9ICFuZWVkRHJhd1tyLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcblxuICBpZiAobmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IHRydWU7XG4gIH1cblxuICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSA6IGRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpO1xuXG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cblxuICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSkge1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddIDogZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCk7XG5cbiAgICBpZiAoaGlkZUVkZ2VzKSB7XG4gICAgICByLmRyYXdDYWNoZWROb2Rlcyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5kcmFnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoci5zaG93RnBzIHx8ICFkcmF3T25seU5vZGVMYXllciAmJiBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdICYmICFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbci5TRUxFQ1RfQk9YXTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQpO1xuXG4gICAgaWYgKHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcpKSB7XG4gICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnKS52YWx1ZSAvIHpvb207XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG5cbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1zaXplJykucGZWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuXG4gICAgaWYgKHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIpIHtcbiAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQodGltZVRvUmVuZGVyKTtcbiAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAgLyB0aW1lVG9SZW5kZXIpO1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgY29udGV4dC5maWxsVGV4dCgnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjApO1xuICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIDMwLCAyNTAsIDIwKTtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMzAsIDI1MCAqIE1hdGgubWluKGZwcyAvIG1heEZwcywgMSksIDIwKTtcbiAgICB9XG5cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSBmYWxzZTtcbiAgICB9XG4gIH0gLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG5cblxuICBpZiAobW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEpIHtcbiAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdHh0Tm9kZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdO1xuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tyLkRSQUddO1xuICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR107XG5cbiAgICB2YXIgZHJhd01vdGlvbkJsdXIgPSBmdW5jdGlvbiBkcmF3TW90aW9uQmx1cihjeHQsIHR4dCwgbmVlZENsZWFyKSB7XG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICBpZiAobmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCkge1xuICAgICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1iY2xlYXIoY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBweHIgPSBtYlB4UmF0aW87XG4gICAgICBjeHQuZHJhd0ltYWdlKHR4dCwgLy8gaW1nXG4gICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgIDAsIDAsIC8vIHgsIHlcbiAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW3IuTk9ERV0pO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZWVkRHJhd1tyLkRSQUddIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW3IuRFJBR10pO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHIucHJldlZpZXdwb3J0ID0gdnA7XG5cbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gIXRleHR1cmVEcmF3O1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSB0cnVlO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCBtb3Rpb25CbHVyRGVsYXkpO1xuICB9XG5cbiAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgY3kuZW1pdCgncmVuZGVyJyk7XG4gIH1cbn07XG5cbnZhciBDUnAkNyA9IHt9OyAvLyBATyBQb2x5Z29uIGRyYXdpbmdcblxuQ1JwJDcuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGNvbnRleHQubW92ZVRvKHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSk7XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwJDcuZHJhd1JvdW5kUG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvaW50cy5sZW5ndGggLyA0OyBfaSsrKSB7XG4gICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICBpZiAoX2kgPT09IDApIHtcbiAgICAgIHNvdXJjZVV2ID0gcG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVV2ID0gX2kgKiA0IC0gMjtcbiAgICB9XG5cbiAgICBkZXN0VXYgPSBfaSAqIDQgKyAyO1xuICAgIHZhciBweCA9IHggKyBoYWxmVyAqIHBvaW50c1tfaSAqIDRdO1xuICAgIHZhciBweSA9IHkgKyBoYWxmSCAqIHBvaW50c1tfaSAqIDQgKyAxXTtcbiAgICB2YXIgY29zVGhldGEgPSAtcG9pbnRzW3NvdXJjZVV2XSAqIHBvaW50c1tkZXN0VXZdIC0gcG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBwb2ludHNbZGVzdFV2ICsgMV07XG4gICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogcG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogcG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIHBvaW50c1tkZXN0VXZdO1xuICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoX2kgPT09IDApIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKGNwMHgsIGNwMHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjcDB4LCBjcDB5KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFyY1RvKHB4LCBweSwgY3AxeCwgY3AxeSwgY29ybmVyUmFkaXVzKTtcbiAgfVxuXG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59OyAvLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuXG5cbkNScCQ3LmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTsgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG5cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTsgLy8gQXJjIGZyb20gcmlnaHQgc2lkZSB0byBib3R0b21cblxuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTsgLy8gQXJjIGZyb20gYm90dG9tIHRvIGxlZnQgc2lkZVxuXG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcblxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTsgLy8gSm9pbiBsaW5lXG5cbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwJDcuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH0gLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuXG5cbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkpO1xuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAkNy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lckxlbmd0aCA9IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpO1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGggLSBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQ3LmRyYXdCYXJyZWxQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgeEJlZ2luID0geCAtIGhhbGZXaWR0aDtcbiAgdmFyIHhFbmQgPSB4ICsgaGFsZldpZHRoO1xuICB2YXIgeUJlZ2luID0geSAtIGhhbGZIZWlnaHQ7XG4gIHZhciB5RW5kID0geSArIGhhbGZIZWlnaHQ7XG4gIHZhciBiYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgd09mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICB2YXIgaE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgdmFyIGN0cmxQdFhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3T2Zmc2V0O1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiArIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kIC0gd09mZnNldCwgeUVuZCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCwgeUVuZCAtIGhPZmZzZXQpO1xuICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LmxpbmVUbyh4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW4pO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxudmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbnZhciBjb3MwID0gTWF0aC5jb3MoMCk7XG52YXIgc2luID0ge307XG52YXIgY29zID0ge307XG52YXIgZWxsaXBzZVN0ZXBTaXplID0gTWF0aC5QSSAvIDQwO1xuXG5mb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgc2luW2ldID0gTWF0aC5zaW4oaSk7XG4gIGNvc1tpXSA9IE1hdGguY29zKGkpO1xufVxuXG5DUnAkNy5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuZWxsaXBzZSkge1xuICAgIGNvbnRleHQuZWxsaXBzZShjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgeFBvcywgeVBvcztcbiAgICB2YXIgcncgPSB3aWR0aCAvIDI7XG4gICAgdmFyIHJoID0gaGVpZ2h0IC8gMjtcblxuICAgIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICAgICAgeFBvcyA9IGNlbnRlclggLSBydyAqIHNpbltpXSAqIHNpbjAgKyBydyAqIGNvc1tpXSAqIGNvczA7XG4gICAgICB5UG9zID0gY2VudGVyWSArIHJoICogY29zW2ldICogc2luMCArIHJoICogc2luW2ldICogY29zMDtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLyogZ2xvYmFsIGF0b2IsIEFycmF5QnVmZmVyLCBVaW50OEFycmF5LCBCbG9iICovXG52YXIgQ1JwJDggPSB7fTtcblxuQ1JwJDguY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKHcsIGgpIHtcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgYnVmZmVyLndpZHRoID0gdztcbiAgYnVmZmVyLmhlaWdodCA9IGg7XG4gIHJldHVybiBbYnVmZmVyLCBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKV07XG59O1xuXG5DUnAkOC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogY3RyUmVjdFsyXTtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IGN0clJlY3RbM107XG4gIHZhciBzcGVjZE1heERpbXMgPSBudW1iZXIob3B0aW9ucy5tYXhXaWR0aCkgfHwgbnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KTtcbiAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIHNjYWxlID0gMTtcblxuICBpZiAob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIH0gZWxzZSBpZiAoc3BlY2RNYXhEaW1zKSB7XG4gICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcblxuICAgIGlmIChudW1iZXIob3B0aW9ucy5tYXhXaWR0aCkpIHtcbiAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIob3B0aW9ucy5tYXhIZWlnaHQpKSB7XG4gICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgIH1cblxuICAgIHNjYWxlID0gTWF0aC5taW4obWF4U2NhbGVXLCBtYXhTY2FsZUgpO1xuICAgIHdpZHRoICo9IHNjYWxlO1xuICAgIGhlaWdodCAqPSBzY2FsZTtcbiAgfVxuXG4gIGlmICghc3BlY2RNYXhEaW1zKSB7XG4gICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICBzY2FsZSAqPSBweFJhdGlvO1xuICB9XG5cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuXG4gIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgICBpZiAob3B0aW9ucy5mdWxsKSB7XG4gICAgICAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC1iYi54MSAqIHNjYWxlLCAtYmIueTEgKiBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKGJiLngxICogc2NhbGUsIGJiLnkxICogc2NhbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogcGFuLnggKiBzY2FsZSxcbiAgICAgICAgeTogcGFuLnkgKiBzY2FsZVxuICAgICAgfTtcbiAgICAgIHNjYWxlICo9IGN5Lnpvb20oKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtdHJhbnNsYXRpb24ueCwgLXRyYW5zbGF0aW9uLnkpO1xuICAgIH0gLy8gbmVlZCB0byBmaWxsIGJnIGF0IGVuZCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gZmlsbCBjbGVhcmVkIHRyYW5zcGFyZW50IHBpeGVscyBpbiBqcGdzXG5cblxuICAgIGlmIChvcHRpb25zLmJnKSB7XG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmQ2FudmFzO1xufTtcblxuZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZdLCB7XG4gICAgdHlwZTogbWltZVR5cGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KGI2NHVyaSkge1xuICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0KG9wdGlvbnMsIGNhbnZhcywgbWltZVR5cGUpIHtcbiAgdmFyIGdldEI2NFVyaSA9IGZ1bmN0aW9uIGdldEI2NFVyaSgpIHtcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgfTtcblxuICBzd2l0Y2ggKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgY2FzZSAnYmxvYi1wcm9taXNlJzpcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICBpZiAoYmxvYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdgY2FudmFzLnRvQmxvYigpYCBzZW50IGEgbnVsbCB2YWx1ZSBpbiBpdHMgY2FsbGJhY2snKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYihiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSksIG1pbWVUeXBlKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpO1xuXG4gICAgY2FzZSAnYmFzZTY0dXJpJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdldEI2NFVyaSgpO1xuICB9XG59XG5cbkNScCQ4LnBuZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL3BuZycpO1xufTtcblxuQ1JwJDguanBnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvanBlZycpO1xufTtcblxudmFyIENScCQ5ID0ge307XG5cbkNScCQ5Lm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgIGNhc2UgJ3JvdW5kLXBvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdyb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ2N1dHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnY3V0LXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdiYXJyZWwnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0JhcnJlbFBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbn07XG5cbnZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xudmFyIENScCRhID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuQ1JwJGEuQ0FOVkFTX0xBWUVSUyA9IDM7IC8vXG5cbkNScCRhLlNFTEVDVF9CT1ggPSAwO1xuQ1JwJGEuRFJBRyA9IDE7XG5DUnAkYS5OT0RFID0gMjtcbkNScCRhLkJVRkZFUl9DT1VOVCA9IDM7IC8vXG5cbkNScCRhLlRFWFRVUkVfQlVGRkVSID0gMDtcbkNScCRhLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwJGEuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAkYS5DQU5WQVNfTEFZRVJTKSxcbiAgICBjb250ZXh0czogbmV3IEFycmF5KENScCRhLkNBTlZBU19MQVlFUlMpLFxuICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ1JwJGEuQ0FOVkFTX0xBWUVSUyksXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheShDUnAkYS5CVUZGRVJfQ09VTlQpLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwJGEuQ0FOVkFTX0xBWUVSUylcbiAgfTtcbiAgdmFyIHRhcEhsT2ZmQXR0ciA9ICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InO1xuICB2YXIgdGFwSGxPZmZTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBjb250YWluZXJTdHlsZS56SW5kZXggPSAnMCc7XG4gIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmNhbnZhc0NvbnRhaW5lcik7XG4gIGNvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgdmFyIHN0eWxlTWFwID0ge1xuICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctbW96LXVzZXItc2VsZWN0JzogJy1tb3otbm9uZScsXG4gICAgJ3VzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKScsXG4gICAgJ291dGxpbmUtc3R5bGUnOiAnbm9uZSdcbiAgfTtcblxuICBpZiAobXMoKSkge1xuICAgIHN0eWxlTWFwWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgc3R5bGVNYXBbJ3RvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUnAkYS5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuZGF0YS5jb250ZXh0c1tpXSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIE9iamVjdC5rZXlzKHN0eWxlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBjYW52YXMuc3R5bGVba10gPSBzdHlsZU1hcFtrXTtcbiAgICB9KTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAkYS5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICB9XG5cbiAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScCRhLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAkYS5OT0RFICsgJy1ub2RlJyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAkYS5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwJGEuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94Jyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAkYS5EUkFHXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwJGEuRFJBRyArICctZHJhZycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwJGEuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsgLy9yLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSk7XG4gIH1cblxuICByLnBhdGhzRW5hYmxlZCA9IHRydWU7XG4gIHZhciBlbXB0eUJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgdmFyIGdldEJveENlbnRlciA9IGZ1bmN0aW9uIGdldEJveENlbnRlcihiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoYmIueDEgKyBiYi54MikgLyAyLFxuICAgICAgeTogKGJiLnkxICsgYmIueTIpIC8gMlxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGdldENlbnRlck9mZnNldChiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAtYmIudyAvIDIsXG4gICAgICB5OiAtYmIuaCAvIDJcbiAgICB9O1xuICB9O1xuXG4gIHZhciBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCA9IGZ1bmN0aW9uIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkKGVsZSkge1xuICAgIHZhciBfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICB2YXIgc2FtZSA9IF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPT09IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgcmV0dXJuICFzYW1lO1xuICB9O1xuXG4gIHZhciBnZXRTdHlsZUtleSA9IGZ1bmN0aW9uIGdldFN0eWxlS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubm9kZUtleTtcbiAgfTtcblxuICB2YXIgZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsU3R5bGVLZXk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5zb3VyY2VMYWJlbFN0eWxlS2V5O1xuICB9O1xuXG4gIHZhciBnZXRUYXJnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUudGFyZ2V0TGFiZWxTdHlsZUtleTtcbiAgfTtcblxuICB2YXIgZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiBkcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgZmFsc2UsIGZhbHNlLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd0xhYmVsID0gZnVuY3Rpb24gZHJhd0xhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ21haW4nLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd1NvdXJjZUxhYmVsID0gZnVuY3Rpb24gZHJhd1NvdXJjZUxhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3NvdXJjZScsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBkcmF3VGFyZ2V0TGFiZWwgPSBmdW5jdGlvbiBkcmF3VGFyZ2V0TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAndGFyZ2V0JywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGdldEVsZW1lbnRCb3ggPSBmdW5jdGlvbiBnZXRFbGVtZW50Qm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuYm9keUJvdW5kcztcbiAgfTtcblxuICB2YXIgZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLm1haW4gfHwgZW1wdHlCYjtcbiAgfTtcblxuICB2YXIgZ2V0U291cmNlTGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnNvdXJjZSB8fCBlbXB0eUJiO1xuICB9O1xuXG4gIHZhciBnZXRUYXJnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMudGFyZ2V0IHx8IGVtcHR5QmI7XG4gIH07XG5cbiAgdmFyIGlzTGFiZWxWaXNpYmxlQXRTY2FsZSA9IGZ1bmN0aW9uIGlzTGFiZWxWaXNpYmxlQXRTY2FsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pIHtcbiAgICByZXR1cm4gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcblxuICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Qm94Q2VudGVyKGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGFkZFRleHRNYXJnaW4gPSBmdW5jdGlvbiBhZGRUZXh0TWFyZ2luKHByZWZpeCwgcHQsIGVsZSkge1xuICAgIHZhciBwcmUgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgeDogcHQueCArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlLFxuICAgICAgeTogcHQueSArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0UnNQdCA9IGZ1bmN0aW9uIGdldFJzUHQoZWxlLCB4LCB5KSB7XG4gICAgdmFyIHJzID0gZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHJldHVybiB7XG4gICAgICB4OiByc1t4XSxcbiAgICAgIHk6IHJzW3ldXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCcnLCBnZXRSc1B0KGVsZSwgJ2xhYmVsWCcsICdsYWJlbFknKSwgZWxlKTtcbiAgfTtcblxuICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCdzb3VyY2UnLCBnZXRSc1B0KGVsZSwgJ3NvdXJjZUxhYmVsWCcsICdzb3VyY2VMYWJlbFknKSwgZWxlKTtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCd0YXJnZXQnLCBnZXRSc1B0KGVsZSwgJ3RhcmdldExhYmVsWCcsICd0YXJnZXRMYWJlbFknKSwgZWxlKTtcbiAgfTtcblxuICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgfTtcblxuICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRTb3VyY2VMYWJlbEJveChlbGUpKTtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRUYXJnZXRMYWJlbEJveChlbGUpKTtcbiAgfTtcblxuICB2YXIgZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgdmFyIGJiID0gZ2V0TGFiZWxCb3goZWxlKTtcbiAgICB2YXIgcCA9IGdldENlbnRlck9mZnNldChnZXRMYWJlbEJveChlbGUpKTtcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBwLnggPSAtYmIudztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcC54ID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcC55ID0gLWJiLmg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBwLnkgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHZhciBlbGVUeHJDYWNoZSA9IHIuZGF0YS5lbGVUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFN0eWxlS2V5LFxuICAgIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCxcbiAgICBkcmF3RWxlbWVudDogZHJhd0VsZW1lbnQsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEVsZW1lbnRCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCxcbiAgICBhbGxvd0VkZ2VUeHJDYWNoaW5nOiBmYWxzZSxcbiAgICBhbGxvd1BhcmVudFR4ckNhY2hpbmc6IGZhbHNlXG4gIH0pO1xuICB2YXIgbGJsVHhyQ2FjaGUgPSByLmRhdGEubGJsVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd0xhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciBzbGJUeHJDYWNoZSA9IHIuZGF0YS5zbGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFNvdXJjZUxhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3U291cmNlTGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldFNvdXJjZUxhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIHRsYlR4ckNhY2hlID0gci5kYXRhLnRsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0VGFyZ2V0TGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdUYXJnZXRMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0VGFyZ2V0TGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgbHlyVHhyQ2FjaGUgPSByLmRhdGEubHlyVHhyQ2FjaGUgPSBuZXcgTGF5ZXJlZFRleHR1cmVDYWNoZShyKTtcbiAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uIGludmFsaWRhdGVUZXh0dXJlQ2FjaGVzKHdpbGxEcmF3LCBlbGVzKSB7XG4gICAgLy8gZWFjaCBjYWNoZSBzaG91bGQgY2hlY2sgZm9yIHN1Yi1rZXkgZGlmZiB0byBzZWUgdGhhdCB0aGUgdXBkYXRlIGFmZmVjdHMgdGhhdCBjYWNoZSBwYXJ0aWN1bGFybHlcbiAgICBlbGVUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgbGJsVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIHNsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICB0bGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7IC8vIGFueSBjaGFuZ2UgaW52YWxpZGF0ZXMgdGhlIGxheWVyc1xuXG4gICAgbHlyVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpOyAvLyB1cGRhdGUgdGhlIG9sZCBiZyB0aW1lc3RhbXAgc28gZGlmZnMgY2FuIGJlIGRvbmUgaW4gdGhlIGVsZSB0eHIgY2FjaGVzXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbX2ldLl9wcml2YXRlO1xuICAgICAgX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcmVmaW5lSW5MYXllcnMgPSBmdW5jdGlvbiByZWZpbmVJbkxheWVycyhyZXFzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBseXJUeHJDYWNoZS5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQocmVxc1tpXS5lbGUpO1xuICAgIH1cbiAgfTtcblxuICBlbGVUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICBsYmxUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICBzbGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICB0bGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xufVxuXG5DUnAkYS5yZWRyYXdIaW50ID0gZnVuY3Rpb24gKGdyb3VwLCBib29sKSB7XG4gIHZhciByID0gdGhpcztcblxuICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwJGEuTk9ERV0gPSBib29sO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAkYS5EUkFHXSA9IGJvb2w7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwJGEuU0VMRUNUX0JPWF0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gIH1cbn07IC8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG5cblxudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuQ1JwJGEucGF0aDJkRW5hYmxlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzRW5hYmxlZDtcbiAgfVxuXG4gIHRoaXMucGF0aHNFbmFibGVkID0gb24gPyB0cnVlIDogZmFsc2U7XG59O1xuXG5DUnAkYS51c2VQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuXG5DUnAkYS5zZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCwgYm9vbCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9XG59O1xuXG5DUnAkYS5nZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgfVxufTtcblxuQ1JwJGEubWFrZU9mZnNjcmVlbkNhbnZhcyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKCh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoT2Zmc2NyZWVuQ2FudmFzKSkgIT09ICggXCJ1bmRlZmluZWRcIiApKSB7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59O1xuXG5bQ1JwLCBDUnAkMSwgQ1JwJDIsIENScCQzLCBDUnAkNCwgQ1JwJDUsIENScCQ2LCBDUnAkNywgQ1JwJDgsIENScCQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoQ1JwJGEsIHByb3BzKTtcbn0pO1xuXG52YXIgcmVuZGVyZXIgPSBbe1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxSZW5kZXJlclxufSwge1xuICBuYW1lOiAnYmFzZScsXG4gIGltcGw6IEJSXG59LCB7XG4gIG5hbWU6ICdjYW52YXMnLFxuICBpbXBsOiBDUlxufV07XG5cbnZhciBpbmNFeHRzID0gW3tcbiAgdHlwZTogJ2xheW91dCcsXG4gIGV4dGVuc2lvbnM6IGxheW91dFxufSwge1xuICB0eXBlOiAncmVuZGVyZXInLFxuICBleHRlbnNpb25zOiByZW5kZXJlclxufV07XG5cbnZhciBleHRlbnNpb25zID0ge307IC8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG5cbnZhciBtb2R1bGVzID0ge307XG5cbmZ1bmN0aW9uIHNldEV4dGVuc2lvbih0eXBlLCBuYW1lLCByZWdpc3RyYW50KSB7XG4gIHZhciBleHQgPSByZWdpc3RyYW50O1xuXG4gIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyKGZpZWxkKSB7XG4gICAgZXJyb3IoJ0NhbiBub3QgcmVnaXN0ZXIgYCcgKyBuYW1lICsgJ2AgZm9yIGAnICsgdHlwZSArICdgIHNpbmNlIGAnICsgZmllbGQgKyAnYCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlIGFuZCBjYW4gbm90IGJlIG92ZXJyaWRkZW4nKTtcbiAgfTtcblxuICBpZiAodHlwZSA9PT0gJ2NvcmUnKSB7XG4gICAgaWYgKENvcmUucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvcmUucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbGxlY3Rpb24nKSB7XG4gICAgaWYgKENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xheW91dCcpIHtcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgcmVnaXN0cmFudC5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcblxuICAgICAgaWYgKCFwbGFpbk9iamVjdCh0aGlzLl9wcml2YXRlKSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYW50LnByb3RvdHlwZSk7XG4gICAgdmFyIG9wdExheW91dEZucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG5cbiAgICAgIGxheW91dFByb3RvW2ZuTmFtZV0gPSBsYXlvdXRQcm90b1tmbk5hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuXG5cbiAgICBpZiAobGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1bikge1xuICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuXG4gICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGFuaXMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cbiAgICAgICAgaWYgKGFuaXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYW5pcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFuaXNbX2ldLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlZ1N0b3ApIHtcbiAgICAgICAgcmVnU3RvcC5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBpZiAoIWxheW91dFByb3RvLmRlc3Ryb3kpIHtcbiAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsYXlvdXRQcm90by5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0Q3kgPSBmdW5jdGlvbiBnZXRDeShsYXlvdXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuX3ByaXZhdGUuY3k7XG4gICAgfTtcblxuICAgIHZhciBlbWl0dGVyT3B0cyA9IHtcbiAgICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhsYXlvdXQsIGV2dCkge1xuICAgICAgICBldnQubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICBldnQuY3kgPSBnZXRDeShsYXlvdXQpO1xuICAgICAgICBldnQudGFyZ2V0ID0gbGF5b3V0O1xuICAgICAgfSxcbiAgICAgIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChsYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldEN5KGxheW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHRlbmQobGF5b3V0UHJvdG8sIHtcbiAgICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRzLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICAgIH0sXG4gICAgICBvbjogZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgb25lOiBmdW5jdGlvbiBvbmUoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZ0LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldnQsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZSQzLmV2ZW50QWxpYXNlc09uKGxheW91dFByb3RvKTtcbiAgICBleHQgPSBMYXlvdXQ7IC8vIHJlcGxhY2Ugd2l0aCBvdXIgd3JhcHBlZCBsYXlvdXRcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncmVuZGVyZXInICYmIG5hbWUgIT09ICdudWxsJyAmJiBuYW1lICE9PSAnYmFzZScpIHtcbiAgICAvLyB1c2VyIHJlZ2lzdGVyZWQgcmVuZGVyZXJzIGluaGVyaXQgZnJvbSBiYXNlXG4gICAgdmFyIEJhc2VSZW5kZXJlciA9IGdldEV4dGVuc2lvbigncmVuZGVyZXInLCAnYmFzZScpO1xuICAgIHZhciBiUHJvdG8gPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlO1xuICAgIHZhciBSZWdpc3RyYW50UmVuZGVyZXIgPSByZWdpc3RyYW50O1xuICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcblxuICAgIHZhciBSZW5kZXJlciA9IGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgQmFzZVJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBSZWdpc3RyYW50UmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgcE5hbWUgaW4gYlByb3RvKSB7XG4gICAgICB2YXIgcFZhbCA9IGJQcm90b1twTmFtZV07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvW3BOYW1lXSAhPSBudWxsO1xuXG4gICAgICBpZiAoZXhpc3RzSW5SKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVycihwTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvW3BOYW1lXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfcE5hbWUgaW4gclByb3RvKSB7XG4gICAgICBwcm90b1tfcE5hbWVdID0gclByb3RvW19wTmFtZV07IC8vIHRha2UgaW1wbCBmcm9tIHJlZ2lzdHJhbnRcbiAgICB9XG5cbiAgICBiUHJvdG8uY2xpZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gcHJvdG9bbmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlcnJvcignUmVuZGVyZXIgZG9lcyBub3QgaW1wbGVtZW50IGByZW5kZXJlci4nICsgbmFtZSArICcoKWAgb24gaXRzIHByb3RvdHlwZScpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBleHQgPSBSZW5kZXJlcjtcbiAgfVxuXG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV0sXG4gICAgdmFsdWU6IGV4dFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUpIHtcbiAgcmV0dXJuIGdldE1hcCh7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lXVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgcmV0dXJuIHNldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXSxcbiAgICB2YWx1ZTogcmVnaXN0cmFudFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUpIHtcbiAgcmV0dXJuIGdldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXVxuICB9KTtcbn1cblxudmFyIGV4dGVuc2lvbiA9IGZ1bmN0aW9uIGV4dGVuc2lvbigpIHtcbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gc2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gICAgICAgIH1cbn07IC8vIGFsbG93cyBhIGNvcmUgaW5zdGFuY2UgdG8gYWNjZXNzIGV4dGVuc2lvbnMgaW50ZXJuYWxseVxuXG5cbkNvcmUucHJvdG90eXBlLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjsgLy8gaW5jbHVkZWQgZXh0ZW5zaW9uc1xuXG5pbmNFeHRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gIGdyb3VwLmV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gICAgc2V0RXh0ZW5zaW9uKGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCk7XG4gIH0pO1xufSk7XG5cbi8vICh1c2VmdWwgZm9yIGluaXQpXG5cbnZhciBTdHlsZXNoZWV0ID0gZnVuY3Rpb24gU3R5bGVzaGVldCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlc2hlZXQpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZXNoZWV0KCk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG52YXIgc2hlZXRmbiA9IFN0eWxlc2hlZXQucHJvdG90eXBlO1xuXG5zaGVldGZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xufTsgLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5cblxuc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdXG4gIH07XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTsgLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG5cblxuc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgIHZhciBtYXAgPSBuYW1lO1xuICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wTmFtZXNbal07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW2tleV07XG5cbiAgICAgIGlmIChtYXBWYWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3AgPSBTdHlsZS5wcm9wZXJ0aWVzW2tleV0gfHwgU3R5bGUucHJvcGVydGllc1tkYXNoMmNhbWVsKGtleSldO1xuXG4gICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICB2YXIgX3ZhbHVlID0gbWFwVmFsO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBfbmFtZSxcbiAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zaGVldGZuLnN0eWxlID0gc2hlZXRmbi5jc3M7IC8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuXG5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoY3kpIHtcbiAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kVG9TdHlsZShzdHlsZSk7XG59OyAvLyBhcHBlbmQgYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCBvbiBhIHJlYWwgc3R5bGUgb2JqZWN0XG5cblxuc2hlZXRmbi5hcHBlbmRUb1N0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgc3R5bGUuY3NzKHByb3AubmFtZSwgcHJvcC52YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIHZlcnNpb24gPSBcIjMuMTIuMVwiO1xuXG52YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24gY3l0b3NjYXBlKG9wdGlvbnMpIHtcbiAgLy8gaWYgbm8gb3B0aW9ucyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH0gLy8gY3JlYXRlIGluc3RhbmNlXG5cblxuICBpZiAocGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gbmV3IENvcmUob3B0aW9ucyk7XG4gIH0gLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gIGVsc2UgaWYgKHN0cmluZyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbi5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gICAgfVxufTsgLy8gZS5nLiBjeXRvc2NhcGUudXNlKCByZXF1aXJlKCdjeXRvc2NhcGUtZm9vJyksIGJhciApXG5cblxuY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgYXJncy51bnNoaWZ0KGN5dG9zY2FwZSk7IC8vIGN5dG9zY2FwZSBpcyBmaXJzdCBhcmcgdG8gZXh0XG5cbiAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmN5dG9zY2FwZS53YXJuaW5ncyA9IGZ1bmN0aW9uIChib29sKSB7XG4gIHJldHVybiB3YXJuaW5ncyhib29sKTtcbn07IC8vIHJlcGxhY2VkIGJ5IGJ1aWxkIHN5c3RlbVxuXG5cbmN5dG9zY2FwZS52ZXJzaW9uID0gdmVyc2lvbjsgLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5cbmN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN5dG9zY2FwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaGVhcCcpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gIC8qXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG5cbiAgLypcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cbiAgXG4gIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cbiAgXG4gIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2VcbiAgb2YgYSB0byBiZSBzZWFyY2hlZC5cbiAgICovXG5cbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICBsbyA9IDA7XG4gICAgfVxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGxvIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICBoaSA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgfTtcblxuXG4gIC8qXG4gIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuICBcbiAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgKi9cblxuICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICovXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICovXG5cbiAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqL1xuXG4gIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgfTtcblxuICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydHBvcyA9IHBvcztcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgfVxuICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYXA7XG4gICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgcmV0dXJuIEhlYXA7XG5cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHJldHVybiBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290LkhlYXAgPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSGVhcDtcbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIG4sbCx1LHQsaSxvLHIsZj17fSxlPVtdLGM9L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtmdW5jdGlvbiBzKG4sbCl7Zm9yKHZhciB1IGluIGwpblt1XT1sW3VdO3JldHVybiBufWZ1bmN0aW9uIGEobil7dmFyIGw9bi5wYXJlbnROb2RlO2wmJmwucmVtb3ZlQ2hpbGQobil9ZnVuY3Rpb24gaChuLGwsdSl7dmFyIHQsaSxvLHIsZj1hcmd1bWVudHM7aWYobD1zKHt9LGwpLGFyZ3VtZW50cy5sZW5ndGg+Mylmb3IodT1bdV0sdD0zO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspdS5wdXNoKGZbdF0pO2lmKG51bGwhPXUmJihsLmNoaWxkcmVuPXUpLG51bGwhPW4mJm51bGwhPW4uZGVmYXVsdFByb3BzKWZvcihpIGluIG4uZGVmYXVsdFByb3BzKXZvaWQgMD09PWxbaV0mJihsW2ldPW4uZGVmYXVsdFByb3BzW2ldKTtyZXR1cm4gcj1sLmtleSxudWxsIT0obz1sLnJlZikmJmRlbGV0ZSBsLnJlZixudWxsIT1yJiZkZWxldGUgbC5rZXksdihuLGwscixvKX1mdW5jdGlvbiB2KGwsdSx0LGkpe3ZhciBvPXt0eXBlOmwscHJvcHM6dSxrZXk6dCxyZWY6aSxfX2s6bnVsbCxfXzpudWxsLF9fYjowLF9fZTpudWxsLF9fZDpudWxsLF9fYzpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMH07cmV0dXJuIG4udm5vZGUmJm4udm5vZGUobyksb31mdW5jdGlvbiBwKCl7cmV0dXJue319ZnVuY3Rpb24gZChuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiB5KG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIG0obixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP20obi5fXyxuLl9fLl9fay5pbmRleE9mKG4pKzEpOm51bGw7Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXJldHVybiB1Ll9fZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/bShuKTpudWxsfWZ1bmN0aW9uIHcobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fKSYmbnVsbCE9bi5fX2Mpe2ZvcihuLl9fZT1uLl9fYy5iYXNlPW51bGwsbD0wO2w8bi5fX2subGVuZ3RoO2wrKylpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfXJldHVybiB3KG4pfX1mdW5jdGlvbiBnKGwpeyghbC5fX2QmJihsLl9fZD0hMCkmJjE9PT11LnB1c2gobCl8fGkhPT1uLmRlYm91bmNlUmVuZGVyaW5nKSYmKChpPW4uZGVib3VuY2VSZW5kZXJpbmcpfHx0KShrKX1mdW5jdGlvbiBrKCl7dmFyIG4sbCx0LGksbyxyLGY7Zm9yKHUuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBsLl9fdi5fX2Itbi5fX3YuX19ifSk7bj11LnBvcCgpOyluLl9fZCYmKHQ9dm9pZCAwLGk9dm9pZCAwLHI9KG89KGw9bikuX192KS5fX2UsKGY9bC5fX1ApJiYodD1bXSxpPVQoZixvLHMoe30sbyksbC5fX24sdm9pZCAwIT09Zi5vd25lclNWR0VsZW1lbnQsbnVsbCx0LG51bGw9PXI/bShvKTpyKSwkKHQsbyksaSE9ciYmdyhvKSkpfWZ1bmN0aW9uIF8obixsLHUsdCxpLG8scixjLHMpe3ZhciBoLHYscCxkLHksdyxnLGs9dSYmdS5fX2t8fGUsXz1rLmxlbmd0aDtpZihjPT1mJiYoYz1udWxsIT1vP29bMF06Xz9tKHUsMCk6bnVsbCksaD0wLGwuX19rPWIobC5fX2ssZnVuY3Rpb24odSl7aWYobnVsbCE9dSl7aWYodS5fXz1sLHUuX19iPWwuX19iKzEsbnVsbD09PShwPWtbaF0pfHxwJiZ1LmtleT09cC5rZXkmJnUudHlwZT09PXAudHlwZSlrW2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djxfO3YrKyl7aWYoKHA9a1t2XSkmJnUua2V5PT1wLmtleSYmdS50eXBlPT09cC50eXBlKXtrW3ZdPXZvaWQgMDticmVha31wPW51bGx9aWYoZD1UKG4sdSxwPXB8fGYsdCxpLG8scixjLHMpLCh2PXUucmVmKSYmcC5yZWYhPXYmJihnfHwoZz1bXSkscC5yZWYmJmcucHVzaChwLnJlZixudWxsLHUpLGcucHVzaCh2LHUuX19jfHxkLHUpKSxudWxsIT1kKXtpZihudWxsPT13JiYodz1kKSxudWxsIT11Ll9fZClkPXUuX19kLHUuX19kPW51bGw7ZWxzZSBpZihvPT1wfHxkIT1jfHxudWxsPT1kLnBhcmVudE5vZGUpe246aWYobnVsbD09Y3x8Yy5wYXJlbnROb2RlIT09biluLmFwcGVuZENoaWxkKGQpO2Vsc2V7Zm9yKHk9Yyx2PTA7KHk9eS5uZXh0U2libGluZykmJnY8Xzt2Kz0yKWlmKHk9PWQpYnJlYWsgbjtuLmluc2VydEJlZm9yZShkLGMpfVwib3B0aW9uXCI9PWwudHlwZSYmKG4udmFsdWU9XCJcIil9Yz1kLm5leHRTaWJsaW5nLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwudHlwZSYmKGwuX19kPWQpfX1yZXR1cm4gaCsrLHV9KSxsLl9fZT13LG51bGwhPW8mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGwudHlwZSlmb3IoaD1vLmxlbmd0aDtoLS07KW51bGwhPW9baF0mJmEob1toXSk7Zm9yKGg9XztoLS07KW51bGwhPWtbaF0mJkEoa1toXSxrW2hdKTtpZihnKWZvcihoPTA7aDxnLmxlbmd0aDtoKyspeihnW2hdLGdbKytoXSxnWysraF0pfWZ1bmN0aW9uIGIobixsLHUpe2lmKG51bGw9PXUmJih1PVtdKSxudWxsPT1ufHxcImJvb2xlYW5cIj09dHlwZW9mIG4pbCYmdS5wdXNoKGwobnVsbCkpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShuKSlmb3IodmFyIHQ9MDt0PG4ubGVuZ3RoO3QrKyliKG5bdF0sbCx1KTtlbHNlIHUucHVzaChsP2woXCJzdHJpbmdcIj09dHlwZW9mIG58fFwibnVtYmVyXCI9PXR5cGVvZiBuP3YobnVsbCxuLG51bGwsbnVsbCk6bnVsbCE9bi5fX2V8fG51bGwhPW4uX19jP3Yobi50eXBlLG4ucHJvcHMsbi5rZXksbnVsbCk6bik6bik7cmV0dXJuIHV9ZnVuY3Rpb24geChuLGwsdSx0LGkpe3ZhciBvO2ZvcihvIGluIHUpbyBpbiBsfHxQKG4sbyxudWxsLHVbb10sdCk7Zm9yKG8gaW4gbClpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsW29dfHxcInZhbHVlXCI9PT1vfHxcImNoZWNrZWRcIj09PW98fHVbb109PT1sW29dfHxQKG4sbyxsW29dLHVbb10sdCl9ZnVuY3Rpb24gQyhuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPVwibnVtYmVyXCI9PXR5cGVvZiB1JiYhMT09PWMudGVzdChsKT91K1wicHhcIjpudWxsPT11P1wiXCI6dX1mdW5jdGlvbiBQKG4sbCx1LHQsaSl7dmFyIG8scixmLGUsYztpZihpP1wiY2xhc3NOYW1lXCI9PT1sJiYobD1cImNsYXNzXCIpOlwiY2xhc3NcIj09PWwmJihsPVwiY2xhc3NOYW1lXCIpLFwia2V5XCI9PT1sfHxcImNoaWxkcmVuXCI9PT1sKTtlbHNlIGlmKFwic3R5bGVcIj09PWwpaWYobz1uLnN0eWxlLFwic3RyaW5nXCI9PXR5cGVvZiB1KW8uY3NzVGV4dD11O2Vsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJihvLmNzc1RleHQ9XCJcIix0PW51bGwpLHQpZm9yKHIgaW4gdCl1JiZyIGluIHV8fEMobyxyLFwiXCIpO2lmKHUpZm9yKGYgaW4gdSl0JiZ1W2ZdPT09dFtmXXx8QyhvLGYsdVtmXSl9ZWxzZVwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdPyhlPWwhPT0obD1sLnJlcGxhY2UoL0NhcHR1cmUkLyxcIlwiKSksYz1sLnRvTG93ZXJDYXNlKCksbD0oYyBpbiBuP2M6bCkuc2xpY2UoMiksdT8odHx8bi5hZGRFdmVudExpc3RlbmVyKGwsTixlKSwobi5sfHwobi5sPXt9KSlbbF09dSk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsTixlKSk6XCJsaXN0XCIhPT1sJiZcInRhZ05hbWVcIiE9PWwmJlwiZm9ybVwiIT09bCYmIWkmJmwgaW4gbj9uW2xdPW51bGw9PXU/XCJcIjp1OlwiZnVuY3Rpb25cIiE9dHlwZW9mIHUmJlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWwmJihsIT09KGw9bC5yZXBsYWNlKC9eeGxpbms6Py8sXCJcIikpP251bGw9PXV8fCExPT09dT9uLnJlbW92ZUF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLGwudG9Mb3dlckNhc2UoKSk6bi5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixsLnRvTG93ZXJDYXNlKCksdSk6bnVsbD09dXx8ITE9PT11P24ucmVtb3ZlQXR0cmlidXRlKGwpOm4uc2V0QXR0cmlidXRlKGwsdSkpfWZ1bmN0aW9uIE4obCl7dGhpcy5sW2wudHlwZV0obi5ldmVudD9uLmV2ZW50KGwpOmwpfWZ1bmN0aW9uIFQobCx1LHQsaSxvLHIsZixlLGMpe3ZhciBhLGgsdixwLG0sdyxnLGsseCxDLFA9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7KGE9bi5fX2IpJiZhKHUpO3RyeXtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFApe2lmKGs9dS5wcm9wcyx4PShhPVAuY29udGV4dFR5cGUpJiZpW2EuX19jXSxDPWE/eD94LnByb3BzLnZhbHVlOmEuX186aSx0Ll9fYz9nPShoPXUuX19jPXQuX19jKS5fXz1oLl9fRTooXCJwcm90b3R5cGVcImluIFAmJlAucHJvdG90eXBlLnJlbmRlcj91Ll9fYz1oPW5ldyBQKGssQyk6KHUuX19jPWg9bmV3IHkoayxDKSxoLmNvbnN0cnVjdG9yPVAsaC5yZW5kZXI9RCkseCYmeC5zdWIoaCksaC5wcm9wcz1rLGguc3RhdGV8fChoLnN0YXRlPXt9KSxoLmNvbnRleHQ9QyxoLl9fbj1pLHY9aC5fX2Q9ITAsaC5fX2g9W10pLG51bGw9PWguX19zJiYoaC5fX3M9aC5zdGF0ZSksbnVsbCE9UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihoLl9fcz09aC5zdGF0ZSYmKGguX19zPXMoe30saC5fX3MpKSxzKGguX19zLFAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKGssaC5fX3MpKSkscD1oLnByb3BzLG09aC5zdGF0ZSx2KW51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsIT1oLmNvbXBvbmVudFdpbGxNb3VudCYmaC5jb21wb25lbnRXaWxsTW91bnQoKSxudWxsIT1oLmNvbXBvbmVudERpZE1vdW50JiZoLl9faC5wdXNoKGguY29tcG9uZW50RGlkTW91bnQpO2Vsc2V7aWYobnVsbD09UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGw9PWguX19lJiZudWxsIT1oLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhrLEMpLCFoLl9fZSYmbnVsbCE9aC5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09aC5zaG91bGRDb21wb25lbnRVcGRhdGUoayxoLl9fcyxDKSl7Zm9yKGgucHJvcHM9ayxoLnN0YXRlPWguX19zLGguX19kPSExLGguX192PXUsdS5fX2U9dC5fX2UsdS5fX2s9dC5fX2ssaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksYT0wO2E8dS5fX2subGVuZ3RoO2ErKyl1Ll9fa1thXSYmKHUuX19rW2FdLl9fPXUpO2JyZWFrIG59bnVsbCE9aC5jb21wb25lbnRXaWxsVXBkYXRlJiZoLmNvbXBvbmVudFdpbGxVcGRhdGUoayxoLl9fcyxDKSxudWxsIT1oLmNvbXBvbmVudERpZFVwZGF0ZSYmaC5fX2gucHVzaChmdW5jdGlvbigpe2guY29tcG9uZW50RGlkVXBkYXRlKHAsbSx3KX0pfWguY29udGV4dD1DLGgucHJvcHM9ayxoLnN0YXRlPWguX19zLChhPW4uX19yKSYmYSh1KSxoLl9fZD0hMSxoLl9fdj11LGguX19QPWwsYT1oLnJlbmRlcihoLnByb3BzLGguc3RhdGUsaC5jb250ZXh0KSx1Ll9faz1iKG51bGwhPWEmJmEudHlwZT09ZCYmbnVsbD09YS5rZXk/YS5wcm9wcy5jaGlsZHJlbjphKSxudWxsIT1oLmdldENoaWxkQ29udGV4dCYmKGk9cyhzKHt9LGkpLGguZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwodz1oLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHAsbSkpLF8obCx1LHQsaSxvLHIsZixlLGMpLGguYmFzZT11Ll9fZSxoLl9faC5sZW5ndGgmJmYucHVzaChoKSxnJiYoaC5fX0U9aC5fXz1udWxsKSxoLl9fZT1udWxsfWVsc2UgdS5fX2U9aih0Ll9fZSx1LHQsaSxvLHIsZixjKTsoYT1uLmRpZmZlZCkmJmEodSl9Y2F0Y2gobCl7bi5fX2UobCx1LHQpfXJldHVybiB1Ll9fZX1mdW5jdGlvbiAkKGwsdSl7bi5fX2MmJm4uX19jKHUsbCksbC5zb21lKGZ1bmN0aW9uKHUpe3RyeXtsPXUuX19oLHUuX19oPVtdLGwuc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChsKXtuLl9fZShsLHUuX192KX19KX1mdW5jdGlvbiBqKG4sbCx1LHQsaSxvLHIsYyl7dmFyIHMsYSxoLHYscCxkPXUucHJvcHMseT1sLnByb3BzO2lmKGk9XCJzdmdcIj09PWwudHlwZXx8aSxudWxsPT1uJiZudWxsIT1vKWZvcihzPTA7czxvLmxlbmd0aDtzKyspaWYobnVsbCE9KGE9b1tzXSkmJihudWxsPT09bC50eXBlPzM9PT1hLm5vZGVUeXBlOmEubG9jYWxOYW1lPT09bC50eXBlKSl7bj1hLG9bc109bnVsbDticmVha31pZihudWxsPT1uKXtpZihudWxsPT09bC50eXBlKXJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh5KTtuPWk/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixsLnR5cGUpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobC50eXBlKSxvPW51bGx9aWYobnVsbD09PWwudHlwZSludWxsIT1vJiYob1tvLmluZGV4T2YobildPW51bGwpLGQhPT15JiYobi5kYXRhPXkpO2Vsc2UgaWYobCE9PXUpe2lmKG51bGwhPW8mJihvPWUuc2xpY2UuY2FsbChuLmNoaWxkTm9kZXMpKSxoPShkPXUucHJvcHN8fGYpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLHY9eS5kYW5nZXJvdXNseVNldElubmVySFRNTCwhYyl7aWYoZD09PWYpZm9yKGQ9e30scD0wO3A8bi5hdHRyaWJ1dGVzLmxlbmd0aDtwKyspZFtuLmF0dHJpYnV0ZXNbcF0ubmFtZV09bi5hdHRyaWJ1dGVzW3BdLnZhbHVlOyh2fHxoKSYmKHYmJmgmJnYuX19odG1sPT1oLl9faHRtbHx8KG4uaW5uZXJIVE1MPXYmJnYuX19odG1sfHxcIlwiKSl9eChuLHksZCxpLGMpLGwuX19rPWwucHJvcHMuY2hpbGRyZW4sdnx8XyhuLGwsdSx0LFwiZm9yZWlnbk9iamVjdFwiIT09bC50eXBlJiZpLG8scixmLGMpLGN8fChcInZhbHVlXCJpbiB5JiZ2b2lkIDAhPT15LnZhbHVlJiZ5LnZhbHVlIT09bi52YWx1ZSYmKG4udmFsdWU9bnVsbD09eS52YWx1ZT9cIlwiOnkudmFsdWUpLFwiY2hlY2tlZFwiaW4geSYmdm9pZCAwIT09eS5jaGVja2VkJiZ5LmNoZWNrZWQhPT1uLmNoZWNrZWQmJihuLmNoZWNrZWQ9eS5jaGVja2VkKSl9cmV0dXJuIG59ZnVuY3Rpb24geihsLHUsdCl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIGw/bCh1KTpsLmN1cnJlbnQ9dX1jYXRjaChsKXtuLl9fZShsLHQpfX1mdW5jdGlvbiBBKGwsdSx0KXt2YXIgaSxvLHI7aWYobi51bm1vdW50JiZuLnVubW91bnQobCksKGk9bC5yZWYpJiZ6KGksbnVsbCx1KSx0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnR5cGV8fCh0PW51bGwhPShvPWwuX19lKSksbC5fX2U9bC5fX2Q9bnVsbCxudWxsIT0oaT1sLl9fYykpe2lmKGkuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2kuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChsKXtuLl9fZShsLHUpfWkuYmFzZT1pLl9fUD1udWxsfWlmKGk9bC5fX2spZm9yKHI9MDtyPGkubGVuZ3RoO3IrKylpW3JdJiZBKGlbcl0sdSx0KTtudWxsIT1vJiZhKG8pfWZ1bmN0aW9uIEQobixsLHUpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yKG4sdSl9ZnVuY3Rpb24gRShsLHUsdCl7dmFyIGkscixjO24uX18mJm4uX18obCx1KSxyPShpPXQ9PT1vKT9udWxsOnQmJnQuX19rfHx1Ll9fayxsPWgoZCxudWxsLFtsXSksYz1bXSxUKHUsKGk/dTp0fHx1KS5fX2s9bCxyfHxmLGYsdm9pZCAwIT09dS5vd25lclNWR0VsZW1lbnQsdCYmIWk/W3RdOnI/bnVsbDplLnNsaWNlLmNhbGwodS5jaGlsZE5vZGVzKSxjLHR8fGYsaSksJChjLGwpfWZ1bmN0aW9uIEgobixsKXtFKG4sbCxvKX1mdW5jdGlvbiBJKG4sbCl7cmV0dXJuIGw9cyhzKHt9LG4ucHJvcHMpLGwpLGFyZ3VtZW50cy5sZW5ndGg+MiYmKGwuY2hpbGRyZW49ZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSksdihuLnR5cGUsbCxsLmtleXx8bi5rZXksbC5yZWZ8fG4ucmVmKX1mdW5jdGlvbiBMKG4pe3ZhciBsPXt9LHU9e19fYzpcIl9fY0NcIityKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdCxpPXRoaXM7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodD1bXSx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBsW3UuX19jXT1pLGx9LHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKGwpe24udmFsdWUhPT1sLnZhbHVlJiZ0LnNvbWUoZnVuY3Rpb24obil7bi5jb250ZXh0PWwudmFsdWUsZyhuKX0pfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt0LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dC5zcGxpY2UodC5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuQ29uc3VtZXIuY29udGV4dFR5cGU9dSx1fW49e19fZTpmdW5jdGlvbihuLGwpe2Zvcih2YXIgdTtsPWwuX187KWlmKCh1PWwuX19jKSYmIXUuX18pdHJ5e2lmKHUuY29uc3RydWN0b3ImJm51bGwhPXUuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKXUuc2V0U3RhdGUodS5jb25zdHJ1Y3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IobikpO2Vsc2V7aWYobnVsbD09dS5jb21wb25lbnREaWRDYXRjaCljb250aW51ZTt1LmNvbXBvbmVudERpZENhdGNoKG4pfXJldHVybiBnKHUuX19FPXUpfWNhdGNoKGwpe249bH10aHJvdyBufX0sbD1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbCE9biYmdm9pZCAwPT09bi5jb25zdHJ1Y3Rvcn0seS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24obixsKXt2YXIgdTt1PXRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1zKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4odSx0aGlzLnByb3BzKSksbiYmcyh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYodGhpcy5fX2U9ITEsbCYmdGhpcy5fX2gucHVzaChsKSxnKHRoaXMpKX0seS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLGcodGhpcykpfSx5LnByb3RvdHlwZS5yZW5kZXI9ZCx1PVtdLHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsbz1mLHI9MDtleHBvcnR7RSBhcyByZW5kZXIsSCBhcyBoeWRyYXRlLGggYXMgY3JlYXRlRWxlbWVudCxoLGQgYXMgRnJhZ21lbnQscCBhcyBjcmVhdGVSZWYsbCBhcyBpc1ZhbGlkRWxlbWVudCx5IGFzIENvbXBvbmVudCxJIGFzIGNsb25lRWxlbWVudCxMIGFzIGNyZWF0ZUNvbnRleHQsYiBhcyB0b0NoaWxkQXJyYXksQSBhcyBfdW5tb3VudCxuIGFzIG9wdGlvbnN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0Lm1vZHVsZS5qcy5tYXBcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnLi4vY29udHJvbGxlcic7XG5pbXBvcnQgQ3l0b3NjYXBlIGZyb20gJ2N5dG9zY2FwZSc7XG4vL2ltcG9ydCBmY29zZSBmcm9tICdjeXRvc2NhcGUtZmNvc2UnO1xuLy9DeXRvc2NhcGUudXNlKCBmY29zZSApO1xuaW1wb3J0IHsgZWxlbWVudHMsIHN0eWxlIH0gZnJvbSAnLi4vY3ktY29uZic7XG5pbXBvcnQgQ3l0b3NjYXBlQ29tcG9uZW50IGZyb20gJy4vY3l0b3NjYXBlJztcbmltcG9ydCB7IGlzRGV2IH0gZnJvbSAnLi4vZW52JztcbmltcG9ydCB7IE5vZGVJbmZvIH0gZnJvbSAnLi9ub2RlLWluZm8nO1xuaW1wb3J0IHsgTWVudSB9IGZyb20gJy4vbWVudSc7XG5cbmNsYXNzIEFwcENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCBjeSA9IG5ldyBDeXRvc2NhcGUoe1xuICAgICAgZWxlbWVudHMsXG4gICAgICBzdHlsZSxcbiAgICAgIC8vbGF5b3V0OiB7IG5hbWU6ICdmY29zZScgfSxcbiAgICAgIGxheW91dDogeyBuYW1lOiAncHJlc2V0JyB9LFxuICAgICAgLy9sYXlvdXQ6IHsgbmFtZTogJ2dyaWQnIH0sXG4gICAgICBzZWxlY3Rpb25UeXBlOiAnc2luZ2xlJyxcbiAgICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgem9vbWluZ0VuYWJsZWQ6IHRydWUsXG4gICAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvL2N5LnVzZShmY29zZSlcbiAgICBjeS5ub2RlcygpLnBhbmlmeSgpLnVuZ3JhYmlmeSgpO1xuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHsgY3kgfSk7XG4gICAgY29uc3QgYnVzID0gY29udHJvbGxlci5idXM7XG5cbiAgICBpZiggaXNEZXYgKXtcbiAgICAgIHdpbmRvdy5jeSA9IGN5O1xuICAgICAgd2luZG93LmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB7IGNvbnRyb2xsZXIsIGN5IH07XG5cbiAgICBidXMub24oJ3Nob3dJbmZvJywgdGhpcy5vblNob3dJbmZvID0gKG5vZGUgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluZm9Ob2RlOiBub2RlIH0pO1xuICAgIH0pKTtcblxuICAgIGJ1cy5vbignaGlkZUluZm8nLCB0aGlzLm9uSGlkZUluZm8gPSAoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGluZm9Ob2RlOiBudWxsIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgY29uc3QgYnVzID0gdGhpcy5zdGF0ZS5jb250cm9sbGVyLmJ1cztcblxuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignc2hvd0luZm8nLCB0aGlzLm9uU2hvd0luZm8pO1xuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignaGlkZUluZm8nLCB0aGlzLm9uSGlkZUluZm8pO1xuICB9XG5cbiAgcmVuZGVyKCl7XG4gICAgY29uc3QgeyBjeSwgY29udHJvbGxlciwgaW5mb05vZGUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzczogJ2FwcCcgfSwgW1xuICAgICAgaChDeXRvc2NhcGVDb21wb25lbnQsIHsgY3ksIGNvbnRyb2xsZXIgfSksXG5cbiAgICAgIGluZm9Ob2RlID8gKFxuICAgICAgICBoKCdkaXYnLCB7IGNsYXNzOiAnYXBwLW5vZGUtaW5mbycgfSwgW1xuICAgICAgICAgIGgoTm9kZUluZm8sIHsgbm9kZTogaW5mb05vZGUgfSlcbiAgICAgICAgXSlcbiAgICAgICkgOiBudWxsLFxuXG4gICAgICBoKE1lbnUsIHsgY29udHJvbGxlciB9KVxuICAgIF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFwcENvbXBvbmVudDtcbmV4cG9ydCB7IEFwcENvbXBvbmVudCB9OyIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNsYXNzIEN5dG9zY2FwZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICByZXR1cm4gaCgnZGl2JywgeyBpZDogJ2N5JyB9KTsgICAgXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpe1xuICAgIGNvbnN0IHsgY3ksIGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N5Jyk7XG5cbiAgICBjeS5tb3VudChjb250YWluZXIpO1xuICAgIGN5LmZpdCgxMCk7XG5cbiAgICBjeS5vbigndGFwJywgdGhpcy5vblRhcCA9IGUgPT4ge1xuICAgICAgaWYoIGUudGFyZ2V0ID09PSBjeSApe1xuICAgICAgICBjb250cm9sbGVyLnVuaGlnaGxpZ2h0KCk7XG4gICAgICAgIGNvbnRyb2xsZXIuaGlkZUluZm8oKTtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZU1lbnUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuaGlnaGxpZ2h0KGUudGFyZ2V0KTtcbiAgICAgICAgY29udHJvbGxlci5zaG93SW5mbyhlLnRhcmdldCk7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2VNZW51KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpe1xuICAgIGNvbnN0IHsgY3kgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjeS5yZW1vdmVMaXN0ZW5lcigndGFwJywgdGhpcy5vblRhcCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ3l0b3NjYXBlQ29tcG9uZW50O1xuZXhwb3J0IHsgQ3l0b3NjYXBlQ29tcG9uZW50IH07IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSc7XG5pbXBvcnQgeyBOb2RlSW5mbyB9IGZyb20gJy4vbm9kZS1pbmZvJztcblxuY2xhc3MgTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgYnVzIH0gPSBjb250cm9sbGVyO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG9wZW46IGNvbnRyb2xsZXIuaXNNZW51T3BlbigpXG4gICAgfTtcblxuICAgIGJ1cy5vbignb3Blbk1lbnUnLCB0aGlzLm9uT3Blbk1lbnUgPSAoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW46IHRydWUgfSk7XG5cbiAgICAgIHRoaXMuZm9jdXNUZXh0Qm94KCk7XG4gICAgfSkpO1xuXG4gICAgYnVzLm9uKCdjbG9zZU1lbnUnLCB0aGlzLm9uT3Blbk1lbnUgPSAoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wZW46IGZhbHNlIH0pO1xuICAgIH0pKTtcblxuICAgIGJ1cy5vbigndXBkYXRlU2VhcmNoJywgdGhpcy5vblVwZGF0ZVNlYXJjaCA9IChzZWFyY2hNYXRjaE5vZGVzID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWFyY2hNYXRjaE5vZGVzIH0pO1xuICAgIH0pKTtcblxuICAgIHRoaXMuZGVib3VuY2VkVXBkYXRlU2VhcmNoID0gZGVib3VuY2UoKCkgPT4gdGhpcy51cGRhdGVTZWFyY2goKSwgMjUwKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgY29uc3QgeyBidXMgfSA9IHRoaXMucHJvcHMuY29udHJvbGxlcjtcblxuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignb3Blbk1lbnUnLCB0aGlzLm9uT3Blbk1lbnUpO1xuICAgIGJ1cy5yZW1vdmVMaXN0ZW5lcignY2xvc2VNZW51JywgdGhpcy5vbkNsb3NlTWVudSk7XG4gICAgYnVzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGVTZWFyY2gnLCB0aGlzLm9uVXBkYXRlU2VhcmNoKTtcbiAgfVxuXG4gIG9wZW4oKXtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb250cm9sbGVyLm9wZW5NZW51KCk7XG4gIH1cblxuICB1cGRhdGVTZWFyY2goKXtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudS1zZWFyY2gnKTtcbiAgICBjb25zdCByZXN1bHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnUtc2VhcmNoLXJlc3VsdHMnKTtcbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IGlucHV0LnZhbHVlO1xuXG4gICAgcmVzdWx0cy5zY3JvbGxUbygwLCAwKTtcblxuICAgIGNvbnRyb2xsZXIudXBkYXRlU2VhcmNoKHF1ZXJ5U3RyaW5nKTtcbiAgfVxuXG4gIGZvY3VzVGV4dEJveCgpe1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnUtc2VhcmNoJyk7XG5cbiAgICBpZiggaW5wdXQgKXtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgc2VsZWN0Tm9kZShub2RlKXtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb250cm9sbGVyLmNsb3NlTWVudSgpO1xuICAgIGNvbnRyb2xsZXIuaGlnaGxpZ2h0KG5vZGUpO1xuICAgIGNvbnRyb2xsZXIuc2hvd0luZm8obm9kZSk7XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICBjb25zdCB7IGNvbnRyb2xsZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBvcGVuLCBzZWFyY2hNYXRjaE5vZGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNsb3NlZCA9ICFvcGVuO1xuXG4gICAgbGV0IHNlYXJjaFJlc3VsdHMgPSBbXTtcblxuICAgIGlmKCBzZWFyY2hNYXRjaE5vZGVzICl7XG4gICAgICBzZWFyY2hSZXN1bHRzID0gc2VhcmNoTWF0Y2hOb2Rlcy5tYXAobm9kZSA9PiBoKCdkaXYubWVudS1ub2RlLWluZm8nLCB7XG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMuc2VsZWN0Tm9kZShub2RlKVxuICAgICAgfSwgW1xuICAgICAgICBoKE5vZGVJbmZvLCB7IG5vZGUgfSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzczogJ21lbnUtcGFyZW50JyB9LCBbXG4gICAgICBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWVzKHsgJ21lbnUtdG9nZ2xlJzogdHJ1ZSwgJ21lbnUtb3Blbic6IG9wZW4gfSksXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGNvbnRyb2xsZXIudG9nZ2xlTWVudSgpXG4gICAgICB9KSxcbiAgICAgIGgoJ2RpdicsIHsgY2xhc3M6IGNsYXNzTmFtZXMoeyAnbWVudSc6IHRydWUsICdtZW51LWNsb3NlZCc6IGNsb3NlZCB9KSB9LCBbXG4gICAgICAgIGgoJ2lucHV0Jywge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBjbGFzczogJ21lbnUtc2VhcmNoJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlYXJjaCcsXG4gICAgICAgICAgaWQ6ICdtZW51LXNlYXJjaCcsXG4gICAgICAgICAgb25DbGljazogKCkgPT4gdGhpcy5vcGVuKCksXG4gICAgICAgICAgb25LZXlEb3duOiAoKSA9PiB0aGlzLmRlYm91bmNlZFVwZGF0ZVNlYXJjaCgpXG4gICAgICAgIH0pLFxuICAgICAgICBoKCdkaXYnLCB7IGNsYXNzOiAnbWVudS1zZWFyY2gtcmVzdWx0cycsIGlkOiAnbWVudS1zZWFyY2gtcmVzdWx0cycgfSwgc2VhcmNoUmVzdWx0cylcbiAgICAgIF0pXG4gICAgXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVudTtcbmV4cG9ydCB7IE1lbnUgfTsiLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5jbGFzcyBOb2RlSW5mbyBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICBjb25zdCB7IG5vZGUgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YSgpO1xuICAgIGNvbnN0IHsgZmFtaWx5X25hbWUgfSA9IGRhdGE7XG5cbiAgICBjb25zdCBjb3VudHJ5ID0gZGF0YS5iaXJ0aF9jb3VudHJ5O1xuICAgIGNvbnN0IGhhc0NvdW50cnkgPSBjb3VudHJ5ICE9IG51bGw7XG4gICAgY29uc3QgdXJsID0gZGF0YS5yZWZlcmVuY2U7XG4gICAgY29uc3QgcmFjZSA9IGRhdGEucmFjZTtcbiAgICBjb25zdCBoYXNSYWNlID0gcmFjZSAhPSBudWxsO1xuICAgIGNvbnN0IGdlbmRlciA9IGRhdGEuZ2VuZGVyO1xuICAgIGNvbnN0IG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgY29uc3QgYmlydGh5ciA9IGRhdGEuYmlydGhfeWVhcjtcbiAgICBjb25zdCBkZWF0aHlyID0gZGF0YS5kZWF0aF95ZWFyO1xuXG4gICAgcmV0dXJuIGgoJ2RpdicsIHsgY2xhc3M6ICdub2RlLWluZm8nIH0sIFtcbiAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdub2RlLWluZm8tbmFtZScgfSwgbmFtZSksXG4gICAgICBoYXNDb3VudHJ5ID8gaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mby1jb3VudHJ5JyB9LCBjb3VudHJ5KSA6IG51bGwsXG4gICAgICBoYXNSYWNlID8gaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mby1tb3JlJyB9LCByYWNlKSA6IG51bGwsXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvLW1vcmUnIH0sIGdlbmRlciksXG4gICAgICBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvLW1vcmUnIH0sIFtcbiAgICAgICAgaCgnYScsIHsgdGFyZ2V0OiAnX2JsYW5rJywgaHJlZjogYCR7dXJsfWAgfSwgJ01vcmUgaW5mb3JtYXRpb24nKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlSW5mbztcbmV4cG9ydCB7IE5vZGVJbmZvIH07IiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcblxuY29uc3QgbGF5b3V0UGFkZGluZyA9IDEwO1xuY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSA1MDA7XG5jb25zdCBlYXNpbmcgPSAnZWFzZSc7XG5cbi8vIHNlYXJjaCBwYXJhbWV0ZXJzXG5jb25zdCBtaW5NZXRyaWNWYWx1ZSA9IDAuMjU7IC8vIGZpbHRlciBvdXQgbm9kZXMgZnJvbSBzZWFyY2ggcmVzdWx0cyBpZiB0aGV5IGhhdmUgdG90YWwgc2NvcmVzIGxvd2VyIHRoYW4gdGhpc1xuY29uc3QgbWluU2ltaWxhcml0eVZhbHVlID0gMDsgLy8gb25seSBpbmNsdWRlIGluIHRvdGFsIG1ldHJpYyBpZiB0aGUgaW5kaXZpZHVhbCBzaW0gdmFsIGlzIG9uIFswLjUsIDFdXG5cbmNvbnN0IGRlbGF5UHJvbWlzZSA9IGR1cmF0aW9uID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xuXG5jb25zdCBnZXRPcmdQb3MgPSBuID0+IE9iamVjdC5hc3NpZ24oe30sIG4uZGF0YSgnb3JnUG9zJykpO1xuXG5jbGFzcyBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoeyBjeSB9KXtcbiAgICB0aGlzLmN5ID0gY3k7XG4gICAgdGhpcy5idXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5tZW51ID0gZmFsc2U7XG4gICAgdGhpcy5ub2RlcyA9IGN5Lm5vZGVzKCk7XG4gICAgdGhpcy5zZWFyY2hNYXRjaE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICB9XG5cbiAgaXNNZW51T3Blbigpe1xuICAgIHJldHVybiB0aGlzLm1lbnU7XG4gIH1cblxuICBvcGVuTWVudSgpe1xuICAgIHRoaXMubWVudSA9IHRydWU7XG5cbiAgICB0aGlzLmJ1cy5lbWl0KCdvcGVuTWVudScpO1xuICAgIHRoaXMuYnVzLmVtaXQoJ3RvZ2dsZU1lbnUnLCB0cnVlKTtcbiAgfVxuXG4gIGNsb3NlTWVudSgpe1xuICAgIHRoaXMubWVudSA9IGZhbHNlO1xuXG4gICAgdGhpcy5idXMuZW1pdCgnY2xvc2VNZW51Jyk7XG4gICAgdGhpcy5idXMuZW1pdCgndG9nZ2xlTWVudScsIGZhbHNlKTtcbiAgfVxuXG4gIHRvZ2dsZU1lbnUoKXtcbiAgICBpZiggdGhpcy5pc01lbnVPcGVuKCkgKXtcbiAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Blbk1lbnUoKTtcbiAgICB9XG4gIH1cblxuICBpc0luZm9TaG93bigpe1xuICAgIHJldHVybiB0aGlzLmluZm9Ob2RlICE9IG51bGw7XG4gIH1cblxuICBzaG93SW5mbyhub2RlKXtcbiAgICB0aGlzLmluZm9Ob2RlID0gbm9kZTtcblxuICAgIHRoaXMuYnVzLmVtaXQoJ3Nob3dJbmZvJywgbm9kZSk7XG4gIH1cblxuICBoaWRlSW5mbygpe1xuICAgIHRoaXMuYnVzLmVtaXQoJ2hpZGVJbmZvJywgdGhpcy5pbmZvTm9kZSk7XG5cbiAgICB0aGlzLmluZm9Ob2RlID0gbnVsbDtcbiAgfVxuXG4gIGhhc0hpZ2hsaWdodCgpe1xuICAgIHJldHVybiB0aGlzLmxhc3RIaWdobGlnaHRlZCAhPSBudWxsO1xuICB9XG5cbiAgaGlnaGxpZ2h0KG5vZGUpe1xuICAgIGNvbnN0IHsgY3kgfSA9IHRoaXM7XG5cbiAgICBpZiggdGhpcy5oaWdobGlnaHRJblByb2dyZXNzICl7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfVxuXG4gICAgdGhpcy5oaWdobGlnaHRJblByb2dyZXNzID0gdHJ1ZTtcblxuICAgIGNvbnN0IGFsbEVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgIGNvbnN0IG5ob29kID0gdGhpcy5sYXN0SGlnaGxpZ2h0ZWQgPSBub2RlLmNsb3NlZE5laWdoYm9yaG9vZCgpO1xuICAgIGNvbnN0IG90aGVycyA9IHRoaXMubGFzdFVuaGlnaGxpZ2h0ZWQgPSBhbGxFbGVzLm5vdCggbmhvb2QgKTtcblxuICAgIGNvbnN0IHNob3dPdmVydmlldyA9ICgpID0+IHtcbiAgICAgIGN5LmJhdGNoKCgpID0+IHtcbiAgICAgICAgYWxsRWxlcy5yZW1vdmVDbGFzcygnZmFkZWQgaGlnaGxpZ2h0ZWQgaGlkZGVuJyk7XG5cbiAgICAgICAgbmhvb2QuYWRkQ2xhc3MoJ2hpZ2hsaWdodGVkJyk7XG4gICAgICAgIG90aGVycy5hZGRDbGFzcygnaGlkZGVuJyk7XG5cbiAgICAgICAgb3RoZXJzLnBvc2l0aW9ucyhnZXRPcmdQb3MpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxheW91dCA9IG5ob29kLmxheW91dCh7XG4gICAgICAgIC8vbmFtZTogJ2Zjb3NlJyxcbiAgICAgICAgbmFtZTogJ3ByZXNldCcsXG4gICAgICAgIHBvc2l0aW9uczogZ2V0T3JnUG9zLFxuICAgICAgICBmaXQ6IHRydWUsXG4gICAgICAgIGFuaW1hdGU6IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiBlYXNpbmcsXG4gICAgICAgIHBhZGRpbmc6IGxheW91dFBhZGRpbmdcbiAgICAgIH0pO1xuXG4gICAgICBsYXlvdXQucnVuKCk7XG5cbiAgICAgIHJldHVybiBsYXlvdXQucHJvbWlzZU9uKCdsYXlvdXRzdG9wJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJ1bkxheW91dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHAgPSBnZXRPcmdQb3Mobm9kZSk7XG5cbiAgICAgIGNvbnN0IGxheW91dCA9IG5ob29kLmxheW91dCh7XG4gICAgICAgIG5hbWU6ICdjb25jZW50cmljJyxcbiAgICAgICAgZml0OiB0cnVlLFxuICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogZWFzaW5nLFxuICAgICAgICBib3VuZGluZ0JveDoge1xuICAgICAgICAgIHgxOiBwLnggLSAxLFxuICAgICAgICAgIHgyOiBwLnggKyAxLFxuICAgICAgICAgIHkxOiBwLnkgLSAxLFxuICAgICAgICAgIHkyOiBwLnkgKyAxXG4gICAgICAgIH0sXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgICAgICAgY29uY2VudHJpYzogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIGlmKCBlbGUuc2FtZSggbm9kZSApICl7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZXZlbFdpZHRoOiAoKSA9PiB7IHJldHVybiAxOyB9LFxuICAgICAgICBwYWRkaW5nOiBsYXlvdXRQYWRkaW5nXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcHJvbWlzZSA9IGxheW91dC5wcm9taXNlT24oJ2xheW91dHN0b3AnKTtcblxuICAgICAgbGF5b3V0LnJ1bigpO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvd090aGVyc0ZhZGVkID0gKCkgPT4ge1xuICAgICAgY3kuYmF0Y2goKCkgPT4ge1xuICAgICAgICBvdGhlcnMucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLmFkZENsYXNzKCdmYWRlZCcpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuYnVzLmVtaXQoJ2hpZ2hsaWdodCcsIG5vZGUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbiggc2hvd092ZXJ2aWV3IClcbiAgICAgIC50aGVuKCAoKSA9PiBkZWxheVByb21pc2UoYW5pbWF0aW9uRHVyYXRpb24pIClcbiAgICAgIC50aGVuKCBydW5MYXlvdXQgKVxuICAgICAgLnRoZW4oIHNob3dPdGhlcnNGYWRlZCApXG4gICAgICAudGhlbiggKCkgPT4ge1xuICAgICAgICB0aGlzLmhpZ2hsaWdodEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idXMuZW1pdCgnaGlnaGxpZ2h0ZW5kJywgbm9kZSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICB1bmhpZ2hsaWdodCgpe1xuICAgIGlmKCAhdGhpcy5oYXNIaWdobGlnaHQoKSApeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IH1cblxuICAgIGNvbnN0IHsgY3kgfSA9IHRoaXM7XG4gICAgY29uc3QgYWxsRWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgY29uc3QgYWxsTm9kZXMgPSBjeS5ub2RlcygpO1xuXG4gICAgY3kuc3RvcCgpO1xuICAgIGFsbE5vZGVzLnN0b3AoKTtcblxuICAgIGNvbnN0IG5ob29kID0gdGhpcy5sYXN0SGlnaGxpZ2h0ZWQ7XG4gICAgY29uc3Qgb3RoZXJzID0gdGhpcy5sYXN0VW5oaWdobGlnaHRlZDtcblxuICAgIHRoaXMubGFzdEhpZ2hsaWdodGVkID0gdGhpcy5sYXN0VW5oaWdobGlnaHRlZCA9IG51bGw7XG5cbiAgICBjb25zdCBoaWRlT3RoZXJzID0gZnVuY3Rpb24oKXtcbiAgICAgIG90aGVycy5hZGRDbGFzcygnaGlkZGVuJyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVzZXRDbGFzc2VzID0gZnVuY3Rpb24oKXtcbiAgICAgIGN5LmJhdGNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGFsbEVsZXMucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpLnJlbW92ZUNsYXNzKCdmYWRlZCcpLnJlbW92ZUNsYXNzKCdoaWdobGlnaHRlZCcpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5pbWF0ZVRvT3JnUG9zID0gZnVuY3Rpb24oIG5ob29kICl7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoIG5ob29kLm5vZGVzKCkubWFwKG4gPT4ge1xuICAgICAgICByZXR1cm4gbi5hbmltYXRpb24oe1xuICAgICAgICAgIHBvc2l0aW9uOiBnZXRPcmdQb3MobiksXG4gICAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWFzaW5nXG4gICAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgICB9KSApO1xuICAgIH07XG5cbiAgICBjb25zdCByZXN0b3JlUG9zaXRpb25zID0gKCkgPT4ge1xuICAgICAgY3kuYmF0Y2goKCkgPT4ge1xuICAgICAgICBvdGhlcnMubm9kZXMoKS5wb3NpdGlvbnMoZ2V0T3JnUG9zKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYW5pbWF0ZVRvT3JnUG9zKCBuaG9vZC5ub2RlcygpICk7XG4gICAgfTtcblxuICAgIHRoaXMuYnVzLmVtaXQoJ3VuaGlnaGxpZ2h0Jyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCBoaWRlT3RoZXJzIClcbiAgICAgIC50aGVuKCByZXN0b3JlUG9zaXRpb25zIClcbiAgICAgIC50aGVuKCByZXNldENsYXNzZXMgKVxuICAgICk7XG4gIH1cblxuICB1cGRhdGVTZWFyY2gocXVlcnlTdHJpbmcpe1xuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBnZXRXb3JkcyA9IHN0ciA9PiBzdHIuc3BsaXQoL1xccysvKTtcbiAgICBjb25zdCBxdWVyeVdvcmRzID0gZ2V0V29yZHMobm9ybWFsaXplKHF1ZXJ5U3RyaW5nKSk7XG5cbiAgICBjb25zdCBhZGRXb3JkcyA9ICh3b3JkTGlzdCwgd29yZHNTdHIpID0+IHtcbiAgICAgIGlmKCB3b3Jkc1N0ciApe1xuICAgICAgICB3b3JkTGlzdC5wdXNoKC4uLmdldFdvcmRzKG5vcm1hbGl6ZSh3b3Jkc1N0cikpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY2FjaGVOb2RlV29yZHMgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGEoKTtcbiAgICAgIGNvbnN0IHdvcmRMaXN0ID0gW107XG4gICAgICBcbiAgICAgIGFkZFdvcmRzKHdvcmRMaXN0LCBkYXRhLm5hbWUpO1xuICAgICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEuU3lub255bSk7XG4gICAgICBhZGRXb3Jkcyh3b3JkTGlzdCwgZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCk7XG4gICAgICBhZGRXb3Jkcyh3b3JkTGlzdCwgZGF0YS5NaWxrKTtcbiAgICAgIGFkZFdvcmRzKHdvcmRMaXN0LCBkYXRhLlR5cGUpO1xuICAgICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEuQ291bnRyeSk7XG4gICAgICAgIFxuICAgICAgbm9kZS5kYXRhKCd3b3JkcycsIHdvcmRMaXN0KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0U3RyaW5nU2ltaWxhcml0eSA9IChxdWVyeVdvcmQsIG5vZGVXb3JkKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IG5vZGVXb3JkLmluZGV4T2YocXVlcnlXb3JkKTtcblxuICAgICAgaWYoIGluZGV4ID09PSAwICl7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhub2RlV29yZC5sZW5ndGggLSBxdWVyeVdvcmQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5tYXgobm9kZVdvcmQubGVuZ3RoLCBxdWVyeVdvcmQubGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAxIC0gKGRpZmYgLyBtYXhMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGdldE1ldHJpYyA9IChub2RlLCBxdWVyeVdvcmRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlV29yZHMgPSBub2RlLmRhdGEoJ3dvcmRzJyk7XG4gICAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgICBmb3IoIGxldCBpID0gMDsgaSA8IG5vZGVXb3Jkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBsZXQgbm9kZVdvcmQgPSBub2RlV29yZHNbaV07XG5cbiAgICAgICAgZm9yKCBsZXQgaiA9IDA7IGogPCBxdWVyeVdvcmRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgbGV0IHF1ZXJ5V29yZCA9IHF1ZXJ5V29yZHNbal07XG4gICAgICAgICAgbGV0IHNpbWlsYXJpdHkgPSBnZXRTdHJpbmdTaW1pbGFyaXR5KHF1ZXJ5V29yZCwgbm9kZVdvcmQpO1xuXG4gICAgICAgICAgaWYoIHNpbWlsYXJpdHkgPiBtaW5TaW1pbGFyaXR5VmFsdWUgKXtcbiAgICAgICAgICAgIHNjb3JlICs9IHNpbWlsYXJpdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcmU7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldE5vZGVNZXRyaWMgPSBtZW1vaXplKG5vZGUgPT4gZ2V0TWV0cmljKG5vZGUsIHF1ZXJ5V29yZHMpLCBub2RlID0+IG5vZGUuaWQoKSk7XG5cbiAgICBpZiggIXRoaXMuY2FjaGVkTm9kZVdvcmRzICl7XG4gICAgICB0aGlzLmN5LmJhdGNoKCgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNhY2hlTm9kZVdvcmRzKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNhY2hlZE5vZGVXb3JkcyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hNYXRjaE5vZGVzID0gdGhpcy5ub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICByZXR1cm4gZ2V0Tm9kZU1ldHJpYyhub2RlKSA+IG1pbk1ldHJpY1ZhbHVlO1xuICAgIH0pLnNvcnQoKG5vZGVBLCBub2RlQikgPT4ge1xuICAgICAgcmV0dXJuIGdldE5vZGVNZXRyaWMobm9kZUIpIC0gZ2V0Tm9kZU1ldHJpYyhub2RlQSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJ1cy5lbWl0KCd1cGRhdGVTZWFyY2gnLCB0aGlzLnNlYXJjaE1hdGNoTm9kZXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoTWF0Y2hOb2RlcztcbiAgfVxuXG4gIGdldFNlYXJjaE1hdGNoTm9kZXMoKXtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hNYXRjaE5vZGVzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyb2xsZXI7XG5leHBvcnQgeyBDb250cm9sbGVyIH07IiwiY29uc3QgZWxlbWVudHMgPSB7XG4gIFwibm9kZXNcIjogW1xuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJvZ2VyIENvdGVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNjgyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSb2dlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTcxNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvZ2VyX0NvdGVzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDb3Rlc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM2NS4yNzg3NDE2MzY5OTYsXG4gICAgICAgIFwieVwiOiAzNzUxLjMzMTE0MDY4NzkyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRXVnw6huZSBDYWhlblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRXVnw6huZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9nLmNvL2tncy84NTdRWm9cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNhaGVuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2MDI0LjQwNDk5MDQ1OTE1OSxcbiAgICAgICAgXCJ5XCI6IDM0NTUuODg2MjUyOTEzMTAzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldhcnJlbiBXZWF2ZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhcnJlblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhcnJlbl9XZWF2ZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldlYXZlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjcyMS4yNTU2OTUzOTQsXG4gICAgICAgIFwieVwiOiA0MTkxLjI5ODgyNTI5NjcxMVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKZWZmcmV5IFdlaXNzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmVmZnJleVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXZWlzc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzY3MS44MjU3NzA4NDcxNDksXG4gICAgICAgIFwieVwiOiA0OTc5Ljg5NDQ5OTQwNjg0OVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI2MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvaG4gQ3JhbmtcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaG5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX0NyYW5rXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDcmFua1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjk0My44Njc0MzExODI4OTcyLFxuICAgICAgICBcInlcIjogNDczNi43NTAxNzkzMzk0NjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjIwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSGVucmkgTGViZXNndWVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhlbnJpXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZW5yaV9MZWJlc2d1ZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGViZXNndWVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3OTIuODY2ODkwMzY4NjEzNCxcbiAgICAgICAgXCJ5XCI6IDM3MTMuNzgyMzg1MjU3MTUxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVhcmxlIFBoZWxwc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk3NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWFybGVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJsZV9CLl9QaGVscHNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBoZWxwc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTYxNi40NzE4MTU4OTAyMDI4LFxuICAgICAgICBcInlcIjogMzIzNi41MDA5MjE5MTY3NTk2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FuZGVyIGRlIEhhYXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhbmRlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiTmV0aGVybGFuZHNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XYW5kZXJfSm9oYW5uZXNfZGVfSGFhc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiZGUgSGFhc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM2MC4xMDY1NDUzNjMzMDksXG4gICAgICAgIFwieVwiOiAzNjQ3LjEwOTY0MzUzNjYyMTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRWRtdW5kIExhbmRhdVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg3NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWRtdW5kXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWRtdW5kX0xhbmRhdVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFuZGF1XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTAwLjYzNDQ5NTU1MjI1ODYsXG4gICAgICAgIFwieVwiOiA0Mjg3LjM4NjE1MTUzMDcwMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI3M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJlbsOpIERlc2NhcnRlc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTU5NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUmVuw6lcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE2NTAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JlbsOpX0Rlc2NhcnRlc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGVzY2FydGVzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxMzQwLjc2NTEwNDY3NDQ1NCxcbiAgICAgICAgXCJ5XCI6IDMzNjUuNjM2NzcxODQ2NTk4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdlb3JnZSBQw7NseWFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdlb3JnZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSHVuZ2FyeVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZV9Qw7NseWFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlDDs2x5YVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzg1OS43MjQ5Nzk5MDczNTY2LFxuICAgICAgICBcInlcIjogMzkyMS42NTM4NjU5MzQzMTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjUxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR3JpZ29yeSBNYXJndWxpc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR3JpZ29yeVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlJ1c3NpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyaWdvcnlfTWFyZ3VsaXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1hcmd1bGlzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyOTcxLjA0MDkyNzMzMTg5MzcsXG4gICAgICAgIFwieVwiOiAzODk3LjgzMTQ0MDIzMTY4NzNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUGF1bCBHb3JkYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBhdWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXVsX0dvcmRhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR29yZGFuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1ODM0LjY4NjAxNzg1MDkzNyxcbiAgICAgICAgXCJ5XCI6IDM4NzkuMjM4Njk2ODYyNjgzNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJWaXRhbHkgR2luemJ1cmdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlZpdGFseVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVml0YWx5X0dpbnpidXJnXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHaW56YnVyZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTMwMy41NTAzODU1MjYwMDUsXG4gICAgICAgIFwieVwiOiAzNjc5LjkzODM5MDE2MDMzNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxODVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBcnRodXIgS2VubmVsbHlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFydGh1clwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXJlbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FydGh1cl9FLl9LZW5uZWxseVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS2VubmVsbHlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0NzYuMjUxMDkwNTEzNzA5LFxuICAgICAgICBcInlcIjogMzE5MC40ODU0NDU0MTIwMjM2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNhcmwgUnVuZ2VcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhcmxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MjcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXJsX1J1bmdlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSdW5nZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzIwNS4xNDYxMjAwODMzNTMzLFxuICAgICAgICBcInlcIjogNDg3My45NTE1MTU5MzAwMjQ1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQyMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlcmJlcnQgV2FnbmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTM1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJiZXJ0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcmJlcnRfV2FnbmVyXyhwaHlzaWNpc3QpXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXYWduZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQyMzYuOTk3NzEwNDQ1OTgzLFxuICAgICAgICBcInlcIjogNDkyNC40NTQ3MDU5Nzg1MjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDA0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRWR3YXJkIFRlbGxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwOCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWR3YXJkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDAzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJIdW5nYXJ5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWR3YXJkX1RlbGxlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiVGVsbGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NjE5LjY3MjcyNjIwNzA5NSxcbiAgICAgICAgXCJ5XCI6IDQzMTIuNTU3ODEwNDIxNDkxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkZyZWRlcmljayBTZWl0elwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRnJlZGVyaWNrXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJlZGVyaWNrX1NlaXR6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTZWl0elwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjE2NC43NDU1NTk4MjYzNTMsXG4gICAgICAgIFwieVwiOiAzNDA0LjcxMjk0ODU5ODk2OTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDE3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVGhlb2RvcmUgdm9uIEvDoXJtw6FuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJUaGVvZG9yZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSHVuZ2FyeVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RoZW9kb3JlX3Zvbl9Lw6FybcOhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwidm9uIEvDoXJtw6FuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMzY4Ljc4MzQ4NDgzMzk4MyxcbiAgICAgICAgXCJ5XCI6IDMzODkuOTQ0ODg3ODUzNTUzNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMb3JkKiBSYXlsZWlnaFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg0MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTG9yZCpcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX1dpbGxpYW1fU3RydXR0LF8zcmRfQmFyb25fUmF5bGVpZ2hcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlJheWxlaWdoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0ODA2LjU4OTg2NjM0NzA1MSxcbiAgICAgICAgXCJ5XCI6IDMxOTMuMzI5MjMxNjAwNDc2OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI4NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIm1pc3NpbmcgRXVjbGlkXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAtMzUwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAtMjUwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHcmVlY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkV1Y2xpZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTc2My4xODA1NTcwNjEzNDUsXG4gICAgICAgIFwieVwiOiAzNTM3LjkxODY1NzUxMDY1NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJCw7hyZ2UgSmVzc2VuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJCw7hyZ2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkRlbm1hcmtcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw7hyZ2VfSmVzc2VuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJKZXNzZW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1MzEuNTU0Mzc4MjE4MzcyNyxcbiAgICAgICAgXCJ5XCI6IDQzNzUuMjA4NTgxNTIwMzk1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBoaWxpcHAgU2VpZGVsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODIxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQaGlsaXBwXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODk2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGhpbGlwcF9MdWR3aWdfdm9uX1NlaWRlbFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2VpZGVsXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTM4LjEyMDYyOTg1MTMwOSxcbiAgICAgICAgXCJ5XCI6IDM0NzAuNTc1Mzg5NzU3ODg4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIwN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJ5b2dvIEt1Ym9cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJ5b2dvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTk1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJKYXBhblwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUnlvZ29fS3Vib1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS3Vib1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTk3NS4xMDE4MjQyNTEyODA1LFxuICAgICAgICBcInlcIjogMjk2NS4yMzQ4ODE5NzAxMTM3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlRoZW9kb3IgTWV5ZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRoZW9kb3JcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaGVvZG9yX01leWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNZXllclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDA4OC4xMTM4OTc1OTg4MDIsXG4gICAgICAgIFwieVwiOiA0NDM3LjczMjU2OTI4ODg3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQyMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkZ1Z2FvIFdhbmdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGdWdhb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkNoaW5hXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXYW5nXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MjY1LjM5NDg1MzgxMzA0NCxcbiAgICAgICAgXCJ5XCI6IDI5MjYuOTEwNjc1MDUzNDc5M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MzFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQaWVycmUgV2Vpc3NcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBpZXJyZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGllcnJlX1dlaXNzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXZWlzc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjMzNC4wNzE5MDgwMDA2ODYsXG4gICAgICAgIFwieVwiOiAzMTg1LjIxNTEyNTQyODQ0NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9yZ2UgTHVzenRpZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR2VvcmdlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUm9tYW5pYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZV9MdXN6dGlnXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMdXN6dGlnXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMjE4Ljk2OTExNzE5NTg2NDMsXG4gICAgICAgIFwieVwiOiAzODUxLjg2OTQ0MTg3MjMzN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxODNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMb3JkKiBLZWx2aW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MjQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxvcmQqXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTA3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJcmVsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2lsbGlhbV9UaG9tc29uLF8xc3RfQmFyb25fS2VsdmluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLZWx2aW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2MjMuMzczMDQzNTkwODMyNCxcbiAgICAgICAgXCJ5XCI6IDMzMzguMjU4MjQ4NDQ4MDk1NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTdGVwaGVuIFNtYWxlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTdGVwaGVuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZXBoZW5fU21hbGVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNtYWxlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMjQ5LjcyODU0MzE1MjQzNyxcbiAgICAgICAgXCJ5XCI6IDQxMTkuNjQ4OTk4NTc3NDc1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIyNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJpY2hhcmQgTGVpYmxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUmljaGFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwMyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpY2hhcmRfTGVpYmxlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGVpYmxlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjI1Ni45MTQyMDA4Mjk2MzIsXG4gICAgICAgIFwieVwiOiAzOTUwLjk1MDgzMTM5MTM0NjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTc3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVGhlb2RvciBLYWx1emFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRoZW9kb3JcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaGVvZG9yX0thbHV6YVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS2FsdXphXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTUzLjc5NzIwMDkzNjkxNSxcbiAgICAgICAgXCJ5XCI6IDQxMzAuNzc1NzE0NDYwODI0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQzMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBXZWlzc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9zZXBoXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJBdXN0cmlhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9zZXBoX0pvc2h1YV9XZWlzc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiV2Vpc3NcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyNTguNDMyOTUzNjYwODc2NixcbiAgICAgICAgXCJ5XCI6IDMzMTYuMDMwMDQ3MjA5ODczNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkV1Z2VuaW8gQmVsdHJhbWlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkV1Z2VuaW9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkl0YWx5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVnZW5pb19CZWx0cmFtaVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmVsdHJhbWlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQwNTguNjUzMjkxMjg0OTI4LFxuICAgICAgICBcInlcIjogMzAzNy41Mjg0NTA2NDI0NjFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKZWFuIERpZXVkb25uw6lcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkplYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0plYW5fRGlldWRvbm7DqVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGlldWRvbm7DqVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzc2MC41MjY3MDE4MjMzMTUzLFxuICAgICAgICBcInlcIjogMzY0MC41MTkyNDQwMjcxMjg1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGF2aWQgQm9obVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRGF2aWRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYXZpZF9Cb2htXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCb2htXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMTkwLjU5NzEyNzQwNzY1MTQsXG4gICAgICAgIFwieVwiOiA0MjY3LjAyNzIzOTc4Njk1NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb3NpYWggR2liYnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvc2lhaFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkwMyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvc2lhaF9XaWxsYXJkX0dpYmJzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHaWJic1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzYyOS40NDI3OTg4Njg0MTY1LFxuICAgICAgICBcInlcIjogMzEyMy4zMzgyMTI0NTM0N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNjRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMZW9ub3IgTWljaGFlbGlzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMZW9ub3JcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NDksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZW9ub3JfTWljaGFlbGlzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNaWNoYWVsaXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE2NjMuMjU5Mzc1MDcwMTIwMyxcbiAgICAgICAgXCJ5XCI6IDM3MzYuMjE2MDE5OTY1NDQ1NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBpZXJyZSBDYXJ0aWVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQaWVycmVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaWVycmVfQ2FydGllcl8obWF0aGVtYXRpY2lhbilcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNhcnRpZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5ODMuMzE5MDg3NzEwMjY2NixcbiAgICAgICAgXCJ5XCI6IDM2MTcuODcyMjM4OTAzOTUyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjY4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWJyYWhhbSBkZSBNb2l2cmVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE2NjcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFicmFoYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE3NTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FicmFoYW1fZGVfTW9pdnJlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJkZSBNb2l2cmVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM4ODcuNzUxNjM1NjA3Mzk0LFxuICAgICAgICBcInlcIjogMjk2OS43MTk1Mzg2MTk3MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFsYmVydCBFaW5zdGVpblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg3OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWxiZXJ0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWxiZXJ0X0VpbnN0ZWluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJFaW5zdGVpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzUzNy4wOTY4NTc0NTAyNTIsXG4gICAgICAgIFwieVwiOiAzNjQyLjQ5NjcwNTE1MzE3OTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTMwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR290dGhpbGYgSGFnZW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE3OTcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdvdHRoaWxmXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODg0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR290dGhpbGZfSGFnZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhhZ2VuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTkyLjQ5ODY2ODIwNzk2MyxcbiAgICAgICAgXCJ5XCI6IDQ0MzIuODU0NDg4NzMzNjcyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJvbmFsZCBHdXJuZXlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJvbmFsZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbmFsZF9XaWxmcmVkX0d1cm5leVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR3VybmV5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTMzLjQwNjA2MDI1NzM3MTMsXG4gICAgICAgIFwieVwiOiAzMTAwLjEzMDQ5NTcyMDM4OTNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQYXVsIERpcmFjXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQYXVsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGF1bF9EaXJhY1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGlyYWNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIzOTYuNTE0OTc3Nzg0NjgxNCxcbiAgICAgICAgXCJ5XCI6IDM0MDcuMzM0NzA5MzU5ODg3M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNzJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQYXNjdWFsIEpvcmRhblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGFzY3VhbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Bhc2N1YWxfSm9yZGFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJKb3JkYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDYxNjcuODQyMzM4MzAxNjc4LFxuICAgICAgICBcInlcIjogMzM1Ni44Mjg2NzkzNzY2NjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNzFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQaWVycmUgRGVsaWduZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGllcnJlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQmVsZ2l1bVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BpZXJyZV9EZWxpZ25lXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJEZWxpZ25lXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMzk5LjQ1MjU4NzY2NDY5NyxcbiAgICAgICAgXCJ5XCI6IDM4MjQuNzc5MjUyNTUzMjA5NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJGcmlneWVzIFJpZXN6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcmlneWVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJBdXN0cmlhLUh1bmdhcnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmlneWVzX1JpZXN6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSaWVzelwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTAzMS4zNjUzNDE1MjQzNjgsXG4gICAgICAgIFwieVwiOiAzNjA4Ljk2NzU5NTk5OTk1NjhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNaWNoZWxlIGRlIEZyYW5jaGlzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNaWNoZWxlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01pY2hlbGVfZGVfRnJhbmNoaXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcImRlIEZyYW5jaGlzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzE3LjEzNTY1Mjc2MjUxOCxcbiAgICAgICAgXCJ5XCI6IDM2NjEuMTQ3MDQxMDg0Mjc4NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJZYWtvdiBGcmVua2VsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODk0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJZYWtvdlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWFrb3ZfRnJlbmtlbFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRnJlbmtlbFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTk1Mi4yMTU1NTM5NTM1NTgsXG4gICAgICAgIFwieVwiOiAzNzIwLjAwMTgzMjk4ODA4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI4MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFsYmVydCBNdWxsaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFsYmVydFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsYmVydF9BLl9NdWxsaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk11bGxpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTc2My45MjAzNDM5NjQyMzksXG4gICAgICAgIFwieVwiOiAzNTE1LjMxNjM5NTMyMzE4MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhhcmFsZCBDcmFtw6lyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODkzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIYXJhbGRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3ZWRlblwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhcmFsZF9DcmFtw6lyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDcmFtw6lyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NTExLjAyMzM4OTk1ODczMyxcbiAgICAgICAgXCJ5XCI6IDQzNDkuNjIyMTc2NDc3NDY5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIwOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNvbG9tb24gS3VsbGJhY2tcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlNvbG9tb25cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb2xvbW9uX0t1bGxiYWNrXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLdWxsYmFja1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjI0NC42MzgzMjMyOTk3NzgsXG4gICAgICAgIFwieVwiOiAzOTcyLjMwNDA0OTc5MTc2MjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzM2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQSBSaHlzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlJoeXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyMzUuNzYzNTM3MTIyODE1LFxuICAgICAgICBcInlcIjogMzM1NC42OTg1MzQ4OTg5OTQ3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQmVybmFyZCBCb2x6YW5vXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzgxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJCZXJuYXJkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODQ4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJCb2hlbWlhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybmFyZF9Cb2x6YW5vXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCb2x6YW5vXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTAzLjgyNDYyNTMzNzkyOTMsXG4gICAgICAgIFwieVwiOiAzNDUwLjYzODY1MTk2MjU2OTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjExXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9zZXBoLUxvdWlzIExhZ3JhbmdlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzM2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb3NlcGgtTG91aXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4MTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkl0YWx5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9zZXBoLUxvdWlzX0xhZ3JhbmdlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMYWdyYW5nZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzUxOS4zMTE0NDU4MzM1MDYsXG4gICAgICAgIFwieVwiOiAzODA5LjIxMjMyODA5MjY2NDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzQzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obiBSb3NzZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaG5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KLl9CYXJrbGV5X1Jvc3NlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUm9zc2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNTk5LjkwNjg5OTI2NzE3MzcsXG4gICAgICAgIFwieVwiOiAzOTA0Ljk5ODQ3MDgxNTA5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM1OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldhbHRlciBTY2hvdHRreVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2FsdGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2FsdGVyX0guX1NjaG90dGt5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTY2hvdHRreVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzAzNS42MDYwMDk1OTgwODIsXG4gICAgICAgIFwieVwiOiAzMDQ3LjI2NTUxODk0NTAyMjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzY2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUm9iZXJ0IFNla2Vya2FcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJvYmVydFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JlcnRfU2VrZXJrYVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2VrZXJrYVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjQ2Ni4zNjI4NzY4MDM4NDA3LFxuICAgICAgICBcInlcIjogMzUzNi4xOTg4MzY4NzEwNjlcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTI3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUnVkb2xmIEhhYWdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJ1ZG9sZlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRmVybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1ZG9sZl9IYWFnXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIYWFnXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNTc0LjY4MTk4NjIyMTcxLFxuICAgICAgICBcInlcIjogMzQ3My4yMzc5NTE4MjI3OTJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTE2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FsdGVyIEdvcmRvblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5MyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2FsdGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2FsdGVyX0dvcmRvbl8ocGh5c2ljaXN0KVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR29yZG9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMDE5LjE5ODM3OTQ1NDcxNDUsXG4gICAgICAgIFwieVwiOiA0MTcwLjc5MTI3NTkwNjQ1M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJUaG9tYXMgRm94XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiVGhvbWFzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9waHlzaWNzdG9kYXkuc2NpdGF0aW9uLm9yZy9kb2kvcGRmLzEwLjEwNjMvMS4yOTk1MDA2XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGb3hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ5MTUuNTQ1MjkyNzY2ODUzLFxuICAgICAgICBcInlcIjogMjkwNy42MjQ3NjM1MzM2OTI3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQxNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkl2YW4gVmlub2dyYWRvdlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSXZhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU292aWV0IFVuaW9uXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXZhbl9WaW5vZ3JhZG92XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJWaW5vZ3JhZG92XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTQ5LjM5MzAzNzM0NjkxNDgsXG4gICAgICAgIFwieVwiOiAzOTQxLjQ0Nzk0NjQ4MjY4OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI3OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlZsYWRpbWlyIERyaW5lZmVsZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk1NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiVmxhZGltaXJcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WbGFkaW1pcl9EcmluZmVsZFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRHJpbmVmZWxkXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTc3LjE3MzUzNjkwMTY1ODMsXG4gICAgICAgIFwieVwiOiAzNTkxLjA1NDg3MDc2OTE1NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMzBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFcm5zdCBMaW5kZWzDtmZcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVybnN0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGaW5sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJuc3RfTGVvbmFyZF9MaW5kZWzDtmZcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxpbmRlbMO2ZlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU4Ni44ODI2NDg1MjI0MixcbiAgICAgICAgXCJ5XCI6IDM1NjcuMjI5Mjk2OTMyMTAxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI3OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1lcnZpbiBNdWxsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1lcnZpblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxOCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnZpbl9FLl9NdWxsZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk11bGxlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDE2NS4yNjMxMTQ3MTE2MTUsXG4gICAgICAgIFwieVwiOiA0NjUyLjI1MjkwNTIxOTQ1M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxOTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFbGxpcyBLb2xjaGluXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFbGxpc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk5MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VsbGlzX0tvbGNoaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktvbGNoaW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyNTYuMTM1MjU0NTcyMTE0LFxuICAgICAgICBcInlcIjogNDI0MS4yNzk4OTAzMzYzNjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzc0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obiBTbGF0ZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaG5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX0MuX1NsYXRlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2xhdGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMzkwLjY3ODE5OTEzNDA0LFxuICAgICAgICBcInlcIjogMzAwMi43MjY1ODAzNDIxMzFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTQxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FsdGVyIEhlaXRsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhbHRlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhbHRlcl9IZWl0bGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIZWl0bGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2NDAzLjg5Nzc4OTMwODU4OSxcbiAgICAgICAgXCJ5XCI6IDM3MTIuOTMzNjQyOTM3MDkzM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTaGlnZXJ1IE11a2FpXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTUzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTaGlnZXJ1XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSmFwYW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwiRWFzdCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NoaWdlcnVfTXVrYWlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk11a2FpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTkzLjc4NTUzNDA1MjQ4NzUsXG4gICAgICAgIFwieVwiOiAzOTU0Ljg2MzIzMDU4ODI4MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJPdHRvIFN0ZXJuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJPdHRvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3R0b19TdGVyblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU3Rlcm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU0NjUuNjY2OTE4NTYyODA2LFxuICAgICAgICBcInlcIjogNDIwMC43OTk1NjkyODg2ODJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTM1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRG91Z2xhcyBIYXJ0cmVlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODk3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEb3VnbGFzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhc19IYXJ0cmVlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIYXJ0cmVlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTk2LjU1MjU2NjM4OTI2NDcsXG4gICAgICAgIFwieVwiOiAzOTkwLjMyNTA2OTUyNzA2N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJUaG9tYXMgU3RpZWx0amVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJUaG9tYXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGhvbWFzX0pvYW5uZXNfU3RpZWx0amVzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdGllbHRqZXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM4MDIuNTYyOTgwNzQ2NTAxLFxuICAgICAgICBcInlcIjogMzY3NC44NjUxMTA4ODc5NjAzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEzOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN0ZXBoZW4gSGF3a2luZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU3RlcGhlblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxOCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZXBoZW5fSGF3a2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGF3a2luZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzQ1MS44NzgwMjY3MzA5MjE2LFxuICAgICAgICBcInlcIjogNDU2Ny42ODUxMDQ4OTA5NjNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjIyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWRyaWVuLU1hcmllIExlZ2VuZHJlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzUyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBZHJpZW4tTWFyaWVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4MzMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Fkcmllbi1NYXJpZV9MZWdlbmRyZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGVnZW5kcmVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQxNDIuMDgxNTE5MTkzMDk5LFxuICAgICAgICBcInlcIjogMzQ1MS45NDg0MDM5MDE0MzRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTA3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2FybCBHYXVzc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc3NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ2FybFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg1NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhcmxfRnJpZWRyaWNoX0dhdXNzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHYXVzc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDA3OC4xNzgxMjQ1Mzk5OTA3LFxuICAgICAgICBcInlcIjogMzQ5OS45NTEzOTExMTk2OTNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFZHVhcmQgxIxlY2hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVkdWFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYS1IdW5nYXJ5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWR1YXJkX8SMZWNoXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCLEjGVjaFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjgwNy42NTIyNzI5ODIzMzksXG4gICAgICAgIFwieVwiOiAzNDE2LjYxMjgwNTUyMjg2NDZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjc2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTmV2aWxsIE1vdHRcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk5ldmlsbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk5NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ldmlsbF9GcmFuY2lzX01vdHRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1vdHRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMwODAuOTE4ODcyNTk0OTE0LFxuICAgICAgICBcInlcIjogMzAzMi4xNzg1OTg4MDc3NjM2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI5NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN1c3VtdSBPa3Vib1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkzMCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU3VzdW11XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJKYXBhblwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3VzdW11X09rdWJvXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJPa3Vib1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTIyNC41Mzg0MzAwOTI1OTMsXG4gICAgICAgIFwieVwiOiAyNjkxLjg2NzkzMzU4OTAwM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1hdXJpY2UgQ291ZXR0ZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWF1cmljZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF1cmljZV9Db3VldHRlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDb3VldHRlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NTkzLjEyNzEwNjUwNzEyOSxcbiAgICAgICAgXCJ5XCI6IDMwNTkuNjc2NzQwNTA2MDEyM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBcm5vbGQgU29tbWVyZmVsZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQXJub2xkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTUxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXJub2xkX1NvbW1lcmZlbGRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNvbW1lcmZlbGRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0NzEuNjM3ODA2Njg4ODk0LFxuICAgICAgICBcInlcIjogMzY1Mi44ODM5NTExMDExNzFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTUyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obiBIb2xsb21vblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvaG5fSGVyYmVydF9Ib2xsb21vbl9Kci5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhvbGxvbW9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0Nzc3LjAwMDYzODUwNzUwNixcbiAgICAgICAgXCJ5XCI6IDM2ODQuMTc4NTE2MTU0NjA2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIklvZWwgTWFsa2luXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJJb2VsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJSdXNzaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2cuY28va2dzL0xRTkZLOVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWFsa2luXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTA4LjU2MjUzNDYzMTk3OSxcbiAgICAgICAgXCJ5XCI6IDM4ODguNjA4NDg1MDU1ODQ3M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNzBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMb3dlbGwgSm9uZXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxvd2VsbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb3dlbGxfRS5fSm9uZXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkpvbmVzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NTQzLjAxNjExMjIwNDg1LFxuICAgICAgICBcInlcIjogNDAyOS42NzAzMzA1MTE2MTAyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM5N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkphY3F1ZXMgU3R1cm1cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MDMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkphY3F1ZXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4NTUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phY3F1ZXNfQ2hhcmxlc19GcmFuw6dvaXNfU3R1cm1cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN0dXJtXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzU0Ljk5MzUyNzk1MTkxMjcsXG4gICAgICAgIFwieVwiOiAzNTYyLjAzMjcxNjIzNTAyODZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTI5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSmFjcXVlcyBIYWRhbWFyZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmFjcXVlc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmFjcXVlc19IYWRhbWFyZFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGFkYW1hcmRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3MjQuMTcxODA3OTkwOTk3LFxuICAgICAgICBcInlcIjogMzYxMi43NjcxOTA2NzY2NjhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjM4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRnJpdHogTG9uZG9uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcml0elwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZyaXR6X0xvbmRvblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTG9uZG9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2NDY3LjQwMjAxMzg5MjY5NSxcbiAgICAgICAgXCJ5XCI6IDM3MTYuMjM2OTc2NDI5MjNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjUwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWF4IE1hcmd1bGVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MjAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyaWFuIEVtcGlyZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01heF9NYXJndWxlc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWFyZ3VsZXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2NDAuOTI5NzE3OTM0NTc4LFxuICAgICAgICBcInlcIjogMzE5My43MTk2NTc0ODE4NjE4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjc4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTW9ucm9lIERvbnNrZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1vbnJvZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk5MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbnJvZV9ELl9Eb25za2VyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJEb25za2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NDgyLjY2NTgwMzE1OTE4NCxcbiAgICAgICAgXCJ5XCI6IDQ0MjcuOTU3MDg2NzE5NDg4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQzOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVyaWNoIFdvaGxmYXJ0aFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRXJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlBvbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VyaWNoX1BldGVyX1dvaGxmYXJ0aFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiV29obGZhcnRoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNzE1LjkxOTk4OTU0MTU2OTcsXG4gICAgICAgIFwieVwiOiAzNTcwLjE3OTg0MDIwMzU2MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKYW1lcyBIYXJ0bGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkphbWVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phbWVzX0hhcnRsZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGFydGxlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDI0LjI1MTExMzAzOTM4NzMsXG4gICAgICAgIFwieVwiOiA0NjAzLjEwMzQ5NTk1ODY5NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI3MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFybmF1ZCBEZW5qb3lcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFybmF1ZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXJuYXVkX0RlbmpveVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGVuam95XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0OTYxLjM0NDAxODk5NDgxNyxcbiAgICAgICAgXCJ5XCI6IDM2MTQuOTMzOTg0Njk4NDA3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI1OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkthcmwgTWVuZ2VyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJLYXJsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJBdXN0cmlhLUh1bmdhcnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYXJsX01lbmdlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWVuZ2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MzI4LjAxMTk3MjgyNzY3NSxcbiAgICAgICAgXCJ5XCI6IDMwODYuNTMwNDkyNTUyNzQzNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFdWdlbmUgV2lnbmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFdWdlbmVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkh1bmdhcnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWdlbmVfV2lnbmVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXaWduZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDYxNDMuNjczOTQwNjMxNDg3LFxuICAgICAgICBcInlcIjogMzM4MC45NTY3MTE4ODU5MjIyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE4NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBDIEtlbmRhbGxcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQQ1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktlbmRhbGxcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0MTcuNDQxNjExOTMxNzE0LFxuICAgICAgICBcInlcIjogNDQ0NC4yMzc0MjEwODkwMTlcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjUyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR2lzaXJvIE1hcnV5YW1hXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHaXNpcm9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkphcGFuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HaXNpcm9fTWFydXlhbWFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1hcnV5YW1hXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDA0LjU1Njc1MzQ5NjYwNixcbiAgICAgICAgXCJ5XCI6IDM3OTAuMzQ0MjA2MjMxOTg0NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTmllbHMgQWJlbFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgwMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTmllbHNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4MjksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5vcndheVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05pZWxzX0hlbnJpa19BYmVsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJBYmVsXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0Mzg5Ljg5OTM0NDc2MjI2NSxcbiAgICAgICAgXCJ5XCI6IDMzMzIuOTkwMjE3Nzc0MjExNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxmcmVkIEhhc3RpbmdzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXaWxmcmVkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJDYW5hZGFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XLl9LLl9IYXN0aW5nc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGFzdGluZ3NcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIxODIuMDY4NDEyMDQ0NDMwMyxcbiAgICAgICAgXCJ5XCI6IDQzMzQuMjI1NTMzNzE5MTM4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGF2aWQgQmxhY2t3ZWxsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEYXZpZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxMCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdmlkX0JsYWNrd2VsbFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmxhY2t3ZWxsXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MzQ2LjAwNTE1MDM3ODcwNCxcbiAgICAgICAgXCJ5XCI6IDQ0MTYuNTM4Nzc5NjkzODM0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldpbGxpYW0gSG9vdmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTM2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXaWxsaWFtXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHA6Ly93aWxsaWFtaG9vdmVyLmluZm9cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhvb3ZlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjE4Mi42ODM3OTc5OTA1MjQsXG4gICAgICAgIFwieVwiOiA0MTQyLjA0NjAxMTIyNjQ5NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYXggUGxhbmNrXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NDcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXhfUGxhbmNrXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQbGFuY2tcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyMDIuMzY0NTI5OTg4NDIsXG4gICAgICAgIFwieVwiOiAzNjA0Ljk5OTQ5MDYyNTQ5MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJOb3JiZXJ0IFdpZW5lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTm9yYmVydFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05vcmJlcnRfV2llbmVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXaWVuZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2NTYuNjk4MzI2NTUzNTc2NCxcbiAgICAgICAgXCJ5XCI6IDQyNDcuNjE1NDIxMjc0NTY5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQyN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkthcmwgV2VpZXJzdHJhc3NcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MTUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkthcmxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYXJsX1dlaWVyc3RyYXNzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXZWllcnN0cmFzc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzIxMC43MDU1NzQxNzcxMixcbiAgICAgICAgXCJ5XCI6IDM0NzYuODY2NTM0NTUyODk0M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzOTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9yZ2UgU3Rva2VzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODE5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHZW9yZ2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIklyZWxhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaXJfR2VvcmdlX1N0b2tlcyxfMXN0X0Jhcm9uZXRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN0b2tlc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzU3OS4wNTA2MDYyMDA1MDksXG4gICAgICAgIFwieVwiOiAzNDgwLjk0NjIxMjcxMDU2MDhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjM3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR3JldGEgTGp1bmdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdyZXRhXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRmlubGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyZXRhX00uX0xqdW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJManVuZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcImZlbWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTA4LjM0NjQzNTUyMTgxNSxcbiAgICAgICAgXCJ5XCI6IDQ2NjMuNjE4MTY0MzE4Njg2NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbGV4YW5kZXIgS3JvbnJvZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWxleGFuZGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbGV4YW5kZXJfS3JvbnJvZFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS3JvbnJvZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDA5My43NjYxMTI5ODE2Njk3LFxuICAgICAgICBcInlcIjogMzQ1MS44NzQ2NzIxMTgxMDNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjg4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSXNhYWMgTmV3dG9uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNjQyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJJc2FhY1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTcyNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lzYWFjX05ld3RvbiNjaXRlX25vdGUtT1NOUy0yXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJOZXd0b25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0NDYuMzU3MzgyNDI2Nzc1NSxcbiAgICAgICAgXCJ5XCI6IDM3MTUuMTY2NTI1OTEzNDI2NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJPc2thciBNb3JnZW5zdGVyblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiT3NrYXJcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Pc2thcl9Nb3JnZW5zdGVyblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTW9yZ2Vuc3Rlcm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0OTkuOTk0MzQxMjMyMTc4LFxuICAgICAgICBcInlcIjogMzQwMS4xNzIwNDkwNDk0NDJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzU0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRsOpbGl4IFNhdmFydFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc5MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRsOpbGl4XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODQxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gw6lsaXhfU2F2YXJ0XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTYXZhcnRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE0MDAuMDMyNTU0MTgzMjMyNCxcbiAgICAgICAgXCJ5XCI6IDM4NjQuNDIxMTIwNzU3Mjg4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI5OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN0ZXBoZW4gT3hmb3JkXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU3RlcGhlblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk94Zm9yZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTQ4Ny40OTMyMDc2MDMyODY1LFxuICAgICAgICBcInlcIjogMjg5Mi40MTc4OTcyMzgyNjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZXJtYW5uIEJydW5uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODYyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJtYW5uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVybWFubl9CcnVublwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQnJ1bm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQzNzQuMTUwOTQyMzQ5OTI2NSxcbiAgICAgICAgXCJ5XCI6IDM2NzMuMDk5NzQwNjk3ODM2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM0NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlMuTi4gUnVkZGxlc2RlblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlMuTi5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSdWRkbGVzZGVuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0OTM0LjA1NDE3MjEyODIxMSxcbiAgICAgICAgXCJ5XCI6IDQ3MjkuNjkzODA3NTE4MjAyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiw4lsaWUgQ2FydGFuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODY5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCLDiWxpZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvw4lsaWVfQ2FydGFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDYXJ0YW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2MDUuNzQxMzMxMjI2NTEzNSxcbiAgICAgICAgXCJ5XCI6IDM2NjcuNDU0MzIyNjUwNTE5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkfDoWJvciBTemVnw7ZcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkfDoWJvclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSHVuZ2FyeVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0fDoWJvcl9TemVnxZFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN6ZWfDtlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzk2NC41OTkzNzAzNzM3NjA0LFxuICAgICAgICBcInlcIjogNDAzNi45MTU1NTY3MzQyODc3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjExM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN5ZG5leSBHb2xkc3RlaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlN5ZG5leVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5ZG5leV9Hb2xkc3RlaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkdvbGRzdGVpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDYyNS41MTU0MTExMTc2OTIsXG4gICAgICAgIFwieVwiOiAzMDYzLjg0OTI1NDE4MDg4MzdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjMxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRmVyZGluYW5kIExpbmRlbWFublwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRmVyZGluYW5kXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmVyZGluYW5kX3Zvbl9MaW5kZW1hbm5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxpbmRlbWFublwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzU3NS45NTkwNTMxMTExNTcsXG4gICAgICAgIFwieVwiOiAzNTIzLjU4NzczNjA1MDcyODRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDMyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSGVybWFubiBXZXlsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJtYW5uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVybWFubl9XZXlsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXZXlsXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNjkyLjM3MTM0MjM1MjY3NixcbiAgICAgICAgXCJ5XCI6IDMwMDYuNTg4NDI0NTE3NzI1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlMuIE1hY2hsdXBcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlMuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJBdXN0cmlhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly93d3cuYmVtcy5vcmcvbm9kZS8xOTBcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1hY2hsdXBcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDEzNjMuNTQ3OTc4MTU5MjIzNyxcbiAgICAgICAgXCJ5XCI6IDM3ODIuNjg2ODIzNjQyNzAxM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJWYXJnaGVzZSBNYXRoYWlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJWYXJnaGVzZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwiU291dGggQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNYXRoYWlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU0MTIuNTI3ODEyMjM4MjAyLFxuICAgICAgICBcInlcIjogMzc5Ny4yNDM4NjA4MzM0MjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjgzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRnJhbmsgTmFiYXJyb1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRnJhbmtcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmFua19OYWJhcnJvXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJOYWJhcnJvXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMTI0LjA2ODQ0NzAxNzkyNyxcbiAgICAgICAgXCJ5XCI6IDM2ODYuMzExNzM2ODM3MTUzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE2NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkphbWVzIEplYW5zXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKYW1lc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phbWVzX0plYW5zXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJKZWFuc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDg0MC41MDc1NDcwOTE1NDYsXG4gICAgICAgIFwieVwiOiAzMTQ0Ljg4MzUwMTkxNjgwODdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzA5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWVsYmEgUGhpbGlwc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWVsYmFcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZWxiYV9QaGlsbGlwc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGhpbGlwc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcImZlbWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTc1LjA5MDczOTA4OTc0MixcbiAgICAgICAgXCJ5XCI6IDMzNzcuMDU0NDA2NjU5NTMxN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIYW5zIEhlbGxtYW5uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIYW5zXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFuc19IZWxsbWFublwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGVsbG1hbm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIxOTkuMzYxNDY0OTg0NjM1NCxcbiAgICAgICAgXCJ5XCI6IDMwOTkuMDA2ODI0NTA2MzIwM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJWaXRvIFZvbHRlcnJhXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODYwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJWaXRvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZpdG9fVm9sdGVycmFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlZvbHRlcnJhXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDYyLjYxMTEzNzYyOTM5MjUsXG4gICAgICAgIFwieVwiOiAzOTExLjE2Mjc2MTI0NDM3OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWljaGFlbCBBdGl5YWhcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1pY2hhZWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NaWNoYWVsX0F0aXlhaFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQXRpeWFoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTg0LjQ0NzQwMDU5MDk2NDQsXG4gICAgICAgIFwieVwiOiAzMzM1LjYyOTUzNDQ2MjEzOTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFZHdhcmQgQ29uZG9uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFZHdhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FZHdhcmRfQ29uZG9uXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDb25kb25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1NjEuMzYwNzEwNTEyMjgzLFxuICAgICAgICBcInlcIjogMjk3MC40MDQ1MjYxNDYyNDJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTE0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSmVmZnJleSBHb2xkc3RvbmVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkplZmZyZXlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVmZnJleV9Hb2xkc3RvbmVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkdvbGRzdG9uZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjc0MC4wOTMzMjE4Njg4NDc0LFxuICAgICAgICBcInlcIjogNDYyMS4wODE2MjU3NDgxNjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjY1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUm9iZXJ0IE1pbGxzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTI3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSb2JlcnRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JlcnRfTWlsbHNfKHBoeXNpY2lzdClcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1pbGxzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MjM4LjUyMzMzNzIwNDYwNixcbiAgICAgICAgXCJ5XCI6IDM4MDAuNTgwMTI4NTk3NzAyMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMjVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb3NlcGggUHJvdWRtYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvc2VwaFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvc2VwaF9Qcm91ZG1hblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUHJvdWRtYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ2MDQuNDIwODUxNzE4NjkzNSxcbiAgICAgICAgXCJ5XCI6IDMwNDQuMjc4NjcyNDcyMDU4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEzNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlbG11dCBIYXNzZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVsbXV0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVsbXV0X0hhc3NlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIYXNzZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDM5OC44NDM5OTc5ODkxOTcsXG4gICAgICAgIFwieVwiOiAzNjU0Ljk0MTA2NTI5NTQ3NTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTE3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVGV0c3VvIEdvdG9cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJUZXRzdW9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJKYXBhblwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR290b1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjgxOS45NjUxOTU1NjgxNzIsXG4gICAgICAgIFwieVwiOiA0NTQxLjg5MzM2Nzk0NzkzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQ1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQXJ0aHVyIENheWxleVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgyMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQXJ0aHVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODk1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXJ0aHVyX0NheWxleVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2F5bGV5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MzA1LjgzMzAxNTM5MzM3NyxcbiAgICAgICAgXCJ5XCI6IDMxNDAuOTI4OTcyMTk3NTM5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE0NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNvbnllcnMgSGVycmluZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ29ueWVyc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnllcnNfSGVycmluZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGVycmluZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjE5OS43MjQyNzY1MjE2OTksXG4gICAgICAgIFwieVwiOiAzNjcxLjA5NjY5NTA1NjEzNTZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDE4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUmljaGFyZCB2b24gTWlzZXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJpY2hhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SaWNoYXJkX3Zvbl9NaXNlc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwidm9uIE1pc2VzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NjMyLjAwMzI3NDI3ODgzMixcbiAgICAgICAgXCJ5XCI6IDQzODQuNDkyMzMyNDAxNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NDRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTdGFuaXPFgmF3IFphcmVtYmFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlN0YW5pc8WCYXdcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NDIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlBvbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0YW5pc8WCYXdfWmFyZW1iYV8obWF0aGVtYXRpY2lhbilcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlphcmVtYmFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ2NTEuMDQ2NDQwNzMwMTc2LFxuICAgICAgICBcInlcIjogMzY2Mi42MzgwMTUxNzM0OTU3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRhdmlkIE11bWZvcmRcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdmlkX011bWZvcmRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk11bWZvcmRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2NzIuMDU0MDExOTgxMzIxOCxcbiAgICAgICAgXCJ5XCI6IDM3MzkuOTM1OTQ5NDU5NTgzOFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbmRyemVqIE1vc3Rvd3NraVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxMyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQW5kcnplalwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYS1IdW5nYXJ5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5kcnplal9Nb3N0b3dza2lcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1vc3Rvd3NraVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU0NS40MTczMjE5NjAxODcsXG4gICAgICAgIFwieVwiOiAzODkwLjgyNDUzNjcyNjIwM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSb2JlcnQgUmljaHRteWVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTEwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSb2JlcnRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JlcnRfRC5fUmljaHRteWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSaWNodG15ZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIwODMuNjMzMTkyNzY0MDAzLFxuICAgICAgICBcInlcIjogMzYyMy40OTA1OTU1MzE3OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMZW9uYXJkIFJvZ2Vyc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTGVvbmFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzMyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xlb25hcmRfSmFtZXNfUm9nZXJzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSb2dlcnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5NzcuNjUxNTM5MzEyMDgxLFxuICAgICAgICBcInlcIjogNDE1Ny43MzU4NjQxODgzMjJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzkzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRWRtdW5kIFN0b25lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWRtdW5kXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWRtdW5kX0NsaWZ0b25fU3RvbmVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdG9uZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE2MTcuODAyMzY2NzI4ODc2LFxuICAgICAgICBcInlcIjogMzU2Mi43NjI3ODMzNTg0NjkzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdyYWVtZSBTZWdhbFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR3JhZW1lXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJhbGlhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JhZW1lX1NlZ2FsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTZWdhbFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTkwNS42MjQyMDQ2NzQyNjczLFxuICAgICAgICBcInlcIjogMzMyNC40MzE5MzQyOTE1MTY0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM3OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1hcmlhbiBTbW9sdWNob3dza2lcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1hcmlhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkxNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUG9sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyaWFuX1Ntb2x1Y2hvd3NraVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU21vbHVjaG93c2tpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDUwLjQzMDc3Njk0OTY0MixcbiAgICAgICAgXCJ5XCI6IDM2NDkuODc2NTY2MTU5MDk4M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFZHdpbiBTYWxwZXRlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWR3aW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FZHdpbl9Fcm5lc3RfU2FscGV0ZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNhbHBldGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTYzLjAxMjIxMjg1ODgyMSxcbiAgICAgICAgXCJ5XCI6IDI5MTcuMTEzNjY0NTczNDEzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkt1biBIdWFuZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiS3VuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJDaGluYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSHVhbmdfS3VuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIdWFuZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzMwMy4yODk4Mjk2NTY2NjM2LFxuICAgICAgICBcInlcIjogMzQwMS41NTc3MTAwMDQzMTc0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIxOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIklydmluZyBMYW5nbXVpclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSXJ2aW5nXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXJ2aW5nX0xhbmdtdWlyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMYW5nbXVpclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDE2Ny4wMTE0MjA4OTI0MDYsXG4gICAgICAgIFwieVwiOiAyOTczLjA5ODE2ODE5ODYwMjNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTc2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRXJpY2ggS8OkaGxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRXJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcmljaF9Lw6RobGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLw6RobGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNTQ2LjkzNDAwODA0OTczNixcbiAgICAgICAgXCJ5XCI6IDM2NTguMzU4MDEyNDU3NjQ5MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBdXJlbCBXaW50bmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBdXJlbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSHVuZ2FyeVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F1cmVsX1dpbnRuZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldpbnRuZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1ODUuMTE1NTY0MDMzMDk2NyxcbiAgICAgICAgXCJ5XCI6IDQzMjIuMTkxODkxNDc5NTUxNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1heCBCb3JuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXhfQm9yblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQm9yblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM4MC41MDgzMzA1ODI5OTg1LFxuICAgICAgICBcInlcIjogMzQ2NS4yNjYzNjAwNDAwNjU2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVkbXVuZCBIbGF3a2FcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVkbXVuZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VkbXVuZF9IbGF3a2FcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhsYXdrYVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDU1Ni44NzU2MjM4NTA1NTIsXG4gICAgICAgIFwieVwiOiAzNjUxLjE2ODI0NjI0MTYwNjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiOTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJGcmFueiBGaXNjaGVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcmFuelwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZyYW56X0pvc2VwaF9FbWlsX0Zpc2NoZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZpc2NoZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDY0NTIuMzExNTIwNTM3MTQ0LFxuICAgICAgICBcInlcIjogMzYxNy4yNjg2MjkyNjA5NzU2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQXVndXN0aW4gQ2F1Y2h5XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzg5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBdWd1c3RpblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg1NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVndXN0aW4tTG91aXNfQ2F1Y2h5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDYXVjaHlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1MzcuNTQ4NTk2ODI4NzM4NSxcbiAgICAgICAgXCJ5XCI6IDM2MDguNzM3OTk4MDUzOTAxM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMb3VpcyBHb3V5XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMb3Vpc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkyNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG91aXNfR2Vvcmdlc19Hb3V5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHb3V5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNDg5LjcxMjU5MDkwMzYyODYsXG4gICAgICAgIFwieVwiOiA0NjE2LjQxNjc2MTc0MTE1NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTaGlrYW8gSWtlaGFyYVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU2hpa2FvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJKYXBhblwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2hpa2FvX0lrZWhhcmFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIklrZWhhcmFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2MDUuMDQyNjQ1Nzc5MzU4NyxcbiAgICAgICAgXCJ5XCI6IDQyOTIuOTYxMzM3Njg1OTYxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjg0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWxmcmVkIEVubmVwZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFsZnJlZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsZnJlZF9Fbm5lcGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJFbm5lcGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTAyLjc0MDAyNDM2NzI5NzMsXG4gICAgICAgIFwieVwiOiAzNDY5Ljc3MjUzMDUwNzY5NTZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVybmVzdCBCYXJuZXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVybmVzdFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VybmVzdF9CYXJuZXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJhcm5lc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTg2NS4zNzUyNTk1MDE4MTgsXG4gICAgICAgIFwieVwiOiAzNDU3Ljc4MTkwNTY2MjM1NTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMdWR3aWcgQm9sdHptYW5uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODQ0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMdWR3aWdcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWR3aWdfQm9sdHptYW5uXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCb2x0em1hbm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUxMjUuODA0OTM3ODIwMDc2LFxuICAgICAgICBcInlcIjogNDUyNC4wNTE0MTM0ODU5M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI5NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlZsYWRpbWlyIEZvY2tcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlZsYWRpbWlyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WbGFkaW1pcl9Gb2NrXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGb2NrXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTg0LjUxNzYwMTY4MzYxNDQsXG4gICAgICAgIFwieVwiOiAzOTY5LjI2NjcwNTE5NDI0MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIYW5zIEtyYW1lcnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhhbnNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFuc19LcmFtZXJzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLcmFtZXJzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyODA1LjQyNjg5MzUyNjQyNjMsXG4gICAgICAgIFwieVwiOiAzMDg5LjY1MTk0NzM0MzkzNTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjkyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiU2h1aWNoaSBOb3PDqVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk1MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU2h1aWNoaVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwNSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSmFwYW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwiRWFzdCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NodWljaGlfTm9zw6lcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk5vc8OpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2Mjc5LjQwNDYzNTkwNjQyOCxcbiAgICAgICAgXCJ5XCI6IDQxNjQuNjUyODMzNDUxNTUxNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJUIFNhdG9cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJUXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSmFwYW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwiRWFzdCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNhdG9cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQwMjQuODg3OTY1Nzg0MjU1LFxuICAgICAgICBcInlcIjogNDMxNy4xMzQ0NjQ3MTMyNzhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjMyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQW5kZXJzIExpbmRzdGVkdFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQW5kZXJzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2VkZW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbmRlcnNfTGluZHN0ZWR0XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMaW5kc3RlZHRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM4MTMuOTY2MDIwNzA5MzQ4NCxcbiAgICAgICAgXCJ5XCI6IDM5NTYuNzI1MTc5NzU2MTcwM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI5M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJvbmFsZCBGaXNoZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJvbmFsZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbmFsZF9GaXNoZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZpc2hlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDY5NC4xNTU4MDgzNzg5MDgsXG4gICAgICAgIFwieVwiOiA0NDEzLjAyNTk4MTQxMTQ2N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyOTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJMYXJzIE9uc2FnZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxhcnNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5vcndheVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhcnNfT25zYWdlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiT25zYWdlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTMxNC42NjA2OTc0NDg5MzMyLFxuICAgICAgICBcInlcIjogMzc5MS4yNDI4NjA2NzM3MDUzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJ1ZG9sZiBQZWllcmxzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSdWRvbGZcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SdWRvbGZfUGVpZXJsc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGVpZXJsc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjA0NC40NDYyNTA3NTQzNzc4LFxuICAgICAgICBcInlcIjogMzY5NS4yNzYxNTk2OTgxNzlcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJGcmllZHJpY2ggQmVzc2VsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzg0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcmllZHJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4NDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmllZHJpY2hfQmVzc2VsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCZXNzZWxcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMxNTkuODQ0MDAxNjc5OTgzLFxuICAgICAgICBcInlcIjogMzk0NS4wODE2MjMzMTA0MDM4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkx1ZHZpZyBMb3JlbnpcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MjksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkx1ZHZpZ1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg5MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRGVubWFya1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0x1ZHZpZ19Mb3JlbnpcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxvcmVuelwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDc4MC42OTczOTA4MzY5MTEsXG4gICAgICAgIFwieVwiOiAzMzM0Ljg3MjcxNDY4OTAyODdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTQ3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGF2aWQgSGlsYmVydFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRGF2aWRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NDMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYXZpZF9IaWxiZXJ0XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIaWxiZXJ0XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzIyLjg1NjU0OTE5NzE2MzUsXG4gICAgICAgIFwieVwiOiAzODAzLjEzNjUwMTAyOTEwOTJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTU3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTGVzbGllIEhvd2FydGhcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxlc2xpZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwMSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xlc2xpZV9Ib3dhcnRoXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIb3dhcnRoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMzUxLjk1MTE5MDcxMDc1NCxcbiAgICAgICAgXCJ5XCI6IDMzMzUuNDY5OTUyMTYzMzY4NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBCZXJuc3RlaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvc2VwaFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlNvdmlldCBVbmlvblwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvc2VwaF9CZXJuc3RlaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJlcm5zdGVpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTUwMS44OTQ1MzA4MzE1NzQsXG4gICAgICAgIFwieVwiOiAzOTQ0LjU2MTI4OTc4NjExNzRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzcwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2xhdWRlIFNoYW5ub25cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNsYXVkZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwMSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NsYXVkZV9TaGFubm9uXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTaGFubm9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNzYxLjA4Mjg2MjM0NDU1OCxcbiAgICAgICAgXCJ5XCI6IDQxNDUuODQ2MDc3NTI2ODQ5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM5MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1hcnNoYWxsIFN0b25lXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXJzaGFsbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcnNoYWxsX0hhcnZleV9TdG9uZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU3RvbmVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI4ODkuNzcxODY1MzQyNTAzNixcbiAgICAgICAgXCJ5XCI6IDM0NTAuMTQxOTY3OTgyOTYzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM0MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkd1c3RhdiBSb2NoXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODM5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHdXN0YXZcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4NjYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HdXN0YXZfUm9jaFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUm9jaFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzgxMi45MjQyNjg5MzkwNDksXG4gICAgICAgIFwieVwiOiAzNjk0LjM5OTgwNTQ2MjQ3MjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWF4IFZvbG1lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWF4XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF4X1ZvbG1lclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiVm9sbWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NDM5Ljc4MDk4NjM4MTMzNCxcbiAgICAgICAgXCJ5XCI6IDQyMjkuMjY0MjE3NDcwNzUzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI4N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFuZHLDqSBOw6lyb25cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFuZHLDqVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5kcsOpX07DqXJvblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTsOpcm9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MzcwLjQ5NzIxODM1NDY3MSxcbiAgICAgICAgXCJ5XCI6IDM5OTQuOTI4NzY5NTkwMzgzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM0OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk90dG8gU2Fja3VyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJPdHRvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTE0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3R0b19TYWNrdXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNhY2t1clwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDAxNS43NDg1NTMyNzkzMTQ0LFxuICAgICAgICBcInlcIjogNDk3Mi43NjI2ODExNTYxNjFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIYW5zIEJldGhlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIYW5zXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFuc19CZXRoZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmV0aGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyMTEuNzc1Njc2ODkzMDE4LFxuICAgICAgICBcInlcIjogMjk3Ny4wMTQ5NDM3ODc3N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkd1aWRvIENhc3RlbG51b3ZvXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODY1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHdWlkb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXRhbHlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HdWlkb19DYXN0ZWxudW92b1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2FzdGVsbnVvdm9cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3MTUuODg0MTU1NDcxNjU3MyxcbiAgICAgICAgXCJ5XCI6IDM3MDYuNTQ1NTQ1MzE1MDEyNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZXJtYW5uIE1pbmtvd3NraVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVybWFublwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkwOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUG9sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVybWFubl9NaW5rb3dza2kjU2VlX2Fsc29cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1pbmtvd3NraVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDI5OS43NzM5NzI3NTA1NjMsXG4gICAgICAgIFwieVwiOiAzNjU4LjMwNDM3Njg0MDc3NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdlb3JnZSBCb3hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdlb3JnZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxMyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZV9FLl9QLl9Cb3hcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJveFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDEyNC41MTI1MDE3NzYyMTUsXG4gICAgICAgIFwieVwiOiA0NjA5Ljg1MzY0OTAxNjc1OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSb2JlcnQgTGFuZ2xhbmRzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTM2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSb2JlcnRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJDYW5hZGFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JlcnRfTGFuZ2xhbmRzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMYW5nbGFuZHNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMzMDkuMTQ5MzE4NTQxMTg0NixcbiAgICAgICAgXCJ5XCI6IDM4NTQuOTA3MzgzODc5NTQ3NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZWlucmljaCBIZXJ0elwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVpbnJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWlucmljaF9IZXJ0elwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGVydHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5MTguNTA3NTU0MDQ0NTUxLFxuICAgICAgICBcInlcIjogMjk2OC4xNDMwMDYyMjAzNzk0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpheWFudCBTaGFoXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmF5YW50XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJhY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2hhaFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzc0Mi41OTMwMTM3NDM2OCxcbiAgICAgICAgXCJ5XCI6IDM3NzQuNzYwMjA1OTk5NDU2NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI3NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkxlb25hcmQgRGlja3NvblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg3NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTGVvbmFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xlb25hcmRfRXVnZW5lX0RpY2tzb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkRpY2tzb25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQzNjQuNDg2NDIxMjA4NjUsXG4gICAgICAgIFwieVwiOiAzMDkxLjE4ODgyNzQzODEzMDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQaWVycmUgQ3VyaWVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NTksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBpZXJyZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkwNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGllcnJlX0N1cmllXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDdXJpZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjMwOC4wMTMzMjI4MzAyNjgsXG4gICAgICAgIFwieVwiOiAzMTY2LjU0Nzc2ODMxNTI3MTJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDYXJsIEJvc2NoXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJDYXJsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FybF9Cb3NjaFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQm9zY2hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyMjAuMTM5OTU1NTQwNzEyNCxcbiAgICAgICAgXCJ5XCI6IDMzMjUuNjQ5MTQ5NTI4NjIxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNhdGhhbWFuZ2FsYW0gVmFyYWRoYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlNhdGhhbWFuZ2FsYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJbmRpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJTb3V0aCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1MuX1IuX1NyaW5pdmFzYV9WYXJhZGhhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiVmFyYWRoYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU1MjMuODE3MTQyNjk1MTY2LFxuICAgICAgICBcInlcIjogNDQxOS40Nzk5MTgxNDUyOThcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzkwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FsdGVyIFN0b2NrbWF5ZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhbHRlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwNCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhbHRlcl9ILl9TdG9ja21heWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdG9ja21heWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MDIyLjUyODcyODIwNDI3NyxcbiAgICAgICAgXCJ5XCI6IDI5MDcuMDkyNTk0NzgwNTQ2M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2hhbm4gU29sZG5lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc3NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oYW5uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODMzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9oYW5uX0dlb3JnX3Zvbl9Tb2xkbmVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTb2xkbmVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTg2LjA3NjM1MzI4NDk3NCxcbiAgICAgICAgXCJ5XCI6IDQzMjcuNzk2NTYzODc0MTgxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldpbGxpcyBMYW1iXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTEzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXaWxsaXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsaXNfTGFtYlwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFtYlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTgwMS43ODM3Njg0Njc3NzI1LFxuICAgICAgICBcInlcIjogMzg1MC4yMDk0NjMzODU5Mzg4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIm1pc3NpbmcgUGVhY2hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJhY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGVhY2hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDYxODMuMjE4MDMzMTIzOTk5LFxuICAgICAgICBcInlcIjogMzgxNC42Mjc4MjEyNzE0MjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDI0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRHVuY2FuIFdhdHRzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTcxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEdW5jYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRHVuY2FuX0ouX1dhdHRzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXYXR0c1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzY2NC43MTg4MjAzNDYxMDgsXG4gICAgICAgIFwieVwiOiAyOTY0LjI5OTY4NDYzMzY4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIyOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVsbGlvdHQgTGllYlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkzMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRWxsaW90dFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbGxpb3R0X0guX0xpZWJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxpZWJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU0NjkuMjcwMDAyMDE4MTQ0LFxuICAgICAgICBcInlcIjogMjkyMy45NzIzMDg5MTkxMDE2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVyaWNoIEjDvGNrZWxcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVyaWNoXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTgwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXJpY2hfSMO8Y2tlbFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSMO8Y2tlbFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDIxMC41NjA0MTQ1MjkzMjYsXG4gICAgICAgIFwieVwiOiAyNTg3LjgwNzMyODMxNTA4NzVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTkzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FsdGVyIEtvaG5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhbHRlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkxNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhbHRlcl9Lb2huXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb2huXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNTA3Ljk4OTA2MzQ0ODc3NjcsXG4gICAgICAgIFwieVwiOiAzODUxLjQ1NDAwODUwMjQ2NTVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjI2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWVsIExldnlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1lbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL3d3dy5pYXFtcy5vcmcvbWVtYmVycy9sZXZ5LnBocFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGV2eVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTUyOS42Njg0NTc3NDg1MTEsXG4gICAgICAgIFwieVwiOiAyOTI1LjY2MDMwMjgxOTYzNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMDFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKYW1lcyBGcmFuY2tcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkphbWVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmFtZXNfRnJhbmNrXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGcmFuY2tcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3NDMuODEwMDU1Mzc5MTI5NixcbiAgICAgICAgXCJ5XCI6IDI5NjAuMzA5MDQyNDQ0Mzg0NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNjBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHw7xudGVyIFNjaHVselwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR8O8bnRlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk5OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUG9sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9kZS53aWtpcGVkaWEub3JnL3dpa2kvR8O8bnRlcl9WaWN0b3JfU2NodWx6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTY2h1bHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ5OTEuOTU3NDc2MDQ4MTg2LFxuICAgICAgICBcInlcIjogMjg3OS45MzM4Mjg4OTUxMjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTA1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR2VvcmdlIEdhbW93XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHZW9yZ2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NjgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlJ1c3NpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZV9HYW1vd1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR2Ftb3dcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU3MzguNDA3MzUyMDk2NjYsXG4gICAgICAgIFwieVwiOiA0MzM2LjcwNTUwNDEzMTAyMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYW5pZWwgTGVobXVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzgwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEYW5pZWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4NjMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DLl9MLl9MZWhtdXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxlaG11c1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDU5NC40MDcwMzUyOTQwMDcsXG4gICAgICAgIFwieVwiOiAzODAxLjI2MTEyNDQ1NzE1M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzOTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSaWNoYXJkIFN3YW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJpY2hhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmljaGFyZF9Td2FuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTd2FuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NzY0LjYwMDU4MTE4NzQ0NCxcbiAgICAgICAgXCJ5XCI6IDM4NjguNTEwNTc5NTU0ODU4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI4NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNsYXVkZS1Mb3VpcyBOYXZpZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE3ODUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNsYXVkZS1Mb3Vpc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTgzNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2xhdWRlLUxvdWlzX05hdmllclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTmF2aWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNTc5Ljc0Mjc4NTc0NDc2NjUsXG4gICAgICAgIFwieVwiOiAzNDMyLjA2MDY2NTYwMDgzM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNlcmdlaSBCZXJuc3RlaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlNlcmdlaVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VyZ2VpX05hdGFub3ZpY2hfQmVybnN0ZWluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCZXJuc3RlaW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ3MTEuOTM4MjU3MzkzNzM2LFxuICAgICAgICBcInlcIjogNDM4Ni4yNDY2OTA1NTQ2MjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDIxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSXZhciBXYWxsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkl2YXJcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3ZWRlblwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0l2YXJfV2FsbGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXYWxsZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQyOTguODk2MTY2ODYxMDUsXG4gICAgICAgIFwieVwiOiAyNjA5LjcyNTM0ODYyMjE4OVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYXJzdG9uIE1vcnNlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODkyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXJzdG9uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyc3Rvbl9Nb3JzZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTW9yc2VcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyOTEuOTYxNzYyMjk1MDA4LFxuICAgICAgICBcInlcIjogNDA5Mi43Nzg0NDE1NTEyNDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzM1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUnVkb2xmIFJlbm5lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUnVkb2xmXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTkxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9hcnRpY2xlLzEwLjEwMDcvczExMjI0LTAwOS05NDc5LXpcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlJlbm5lclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTcxNi41ODc3NTg0MjUwNjEsXG4gICAgICAgIFwieVwiOiA0MzQ5LjA4MzQ3ODMxNjUwMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZWlucmljaCBXZWJlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg0MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVpbnJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWlucmljaF9NYXJ0aW5fV2ViZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldlYmVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NDA2LjQ3MzIyOTE2MDk1NSxcbiAgICAgICAgXCJ5XCI6IDQ2OTYuNzk1NjA4NTQ4MzY5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE2NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk9sZWcgSmVmaW1lbmtvXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJPbGVnXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVa3JhaW5lXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2xlZ19ELl9KZWZpbWVua29cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkplZmltZW5rb1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjIyNi45NDE1MTkxNDc0NTgsXG4gICAgICAgIFwieVwiOiAzMDg1LjIxNTM3ODI1NDcyNzVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiODlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNaWNoYWVsIEZla2V0ZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWljaGFlbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSHVuZ2FyeVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01pY2hhZWxfRmVrZXRlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGZWtldGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQwODkuNTI5MTIxMzgyMjM1LFxuICAgICAgICBcInlcIjogNDAwNy42NTAwMTA4NDIzMjQ3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE5OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkJlcm5hcmQgS29vcG1hblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQmVybmFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybmFyZF9Lb29wbWFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb29wbWFuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNDg1LjQ4MjI3MDA1NzEwNixcbiAgICAgICAgXCJ5XCI6IDM0MjMuOTA5NjM2ODMyMjgyNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYXZpZCBMYW5kYXVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdmlkX1AuX0xhbmRhdVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFuZGF1XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MzA1Ljg2NDgzNzIyNDM4MixcbiAgICAgICAgXCJ5XCI6IDI5MzcuMTM3MDI5MTU0Nzc1NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI4MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBhdWwgRHJ1ZGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBhdWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXVsX0RydWRlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJEcnVkZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDU3OC40OTg1NDA3MjYyNSxcbiAgICAgICAgXCJ5XCI6IDM1MDQuNjE4MzE2NTk2ODg5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMzMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBSYXBoc29uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNjQ4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb3NlcGhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE3MTUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb3NlcGhfUmFwaHNvblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUmFwaHNvblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM0Mi42ODUwNjMxNTExMDI0LFxuICAgICAgICBcInlcIjogMzczMi44NTA1MTM0MTYwMzE0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjUxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWxvbnpvIENodXJjaFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWxvbnpvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTk1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWxvbnpvX0NodXJjaFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2h1cmNoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNjQ0LjQ2MTM0OTQ2NTcyMzMsXG4gICAgICAgIFwieVwiOiAzOTIyLjc2Njk2NzI4MzQ4OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9yZ2UgTW9zdG93XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHZW9yZ2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9yZ2VfTW9zdG93I1NlZV9hbHNvXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNb3N0b3dcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyNzYuNDI1NTEwMDY4NTg3MyxcbiAgICAgICAgXCJ5XCI6IDQxNTIuNzQxMTE2MjYzNjk0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNvbGluIE1hY2xhdXJpblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTY5OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ29saW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE3NDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlNjb3RsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29saW5fTWFjbGF1cmluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNYWNsYXVyaW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0MjUuMTkzMDI1MzI4OTg3NSxcbiAgICAgICAgXCJ5XCI6IDM4MTAuMDA0MTk4NDgzMTI2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlcm1hbm4gSGVsbWhvbHR6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODIxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJtYW5uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODk0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVybWFubl92b25fSGVsbWhvbHR6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIZWxtaG9sdHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2NjkuNzUxMTk5OTg1NTYzMyxcbiAgICAgICAgXCJ5XCI6IDMxOTcuMTI1MTUwNDYxMjA0NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRhdmlkIENoYXBtYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF2aWRfQ2hhcG1hbl8oY2hlbWlzdClcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNoYXBtYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0NzguMTEyNDY1MDEzMzg5LFxuICAgICAgICBcInlcIjogNDU4OC45MDU0OTM1Mzg3MThcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYW5pZWwgQmVybm91bGxpXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzAwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEYW5pZWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE3ODIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3aXR6ZXJsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFuaWVsX0Jlcm5vdWxsaVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmVybm91bGxpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDU2Ljc3MTgwNDM1NjMwNixcbiAgICAgICAgXCJ5XCI6IDM4MDIuNTM3MzQ4NjI4OTMyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjk3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiS2VudCBGb3JkXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJLZW50XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlbnRfRm9yZF8oYXN0cm9ub21lcilcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZvcmRcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1OTguMDczODQ5NzM5NDIxLFxuICAgICAgICBcInlcIjogMjYxOC4zNDY4MjU0MDkxMzVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzMwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2FseWFtcHVkaSBSYW9cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhbHlhbXB1ZGlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJbmRpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJTb3V0aCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0MuX1IuX1Jhb1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUmFvXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0Mzg4LjA5MzU1NDYxNTA5NixcbiAgICAgICAgXCJ5XCI6IDQzODYuODE4NDM2NTgyMTk2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI4NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIllvaWNoaXJvIE5hbWJ1XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJZb2ljaGlyb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSmFwYW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwiRWFzdCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1lvaWNoaXJvX05hbWJ1XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJOYW1idVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjc4MC43ODE0OTQ3NTI4MDcsXG4gICAgICAgIFwieVwiOiA0NTgwLjc4NDk2Mjc3NzA2NjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTM0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUmFscGggSGFydGxleVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUmFscGhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYWxwaF9IYXJ0bGV5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIYXJ0bGV5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNjkzLjcxODg1MzgwNzcyNDQsXG4gICAgICAgIFwieVwiOiA0MTQwLjI1NTY2ODUxNzc5NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2huIFRhdGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaG5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX1RhdGVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlRhdGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUyODUuOTk1NDU4MjU1ODAyLFxuICAgICAgICBcInlcIjogMzk1Ny44NjMxNDcyMzE0N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFcm5lc3QgVmVzc2lvdFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRXJuZXN0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTUyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Fcm5lc3RfVmVzc2lvdFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiVmVzc2lvdFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU3NC44MDIzMzgzNzI1OCxcbiAgICAgICAgXCJ5XCI6IDM0MTcuMjk4Nzk4MzA4ODg3NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHYXJ5IEdpYmJvbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdhcnlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2FyeV9HaWJib25zXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHaWJib25zXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDIzLjI3ODIzNzk3NTM1NTgsXG4gICAgICAgIFwieVwiOiA0NjI5LjI0OTUyMDM1MDc4OVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNhdHllbmRyYSBCb3NlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODk0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTYXR5ZW5kcmFcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkluZGlhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIlNvdXRoIEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2F0eWVuZHJhX05hdGhfQm9zZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQm9zZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzQ3NC4zMTc1MzE2MjM0NjMzLFxuICAgICAgICBcInlcIjogMzYxMC41MjAwMzEwMDIxMjM3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQxOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvaG4gdm9uIE5ldW1hbm5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaG5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkh1bmdhcnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX3Zvbl9OZXVtYW5uXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJ2b24gTmV1bWFublwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU5OC44OTQ1OTY5MDMyMjg0LFxuICAgICAgICBcInlcIjogMzQzNC4yNjM1Nzg4NzA5Mzk1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJJc2FhayBCYWNoYXJhY2hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIklzYWFrXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSXNhYWtfQmFjaGFyYWNoXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCYWNoYXJhY2hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQzMDUuMzI1OTAxNDY3NDc2LFxuICAgICAgICBcInlcIjogMzExOC41NTAwMDUxMjcxMDQ3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIzNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkJlcm5hcmQgTGlwcG1hbm5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkJlcm5hcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkFtZXJpY2FuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybmFyZF9MaXBwbWFublwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGlwcG1hbm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ1ODIuMzMwNzE1ODk4MDczLFxuICAgICAgICBcInlcIjogMjYwOS44NDczNDU5NDU4OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQaWVycmUtU2ltb24gTGFwbGFjZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc0OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGllcnJlLVNpbW9uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODI3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaWVycmUtU2ltb25fTGFwbGFjZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFwbGFjZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzg5OS4xNzcxOTk5MjcyMjUsXG4gICAgICAgIFwieVwiOiAzMDMzLjM5OTQzMDE1NDUyNDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSmVhbi1QaWVycmUgU2VycmVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkplYW4tUGllcnJlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVhbi1QaWVycmVfU2VycmVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNlcnJlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MDM0LjAxOTk0OTA2ODgzMSxcbiAgICAgICAgXCJ5XCI6IDM4OTIuMDQ5NjU3NzU0OTc5M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNzJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSdWRvbGYgTcO2c3NiYXVlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUnVkb2xmXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDExLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUnVkb2xmX03DtnNzYmF1ZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk3DtnNzYmF1ZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE4MTQuMDEwNTA1MDk4NTMxNyxcbiAgICAgICAgXCJ5XCI6IDM4NzEuNTkxNzgwODY3NTQ2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRhdmlkIEthemhkYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU292aWV0IFVuaW9uXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF2aWRfS2F6aGRhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS2F6aGRhblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzA3My41NzE2OTkxMjE5Nzc0LFxuICAgICAgICBcInlcIjogMzg3Ni4wODYxNjM3NDQ3NzQyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE2NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlcm1hbm4gSmFoblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVybWFublwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcm1hbm5fQXJ0aHVyX0phaG5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkphaG5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU1OTIuOTcyMDA0NTA1MjEsXG4gICAgICAgIFwieVwiOiA0MjkxLjA0ODU2MzU0MTQ3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlRoZW9kb3JlIEhvbHN0ZWluXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJUaGVvZG9yZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RoZW9kb3JlX0hvbHN0ZWluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIb2xzdGVpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjMwNC4wMjQxNzYxNjQ4NTksXG4gICAgICAgIFwieVwiOiAzNjU5LjgyODMyNzEyOTgxNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxODZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbGVrc2FuZHIgS2hpbmNoaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFsZWtzYW5kclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWxla3NhbmRyX0toaW5jaGluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLaGluY2hpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzcxNy4yMzc1Nzg4NDk5NjU4LFxuICAgICAgICBcInlcIjogNDI5Mi45MjQ1OTgzODQ3MjFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjUzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTG9yZW56byBNYXNjaGVyb25pXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzUwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMb3JlbnpvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODAwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvcmVuem9fTWFzY2hlcm9uaVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWFzY2hlcm9uaVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzQyMi43MDM3OTQyMDgzNDA3LFxuICAgICAgICBcInlcIjogMzg0Ni4wNjg4OTY2ODc4NDgzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjY0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2hhcmxlcyBHIERhcndpblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ2hhcmxlcyBHXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTYyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmxlc19HYWx0b25fRGFyd2luXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJEYXJ3aW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ2MzguNjQ3MDcyMzA2OTc4LFxuICAgICAgICBcInlcIjogMjc5OC4yMzE0ODI4Nzk4MDc2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI2N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFkcmlhYW4gTW9lbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NDYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFkcmlhYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWRyaWFhbl9Jc2VicmVlX01vZW5zXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNb2Vuc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjA3OC4xNTQ2NjA1MDY0MzUsXG4gICAgICAgIFwieVwiOiA0MDU3LjY0NTUxNTQyODc4MzNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzk0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSC4gVy4gU3RyZWV0ZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJILiBXLlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdHJlZXRlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTYwNy4yMjUyMjIwNDI0NDI1LFxuICAgICAgICBcInlcIjogMzI1OC43NDU0Nzg0MDUyNzVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiOTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJFbnJpY28gRmVybWlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVucmljb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXRhbHlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbnJpY29fRmVybWlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZlcm1pXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMjc1LjE3MTAyOTA5Nzg0LFxuICAgICAgICBcInlcIjogMzQwMC40MDUyODI0NTExMTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiT2xpdmVyIEhlYXZpc2lkZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiT2xpdmVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTI1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2xpdmVyX0hlYXZpc2lkZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSGVhdmlzaWRlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNDM3LjcxMDcxOTI1NTAzMjUsXG4gICAgICAgIFwieVwiOiAzMjAxLjk4ODMzODUwMzY2ODNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkZyYW7Dp29pcyBBcmFnb1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc4NixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRnJhbsOnb2lzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODUzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmFuw6dvaXNfQXJhZ29cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkFyYWdvXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0ODE5LjQ1MzE3NDg5NDk1NixcbiAgICAgICAgXCJ5XCI6IDM5NjAuMTE5OTk3MzExMTExNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlbnJpIELDqW5hcmRcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhlbnJpXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZW5yaV9Cw6luYXJkXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCw6luYXJkXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0ODc0LjE0MDQ5NzQzODExNSxcbiAgICAgICAgXCJ5XCI6IDMxNDIuMDM1NTE0NTc4NThcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzU5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRXJ3aW4gU2NocsO2ZGluZ2VyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFcndpblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Vyd2luX1NjaHLDtmRpbmdlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2NocsO2ZGluZ2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0OTE1LjIwNTQyNDc5NzM0NyxcbiAgICAgICAgXCJ5XCI6IDMxOTIuMDc4ODkzODg1MjA0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkh1Z28gVGV0cm9kZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSHVnb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzMSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiTmV0aGVybGFuZHNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IdWdvX1RldHJvZGVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlRldHJvZGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5NzEuNzQ1NjY0MTc4MDM5NSxcbiAgICAgICAgXCJ5XCI6IDQ5NjguMzExNjE5MDQ0NzIxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEwNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkF1Z3VzdGluLUplYW4gRnJlc25lbFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc4OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQXVndXN0aW4tSmVhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTgyNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXVndXN0aW4tSmVhbl9GcmVzbmVsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGcmVzbmVsXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NzQxLjIxNTY2NjUwNTY0OCxcbiAgICAgICAgXCJ5XCI6IDM5MTAuMzM1NDc0NTY1MTk0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlbnJpIFBvaW5jYXLDqVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVucmlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbnJpX1BvaW5jYXLDqVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUG9pbmNhcsOpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzIwLjgxNzcwMzEyNjU4NSxcbiAgICAgICAgXCJ5XCI6IDM5NTcuNTA2MjI5MDY4MTExN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYW5pZWwgUXVpbGxlblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRGFuaWVsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDExLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFuaWVsX1F1aWxsZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlF1aWxsZW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUzMDMuMjc1MTY0NDM2Njc0NSxcbiAgICAgICAgXCJ5XCI6IDM3OTkuNDYyODYxODc3MjQ4NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkJlbm/DrnQgQ2xhcGV5cm9uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzk5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJCZW5vw650XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODY0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZW5vw650X1BhdWxfw4ltaWxlX0NsYXBleXJvblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2xhcGV5cm9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzY4LjYwMTQ3MjM5NTgxMzMsXG4gICAgICAgIFwieVwiOiAzMTE4LjM2NDE2MjUzNzg1OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJJcnZpbmcgS2FwbGFuc2t5XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJJcnZpbmdcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkNhbmFkYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lydmluZ19LYXBsYW5za3lcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkthcGxhbnNreVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjE0MS4xMjk3MDgzMTgwNTcsXG4gICAgICAgIFwieVwiOiAzMzM5LjQwODg2NjU1MTk4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM2OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkx1IFNoYW1cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkx1XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSG9uZyBLb25nXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdV9KZXVfU2hhbVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2hhbVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTQ2My4wMjEzMzYxMzY1NzA3LFxuICAgICAgICBcInlcIjogMzgzMS4xMDgxODU1MDk3ODY0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQxMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBpZXRlciB2YW4gQWxwaGVuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGlldGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJhY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwidmFuIEFscGhlblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzI0NC42ODMwNTA0Mzk4ODk1LFxuICAgICAgICBcInlcIjogMzYzOC4xOTczMjkzNzA2NzVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzU2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWFyaW8gU2Now7ZuYmVyZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWFyaW9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkJyYXppbFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL03DoXJpb19TY2hlbmJlcmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNjaMO2bmJlcmdcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0MzkuMTM0MTA3NTIwMzg4LFxuICAgICAgICBcInlcIjogNDM2Ny40NDgwMTg4NjI3MjhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzAwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRG9uIFBhZ2VcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRvblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQYWdlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NDM3Ljg2NTQwNzYyNjYyMSxcbiAgICAgICAgXCJ5XCI6IDQ0MjYuNTk5ODA4NDYyNjAzNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkZlbGljZSBDYXNvcmF0aVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgzNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRmVsaWNlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODkwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZlbGljZV9DYXNvcmF0aV8obWF0aGVtYXRpY2lhbilcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNhc29yYXRpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTMxLjExNjQyODM3NzQ3MzMsXG4gICAgICAgIFwieVwiOiAzNDM4LjA5NTU0MDQ1NTU2OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkF1Z3VzdCBCZWVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODI1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBdWd1c3RcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4NjMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BdWd1c3RfQmVlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmVlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTM0MC42NTYzMjc3NDEwMDQsXG4gICAgICAgIFwieVwiOiA0Mzk3LjYxOTI5ODU2MjI4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjY5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR3VzdGF2IGRlIFZyaWVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODY2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHdXN0YXZcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MzQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3VzdGF2X2RlX1ZyaWVzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJkZSBWcmllc1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTk2MS41Mzg0NzYxMzM4NTU1LFxuICAgICAgICBcInlcIjogNDAxMS42NzI0MzkxMjIzOTNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTcxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2FtaWxsZSBKb3JkYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhbWlsbGVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MjIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWlsbGVfSm9yZGFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJKb3JkYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0MDUuMDA5MDk2NzU4MjYyMyxcbiAgICAgICAgXCJ5XCI6IDM3ODcuMDIwOTQ1ODE0NjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUmF5bW9uZCBQYWxleVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUmF5bW9uZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzMyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JheW1vbmRfUGFsZXlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBhbGV5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNjk0LjMwMjAzOTIxNTQzNixcbiAgICAgICAgXCJ5XCI6IDQzNDAuNDcyNjQ0MzM5OTE2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjg1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGF2aWQgRW5za29nXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEYXZpZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dlZGVuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF2aWRfRW5za29nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJFbnNrb2dcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDYxNjkuNzQ5MjMxODA4Mzg3LFxuICAgICAgICBcInlcIjogMzgzNi45ODAwNjkyODk4MDNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTE5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSsO4cmdlbiBHcmFtXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODUwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKw7hyZ2VuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTE2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJEZW5tYXJrXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSsO4cmdlbl9QZWRlcnNlbl9HcmFtXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHcmFtXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTc3LjAwNDAzNjA4ODc5MixcbiAgICAgICAgXCJ5XCI6IDM5MTIuNDExMDI0MjkzODI4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTm9ybWFuIENhcm5haGFuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTQyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJOb3JtYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFuX0YuX0Nhcm5haGFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDYXJuYWhhblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNjExMC42ODc0MTU3MTIyOTMsXG4gICAgICAgIFwieVwiOiAzMTc0LjYzOTU4NzYxMDg0NTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDA2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQXhlbCBUaHVlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODYzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBeGVsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTIyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOb3J3YXlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BeGVsX1RodWVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlRodWVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyNzMuODM1NjU5NzQ5MjU0MyxcbiAgICAgICAgXCJ5XCI6IDQwNTYuOTg2NTM1NjQ0NzE2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIxNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkxldiBMYW5kYXVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxldlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU292aWV0IFVuaW9uXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV2X0xhbmRhdVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFuZGF1XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MTkxLjkzNjY1NTc0NjA0OSxcbiAgICAgICAgXCJ5XCI6IDM3MDguNDg4MTQ5OTU1MDY0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEyNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNhcmwgR3V0bWFublwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhcmxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHdXRtYW5uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNzMxLjIxNDY1NjUxMjMyMzIsXG4gICAgICAgIFwieVwiOiAzNzQxLjA3MTE3NzE3OTUzODZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTA4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTXVycmF5IEdlbGwtTWFublwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTXVycmF5XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXVycmF5X0dlbGwtTWFublwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR2VsbC1NYW5uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MjUwLjk5MjE1MzA4MTk2MSxcbiAgICAgICAgXCJ5XCI6IDI3MTUuNjg4Mjk2MzAzOTcxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQ0MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkp1bGl1cyBXb2xmZlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSnVsaXVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOZXRoZXJsYW5kc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0p1bGl1c19Xb2xmZl8obWF0aGVtYXRpY2lhbilcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldvbGZmXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MDUxLjU0NDk4MzAzNDgwNixcbiAgICAgICAgXCJ5XCI6IDM2MzAuMjQzNzAxNjY3NTIxMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJUaG9tYXMgWW91bmdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE3NzMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRob21hc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTgyOSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Rob21hc19Zb3VuZ18oc2NpZW50aXN0KVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiWW91bmdcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3ODEuMDQzMDM0MTU3OTIxMyxcbiAgICAgICAgXCJ5XCI6IDMxMDIuNDE5Njg4MDYxNDU5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlcmJlcnQgU3F1aXJlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJiZXJ0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTYxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVyYmVydF9TcXVpcmVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNxdWlyZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTI5My40MzU2MjUzMzMwNDMsXG4gICAgICAgIFwieVwiOiAzNzIyLjk2NTgzMzkzMDAwNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9mZnJleSBIb3Jyb2Nrc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkzMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR2VvZmZyZXlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9mZnJleV9Ib3Jyb2Nrc1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSG9ycm9ja3NcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2ODkuMDUzNTg5MDEyMjI1NSxcbiAgICAgICAgXCJ5XCI6IDM3NjMuNTA4OTk4MTAyMjE1NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZXJtYW4gV29sZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwOCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVybWFuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTkyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOb3J3YXlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZXJtYW5fV29sZFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiV29sZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDU4MC43MzI4NTc5MzY2NDgsXG4gICAgICAgIFwieVwiOiA0MzM5LjEyODM2ODg5NTYyM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUGhpbGlwIEFuZGVyc29uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQaGlsaXBcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMjAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaGlsaXBfVy5fQW5kZXJzb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkFuZGVyc29uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNzI1LjU3NzAzMzcxMTU1NTUsXG4gICAgICAgIFwieVwiOiAzMDYzLjQ2NDgyNjIyOTExMjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9yZ2UgQmF0Y2hlbG9yXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHZW9yZ2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkF1c3RyYWxpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZV9CYXRjaGVsb3JcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJhdGNoZWxvclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDI1NS45NTcxNTE5NDg5NzksXG4gICAgICAgIFwieVwiOiA0Mzg1LjI1NTk3MTkxMjYwNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBpZXJyZSBCb25uZXRcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MTksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBpZXJyZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg5MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGllcnJlX09zc2lhbl9Cb25uZXRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJvbm5ldFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDE3Mi45NDQ0NzM3OTE4MTc1LFxuICAgICAgICBcInlcIjogMzQ5My45Nzc5NDg3ODgzOTlcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTI0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSGFucyBHcmltbVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGFuc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZGUuenhjLndpa2kvd2lraS9IYW5zX0cuX0dyaW1tXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHcmltbVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDQ1OC4zMzUyNjMzNTkyMDgsXG4gICAgICAgIFwieVwiOiAzNzI2LjAxNzgzODM1MDk4NDdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjYxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRSBNZXNoa292XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiRVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1lc2hrb3ZcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIwODkuNjk1NzYwODE1NTI5NCxcbiAgICAgICAgXCJ5XCI6IDM2MDEuNjI0NjAwOTQ4ODQ4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkZyaXR6IFBldGVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODk5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcml0elwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZyaXR6X1BldGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQZXRlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTY0OC40OTIyNzQ4NDQ1NTQyLFxuICAgICAgICBcInlcIjogMjk5OS4zODc2MjQxMzY2NzhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTQ0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQ2hhcmxlcyBIZXJtaXRlXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODIyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJDaGFybGVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTAxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFybGVzX0hlcm1pdGVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhlcm1pdGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5MzkuNDE1NTExMDkwOTcyLFxuICAgICAgICBcInlcIjogMzU3OC4yNDU2MDQ1MzUyMzgzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI3M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk90dGF2aWFuby1GYWJyaXppbyBNb3Nzb3R0aVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc5MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiT3R0YXZpYW5vLUZhYnJpemlvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODYzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJpdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL090dGF2aWFuby1GYWJyaXppb19Nb3Nzb3R0aVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTW9zc290dGlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM4MTQuNzc2NTMwMTE4MzYyLFxuICAgICAgICBcInlcIjogMzEyNy42NzAyMDcxNjE1Mjk2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI1N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhqYWxtYXIgTWVsbGluXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIamFsbWFyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTMzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGaW5sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGphbG1hcl9NZWxsaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1lbGxpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTkwOS43MzE1NzUxNzE5MTksXG4gICAgICAgIFwieVwiOiAzNDcxLjQzOTk1ODA2NTI5OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNaWtpbyBTYXRvXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTI4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNaWtpb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkphcGFuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NaWtpb19TYXRvXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTYXRvXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NDA5LjIzNjU0Mzg1MDUyOSxcbiAgICAgICAgXCJ5XCI6IDM5NDkuNDE5MzQ4MzE2MTI0M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXYWx0aGVyIEtvc3NlbFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2FsdGhlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhbHRoZXJfS29zc2VsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb3NzZWxcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0MDAuMjg1MzUyNjU3NjksXG4gICAgICAgIFwieVwiOiAzNzIxLjIzMTA4NjU3MTY5MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyOTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJLYXp1aGlrbyBOaXNoaWppbWFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkthenVoaWtvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJKYXBhblwiLFxuICAgICAgICBcInJhY2VcIjogXCJFYXN0IEFzaWFuXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2F6dWhpa29fTmlzaGlqaW1hXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJOaXNoaWppbWFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUzMDYuOTU5MjU3MDEyMDA1LFxuICAgICAgICBcInlcIjogMjcxMy4yMDI4MDAwNzkyMzQzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSmVhbi1CYXB0aXN0ZSBCaW90XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzc0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKZWFuLUJhcHRpc3RlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODYyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0plYW4tQmFwdGlzdGVfQmlvdFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQmlvdFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTMwMC4wLFxuICAgICAgICBcInlcIjogMzg3NS44OTUyNjk4MjE2OTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQaWVycmUgRHVoZW1cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBpZXJyZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkxNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGF1bF9EcnVkZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRHVoZW1cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2NjUuOTgzOTA2NTI5OTU1LFxuICAgICAgICBcInlcIjogMzE0NC40MzA4Mjc0MjM4NDE1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdpb3Zhbm5pIFBsYW5hXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzgxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHaW92YW5uaVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg2NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXRhbHlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HaW92YW5uaV9BbnRvbmlvX0FtZWRlb19QbGFuYVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGxhbmFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0OTAuNjY4NTUyNDM5ODY0NSxcbiAgICAgICAgXCJ5XCI6IDMzMTcuODcwNjIxODI1MjE3OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXYWx0aGVyIFJpdHpcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldhbHRoZXJcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3aXR6ZXJsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2FsdGhlcl9SaXR6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSaXR6XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0ODg2LjE5NDEwMTkyNTE2OCxcbiAgICAgICAgXCJ5XCI6IDMxNzEuMjI1NTI0NzgyOTY2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE4N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN0ZXBoZW4gS2xlZW5lXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTdGVwaGVuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTk0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RlcGhlbl9Db2xlX0tsZWVuZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS2xlZW5lXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNjA0Ljg4MzM3MTAwMDcwNDMsXG4gICAgICAgIFwieVwiOiAzODU5LjUzNDAyOTQ0MzQ1OTVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjEzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9oYW5uIExhbWJlcnRcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE3MjgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaGFublwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTc3NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dpdHplcmxhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2hhbm5fSGVpbnJpY2hfTGFtYmVydFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGFtYmVydFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTI4Mi4wMzMxMjYyODI1MixcbiAgICAgICAgXCJ5XCI6IDQzNTguODk4NTg5NzkyNDM3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNyaW5pdmFzYSBSYW1hbnVqYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlNyaW5pdmFzYVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkyMCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSW5kaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwiU291dGggQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcmluaXZhc2FfUmFtYW51amFuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSYW1hbnVqYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5NjUuNzc1NDQ1NzU3MzY5LFxuICAgICAgICBcInlcIjogNDI3NS4wNjQ4NDAzNzgxMDNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzk4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQW5kcmVpIFN1c2xpblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk1MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQW5kcmVpXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbmRyZWlfU3VzbGluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdXNsaW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUzOTcuODY1NjA3MjAxNDksXG4gICAgICAgIFwieVwiOiAzNzcyLjUzNzEyNzY1Nzc1ODRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkh5bWFuIEJhc3NcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkh5bWFuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0h5bWFuX0Jhc3NcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJhc3NcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUxNjUuMDMzMjU0MTIzODkzLFxuICAgICAgICBcInlcIjogMzg0My41MzA0MzE5OTc0NTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzQ0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVmVyYSBSdWJpblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyOCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiVmVyYVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlcmFfUnViaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlJ1YmluXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwiZmVtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1NjguMjQ4MzEyNDgwNjUsXG4gICAgICAgIFwieVwiOiAyNjAwLjQyNjIyMDY0OTQyMjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTg5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiT3NrYXIgS2xlaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk9za2FyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2VkZW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Pc2thcl9LbGVpblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS2xlaW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE5NzMuODI0MzYwODA3OTczOCxcbiAgICAgICAgXCJ5XCI6IDQxNTYuMjcyNTA1MTc3OTkzNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYXZpZCBSdWVsbGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQmVsZ2l1bVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdmlkX1J1ZWxsZSNTZWVfYWxzb1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUnVlbGxlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNzA4LjM4NDkxNzU4OTIwMSxcbiAgICAgICAgXCJ5XCI6IDM1MDUuMzU0MzUyNzI1NjY0N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMjdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTb3BodXMgTGllXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODQyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTb3BodXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5vcndheVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvcGh1c19MaWVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxpZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjI3Mi45MTk4ODk1Nzk3OTE3LFxuICAgICAgICBcInlcIjogNDE5My4zNDIxODk3MDM3MDFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjk0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQSBPa3Vib1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJPa3Vib1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzY4OS44NDIyMzQ0Nzg2ODQsXG4gICAgICAgIFwieVwiOiA1MDAwLjBcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTA5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2FsdGhlciBHZXJsYWNoXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXYWx0aGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2FsdGhlcl9HZXJsYWNoXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHZXJsYWNoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1NTI1LjI2MTIxMjQwNjQ3MixcbiAgICAgICAgXCJ5XCI6IDQxOTIuNDQ1NTEwMTg0MzYyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlN0YW5pc8WCYXcgVWxhbVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU3RhbmlzxYJhd1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUG9sYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RhbmlzbGF3X1VsYW1cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlVsYW1cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU2OTguMzgzMzg2NjkwNDIsXG4gICAgICAgIFwieVwiOiA0MzYyLjcxMTQ5MDczMzgzNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDaHJpc3RpYWFuIEh1eWdlbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE2MjksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNocmlzdGlhYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE2OTUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hyaXN0aWFhbl9IdXlnZW5zXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJIdXlnZW5zXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NjMzLjM1ODgyNTgxMTUxMixcbiAgICAgICAgXCJ5XCI6IDM4NDIuOTgwNTU1Nzc5MjcxNVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDbGFyZW5jZSBaZW5lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ2xhcmVuY2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DbGFyZW5jZV9aZW5lclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiWmVuZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ5NzkuMjE1MDc1OTIwOTAzNSxcbiAgICAgICAgXCJ5XCI6IDM2OTcuODQ2NDM3MzY2MTgyN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNDlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDYXJsbyBNYXJhbmdvbmlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NDAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhcmxvXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTI1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhcmxvX01hcmFuZ29uaVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWFyYW5nb25pXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNTg3LjgzMTQxNzMwNTAwMSxcbiAgICAgICAgXCJ5XCI6IDMwNjQuNzY5NDY1NzgyMjY1M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2huIFN0YWxsaW5nc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkzNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwOCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvaG5fUi5fU3RhbGxpbmdzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdGFsbGluZ3NcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ1NTkuNTc3NzU0NjQ3MjQyLFxuICAgICAgICBcInlcIjogMzg2MC4yOTg3NzYyNTYwMTVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzk1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiU3RldmVuIFN0cm9nYXR6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTU5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTdGV2ZW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RldmVuX1N0cm9nYXR6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdHJvZ2F0elwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzY0OS45MDM1NzgzNjQyODQsXG4gICAgICAgIFwieVwiOiAyOTI2LjI4MDgyMDM0Mzg5MDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzcyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTGV2IFNodWJuaWtvdlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTGV2XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJSdXNzaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZfU2h1Ym5pa292XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTaHVibmlrb3ZcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMyNDUuNzYyMzA1Mzc2NTk2NSxcbiAgICAgICAgXCJ5XCI6IDM2NTkuMjQwOTI5ODU2MzM2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFsZnJlZCBMb3RrYVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWxmcmVkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJBdXN0cmlhLUh1bmdhcnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWR2aWdfTG9yZW56XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMb3RrYVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzQ3OC4wMzU3MDYzMTA2MDYsXG4gICAgICAgIFwieVwiOiAzODUwLjk1MzI3NTAxMjU1OVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MDFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJOaWNjb2zDsiBUYXJ0YWdsaWFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE1MDAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk5pY2NvbMOyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxNTU3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05pY2NvbMOyX0ZvbnRhbmFfVGFydGFnbGlhXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJUYXJ0YWdsaWFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1NTUuNjA4OTU1MjA1MTQ4NSxcbiAgICAgICAgXCJ5XCI6IDQ5MTQuMzk3NzY2ODQ0ODQ4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjg4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVGhvbWFzIEZhcnJlbGxcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5NDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRob21hc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GLl9UaG9tYXNfRmFycmVsbFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRmFycmVsbFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTQzNC40MzA5MDY0ODgwNDgsXG4gICAgICAgIFwieVwiOiA0MDAxLjUyNTYwNDg4ODIwNDNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjA5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWFzYXRha2UgS3VyYW5pc2hpXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTI0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNYXNhdGFrZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkphcGFuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXNhdGFrZV9LdXJhbmlzaGlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkt1cmFuaXNoaVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzUyNC4wOTY1OTc3MjQ5NTAyLFxuICAgICAgICBcInlcIjogMzY4NS4yMTQyMjA5Mjk0Mjk4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIzNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvaG4gTGl0dGxld29vZFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvaG5fRWRlbnNvcl9MaXR0bGV3b29kXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMaXR0bGV3b29kXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzkyLjU0MDU0MTYwNDQ1NzgsXG4gICAgICAgIFwieVwiOiA0Mzc1LjE1OTU4ODQyMzI5NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMjBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIZXJtYW5uIEdyYXNzbWFublwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgwOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVybWFublwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg3NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcm1hbm5fR3Jhc3NtYW5uXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJHcmFzc21hbm5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQzNjUuNTE3NzQ3ODA3NDkxLFxuICAgICAgICBcInlcIjogMzE2MC44MzQwNDAwMTYyMzA2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkxhdXJlbnQgUG90aGVub3RcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE2NTAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxhdXJlbnRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE3MzIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZnIud2lraXBlZGlhLm9yZy93aWtpL0xhdXJlbnRfUG90aGVub3RcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBvdGhlbm90XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxMzg3Ljk3MTAwNDAwOTYyMyxcbiAgICAgICAgXCJ5XCI6IDMzMzUuODYwMTQ1NzYyODkzNFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNjBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYXZpZCBNZXJtaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL04uX0RhdmlkX01lcm1pblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWVybWluXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MjgyLjEwMTc3MzA0ODQyOSxcbiAgICAgICAgXCJ5XCI6IDQ5MjMuMDE1MzM4ODYxMDQzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI5N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJvYmVydCBPcHBlbmhlaW1lclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUm9iZXJ0XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSi5fUm9iZXJ0X09wcGVuaGVpbWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJPcHBlbmhlaW1lclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzI2Mi45MzI4MjE0MzgxNTEsXG4gICAgICAgIFwieVwiOiAzNDE1LjEyNDc1MTE1NTI2NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk5pZWxzIEJvaHJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk5pZWxzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTYyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJEZW5tYXJrXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmllbHNfQm9oclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQm9oclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDQ2OC42NzUzMDYwMzE0ODgsXG4gICAgICAgIFwieVwiOiAyNTI3LjE4ODcwMDU4MjgzN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSWFjb3BvIEJhcnNvdHRpXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTIxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJJYWNvcG9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkl0YWx5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWFjb3BvX0JhcnNvdHRpXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCYXJzb3R0aVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTMzOC42NDgxMzQyOTA4ODMsXG4gICAgICAgIFwieVwiOiA0MDA0LjM3MjAzNDczMTEwMVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdlcm9sYW1vIENhcmRhbm9cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE1MDEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdlcm9sYW1vXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxNTc2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJdGFseVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlcm9sYW1vX0NhcmRhbm9cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNhcmRhbm9cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM1NjkuMjc2NDE2MTE1NTM0LFxuICAgICAgICBcInlcIjogNDg4OS41MjM5MjkyMTExODRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiODNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSb2JlcnQgRW1kZW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJvYmVydFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dpdHplcmxhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2JlcnRfRW1kZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkVtZGVuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NDU1LjA1MTU3NTc5OTU1MSxcbiAgICAgICAgXCJ5XCI6IDQzOTkuMTM0MDQ2MzU4MjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTkwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWFydGluIEtudWRzZW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1hcnRpblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRGVubWFya1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcnRpbl9LbnVkc2VuXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLbnVkc2VuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MDY0Ljc5NTczNzUyNDM3NTUsXG4gICAgICAgIFwieVwiOiAyOTc5LjczMzQwMjg4NDQ1NTJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjAxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR2VvcmdlIEtvc3RlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR2VvcmdlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDEyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/Y2xpZW50PXNhZmFyaSZybHM9ZW4mcT1nZW9yZ2UrZnJlZCtrb3N0ZXImaWU9VVRGLTgmb2U9VVRGLThcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktvc3RlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzQyMS4yOTM0NDczMzA5MzgzLFxuICAgICAgICBcInlcIjogMzA4NS45MTQwNjUxOTIwNDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiOTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSYWxwaCBGb3dsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJhbHBoXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFscGhfSC5fRm93bGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGb3dsZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ2ODYuMzEwOTY0MTY4MjkzLFxuICAgICAgICBcInlcIjogMjc4OS4xODI5Nzc3NTIxMzRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTIxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWxiZXJ0IEdyZWVuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTEyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBbGJlcnRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbGJlcnRfRS5fR3JlZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkdyZWVuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NTU4LjE0NzQ0MDkxNzI1OCxcbiAgICAgICAgXCJ5XCI6IDMwNTkuNzIzNDczNjA0NDI0M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCLDiW1pbGUgUGljYXJkXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCLDiW1pbGVcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NDEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL8OJbWlsZV9QaWNhcmRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBpY2FyZFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU3Ny40NTQyMjc5MjQwNSxcbiAgICAgICAgXCJ5XCI6IDM0NzAuMTI1NTAxNjY5MzEwM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxsaWFtIE11bGxpbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGxpYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsaWFtX1cuX011bGxpbnNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk11bGxpbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0ODcuNTQ4OTY5NzI4OTI3NyxcbiAgICAgICAgXCJ5XCI6IDM0ODAuODE4Mzk5OTMxMTQ3N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvaG4gQmVybmFsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb2huXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJcmVsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSi5fRC5fQmVybmFsXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJCZXJuYWxcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ3MjIuNDEzMTMyMzAzNjg0LFxuICAgICAgICBcInlcIjogMjc1MC4zNTgyNTk4NTUwNDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzg2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9zZWYgU3RlZmFuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODM1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb3NlZlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg5MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvc2VmX1N0ZWZhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU3RlZmFuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MTM0LjA3NzkxNTU1MjI1NyxcbiAgICAgICAgXCJ5XCI6IDQ1NTUuMzY0OTMxNTA3MzI2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQzM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVkbXVuZCBXaGl0dGFrZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkVkbXVuZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk1NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0UuX1QuX1doaXR0YWtlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiV2hpdHRha2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyNjk1LjY1NjYwOTMxMzIxNyxcbiAgICAgICAgXCJ5XCI6IDQxNzAuMDgwNjI5NzY2Njc1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBQbGF0ZWF1XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODAxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb3NlcGhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4ODMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkJlbGdpdW1cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb3NlcGhfUGxhdGVhdVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGxhdGVhdVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDkyOC41NDY0Nzg3MjM0NjMsXG4gICAgICAgIFwieVwiOiAzMTc0LjAxMjIxMzU5NzExMjNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzU3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRnJpZWRyaWNoIFNjaG90dGt5XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODUxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJGcmllZHJpY2hcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmllZHJpY2hfU2Nob3R0a3lcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlNjaG90dGt5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MjQyLjIxMzE4MzU5NDg3NSxcbiAgICAgICAgXCJ5XCI6IDMwOTAuOTcxMzcxNjg1MTEzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMzNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvaG4gUmVobmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlJlaG5lclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTAyOS4wNjI3MTQ5NDkwMjMsXG4gICAgICAgIFwieVwiOiAyOTI5LjIzMDc5NDk4MDY3NjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDAzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiR2VvZmZyZXkgVGF5bG9yXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHZW9mZnJleVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0cuX0kuX1RheWxvclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiVGF5bG9yXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NjI1LjEwNzA5MzUwOTE3MixcbiAgICAgICAgXCJ5XCI6IDMxMDUuMDU1OTU4NjM2MTI5NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNzRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCLDiW1pbGUgSm91Z3VldFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg3MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiw4ltaWxlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS/DiW1pbGVfSm91Z3VldFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSm91Z3VldFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjQyMS4wMDc0NjkxOTE4OTgsXG4gICAgICAgIFwieVwiOiA0NjEyLjk5MjczMjEzMTc4MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQLiBQb3BwZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQLlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBvcHBlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDk3Ny41OTQ1MDA2NTI5MjIsXG4gICAgICAgIFwieVwiOiA0NzIzLjUzMTE2MTQ1NjYzMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDaHJpc3RpYW4gTcO4bGxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ2hyaXN0aWFuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTgwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJEZW5tYXJrXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hyaXN0aWFuX03DuGxsZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk3DuGxsZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUwNTQuNzEyMDEyODIyNzE0LFxuICAgICAgICBcInlcIjogMzEwMy40Mzg3NjY2MTk2MTQ0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk1pbHRvbiBQbGVzc2V0XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTA4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJNaWx0b25cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NaWx0b25fUy5fUGxlc3NldFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUGxlc3NldFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDk1Mi43NzcwNjM0NDQzODYsXG4gICAgICAgIFwieVwiOiAzMTM5LjQ2MTU5NTUxNTE1NzZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTIzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTWVsdmlsbGUgR3JlZW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1lbHZpbGxlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVsdmlsbGVfUy5fR3JlZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkdyZWVuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxOTY1LjUwOTU1MDYwNjE0NjYsXG4gICAgICAgIFwieVwiOiAyOTQyLjg1MzIyMDIwMDI4MjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzA1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGlhbSBQZW5uZXlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGxpYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsaWFtX1Blbm5leSxfQmFyb25fUGVubmV5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQZW5uZXlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI3MjQuOTQ3MzQzMDE2MzY3LFxuICAgICAgICBcInlcIjogMzE4Ni43Mjc0MzIwNTA5MDk2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI2OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdlb3JnIE1vaHJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE2NDAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdlb3JnXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxNjk3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJEZW5tYXJrXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvcmdfTW9oclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTW9oclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM3Ni45MjYwODI1NzQzNjcsXG4gICAgICAgIFwieVwiOiAzOTAyLjkyOTU3MDcxMzUwNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHcmVnb3J5IFdhbm5pZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdyZWdvcnlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3aXR6ZXJsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JlZ29yeV9XYW5uaWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJXYW5uaWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyOTIyLjEwMDAxODE0MTk2NixcbiAgICAgICAgXCJ5XCI6IDMwNDAuMzkzODg5NTQyMTQ0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTHVpdHplbiBCcm91d2VyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMdWl0emVuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOZXRoZXJsYW5kc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0wuX0UuX0ouX0Jyb3V3ZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJyb3V3ZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI1NTYuNzA1NjYwMzc5Mjc0NCxcbiAgICAgICAgXCJ5XCI6IDM3NjguNTA1NTI2NTY3Njk4M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxOTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJUYXRpYW5hIEtvbnRvcm92YVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRhdGlhbmFcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJSdXNzaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb250b3JvdmFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJmZW1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTk3OC4yODgyMDExNzEzNSxcbiAgICAgICAgXCJ5XCI6IDM2OTYuMjk3MzUxMzQ3OTIyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIzM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBMaW91dmlsbGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MDksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvc2VwaFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg4MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9zZXBoX0xpb3V2aWxsZVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGlvdXZpbGxlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzA5LjQ5MjIyMjc2MzY1OCxcbiAgICAgICAgXCJ5XCI6IDM2MDguNjU2NDc3MTY2NzM2M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxOTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbmRyZXkgS29sbW9nb3JvdlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQW5kcmV5XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbmRyZXlfS29sbW9nb3JvdlwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS29sbW9nb3JvdlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzgxMi4wMDg1NDA4OTcwNzUsXG4gICAgICAgIFwieVwiOiA0MjkyLjI3OTkzNDA4MjcyMDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjYyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTmljaG9sYXMgTWV0cm9wb2xpc1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTmljaG9sYXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdyZWVjZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05pY2hvbGFzX01ldHJvcG9saXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1ldHJvcG9saXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIwNzkuMDQ1MjI3NDgzMzUxNSxcbiAgICAgICAgXCJ5XCI6IDQzNTkuMTMyNDQwMjM5ODE2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkplYW4tVmljdG9yIFBvbmNlbGV0XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzg4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKZWFuLVZpY3RvclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg2NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVhbi1WaWN0b3JfUG9uY2VsZXRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBvbmNlbGV0XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NTU4LjUyMzk2OTk4MTA3NCxcbiAgICAgICAgXCJ5XCI6IDM4MDcuOTA3MTQ2ODk4NTE2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFsYW4gVHVyaW5nXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTEyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBbGFuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWxhbl9UdXJpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlR1cmluZ1wiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjY3NS43MTY1NzMzMjI5MDY3LFxuICAgICAgICBcInlcIjogMzk3Mi4wNTg5ODQyMzc5MjcyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkx1ZHdpZyBQcmFuZHRsXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMdWR3aWdcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWR3aWdfUHJhbmR0bFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUHJhbmR0bFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDE0OS41ODcxNTc2NjI2NTgsXG4gICAgICAgIFwieVwiOiA0NDA1LjYxMTM3ODI0NjgxN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxoZWxtIEt1dHRhXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODY3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXaWxoZWxtXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJQb2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXJ0aW5fS3V0dGFcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkt1dHRhXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMTY0LjA4MTY1NzYxMTE4OTMsXG4gICAgICAgIFwieVwiOiA0ODgzLjM3Njk1MjQzNjgyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk90dG8gSMO2bGRlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiT3R0b1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL090dG9fSMO2bGRlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSMO2bGRlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjI5My42NjA4MzEyMTc5MjE0LFxuICAgICAgICBcInlcIjogMzgwMS44Mzk5MDQzNjgyNjY2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIzOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlbmRyaWsgTG9yZW50elwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1MyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGVuZHJpa1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkyOCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiTmV0aGVybGFuZHNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZW5kcmlrX0xvcmVudHpcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxvcmVudHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ2OTIuNjYxNjU2NDE4Njg5LFxuICAgICAgICBcInlcIjogMzM1MC45MjY4Nzg1ODAyMDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbGZyZWQgQ2xlYnNjaFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgzMyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWxmcmVkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODcyLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2xlYnNjaOKAk0dvcmRhbl9jb2VmZmljaWVudHNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNsZWJzY2hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU4MjkuMjUyMTI1NjUzNTIzLFxuICAgICAgICBcInlcIjogMzg1Ni43NjEyNzIwNDMyMTdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHZW9yZ2VzIERhcnJpZXVzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkdlb3JnZXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb3JnZXNfSmVhbl9NYXJpZV9EYXJyaWV1c1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGFycmlldXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUzMTIuOTEwNDU2MTk0OTM3LFxuICAgICAgICBcInlcIjogMzcwOS40OTY2NTY5MzU4NjRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTkxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSmFtZXMgS29laGxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmFtZXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDYsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KYW1lc19TdGFya19Lb2VobGVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb2VobGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2MTkwLjMxNDQzNjE2NzYzOSxcbiAgICAgICAgXCJ5XCI6IDM3ODIuMzY2MTI3MzczMDMxM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI5MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJpY2hhcmQgRmV5bm1hblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxOCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUmljaGFyZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpY2hhcmRfRmV5bm1hblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRmV5bm1hblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjMwMS40ODA1MzcwOTkwODQ0LFxuICAgICAgICBcInlcIjogMzEzNS41OTk0NzYzNzk4OThcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKZWFuIGTigJlBbGVtYmVydFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTcxNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmVhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTc4MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVhbl9sZV9Sb25kX2QlMjdBbGVtYmVydFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiZOKAmUFsZW1iZXJ0XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDg1LjIwNTEzMjYzODg2MzIsXG4gICAgICAgIFwieVwiOiAzODE5LjYxMzQ5MjI2MzE0MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSYWxwaCBLcm9uaWdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJhbHBoXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTk1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFscGhfS3JvbmlnXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLcm9uaWdcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI3NzQuOTU0MTA2MDg3MjksXG4gICAgICAgIFwieVwiOiAzMTUzLjc3MDk1MzA4OTU0ODZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjQ0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWxla3NhbmRyIEx5YXB1bm92XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODU3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBbGVrc2FuZHJcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MTgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlJ1c3NpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FsZWtzYW5kcl9MeWFwdW5vdlwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTHlhcHVub3ZcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQwMTMuODA4MzczNDY0OTY2NyxcbiAgICAgICAgXCJ5XCI6IDM4NzkuNTE0NDY3ODcwMzAxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMyN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhhbnMtSm9hY2hpbSBRdWVpc3NlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkzMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGFucy1Kb2FjaGltXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbnMtSm9hY2hpbV9RdWVpc3NlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUXVlaXNzZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDE3MTkuMTkyMTc3NzA3MTU4OSxcbiAgICAgICAgXCJ5XCI6IDMzMzcuMTcyMzcwMTU2MTA0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBpZXJyZSBIb2hlbmJlcmdcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBpZXJyZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGllcnJlX0hvaGVuYmVyZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSG9oZW5iZXJnXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNDc3LjgzOTM0NzI0MzQzNCxcbiAgICAgICAgXCJ5XCI6IDM4NzguOTIxNTIzNTM5MjczXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjEyMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkdlb3JnZSBHcmVlblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc5MyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiR2VvcmdlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODQxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvcmdlX0dyZWVuXyhtYXRoZW1hdGljaWFuKVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiR3JlZW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2MjguOTgwNzU1MTI0OTk5LFxuICAgICAgICBcInlcIjogMzU4Ny44MjY2MzAzOTA2MDRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJEYXZpZCBDb3hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdmlkX0NveF8oc3RhdGlzdGljaWFuKVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ294XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTA0LjE1Mzc0MjQzMjg4NixcbiAgICAgICAgXCJ5XCI6IDQ1MzcuMTIyNjI3NDY1OTY5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE5OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRpZWRlcmlrIEtvcnRld2VnXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODQ4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJEaWVkZXJpa1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiTmV0aGVybGFuZHNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXJuYXJkX0tvb3BtYW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktvcnRld2VnXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1OTcxLjkzNTYyNTk1MTM0OSxcbiAgICAgICAgXCJ5XCI6IDQwMzQuNTQ0MzM3NzAxNzUxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQzNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkd1c3RhdiBXaWVkZW1hbm5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkd1c3RhdlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg5OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0d1c3Rhdl9IZWlucmljaF9XaWVkZW1hbm5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldpZWRlbWFublwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzc2NC42MTg3ODg4NDYxNTc3LFxuICAgICAgICBcInlcIjogMjUzOC42MjgxNDc3OTg2MDhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTczXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsaGVsbSBKb3JkYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NDIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGhlbG1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxoZWxtX0pvcmRhbl8oZ2VvZGVzaXN0KVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSm9yZGFuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTc5Ljk1NTA2OTUzNjgyLFxuICAgICAgICBcInlcIjogMzQ3Mi41NDgyNTE3Njc5OTA3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI1NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkphbWVzIE1heHdlbGxcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MzEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkphbWVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODc5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTY290bGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phbWVzX0NsZXJrX01heHdlbGxcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1heHdlbGxcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUxODAuNTY5MzI3NDU1NTY1LFxuICAgICAgICBcInlcIjogNDUyNC41Njk4MjMzMDQzNTRcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTg4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRmVsaXggS2xlaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NDksXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkZlbGl4XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTI1LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmVsaXhfS2xlaW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktsZWluXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MTkzLjc2MjgxMjkwMTE5NCxcbiAgICAgICAgXCJ5XCI6IDMwNzYuNzkxNTAxNzgyODg1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI3N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlRoZW9kb3JlIE1vdHpraW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlRoZW9kb3JlXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGhlb2RvcmVfTW90emtpblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTW90emtpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzE0Mi4wNTgzNjMyNzc1MjIsXG4gICAgICAgIFwieVwiOiAzOTI3Ljk4OTczNzI1NzI5MDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzYxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSGVybWFubiBTY2h3YXJ6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODQzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIZXJtYW5uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTIxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVybWFubl9TY2h3YXJ6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTY2h3YXJ6XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNTMyLjcwNDY0MjM3MTgzMjUsXG4gICAgICAgIFwieVwiOiAzNTY0LjU1OTA5MzU2Mjg5NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI5OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkpvc2VwaCBGb3VyaWVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzY4LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb3NlcGhcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4MzAsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvc2VwaF9Gb3VyaWVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJGb3VyaWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMjQxLjQwMDI1MzkwMjY5OCxcbiAgICAgICAgXCJ5XCI6IDM5MDIuMDk2Nzk5NjMxOTI2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM1NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkVyaGFyZCBTY2htaWR0XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFcmhhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcmhhcmRfU2NobWlkdCNTZWVfYWxzb1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2NobWlkdFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzg4NS45NDQyOTQyOTgzMzIsXG4gICAgICAgIFwieVwiOiAzODU5LjAxMDkwNDUzMDUxN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSdWRvbGYgTGlwc2NoaXR6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODMyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSdWRvbGZcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SdWRvbGZfTGlwc2NoaXR6XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMaXBzY2hpdHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0NTcuMzMwOTQ5OTM1MTM5LFxuICAgICAgICBcInlcIjogMzU1Mi4zNjg5MDY0MTMwNzY3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIwNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkxlb3BvbGQgS3JvbmVja2VyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODIzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMZW9wb2xkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODkxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGVvcG9sZF9Lcm9uZWNrZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktyb25lY2tlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTM3My42NzQzODYxMDgxNjcsXG4gICAgICAgIFwieVwiOiA0NzEyLjQ0OTYzNTM2Njk2NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJLZW5uZXRoIFN0YXJsaW5nXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTM1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJLZW5uZXRoXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE5LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9jZW4uYWNzLm9yZy9wZW9wbGUvb2JpdHVhcmllcy9PYml0dWFyeS1LZW5uZXRoLUUtU3RhcmxpbmcvOTgvaThcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN0YXJsaW5nXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2MTA3Ljg1NTUxMzM5NjI3LFxuICAgICAgICBcInlcIjogMzE5Ny4xNDAyMTIyMTU2MTk2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM3N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIk5pa29sYWkgU21pcm5vdlwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTmlrb2xhaVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmlrb2xhaV9TbWlybm92XyhtYXRoZW1hdGljaWFuKVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU21pcm5vdlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzc3OS4yNTc4ODIxODc1NjI3LFxuICAgICAgICBcInlcIjogNDI3OS4xNDM0NDUxODA5MjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDExXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSGVuZHJpa2EgdmFuIExlZXV3ZW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhlbmRyaWthXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOZXRoZXJsYW5kc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbmRyaWthX0pvaGFubmFfdmFuX0xlZXV3ZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcInZhbiBMZWV1d2VuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwiZmVtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ0MjQuMDkwMjAyNjkzMTYzNSxcbiAgICAgICAgXCJ5XCI6IDI1MjIuMjIyODkxOTgzMzE1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkxhcnMgUGhyYWdtw6luXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODYzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJMYXJzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2VkZW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXJzX0VkdmFyZF9QaHJhZ23DqW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBocmFnbcOpblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU3OS40NTUxNjY1OTk5MjIsXG4gICAgICAgIFwieVwiOiAzNjY3LjMxMzIxOTk2ODk0OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJISCBQb29sZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhIXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJhY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUG9vbGVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU5NjYuNzEzMDA2MzM2MDExLFxuICAgICAgICBcInlcIjogMzc0NS4yOTA0OTI1MzUwNTk1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM3MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldpbGxpYW0gU2hvY2tsZXlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGxpYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODksXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsaWFtX1Nob2NrbGV5XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTaG9ja2xleVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTc0MC42Njg2NDIyMTA3NTY2LFxuICAgICAgICBcInlcIjogMzMxNi41MDkyMDQ1Mjc0OTFcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzg0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9oYW5uZXMgU3RhcmtcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkpvaGFubmVzXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTU3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9oYW5uZXNfU3RhcmtcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN0YXJrXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNDUxLjc5Njc4MzI3NjI0NSxcbiAgICAgICAgXCJ5XCI6IDM2MjcuODMwMDc5MzQ4MDU0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjc2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVWxpc3NlIERpbmlcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NDUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlVsaXNzZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkxOCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXRhbHlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VbGlzc2VfRGluaSNTZWVfYWxzb1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRGluaVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzM5OC41NzkxNDczMDcyMzc3LFxuICAgICAgICBcInlcIjogMzUxMi4xNzMyNTQ3MTQzNjZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2huIEJ1dGxlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvaG5fQWxmcmVkX1ZhbGVudGluZV9CdXRsZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJ1dGxlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTQ3My4wMzUyMTk2ODA0NjIsXG4gICAgICAgIFwieVwiOiA0MjU5LjYxOTYxMTI4NzY3MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI1MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNhcmwgQ2hhcmxpZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkNhcmxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MzQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlN3ZWRlblwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhcmxfQ2hhcmxpZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkNoYXJsaWVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0MDM2Ljk0MzkxNTQxMjQ5MyxcbiAgICAgICAgXCJ5XCI6IDM5NTMuOTQ1MDkwMTc2NDMyNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJOaWtvbGFpIEx1emluXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODgzLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJOaWtvbGFpXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTUwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJSdXNzaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OaWtvbGFpX0x1emluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJMdXppblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTA3MC4wNTc4NjgwMjg5MzgsXG4gICAgICAgIFwieVwiOiAzNjAyLjY4MDE0ODkwMTE3ODdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzE4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiU2ltw6lvbiBQb2lzc29uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzgxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJTaW3DqW9uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODQwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJGcmFuY2VcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW3DqW9uX0RlbmlzX1BvaXNzb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBvaXNzb25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIxOTAuNjYzNzM3ODQwNjMzLFxuICAgICAgICBcInlcIjogNDIyMi44MTg5NDQ1NTQ2MTNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTk0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSnVyamVuIEtva3NtYVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSnVyamVuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOZXRoZXJsYW5kc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0p1cmplbl9GZXJkaW5hbmRfS29rc21hXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLb2tzbWFcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ3NjYuOTIzNzI3NTMzNzE0LFxuICAgICAgICBcInlcIjogMzYzMi44OTY3NDM5MzUxNTA0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE2N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkd3aWx5bSBKZW5raW5zXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHd2lseW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIldhbGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3dpbHltX0plbmtpbnNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkplbmtpbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQxNDkuMzQyNzU0NzQ3MTAxLFxuICAgICAgICBcInlcIjogNDY3NC45MjI4NTk5Nzc0NDE1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWhhcm9uIENhc2hlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTk0MSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQWhhcm9uXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDE4LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJQYWxlc3RpbmVcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL3BoeXNpY3MudGF1LmFjLmlsL2luX21lbW9yaWFtX2Nhc2hlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2FzaGVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMDk3LjIzNjc2NjUxOTkwNCxcbiAgICAgICAgXCJ5XCI6IDQzNjIuOTQxMjgyNDU0NDU0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjg3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTGVvbmhhcmQgRXVsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE3MDcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkxlb25oYXJkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxNzgzLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2l0emVybGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvYmVydF9FbWRlblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiRXVsZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0ODAuNjA5NjkwNjk3NDI4NSxcbiAgICAgICAgXCJ5XCI6IDM3NjcuNzIzMjUwOTQzNDA3NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMzJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJHb2RmcmV5IEhhcmR5XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODc3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJHb2RmcmV5XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTQ3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRy5fSC5fSGFyZHlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhhcmR5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzOTA1LjQ1MzI0MTgyNTE5OCxcbiAgICAgICAgXCJ5XCI6IDQzNTcuNTM3MTcxMjU4NjQ3NVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXZXJuZXIgSGVpc2VuYmVyZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkwMSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2VybmVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTc2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VybmVyX0hlaXNlbmJlcmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhlaXNlbmJlcmdcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI3MzUuNjA0NTEwNDM2OTUxNCxcbiAgICAgICAgXCJ5XCI6IDMwMzMuMTc2NTY4NTczMDU1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIwMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlNvZnlhIEtvdmFsZXZza2F5YVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU29meWFcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE4OTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlJ1c3NpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvZnlhX0tvdmFsZXZza2F5YVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiS292YWxldnNrYXlhXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwiZmVtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0NzguNTYyNzg3NDI2MzU3LFxuICAgICAgICBcInlcIjogMzU3NC43MDIxNDUzMzY5NTA3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIll1cmkgTWFuaW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIll1cmlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTb3ZpZXQgVW5pb25cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ZdXJpX01hbmluXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJNYW5pblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzg5My4xNTY5MjY5OTUwODcsXG4gICAgICAgIFwieVwiOiAzNjE4LjM0NzQ1OTkyNDQ3MDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTY5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSm9obiBKb2huc29uXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg3LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKb2huXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2VkZW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX0JlcnRyYW5kX0pvaG5zb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkpvaG5zb25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI4OTIuOTU4NjI4NTUzOTk3NixcbiAgICAgICAgXCJ5XCI6IDQxNTcuMDY0NjM1NTQ1NTI4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJpY2hhcmQgUGFsYWlzXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJSaWNoYXJkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpY2hhcmRfUGFsYWlzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQYWxhaXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIzMTkuNDc1MDg1ODQxOTYxNixcbiAgICAgICAgXCJ5XCI6IDQxMzIuMTAyMDc2NTc2NjI3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMxN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkplYW4gUG9pc2V1aWxsZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTc5NyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSmVhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg2OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmVhbl9Mw6lvbmFyZF9NYXJpZV9Qb2lzZXVpbGxlXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJQb2lzZXVpbGxlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMDAwLjg5ODY4MzY0NDc4MjMsXG4gICAgICAgIFwieVwiOiA0NDU1LjIxODg1NzQwMTI4MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJDaGVuLU5pbmcgWWFuZ1wiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyMixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQ2hlbi1OaW5nXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQ2hpbmFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwiRWFzdCBBc2lhblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1lhbmdfQ2hlbi1OaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJZYW5nXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MTc0LjczMTY2NjUxMDkzNyxcbiAgICAgICAgXCJ5XCI6IDM3NjYuNTY0ODg0MDUwMDMxN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxODBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbmRlcnMgS2FybGhlZGVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBbmRlcnNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJTd2VkZW5cIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLYXJsaGVkZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzU2MS41MzYyMzQxNjIzNjcyLFxuICAgICAgICBcInlcIjogMzcwMy4xNzY2NDE5MTIxNzZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjU1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTHVkd2lnIE1hdXJlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg1OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTHVkd2lnXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTI3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTHVkd2lnX01hdXJlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTWF1cmVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNjEyLjk3MTM5ODA2NzQ1ODMsXG4gICAgICAgIFwieVwiOiAzNzAwLjg3MTg1ODg2MjYxNlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNjBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYXVyaWNlIEh1Z2dpbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1hdXJpY2VcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXVyaWNlX0xveWFsX0h1Z2dpbnNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkh1Z2dpbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ5MTUuNzIxNDk3NDY1MjI3LFxuICAgICAgICBcInlcIjogMjg4OC40Nzc1MTk3MjEzNDhcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjg5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUGh5bGxpcyBOaWNvbHNvblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGh5bGxpc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BoeWxsaXNfTmljb2xzb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk5pY29sc29uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwiZmVtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI4OTkuMjMzNTk4MTUzMjU4LFxuICAgICAgICBcInlcIjogNDczMy41MTk0NDg5NTA3NjNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNDlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTeWRuZXkgQ2hhcG1hblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4OCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU3lkbmV5XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcwLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJFbmdsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3lkbmV5X0NoYXBtYW5fKG1hdGhlbWF0aWNpYW4pXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJDaGFwbWFuXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2MTgyLjY4ODI4NzY3NjAzNSxcbiAgICAgICAgXCJ5XCI6IDM4MDUuMzczNjQ0NDI2MjI0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjI5MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIllvc2hpbyBOaXNoaW5hXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODkwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJZb3NoaW9cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkphcGFuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIkVhc3QgQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Zb3NoaW9fTmlzaGluYVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTmlzaGluYVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTkwMS41NDU5Mzc0MTcyNTcsXG4gICAgICAgIFwieVwiOiA0MTc2LjQwOTc2NTM0MDkzMVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxMDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSaWNoYXJkIEdhbnNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJpY2hhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkdlcm1hbnlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SaWNoYXJkX0dhbnNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkdhbnNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQ5MDIuOTQ1NTQ0NzMyMjAyNSxcbiAgICAgICAgXCJ5XCI6IDMxNTQuNDY5OTQ3NjU5Nzk4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjk0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUGF1bCBGbG9yeVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxMCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUGF1bFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk4NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhdWxfRmxvcnlcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZsb3J5XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0OTYyLjY2Njc3NjY4MjU0MSxcbiAgICAgICAgXCJ5XCI6IDI5MTUuNTQwNjI2MTIyMDQyXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjIyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlZlbmlhbWluIExldmljaFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxNyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiVmVuaWFtaW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVrcmFpbmVcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZW5pYW1pbl9MZXZpY2hcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxldmljaFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTI0Ny43MDU2NjI5ODEyNjMsXG4gICAgICAgIFwieVwiOiAzNzMwLjkyMjAwNDQwMTM3MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0MjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXaWxoZWxtIFdlaW5iZXJnXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODYyLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJXaWxoZWxtXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2lsaGVsbV9XZWluYmVyZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiV2VpbmJlcmdcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM5MDkuNTk3NDg1ODUzNTIyLFxuICAgICAgICBcInlcIjogNDQxNi4xNDc1MzUxNTQ3MjlcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUnVkb2xwaCBGcmFuelwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgyNixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiUnVkb2xwaFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkwMixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1ZG9scGhfRnJhbnpcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZyYW56XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzU2LjIyMTQ1Nzk2MjQxMDYsXG4gICAgICAgIFwieVwiOiAyNTAwLjBcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTI4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRnJpdHogSGFiZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjgsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkZyaXR6XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTM0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJpdHpfSGFiZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhhYmVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzMjk1Ljc5Njg2NDIyNDQ4MyxcbiAgICAgICAgXCJ5XCI6IDMzNzMuNjgzOTM0Njg0NTM4NlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyNTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNYXVkIE1lbnRlblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg3OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTWF1ZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk2MCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQ2FuYWRhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF1ZF9NZW50ZW5cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIk1lbnRlblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcImZlbWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAxNjM4LjQyODEwMjE3MjUzMjYsXG4gICAgICAgIFwieVwiOiAzNzE1LjE4ODY3NDI1MDA1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjcwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUGV0ZXIgRGVieWVcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBldGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTY2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJOZXRoZXJsYW5kc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BldGVyX0RlYnllXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJEZWJ5ZVwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDI0Ni43ODUxOTA2MTgzNDgsXG4gICAgICAgIFwieVwiOiAyNjA4LjQ3NjI0Mzg3MjkzMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNDdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJQYW9sbyBSdWZmaW5pXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzY1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQYW9sb1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTgyMixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXRhbHlcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYW9sb19SdWZmaW5pXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJSdWZmaW5pXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NDczLjA1MDI0OTU4Mzk3MixcbiAgICAgICAgXCJ5XCI6IDMyOTkuNjU3MDI3OTY4NjIwMlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMzJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJBbWFsIFJheWNoYXVkaHVyaVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyMyxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiQW1hbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAwNSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSW5kaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwiU291dGggQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BbWFsX0t1bWFyX1JheWNoYXVkaHVyaVwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUmF5Y2hhdWRodXJpXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1MTgzLjE2NDU2MTQwMzYzMTUsXG4gICAgICAgIFwieVwiOiAzNzM0Ljg0MTg0ODE2MDI5MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlZpbGhlbG0gQmplcmtuZXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlZpbGhlbG1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5vcndheVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZpbGhlbG1fQmplcmtuZXNcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkJqZXJrbmVzXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNzg0LjkyMTE1NTUwMzQ5MzUsXG4gICAgICAgIFwieVwiOiAzOTYyLjEwMjgyNjMzMzczXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM1MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBoaWxpcCBTYWZmbWFuXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTMxLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJQaGlsaXBcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMDgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaGlsaXBfU2FmZm1hblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2FmZm1hblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDUxMy45MTcyOTE4NzAyMTUsXG4gICAgICAgIFwieVwiOiAzMDgxLjcyMTk5OTQ3Nzk0NDNcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjI5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRXZnZW55IExpZnNoaXR6XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTE1LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJFdmdlbnlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlJ1c3NpYVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V2Z2VueV9MaWZzaGl0elwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTGlmc2hpdHpcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUyNzYuOTg1NjgwNzUyOTgzLFxuICAgICAgICBcInlcIjogMzY3MC44OTExMDMxNzkxOTc3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiVG9yc3RlbiBDYXJsZW1hblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiVG9yc3RlblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0OSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dlZGVuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9yc3Rlbl9DYXJsZW1hblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2FybGVtYW5cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDUwMjkuNjA0MTc4OTc1MDE3LFxuICAgICAgICBcInlcIjogMzU4NC4xNjA2MTAwMjY1OTE3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkNhcmwgSmFjb2JpXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODA0LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJDYXJsXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODUxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FybF9HdXN0YXZfSmFjb2JfSmFjb2JpXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJKYWNvYmlcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDQyMzUuOTQ5Njk0MDgzOTM0LFxuICAgICAgICBcInlcIjogMzM3Mi4yNjM3NzA5NzA0MDE4XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjM3NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkRhdmlkIFNsZXBpYW5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhdmlkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAyMDA3LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF2aWRfU2xlcGlhblwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2xlcGlhblwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTY4OS41NjIyNzA2NzQ0NDksXG4gICAgICAgIFwieVwiOiAyODY4Ljg0NTMwNDc0MTM1MjdcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzc5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGVicm9yZCBTbmVsbFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTU4MCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2lsbGVicm9yZFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTYyNixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiTmV0aGVybGFuZHNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsZWJyb3JkX1NuZWxsaXVzXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTbmVsbFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMTQwOC4wNzIwOTU4NjcyOTEyLFxuICAgICAgICBcInlcIjogMzM2Mi4wOTM1MDc4NzgyNjVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTMxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGlhbSBIYW1pbHRvblwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTgwNSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2lsbGlhbVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg2NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSXJlbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpbGxpYW1fUm93YW5fSGFtaWx0b25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhhbWlsdG9uXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0Mjc3LjMzMTkzOTQwMTMxNyxcbiAgICAgICAgXCJ5XCI6IDMyNTQuNzY5MjM4OTYxN1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzOTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKb2huIFN0dWFydFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyOSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSm9oblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkVuZ2xhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb2huX1RyZXZvcl9TdHVhcnRcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlN0dWFydFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNTMwNS4xNzEyMDExMDc5OTUsXG4gICAgICAgIFwieVwiOiAzNjk0Ljc2OTYwMjk2NTc1MVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCI0NDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKYWNrIFdvbGZcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkphY2tcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMTEsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KYWNrX1dvbGZcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIldvbGZcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDU2NDguNjM3MTQyMzQxNzA4LFxuICAgICAgICBcInlcIjogMjg3OC4xMzQ0NzkyNjIyMzE3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE5MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlYuIEEuIEtvaGxyYXVzY2hcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJWLiBBLlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyYWNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIktvaGxyYXVzY2hcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM2MTQuMTQ3ODU4MzUxMzkxMyxcbiAgICAgICAgXCJ5XCI6IDMxNTIuNDUyOTQ5NDU5Mzg2N1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzMjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJNaWNoYWVsIFB1cnNlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIk1pY2hhZWxcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJJcmVsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUHVyc2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0Mzg4LjEyNTA0NTE4OTYwNSxcbiAgICAgICAgXCJ5XCI6IDMxMTYuOTU2ODA1MDIyNTg0NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyMjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJTb2xvbW9uIExlZnNjaGV0elwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiU29sb21vblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3MixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUnVzc2lhXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29sb21vbl9MZWZzY2hldHpcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkxlZnNjaGV0elwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjU0NC4zMDE1OTY1MDQzODYsXG4gICAgICAgIFwieVwiOiAzNDE1LjE0OTI2OTY0MTg2M1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzNzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJJc2Fkb3JlIFNpbmdlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkyNCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSXNhZG9yZVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAyMSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lzYWRvcmVfU2luZ2VyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTaW5nZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIwODkuMDA5MzE2NTgzNTM2LFxuICAgICAgICBcInlcIjogMzM1MS41NDY5NjEyMzk3MTJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiNTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSdWRvbGYgQ2xhdXNpdXNcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MjIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJ1ZG9sZlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg4OCxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1ZG9sZl9DbGF1c2l1c1wiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2xhdXNpdXNcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM3NDYuOTYwNDcyMTUwODk0LFxuICAgICAgICBcInlcIjogMzE0MS45MTQ5NTI1NTE4NTZcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMzYyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiSnVsaWFuIFNjaHdpbmdlclwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTkxOCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSnVsaWFuXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTk0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSnVsaWFuX1NjaHdpbmdlclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiU2Nod2luZ2VyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NjIzLjQzMjg3Njc2NDA2NyxcbiAgICAgICAgXCJ5XCI6IDI2MTguOTA3NTg4ODQ3ODc3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQ3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiU3VicmFobWFueWFuIENoYW5kcmFzZWtoYXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MTAsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlN1YnJhaG1hbnlhblwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk5NSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiSW5kaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwiU291dGggQXNpYW5cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdWJyYWhtYW55YW5fQ2hhbmRyYXNla2hhclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiQ2hhbmRyYXNla2hhclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogNDM5MS44ODE3ODQ3Njg0ODgsXG4gICAgICAgIFwieVwiOiA0Mzg0LjczNjAyOTc2MTE0MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIxNzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJSaWNoYXJkIEthZGlzb25cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjUsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJpY2hhcmRcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDIwMTgsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SaWNoYXJkX0thZGlzb25cIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkthZGlzb25cIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyMjMuMDUxMTYwMTY4MTA0NixcbiAgICAgICAgXCJ5XCI6IDMzNzMuODc5ODY2NjI5MTM3XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQwN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhhbnMgVHJvcHNjaFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg4OSxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiSGFuc1wiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTkzNSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiQXVzdHJpYS1IdW5nYXJ5XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFuc19Ucm9wc2NoXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJUcm9wc2NoXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA2NTAwLjAsXG4gICAgICAgIFwieVwiOiAzNjIyLjA1OTk2ODg2ODMxM1xuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyODZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJXYWx0aGVyIE5lcm5zdFwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg2NCxcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiV2FsdGhlclwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk0MSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiR2VybWFueVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dhbHRoZXJfTmVybnN0XCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJOZXJuc3RcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDMzNjEuMjAzMTMwMDc0Njg3NixcbiAgICAgICAgXCJ5XCI6IDM2MTkuNzE2MzQ4NTgyMDY0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMzOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkJlcm5oYXJkIFJpZW1hbm5cIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4MjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkJlcm5oYXJkXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxODY2LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybmhhcmRfUmllbWFublwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiUmllbWFublwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzcwNS43Njg1NTMzNjA0ODMsXG4gICAgICAgIFwieVwiOiAzNjg1LjQwMzA0MDMyNTY5OVxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiWWFraXIgQWhhcm9ub3ZcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzIsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIllha2lyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiUGFsZXN0aW5lXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWFraXJfQWhhcm9ub3ZcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkFoYXJvbm92XCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMTI0LjQ1NDkwODI1OTk5OCxcbiAgICAgICAgXCJ5XCI6IDQzMTYuMzI4MTE5ODM0MjIxXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE3OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlBldGVyIEthcGl0emFcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlBldGVyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTg0LFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJSdXNzaWFcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QeW90cl9LYXBpdHNhXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJLYXBpdHphXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAyMjkzLjAxNjU4ODgwNTQyMSxcbiAgICAgICAgXCJ5XCI6IDMzNzkuNzg5Njg2OTU1MDg2XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjk2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiQWRyaWFhbiBGb2trZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4ODcsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkFkcmlhYW5cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIk5ldGhlcmxhbmRzXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWRyaWFhbl9Gb2trZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkZva2tlclwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzA5My41MDc3OTY0NzYxNzg2LFxuICAgICAgICBcInlcIjogMzU5OS4yMjUzNTEzMTc3MDkzXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjMwNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIlJvZ2VyIFBlbnJvc2VcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MzEsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIlJvZ2VyXCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRW5nbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvZ2VyX1BlbnJvc2VcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIlBlbnJvc2VcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDM0OTYuMjM2NzI5MTA4MTEsXG4gICAgICAgIFwieVwiOiA0NTU4LjQ3NzMzNjgzNDA3OFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIzODdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJKYWtvYiBTdGVpbmVyXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxNzk2LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJKYWtvYlwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTg2MyxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dpdHplcmxhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KYWtvYl9TdGVpbmVyXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJTdGVpbmVyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NDk3Ljc2MzA1NzQxOTM0MixcbiAgICAgICAgXCJ5XCI6IDM3NjIuNzcxMzc4MTI2MjU1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE0OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIldpbGxpYW0gSG9kZ2VcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MDMsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGxpYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5NzUsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlNjb3RsYW5kXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVy5fVi5fRC5fSG9kZ2VcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkhvZGdlXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA1Mzg0LjkwMTY4MjgxODc4MixcbiAgICAgICAgXCJ5XCI6IDM5NzYuNTMyMTg5NjY1NzA1XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjE1NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkhlaW56IEhvcGZcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkhlaW56XCIsXG4gICAgICAgIFwiZGVhdGhfeWVhclwiOiAxOTcxLFxuICAgICAgICBcImJpcnRoX2NvdW50cnlcIjogXCJHZXJtYW55XCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVpbnpfSG9wZlwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiSG9wZlwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMzY4OS44Mzc4Njc5NTcxNTMsXG4gICAgICAgIFwieVwiOiA0MTA2LjkxNDExMjEwNjUyOTVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMTgxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiRGFuaWVsIEthc3RsZXJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE5MjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIkRhbmllbFwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMjAxNSxcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiRnJhbmNlXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFuaWVsX0thc3RsZXJcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcIkthc3RsZXJcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDI0MDUuMTI2NTE3MzAzNzkyMyxcbiAgICAgICAgXCJ5XCI6IDM0MjEuODU4OTU3MjM2ODU5XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjY1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiTG91aXMgZGUgQnJvZ2xpZVwiLFxuICAgICAgICBcImJpcnRoX3llYXJcIjogMTg5MixcbiAgICAgICAgXCJnaXZlbl9uYW1lXCI6IFwiTG91aXNcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5ODcsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIkZyYW5jZVwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvdWlzX2RlX0Jyb2dsaWVcIixcbiAgICAgICAgXCJmYW1pbHlfbmFtZVwiOiBcImRlIEJyb2dsaWVcIixcbiAgICAgICAgXCJnZW5kZXJcIjogXCJtYWxlXCJcbiAgICAgIH0sXG4gICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgXCJ4XCI6IDIyMzcuMTA4ODg4MDgyMjI0NCxcbiAgICAgICAgXCJ5XCI6IDQyMjYuNDM2MTQ2NTQ2NTQ0XG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIjQ0NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcIk5vZGVUeXBlXCI6IFwiQ2hlZXNlXCIsXG4gICAgICAgIFwibmFtZVwiOiBcIkFudG9uaSBaeWdtdW5kXCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxOTAwLFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJBbnRvbmlcIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5OTIsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIlBvbGFuZFwiLFxuICAgICAgICBcInJhY2VcIjogXCJ3aGl0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FudG9uaV9aeWdtdW5kXCIsXG4gICAgICAgIFwiZmFtaWx5X25hbWVcIjogXCJaeWdtdW5kXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiAzNjYzLjYyNTA0NTk3ODU0OTcsXG4gICAgICAgIFwieVwiOiA0Mzk4LjQ5MDc3NjM1ODQ5MlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCIyOTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJOb2RlVHlwZVwiOiBcIkNoZWVzZVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJIYXJyeSBOeXF1aXN0XCIsXG4gICAgICAgIFwiYmlydGhfeWVhclwiOiAxODg5LFxuICAgICAgICBcImdpdmVuX25hbWVcIjogXCJIYXJyeVwiLFxuICAgICAgICBcImRlYXRoX3llYXJcIjogMTk3NixcbiAgICAgICAgXCJiaXJ0aF9jb3VudHJ5XCI6IFwiU3dlZGVuXCIsXG4gICAgICAgIFwicmFjZVwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFycnlfTnlxdWlzdFwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiTnlxdWlzdFwiLFxuICAgICAgICBcImdlbmRlclwiOiBcIm1hbGVcIlxuICAgICAgfSxcbiAgICAgIFwicG9zaXRpb25cIjoge1xuICAgICAgICBcInhcIjogMjg0MS45NTA4ODczNjMyNDAzLFxuICAgICAgICBcInlcIjogNDEzOC45OTA3NTMxMzg4MDVcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiMjk4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiTm9kZVR5cGVcIjogXCJDaGVlc2VcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiV2lsbGlhbSBPcnJcIixcbiAgICAgICAgXCJiaXJ0aF95ZWFyXCI6IDE4NjYsXG4gICAgICAgIFwiZ2l2ZW5fbmFtZVwiOiBcIldpbGxpYW1cIixcbiAgICAgICAgXCJkZWF0aF95ZWFyXCI6IDE5MzQsXG4gICAgICAgIFwiYmlydGhfY291bnRyeVwiOiBcIklyZWxhbmRcIixcbiAgICAgICAgXCJyYWNlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWxsaWFtX01jRmFkZGVuX09yclwiLFxuICAgICAgICBcImZhbWlseV9uYW1lXCI6IFwiT3JyXCIsXG4gICAgICAgIFwiZ2VuZGVyXCI6IFwibWFsZVwiXG4gICAgICB9LFxuICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgIFwieFwiOiA0NDI3LjkwMjU1NzU5MTE4OSxcbiAgICAgICAgXCJ5XCI6IDM3MjcuNzc5NTIwMDY2NTQ2NFxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuXG4gIF0sXG4gIFwiZWRnZXNcIjogW1xuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEwNyA9PiAzNjRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTA3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzY0XCIsXG4gICAgICAgIFwieWVhclwiOiAxODIzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhdXNz4oCTU2VpZGVsX21ldGhvZFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbGdlYnJhXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzODggPT4gNDE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM4OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxNVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwicmVsYXRpb25zaGlwXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Rlcm7igJNWb2xtZXJfcmVsYXRpb25zaGlwXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlBob3RvY2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA2MyA9PiAyMTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNjNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMTZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzgsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImluc3RhYmlsaXR5XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFycmlldXPigJNMYW5kYXVfaW5zdGFiaWxpdHlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTE5ID0+IDUwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjExOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjUwXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FZGdld29ydGhfc2VyaWVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlByb2JhYmlsaXR5L1N0YXRpc3RpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwMyA9PiAxOTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzAzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTkxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUwLFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZm9yY2VcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hdGVyaWFsc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDAgPT4gNzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI3NVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FydGFu4oCTRGlldWRvbm7DqV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3NCA9PiAyMDFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzc0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjAxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTU0LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlnaHRfYmluZGluZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTb2xpZC1TdGF0ZSBQaHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMzcgPT4gMzFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjM3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGp1bmfigJNCb3hfdGVzdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMSA9PiAyNzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNzlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3jigJNNdWxsZXJfdHJhbnNmb3JtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlJheW1vbmQgUGFsZXksIE5vcmJlcnQgV2VpbmVyXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNjcgPT4gNDAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM2N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwMlwiLFxuICAgICAgICBcInllYXJcIjogMTk2NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TZXJyZeKAk1RhdGVfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE3NSA9PiAxODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTc1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTgxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTcyLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0thZGlzb27igJNLYXN0bGVyX21ldHJpY1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MDMgPT4gMTEzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQwM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjExM1wiLFxuICAgICAgICBcInllYXJcIjogMTkzMSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGF5bG9y4oCTR29sZHN0ZWluX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkIuIEhhdXJ3aXR6XCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDgyID0+IDY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjgyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNjdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FaW5zdGVpbuKAk2RlX0hhYXNfZWZmZWN0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIk93ZW4gUmljaGFyZHNvblwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTWFnbmV0aXNtXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMyA9PiAyNjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4ODcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJ1bm7igJNNaW5rb3dza2lfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZXJtYW55XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0NDMgPT4gMjE5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ0M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIxOVwiLFxuICAgICAgICBcInllYXJcIjogMTgzMCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWW91bmfigJNMYXBsYWNlX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkdhdXNzXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExMCA9PiAxMzhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTEwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTM4XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTc4LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2liYm9uc+KAk0hhd2tpbmdfYW5zYXR6XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlJlbGF0aXZpdHlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE2NiA9PiA5MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNjZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI5MVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KZWZpbWVua28lMjdzX2VxdWF0aW9ucyNIZWF2aXNpZGXigJNGZXlubWFuX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRWxlY3Ryb21hZ25ldGlzbVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjI3ID0+IDMwMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMjdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMDFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGll4oCTUGFsYWlzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR3JvdXAgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNDggPT4gMjgyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI0OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI4MlwiLFxuICAgICAgICBcInllYXJcIjogMTk3MixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bcml0aG1ldGljX29mX2FiZWxpYW5fdmFyaWV0aWVzI01hbmlu4oCTTXVtZm9yZF9jb25qZWN0dXJlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE3NiA9PiA4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI4MlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS8OkaGxlcuKAk0VpbnN0ZWluX21ldHJpY1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDA0ID0+IDQwOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0MDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTEsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJkZXNpZ25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IaXN0b3J5X29mX3RoZV9UZWxsZXLigJNVbGFtX2Rlc2lnblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMDMgPT4gNDIzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIwM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQyM1wiLFxuICAgICAgICBcInllYXJcIjogMTk0MSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tyYW1lcnPigJNXYW5uaWVyX2R1YWxpdHlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU3RhdGlzdGljYWwgTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MzQgPT4gMTAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQzNFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEwMlwiLFxuICAgICAgICBcInllYXJcIjogMTg1MyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGF3XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTb2xpZC1TdGF0ZSBQaHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MzYgPT4gMzY1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQzNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM2NVwiLFxuICAgICAgICBcInllYXJcIjogMTkzMyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY2VsbFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpZ25lcuKAk1NlaXR6X2NlbGxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU29saWQtU3RhdGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDUgPT4gNzRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI3NFwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjb25zdHJ1Y3Rpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXlsZXnigJNEaWNrc29uX2NvbnN0cnVjdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbGdlYnJhXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA1MyA9PiA4MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjgxXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NsYXVzaXVz4oCTRHVoZW1faW5lcXVhbGl0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJUaGVybW9keW5hbWljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzkgPT4gMzg1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzg1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTY5LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvbiBvZiBzdGF0ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHA6Ly93d3cuc2tsb2d3aWtpLm9yZy9Ta2xvZ1dpa2kvaW5kZXgucGhwL0Nhcm5haGFuLVN0YXJsaW5nX2VxdWF0aW9uX29mX3N0YXRlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlN0YXRpc3RpY2FsIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTk5ID0+IDY5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE5OVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjY5XCIsXG4gICAgICAgIFwieWVhclwiOiAxODc3LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tvcnRld2Vn4oCTZGVfVnJpZXNfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiQm91c3NpbmVzcVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTExID0+IDI0OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMTFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NTUsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyYW5nb25pX2VmZmVjdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJKYW1lcyBUaG9tc29uXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDkgPT4gMzY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNjdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3J5XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzc+KAk1NlcnJlX3RoZW9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEzNiA9PiAyNjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTM2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjY2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXNzZeKAk01pbmtvd3NraV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk51bWJlciBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI2NyA9PiAxOTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjY3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTk5XCIsXG4gICAgICAgIFwieWVhclwiOiAxODc3LFxuICAgICAgICBcImZpZWxkXCI6IFwiQmlvbG9neVwiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZW5z4oCTS29ydGV3ZWdfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQmlvbWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4MSA9PiAyNTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiODFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRHVoZW3igJNNYXJndWxlc19lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJUaGVybW9keW5hbWljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNTMgPT4gMjczXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjUzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjczXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwicmVsYXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DbGF1c2l1c+KAk01vc3NvdHRpX3JlbGF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9tYWduZXRpc21cIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExOSA9PiAzNTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTE5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzU1XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmFt4oCTU2NobWlkdF9wcm9jZXNzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlBpZXJyZS1TaW1vbiBMYXBsYWNlXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbGdlYnJhXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0NCA9PiA2NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjY2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXN0ZWxudW92b+KAk2RlX0ZyYW5jaGlzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQ0ID0+IDEyOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMjlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcm1pdGXigJNIYWRhbWFyZF9pbmVxdWFsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4MiA9PiAzNjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjgyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzY4XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTg5LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25hbFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011bWZvcmTigJNTaGFoX2Z1bmN0aW9uYWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgODAgPT4gMjM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjgwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjM5XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE3ID0+IDcxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIxN1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjcxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTcwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmdsYW5kc+KAk0RlbGlnbmVfbG9jYWxfY29uc3RhbnRcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUmVwcmVzZW50YXRpb24gVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMTUgPT4gMzI5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIxNVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMyOVwiLFxuICAgICAgICBcInllYXJcIjogMTkwOCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5kYXXigJNSYW1hbnVqYW5fY29uc3RhbnRcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtYmVyIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTA4ID0+IDI5NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMDhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyOTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjEsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZWxsLU1hbm7igJNPa3Vib19tYXNzX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUGFydGljbGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTI0ID0+IDM4MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMjRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzODFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjYsXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyaW1t4oCTU29tbWVyZmVsZF9ydWxlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIENoZW1pc3RyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTc1ID0+IDM3M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNzVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNzNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTksXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FkaXNvbuKAk1Npbmdlcl9wcm9ibGVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEzNSA9PiA5NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMzVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI5NVwiLFxuICAgICAgICBcInllYXJcIjogMTkzNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ0MiA9PiAyNjVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDQyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjY1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTU0LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcnlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ZYW5n4oCTTWlsbHNfdGhlb3J5I0hpc3RvcnlfYW5kX3RoZW9yZXRpY2FsX2Rlc2NyaXB0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlBhcnRpY2xlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDUxID0+IDM0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM0M1wiLFxuICAgICAgICBcInllYXJcIjogMTkzNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaHVyY2jigJNSb3NzZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNjggPT4gNDM3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE2OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQzN1wiLFxuICAgICAgICBcInllYXJcIjogMTkzNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KZXNzZW7igJNXaW50bmVyX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUHJvYmFiaWxpdHkvU3RhdGlzdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTMyID0+IDQyOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMzJcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MjhcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJCaW9sb2d5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXJkeeKAk1dlaW5iZXJnX3ByaW5jaXBsZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW5ldGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTc3ID0+IDE4OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNzdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxODlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTksXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYWx1emHigJNLbGVpbl90aGVvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUGFydGljbGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTM5ID0+IDkxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEzOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjkxXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0plZmltZW5rbyUyN3NfZXF1YXRpb25zI0hlYXZpc2lkZeKAk0ZleW5tYW5fZm9ybXVsYVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJFbGVjdHJvbWFnbmV0aXNtXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNTIgPT4gNDAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM1MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwMlwiLFxuICAgICAgICBcInllYXJcIjogMTk2MCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImNvbmplY3R1cmVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYXRv4oCTVGF0ZV9jb25qZWN0dXJlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNSA9PiAyNTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4OTQsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJpbnRlZ3JhbFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbGxpbl90cmFuc2Zvcm0jQ2FoZW7igJNNZWxsaW5faW50ZWdyYWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQW5hbHlzaXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ5ID0+IDg1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiODVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yeVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXBtYW7igJNFbnNrb2dfdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlN0YXRpc3RpY2FsIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzMzID0+IDM0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNDBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtZXRob2RcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYXlsZWlnaOKAk1JpdHpfbWV0aG9kXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDUxID0+IDQwOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwOFwiLFxuICAgICAgICBcInllYXJcIjogMTkzNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZXNpc1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NodXJjaOKAk1R1cmluZ190aGVzaXNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzc1ID0+IDQ0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNzVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0NDBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2RpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbGVwaWFu4oCTV29sZl9jb2RpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiSW5mb3JtYXRpb24gVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzOTYgPT4gMjE2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM5NlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIxNlwiLFxuICAgICAgICBcInllYXJcIjogMTk0NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3R1YXJ04oCTTGFuZGF1X2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTMxID0+IDE2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNjNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NDIsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwOi8vd3d3LnNjaG9sYXJwZWRpYS5vcmcvYXJ0aWNsZS9IYW1pbHRvbi1KYWNvYmlfZXF1YXRpb24jSGlzdG9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0NDUgPT4gMTUyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ0NVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE1MlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJwYXJhbWV0ZXJcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9aZW5lcuKAk0hvbGxvbW9uX3BhcmFtZXRlclwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJNYXRlcmlhbHNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDg4ID0+IDE3MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE3MFwiLFxuICAgICAgICBcInllYXJcIjogMTk5MyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GYXJyZWxs4oCTSm9uZXNfY29uamVjdHVyZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI0ID0+IDQxMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxMVwiLFxuICAgICAgICBcInllYXJcIjogMTkxMSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JvaHLigJN2YW5fTGVldXdlbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hZ25ldGlzbVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDQzID0+IDE0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0NDNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NTAsXG4gICAgICAgIFwiZmllbGRcIjogXCJCaW9sb2d5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yeVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1lvdW5n4oCTSGVsbWhvbHR6X3RoZW9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNjIgPT4gMTM3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI2MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEzN1wiLFxuICAgICAgICBcInllYXJcIjogMTk1MyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFsZ29yaXRobVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiQXJpYW5uYSBXLiBSb3NlbmJsdXRoLCBNYXJzaGFsbCBSb3NlbmJsdXRoLCBBdWd1c3RhIEguIFRlbGxlciBhbmQgRWR3YXJkIFRlbGxlclwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtZXJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQzNSA9PiAxNjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDM1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTYyXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpZW5lcuKAk0lrZWhhcmFfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MjcgPT4gODRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDI3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiODRcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NjMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJwYXJhbWV0ZXJpemF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2VpZXJzdHJhc3PigJNFbm5lcGVyX3BhcmFtZXRlcml6YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR2VvbWV0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM4OCA9PiAxMDlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzg4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTA5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTIxLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJleHBlcmltZW50XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Rlcm7igJNHZXJsYWNoX2V4cGVyaW1lbnRcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEyNyA9PiAzNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTI3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzQ2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTU4LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2lnaHRtYW5fYXhpb21zXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gRmllbGQgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMjYgPT4gMjI4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIyNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIyOFwiLFxuICAgICAgICBcInllYXJcIjogMTk3OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjY4ID0+IDI1M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE2NzIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ocuKAk01hc2NoZXJvbmlfdGhlb3JlbSNIaXN0b3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNDQgPT4gOTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzQ0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiOTdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzYsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVmZmVjdFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1Ymlu4oCTRm9yZF9lZmZlY3RcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiTm9yYmVydCBUaG9ubmFyZCwgTW9ydG9uIFJvYmVydHMsIEpvaG4gR3JhaGFtXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBc3Ryb3BoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDgyID0+IDM3OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM3OFwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI1NSA9PiA0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNTVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MFwiLFxuICAgICAgICBcInllYXJcIjogMTkwNCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXVyZXLigJNDYXJ0YW5fZm9ybVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4ID0+IDQxN1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxN1wiLFxuICAgICAgICBcInllYXJcIjogMTkxMixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm91bmRhcnkgY29uZGl0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQm9ybuKAk3Zvbl9LYXJtYW5fYm91bmRhcnlfY29uZGl0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEyNyA9PiAxODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTI3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTgxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTY0LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9jYWxfcXVhbnR1bV9maWVsZF90aGVvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBGaWVsZCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExMSA9PiA4MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMTFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI4MVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlRoZXJtb2R5bmFtaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNjcgPT4gMzk5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM2N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM5OVwiLFxuICAgICAgICBcInllYXJcIjogMTk1NSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TZXJyZeKAk1N3YW5fdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJUb3BvbG9neVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDE4ID0+IDkzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQxOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjkzXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZGlzdHJpYnV0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvdm9uX01pc2Vz4oCTRmlzaGVyX2Rpc3RyaWJ1dGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MCA9PiAyMDlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMDlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FydGFu4oCTS3VyYW5pc2hpX3Byb2xvbmdhdGlvbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDggPT4gNDAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJncm91cFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhcnNvdHRp4oCTVGF0ZV9ncm91cFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDYyID0+IDg3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjYyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiODdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE3NTIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW5jeWNsb3BlZGlhb2ZtYXRoLm9yZy93aWtpL0NhdWNoeS1SaWVtYW5uX2VxdWF0aW9uc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxODYgPT4gMTk2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4NlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE5NlwiLFxuICAgICAgICBcInllYXJcIjogMTkzMCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XaWVuZXLigJNLaGluY2hpbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIk5vcmJlcnQgV2llbmVyXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMTEgPT4gNDEzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxMVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxM1wiLFxuICAgICAgICBcInllYXJcIjogMTg5OCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yeVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BpY2FyZOKAk1Zlc3Npb3RfdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4OCA9PiA1NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyODhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI1NlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmb3JtdWxhXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmV3dG9u4oCTQ290ZXNfZm9ybXVsYXNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtZXJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ3ID0+IDMwMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMwMFwiLFxuICAgICAgICBcInllYXJcIjogMTk3NixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXF1YXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFuZHJhc2VraGFy4oCTUGFnZV9lcXVhdGlvbnNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiTi4gVG9vcFwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQXN0cm9waHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNzEgPT4gMTUxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE3MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE1MVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tcG9zaXRpb25fc2VyaWVzI1VuaXF1ZW5lc3M6X0pvcmRhbuKAk0jDtmxkZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MDMgPT4gNTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDAzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNTdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmxvd1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheWxvcuKAk0NvdWV0dGVfZmxvd1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEwMSA9PiAxNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTAxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTQ2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTE0LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJhbmNr4oCTSGVydHpfZXhwZXJpbWVudFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJRdWFudHVtIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDA2ID0+IDI3MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0MDZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNzFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDYsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJzZXF1ZW5jZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RodWXigJNNb3JzZV9zZXF1ZW5jZSNIaXN0b3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkV1Z8OobmUgUHJvdWhldFwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgOTQgPT4gMTYwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjk0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTYwXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQb2x5bWVyc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTk2ID0+IDM3N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxOTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNzdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS29sbW9nb3JvduKAk1NtaXJub3ZfdGVzdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNTcgPT4gMTg4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM1N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE4OFwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmb3JtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJpbWVfZm9ybVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNTMgPT4gNTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNTNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI1MlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJlbGF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2xhdXNpdXPigJNDbGFwZXlyb25fcmVsYXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiVGhlcm1vZHluYW1pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwID0+IDgyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiODJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjQsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0YXRlIG9mIG1hdHRlclwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jvc2XigJNFaW5zdGVpbl9jb25kZW5zYXRlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkNvbmRlbnNlZCBNYXR0ZXJcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE3NSA9PiAxNzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTc1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTc5XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYXBsYW5za3klMjdzX2NvbmplY3R1cmVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDYxID0+IDQzMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI2MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQzMVwiLFxuICAgICAgICBcInllYXJcIjogMTk0MCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiTGF3XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly93d3cubWVycmlhbS13ZWJzdGVyLmNvbS9kaWN0aW9uYXJ5L0N1cmllLVdlaXNzJTIwbGF3XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hZ25ldGlzbVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgOTAgPT4gNzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiOTBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI3N1wiLFxuICAgICAgICBcInllYXJcIjogMTkyNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zlcm1p4oCTRGlyYWNfc3RhdGlzdGljcyNIaXN0b3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyOCA9PiAyOTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyOTdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjcsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFwcHJveGltYXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cb3Ju4oCTT3BwZW5oZWltZXJfYXBwcm94aW1hdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJRdWFudHVtIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjI3ID0+IDE5NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMjdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxOTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGll4oCTS29sY2hpbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdyb3VwIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDggPT4gMTc0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTc0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTA1LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY29uZGl0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcG1hbuKAk0pvdWd1ZXRfY29uZGl0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQzNSA9PiA0MzdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDM1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDM3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTQxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpZW5lcuKAk1dpbnRuZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4NyA9PiAyNTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiODdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtZXJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQyMyA9PiAyNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDIzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjc2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTM3LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJleGNpdG9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhjaXRvbiNXYW5uaWVy4oCTTW90dF9leGNpdG9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI3MSA9PiAzNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjcxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzc2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN5c3RlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vcnNl4oCTU21hbGVfc3lzdGVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQzNSA9PiAxNTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDM1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTU1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWV0aG9kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbmN5Y2xvcGVkaWFvZm1hdGgub3JnL2luZGV4LnBocD90aXRsZT1XaWVuZXItSG9wZl9tZXRob2RcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjY0ID0+IDEyNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNjRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMjZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDIsXG4gICAgICAgIFwiZmllbGRcIjogXCJCaW9sb2d5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NaWNoYWVsaXPigJNHdXRtYW5uX2JvZGllc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA3MSA9PiAyODJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyODJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjksXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxpX29mX2FsZ2VicmFpY19jdXJ2ZXMjY2l0ZV9ub3RlLTowLTFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR2VvbWV0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE0NiA9PiAxOTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTQ2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTkwXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVydHrigJNLbnVkc2VuX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE4OSA9PiAxMTZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTg5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTE2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2xlaW7igJNHb3Jkb25fZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE3MSA9PiAzMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMlwiLFxuICAgICAgICBcInllYXJcIjogMTkxMSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Kb3JkYW5fY3VydmVfdGhlb3JlbSNQcm9vZl9hbmRfZ2VuZXJhbGl6YXRpb25zXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkhlbnJpIExlYmVzZ3VlXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJUb3BvbG9neVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNTkgPT4gNDM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjU5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDM5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTM2LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NyYW3DqXLigJNXb2xkX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUHJvYmFiaWxpdHkvU3RhdGlzdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTg3ID0+IDM0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxODdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNDNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2xlZW5l4oCTUm9zc2VyX3BhcmFkb3hcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTG9naWNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDg3ID0+IDI1M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI1M1wiLFxuICAgICAgICBcInllYXJcIjogMTczNCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI0NCA9PiAyNDdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjQ0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjQ3XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MeWFwdW5vduKAk01hbGtpbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM4MSA9PiAyMDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzgxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjAwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTE5LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJsYXdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb21tZXJmZWxk4oCTS29zc2VsX2Rpc3BsYWNlbWVudF9sYXdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQU1PXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MCA9PiAxNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNzZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhcnRhbuKAk0vDpGhsZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA1OSA9PiA0MThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNTlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MThcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzAsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjcml0ZXJpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtw6ly4oCTdm9uX01pc2VzX2NyaXRlcmlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDcgPT4gMzE5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE0N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMxOVwiLFxuICAgICAgICBcInllYXJcIjogMTk4MixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IaWxiZXJ04oCTUMOzbHlhX2NvbmplY3R1cmVcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjQ0ID0+IDM1NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0x5YXB1bm924oCTU2NobWlkdF9yZWR1Y3Rpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTA3ID0+IDE0NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMDdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDRcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA2NyA9PiA0MTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNjdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MTBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzAsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVmZmVjdFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL2RlX0hhYXPigJN2YW5fQWxwaGVuX2VmZmVjdCNIaXN0b3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hZ25ldGlzbVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE5ID0+IDEyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIxOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEyXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFwbGFjZeKAk0JlbHRyYW1pX29wZXJhdG9yXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzMgPT4gMTY1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMzM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE2NVwiLFxuICAgICAgICBcInllYXJcIjogMTkwNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGF3XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmF5bGVpZ2jigJNKZWFuc19sYXdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjY0ID0+IDI1OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNjRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiQmlvbG9neVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWljaGFlbGlz4oCTTWVudGVuX2tpbmV0aWNzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkJpb2NoZW1pc3RyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTA3ID0+IDI3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEwN1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTAwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW5jeWNsb3BlZGlhb2ZtYXRoLm9yZy93aWtpL0dhdXNzLUJvbm5ldF90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxID0+IDMxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzEyXCIsXG4gICAgICAgIFwieWVhclwiOiAxODIwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FiZWzigJNQbGFuYV9mb3JtdWxhXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMxOSA9PiA0MDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzE5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDAwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1DDs2x5YeKAk1N6ZWfFkV9pbmVxdWFsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkFuYWx5c2lzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMzMgPT4gMTIyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIzM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEyMlwiLFxuICAgICAgICBcInllYXJcIjogMTgzNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XS0JfYXBwcm94aW1hdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJGcmFuY2VzY28gQ2FybGluaVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzExID0+IDIzMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMTFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMzBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BpY2FyZOKAk0xpbmRlbMO2Zl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkRpZmZlcmVudGlhbCBFcXVhdGlvbnNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDYwID0+IDI4OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI2MFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI4OVwiLFxuICAgICAgICBcInllYXJcIjogMTk0NyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1ldGhvZFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NyYW5r4oCTTmljb2xzb25fbWV0aG9kXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk51bWVyaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMDUgPT4gNDA0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEwNVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwNFwiLFxuICAgICAgICBcInllYXJcIjogMTkzNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JldGFfZGVjYXlfdHJhbnNpdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzMgPT4gMTA2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMzM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEwNlwiLFxuICAgICAgICBcInllYXJcIjogMTg4MSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXBwcm94aW1hdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JheWxlaWdo4oCTR2Fuc19hcHByb3hpbWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk9wdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzgzID0+IDM5OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzODNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzOTlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaG9tb2xvZ2ljYWxfZGltZW5zaW9uI0V4YW1wbGVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdyb3VwIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTg3ID0+IDMyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMyXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTIzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tsZWVuZeKAk0Jyb3V3ZXJfb3JkZXIjSGlzdG9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJOaWtvbGFpIEx1emluLCBXYWPFgmF3IFNpZXJwacWEc2tpXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA3NiA9PiAyMzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMzVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NzIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGluaeKAk0xpcHNjaGl0el9jcml0ZXJpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjg2ID0+IDMxM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyODZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMTNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiQ2hlbWlzdHJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmVybnN04oCTUGxhbmNrX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9jaGVtaXN0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk4ID0+IDI3N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI3N1wiLFxuICAgICAgICBcInllYXJcIjogMTgyNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3VyaWVy4oCTTW90emtpbl9lbGltaW5hdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzUgPT4gNDA0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMzNVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwNFwiLFxuICAgICAgICBcInllYXJcIjogMTkzNCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZWZmZWN0XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVubmVy4oCTVGVsbGVyX2VmZmVjdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBTU9cIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk2ID0+IDMxM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5NlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMxM1wiLFxuICAgICAgICBcInllYXJcIjogMTkxNCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zva2tlcuKAk1BsYW5ja19lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTdGF0aXN0aWNhbCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM0MiA9PiAzMjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzQyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzI5XCIsXG4gICAgICAgIFwieWVhclwiOiAxODk0LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaWRlbnRpdHlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2dlcnPigJNSYW1hbnVqYW5faWRlbnRpdGllc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxODIgPT4gMjQyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI0MlwiLFxuICAgICAgICBcInllYXJcIjogMTk3OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LYXpoZGFu4oCTTHVzenRpZ19wb2x5bm9taWFsXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlJlcHJlc2VudGF0aW9uIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNSA9PiAzNjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM2M1wiLFxuICAgICAgICBcInllYXJcIjogMTk2OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BdGl5YWjigJNTZWdhbF9jb21wbGV0aW9uX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR3JvdXAgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzID0+IDQyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MlwiLFxuICAgICAgICBcInllYXJcIjogMTk4NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZWZmZWN0XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWhhcm9ub3bigJNDYXNoZXJfZWZmZWN0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0NyA9PiAxODRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxODRcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYW5kcmFzZWtoYXLigJNLZW5kYWxsX2Z1bmN0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4MSA9PiAzNjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjgxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzY2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hdGVyaWFsc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzYgPT4gMjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyOFwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJydWxlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F1Y2h54oCTQm9ybl9ydWxlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzcwID0+IDQyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNzBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MjVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtb2RlbFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NoYW5ub27igJNXZWF2ZXJfbW9kZWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiSW5mb3JtYXRpb24gVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MTkgPT4gMjgxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQxOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI4MVwiLFxuICAgICAgICBcInllYXJcIjogMTk1NixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hdGVyaWFsc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTA3ID0+IDE2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMDdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNjNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhdXNz4oCTSmFjb2JpX3F1YWRyYXR1cmVcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtZXJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3NCA9PiA1NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNzRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI1NVwiLFxuICAgICAgICBcInllYXJcIjogMTkzMCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJydWxlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2xhdGVy4oCTQ29uZG9uX3J1bGVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gQ2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4MiA9PiA0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTIyLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWluc3RlaW7igJNDYXJ0YW5fdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4ID0+IDE1OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE1OFwiLFxuICAgICAgICBcInllYXJcIjogMTk1NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXBwcm94aW1hdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jvcm7igJNIdWFuZ19hcHByb3hpbWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA3MiA9PiA0NDFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNzJcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0NDFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjYsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVuam954oCTV29sZmZfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA1ID0+IDM3M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzczXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTYzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0F0aXlhaOKAk1Npbmdlcl9pbmRleF90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMyOSA9PiAzODBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzI5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzgwXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImNvbnN0YW50XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtYW51amFu4oCTU29sZG5lcl9jb25zdGFudFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzMgPT4gMTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzMzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmF5bGVpZ2jigJNCw6luYXJkX2NvbnZlY3Rpb24jUmF5bGVpZ2jigJNCw6luYXJkX2luc3RhYmlsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNjQgPT4gOTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNjRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI5OVwiLFxuICAgICAgICBcInllYXJcIjogMTkyMixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWV0aG9kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGFyd2lu4oCTRm93bGVyX21ldGhvZFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTdGF0aXN0aWNhbCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMzMyA9PiAzNTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzMzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzU5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVydHVyYmF0aW9uX3RoZW9yeV8ocXVhbnR1bV9tZWNoYW5pY3MpXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxODUgPT4gMTM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4NVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEzOVwiLFxuICAgICAgICBcInllYXJcIjogMTkwMixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlbm5lbGx54oCTSGVhdmlzaWRlX2xheWVyXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkF0bW9zcGhlcmljIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDg3ID0+IDE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjg3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE3NTAsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXLigJNCZXJub3VsbGlfYmVhbV90aGVvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA3MiA9PiAzOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM4XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YXNpLWFuYWx5dGljX2Z1bmN0aW9uI1RoZV9EZW5qb3nigJNDYXJsZW1hbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQyNCA9PiAzOTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDI0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzk1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTk4LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kZWxcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XYXR0c+KAk1N0cm9nYXR6X21vZGVsXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEgPT4gMTYzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNjNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQWJlbOKAk0phY29iaV9tYXBcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR2VvbWV0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI2NiA9PiAxNDhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjY2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTQ4XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTExLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01pbmtvd3NraeKAk0hsYXdrYV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNjQgPT4gNDA0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE2NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwNFwiLFxuICAgICAgICBcInllYXJcIjogMTkzNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phaG7igJNUZWxsZXJfZWZmZWN0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk4ID0+IDI3OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI3OFwiLFxuICAgICAgICBcInllYXJcIjogMTk4MSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3VyaWVy4oCTTXVrYWlfdHJhbnNmb3JtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMzNyA9PiAyNjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzM3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjYxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTY5LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5zdGFiaWxpdHlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SaWNodG15ZXLigJNNZXNoa292X2luc3RhYmlsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQ0ID0+IDI2NlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcm1pdGXigJNNaW5rb3dza2lfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxODMgPT4gMzkxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM5MVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Rva2VzJTI3X3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQ2FsY3VsdXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4MyA9PiAxNDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjgzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTQ1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUwLFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY3JlZXBcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OYWJhcnJv4oCTSGVycmluZ19jcmVlcFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJNYXRlcmlhbHNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3MSA9PiAzMjdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzcxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzI3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTYxLFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGltaXRcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaG9ja2xleeKAk1F1ZWlzc2VyX2xpbWl0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9uaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4NyA9PiAyNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiODdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE3MzUsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXLigJNNYWNsYXVyaW5fZm9ybXVsYVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxID0+IDM0N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzQ3XCIsXG4gICAgICAgIFwieWVhclwiOiAxODI0LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FiZWzigJNSdWZmaW5pX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzYgPT4gMzM4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzM4XCIsXG4gICAgICAgIFwieWVhclwiOiAxNzUyLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXF1YXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXVjaHnigJNSaWVtYW5uX2VxdWF0aW9uc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJk4oCZQWxlbWJlcnRcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkFuYWx5c2lzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0NSA9PiAzMjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMjZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5OTksXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJhbGdvcml0aG1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXlsZXnigJNQdXJzZXJfYWxnb3JpdGhtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlNhcmFoIEZsYW5uZXJ5XCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJDcnlwdG9ncmFwaHlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE4MiA9PiAyNTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTgyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjUxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTY4LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0themhkYW7igJNNYXJndWxpc190aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDc1ID0+IDI0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3NVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI0OFwiLFxuICAgICAgICBcInllYXJcIjogMTk1NSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaWV1ZG9ubsOpX21vZHVsZSNEaWV1ZG9ubsOp4oCTTWFuaW5fY2xhc3NpZmljYXRpb25fdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA5MiA9PiA0MDdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiOTJcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjUsXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2NoZXLigJNUcm9wc2NoX3Byb2Nlc3NcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDEgPT4gMjQ4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjQ4XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFzc2XigJNXaXR0X21hdHJpeCNDb2hvbW9sb2d5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIwNCA9PiA0MjZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjA0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDI2XCIsXG4gICAgICAgIFwieWVhclwiOiAxODUzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tyb25lY2tlcuKAk1dlYmVyX3RoZW9yZW0jSGlzdG9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MDIgPT4gODhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDAyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiODhcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjb2hvbW9sb2d5XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGF0ZV9jb2hvbW9sb2d5X2dyb3VwI1RhdGUtRmFycmVsbF9jb2hvbW9sb2d5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdyb3VwIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTkgPT4gMzUxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzUxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JldGhl4oCTU2FscGV0ZXJfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiTmFtYnVcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMTAgPT4gMjMwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxMFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIzMFwiLFxuICAgICAgICBcInllYXJcIjogMTkwOCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInByaW5jaXBsZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BocmFnbcOpbuKAk0xpbmRlbMO2Zl9wcmluY2lwbGVcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDUgPT4gMTMxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTMxXCIsXG4gICAgICAgIFwieWVhclwiOiAxODUzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NheWxleeKAk0hhbWlsdG9uX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQWxnZWJyYVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQ5ID0+IDQwMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNDlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtb2R1bGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib2RnZeKAk1RhdGVfbW9kdWxlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkplYW4tUGllcnJlIFNlcnJlXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHcm91cCBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEzMCA9PiAzMTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTMwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzE3XCIsXG4gICAgICAgIFwieWVhclwiOiAxODM4LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhZ2Vu4oCTUG9pc2V1aWxsZV9lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI5OCA9PiAzODFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjk4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzgxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTA3LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXF1YXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcnLigJNTb21tZXJmZWxkX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzE2ID0+IDIzMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMzJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWV0aG9kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9pbmNhcsOp4oCTTGluZHN0ZWR0X21ldGhvZFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNDggPT4gNzlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjQ4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNzlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hbmlu4oCTRHJpbmZlbGRfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNiA9PiA0MjdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MjdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4MTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQm9semFub+KAk1dlaWVyc3RyYXNzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQW5hbHlzaXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI2NiA9PiAzODdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjY2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzg3XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZvcm11bGFcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NaW5rb3dza2nigJNTdGVpbmVyX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR2VvbWV0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI2OSA9PiAzMTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjY5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzE1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTM0LFxuICAgICAgICBcImZpZWxkXCI6IFwiQ2hlbWlzdHJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nw7hsbGVy4oCTUGxlc3NldF9wZXJ0dXJiYXRpb25fdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gQ2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNiA9PiAzNTJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNTJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzEsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJwb2x5bm9taWFsXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybnN0ZWlu4oCTU2F0b19wb2x5bm9taWFsXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlRha3VybyBTaGludGFuaVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjAzID0+IDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjAzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMlwiLFxuICAgICAgICBcInllYXJcIjogMTkzNCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cGVyZXhjaGFuZ2VcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU29saWQtU3RhdGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE2ID0+IDExMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMTJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2luemJ1cmfigJNMYW5kYXVfdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwNiA9PiAxMzhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzA2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTM4XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlbnJvc2XigJNIYXdraW5nX3Npbmd1bGFyaXR5X3RoZW9yZW1zXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkNvc21vbG9neVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzM4ID0+IDM4OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzODlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4ODQsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJpbnRlZ3JhbFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpZW1hbm7igJNTdGllbHRqZXNfaW50ZWdyYWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQ4ID0+IDQ0NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNDhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0NDRcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvdy1kaXNjcmVwYW5jeV9zZXF1ZW5jZSNUaGVfZm9ybXVsYV9vZl9IbGF3a2HigJNaYXJlbWJhXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM5NCA9PiAzMDhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzk0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzA4XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI1LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXF1YXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdHJlZXRlcuKAk1BoZWxwc19lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJDaXZpbC9FbnZpcm9ubWVudGFsIEVuZ2luZWVyaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyODggPT4gNDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjg4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MjMsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yeVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ld3RvbuKAk0NhcnRhbl90aGVvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTcyID0+IDQzNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNzJcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MzZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSm9yZGFu4oCTV2lnbmVyX3RyYW5zZm9ybWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA2OCA9PiAyMTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMTlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE3MzgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvZGVfTW9pdnJl4oCTTGFwbGFjZV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlByb2JhYmlsaXR5L1N0YXRpc3RpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDg3ID0+IDIxMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIxMVwiLFxuICAgICAgICBcInllYXJcIjogMTc1NSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcuKAk0xhZ3JhbmdlX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk4ID0+IDcxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjk4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNzFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzYsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm91cmllcuKAk0RlbGlnbmVfdHJhbnNmb3JtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMDcgPT4gMjA2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEwN1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIwNlwiLFxuICAgICAgICBcInllYXJcIjogMTk2NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk51bWVyaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNTAgPT4gMTkzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE1MFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE5M1wiLFxuICAgICAgICBcInllYXJcIjogMTk2NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMyMSA9PiAxMDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzIxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTAzXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTM4LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlZmZlY3RcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb29sZeKAk0ZyZW5rZWxfZWZmZWN0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk0ID0+IDEwMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEwMFwiLFxuICAgICAgICBcInllYXJcIjogMTk1MCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxvcnnigJNGb3hfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUG9seW1lcnNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE0NyA9PiAyODJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTQ3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjgyXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IaWxiZXJ04oCTTXVtZm9yZF9jcml0ZXJpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjA1ID0+IDMwNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMDVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMDVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzEsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDUxID0+IDE4N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE4N1wiLFxuICAgICAgICBcInllYXJcIjogMTkzNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm9yZGluYWxcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaHVyY2jigJNLbGVlbmVfb3JkaW5hbFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMDcgPT4gMjQ4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEwN1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI0OFwiLFxuICAgICAgICBcInllYXJcIjogMTk1OCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYXVzc+KAk01hbmluX2Nvbm5lY3Rpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjU0ID0+IDMyOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNTRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMjhcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5ODYsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZvcm1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXRoYWnigJNRdWlsbGVuX2Zvcm1hbGlzbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJRdWFudHVtIEZpZWxkIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzEwID0+IDMyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxMFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMyXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaHJhZ21lbuKAk0Jyb3V3ZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJUb3BvbG9neVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNzcgPT4gNDE5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjc3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDE5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlyYWPigJN2b25fTmV1bWFubl9heGlvbXNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4ID0+IDEyOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEyOFwiLFxuICAgICAgICBcInllYXJcIjogMTkxOSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVybW9keW5hbWljIGN5Y2xlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQm9ybuKAk0hhYmVyX2N5Y2xlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDcwID0+IDQyMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3MFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQyMVwiLFxuICAgICAgICBcInllYXJcIjogMTkxMyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZmFjdG9yXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly93d3cub3hmb3JkcmVmZXJlbmNlLmNvbS92aWV3LzEwLjEwOTMvb2kvYXV0aG9yaXR5LjIwMTEwODAzMDk1NzA1MjY5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ0ID0+IDI4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI4MlwiLFxuICAgICAgICBcInllYXJcIjogMTg5MyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJlZ3VsYXJpdHlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXN0ZWxudW92b+KAk011bWZvcmRfcmVndWxhcml0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMjkgPT4gMzUzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMyOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM1M1wiLFxuICAgICAgICBcInllYXJcIjogMjAwMixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInNlcmllc1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWFudWphbuKAk1NhdG9fc2VyaWVzI2NpdGVfbm90ZS1TYXRvLTdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtYmVyIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDAgPT4gMTgwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTgwXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFsZ29yaXRobVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhcnRhbuKAk0thcmxoZWRlX2FsZ29yaXRobVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJDYXJsIEJyYW5zXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNDIgPT4gNDAwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM0MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwMFwiLFxuICAgICAgICBcInllYXJcIjogMTkyNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInBvbHlub21pYWxcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb2dlcnPigJNTemVnxZFfcG9seW5vbWlhbHNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjU3ID0+IDdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjU3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiN1wiLFxuICAgICAgICBcInllYXJcIjogMTkwOCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXJuZXNfaW50ZWdyYWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQW5hbHlzaXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQzMyA9PiAzNzBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDMzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzcwXCIsXG4gICAgICAgIFwieWVhclwiOiAxODk4LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZm9ybXVsYVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1doaXR0YWtlcuKAk1NoYW5ub25faW50ZXJwb2xhdGlvbl9mb3JtdWxhXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkJvcmVsXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJJbmZvcm1hdGlvbiBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEyID0+IDE4OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE4OFwiLFxuICAgICAgICBcInllYXJcIjogMTg2OCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1vZGVsXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVsdHJhbWnigJNLbGVpbl9tb2RlbFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQgPT4gOTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI5OVwiLFxuICAgICAgICBcInllYXJcIjogMTkzMyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJydWxlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWNlX3J1bGVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI2MCA9PiA0MjBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjYwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDIwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTY2LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVybWlu4oCTV2FnbmVyX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU3RhdGlzdGljYWwgTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDEgPT4gMjM4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE0MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIzOFwiLFxuICAgICAgICBcInllYXJcIjogMTkyNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFsZW5jZV9ib25kX3RoZW9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJRdWFudHVtIENoZW1pc3RyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzE0ID0+IDMzM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMTRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMzNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NzMsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJpbnN0YWJpbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BsYXRlYXXigJNSYXlsZWlnaF9pbnN0YWJpbGl0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM4NCA9PiA4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzODRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI4MlwiLFxuICAgICAgICBcInllYXJcIjogMTkwOCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJsYXdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaG90b2VsZWN0cm9jaGVtaWNhbF9wcm9jZXNzI1N0YXJr4oCTRWluc3RlaW5fbGF3XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlBob3RvY2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMjMgPT4gMjA3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEyM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIwN1wiLFxuICAgICAgICBcInllYXJcIjogMTk1NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyZWVu4oCTS3Vib19yZWxhdGlvbnNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiVGhlcm1vZHluYW1pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDcyID0+IDE5NFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE5NFwiLFxuICAgICAgICBcInllYXJcIjogMTk3OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZW5qb3nigJNLb2tzbWFfaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJNaWNoYWVsLVJvYmVydCBIZXJtYW5cIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk0ID0+IDM2MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM2MFwiLFxuICAgICAgICBcInllYXJcIjogMTkzNixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxvcnnigJNTY2h1bHpfZGlzdHJpYnV0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlBvbHltZXJzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MDMgPT4gMTIxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQwM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEyMVwiLFxuICAgICAgICBcInllYXJcIjogMTkzNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInZvcnRleFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheWxvcuKAk0dyZWVuX3ZvcnRleFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDcyID0+IDI0M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI0M1wiLFxuICAgICAgICBcInllYXJcIjogMTkxMixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZW5qb3nigJNMdXppbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIxNiA9PiA0NDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjE2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDQ1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMyLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuZGF14oCTWmVuZXJfZm9ybXVsYVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJFcm5zdCBTdHVlY2tlbGJlcmcsIEV0dG9yZSBNYWpvcmFuYVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwMiA9PiA0NDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzAyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDQ2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMyLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhbGV54oCTWnlnbXVuZF9pbmVxdWFsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlByb2JhYmlsaXR5L1N0YXRpc3RpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIzMSA9PiA0MjdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjMxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDI3XCIsXG4gICAgICAgIFwieWVhclwiOiAxODgyLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmRlbWFubuKAk1dlaWVyc3RyYXNzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtYmVyIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzcyID0+IDY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM3MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjY3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlZmZlY3RcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaHVibmlrb3bigJNkZV9IYWFzX2VmZmVjdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJNYWduZXRpc21cIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE4MyA9PiAxNDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTgzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTQzXCIsXG4gICAgICAgIFwieWVhclwiOiAxODY4LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlbHZpbuKAk0hlbG1ob2x0el9pbnN0YWJpbGl0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQzNSA9PiAxODZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDM1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTg2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dpZW5lcuKAk0toaW5jaGluX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUHJvYmFiaWxpdHkvU3RhdGlzdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzI0ID0+IDI2M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMjRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJhbmR0bOKAk01leWVyX2V4cGFuc2lvbl9mYW5cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU3VwZXJzb25pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM1OCA9PiAyNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzU4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjc2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJ1bGVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRhbOKAk3NlbWljb25kdWN0b3JfanVuY3Rpb24jU2Nob3R0a3nigJNNb3R0X3J1bGVfYW5kX0Zlcm1pX2xldmVsX3Bpbm5pbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTWF0ZXJpYWxzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMTYgPT4gMTU1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE1NVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9pbmNhcsOp4oCTSG9wZl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlRvcG9sb2d5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNyA9PiA0MThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MThcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDksXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVybnN0ZWlu4oCTdm9uX01pc2VzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiSm9zZXBoIERvb2JcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlByb2JhYmlsaXR5L1N0YXRpc3RpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExMSA9PiAxNDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTExXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTQzXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiVGhlcm1vZHluYW1pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwNCA9PiAyODNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzA0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjgzXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZWllcmxzX3N0cmVzc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJNYXRlcmlhbHNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMzOCA9PiAyMzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzM4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjMzXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImludGVncmFsXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmllbWFubuKAk0xpb3V2aWxsZV9pbnRlZ3JhbFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyOTQgPT4gNDI5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI5NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQyOVwiLFxuICAgICAgICBcInllYXJcIjogMTk3MCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInBhcmFtZXRlclwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09rdWJvLVdlaXNzX3BhcmFtZXRlclwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDU5ID0+IDMzMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI1OVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMzMFwiLFxuICAgICAgICBcInllYXJcIjogMTk0NixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJvdW5kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3JhbcOpcuKAk1Jhb19ib3VuZCNjaXRlX25vdGUtQ3JhbcOpci0xXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIk1hdXJpY2UgRnLDqWNoZXQsIEdlb3JnZXMgRGFybW9pcywgQWxleGFuZGVyIEFpdGtlbiBhbmQgSGFyb2xkIFNpbHZlcnN0b25lXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzODcgPT4gMjIzXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIyM1wiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RlaW5lcuKAk0xlaG11c190aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkdlb21ldHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMjggPT4gMzk4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMyOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM5OFwiLFxuICAgICAgICBcInllYXJcIjogMTk3NixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlsbGVu4oCTU3VzbGluX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQWxnZWJyYVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjk2ID0+IDI0NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyOTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09uc2FnZXLigJNNYWNobHVwX2Z1bmN0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkRpZmZlcmVudGlhbCBFcXVhdGlvbnNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIzNCA9PiAzNjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjM0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzYyXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlwcG1hbm7igJNTY2h3aW5nZXJfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExID0+IDIxM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIxM1wiLFxuICAgICAgICBcInllYXJcIjogMTcyOSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGF3XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVlcuKAk0xhbWJlcnRfbGF3XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlBpZXJyZSBCb3VndWVyXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJPcHRpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQyMiA9PiAyMTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDIyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjE0XCIsXG4gICAgICAgIFwieWVhclwiOiAyMDAxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2FuZ19hbmRfTGFuZGF1X2FsZ29yaXRobVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1lcmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNzAgPT4gMTU5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjcwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTU5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTIzLFxuICAgICAgICBcImZpZWxkXCI6IFwiQ2hlbWlzdHJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVieWXigJNIw7xja2VsX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9jaGVtaXN0cnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMxOSA9PiA0MTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzE5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDE0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTE4LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5lcXVhbGl0eVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YWRyYXRpY19yZXNpZHVlI1RoZV9Qw7NseWHigJNWaW5vZ3JhZG92X2luZXF1YWxpdHlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzMzID0+IDIzOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMzlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInBlbmR1bHVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmF5bGVpZ2jigJNMb3JlbnR6X3BlbmR1bHVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkNsYXNzaWNhbCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk0ID0+IDM5MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI5NFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM5MFwiLFxuICAgICAgICBcInllYXJcIjogMTk0MSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxvcnnigJNTdG9ja21heWVyX3RoZW9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQb2x5bWVyc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzQ4ID0+IDIxMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNDhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMTBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDAsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtZXRob2RcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk51bWVyaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDMgPT4gMTkyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE0M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE5MlwiLFxuICAgICAgICBcInllYXJcIjogMTkzNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkJpb2xvZ3lcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbG1ob2x0euKAk0tvaGxyYXVzY2hfZWZmZWN0XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM4NiA9PiAyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzODZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNVwiLFxuICAgICAgICBcInllYXJcIjogMTg4NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGF3XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RlZmFu4oCTQm9sdHptYW5uX2xhdyNIaXN0b3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3ID0+IDQwMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzN1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQwMVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmb3JtdWxhXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZXF1YXRpb24jQ2FyZGFubydzX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTc4ID0+IDc3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE3OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjc3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMzLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2FwaXRzYeKAk0RpcmFjX2VmZmVjdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJRdWFudHVtIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTAxID0+IDU1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjEwMVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjU1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiQ2hlbWlzdHJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GcmFuY2vigJNDb25kb25fcHJpbmNpcGxlI2NpdGVfbm90ZS0xXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gQ2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDcgPT4gMzE2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE0N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMxNlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlsYmVydOKAk1BvaW5jYXLDqV9zZXJpZXNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQWxnZWJyYVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDUgPT4gMjU4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQ1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImRldGVybWluYW50XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F5bGV54oCTTWVuZ2VyX2RldGVybWluYW50XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4NCA9PiAxMTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjg0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTE3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTcwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJhY3Rpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OYW1ideKAk0dvdG9fYWN0aW9uI2NpdGVfbm90ZS0xXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlN0cmluZyBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwMSA9PiAzNzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzAxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzc2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImNvbmRpdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhbGFpc+KAk1NtYWxlX2NvbXBhY3RuZXNzX2NvbmRpdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMTUgPT4gMTk2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIxNVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE5NlwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuZGF14oCTS29sbW9nb3Jvdl9pbmVxdWFsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEwNyA9PiAxNzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTA3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTczXCIsXG4gICAgICAgIFwieWVhclwiOiAxNzc3LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dhdXNzaWFuX2VsaW1pbmF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkNoaW5lc2UgbWF0aGVtYXRpY2lhbnM/XCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbGdlYnJhXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMjggPT4gMjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTI4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDksXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjM5ID0+IDI0MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMzlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NjksXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DbGF1c2l1c+KAk01vc3NvdHRpX3JlbGF0aW9uI0xvcmVudHrigJNMb3JlbnpfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiT3B0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA0MCA9PiAxMjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMjlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4ODEsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FydGFu4oCTSGFkYW1hcmRfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJIYW5zIENhcmwgRnJpZWRyaWNoIHZvbiBNYW5nb2xkdFwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgOTQgPT4gMzM0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjk0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzM0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTQzLFxuICAgICAgICBcImZpZWxkXCI6IFwiQ2hlbWlzdHJ5XCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbG9yeeKAk1JlaG5lcl9lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQb2x5bWVyc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjg2ID0+IDgyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI4NlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjgyXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRWxlY3Ryb2NoZW1pc3RyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTA3ID0+IDIyMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMDdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMjJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtYmVyIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTI4ID0+IDQzMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MzBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzIsXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTkzID0+IDM2OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxOTNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNjlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjUsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNiA9PiAyMDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NzUsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F1Y2h54oCTS293YWxldnNraV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM1MCA9PiA0MDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzUwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDAzXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTU4LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5zdGFiaWxpdHlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWZmbWFu4oCTVGF5bG9yX2luc3RhYmlsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTUzID0+IDE0NVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNTNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTIsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib2xzdGVpbuKAk0hlcnJpbmdfbWV0aG9kXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ1ID0+IDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNDVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI2XCIsXG4gICAgICAgIFwieWVhclwiOiAxODg2LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NheWxleeKAk0JhY2hhcmFjaF90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIk1pY2hlbCBDaGFzbGVzXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA1NCA9PiAxMTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNTRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiY29lZmZpY2llbnRcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DbGVic2No4oCTR29yZGFuX2NvZWZmaWNpZW50c1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJSZXByZXNlbnRhdGlvbiBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM1NiA9PiA0N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0N1wiLFxuICAgICAgICBcInllYXJcIjogMTk0MixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibGltaXRcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2jDtm5iZXJn4oCTQ2hhbmRyYXNla2hhcl9saW1pdFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBc3Ryb3BoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEwOCA9PiAyOTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTA4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjkwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUzLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VsbC1NYW5u4oCTTmlzaGlqaW1hX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiTmFrYW5vXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQYXJ0aWNsZSBQaHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzOTMgPT4gNDM4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM5M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQzOFwiLFxuICAgICAgICBcInllYXJcIjogMTk0OCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibW9kZWxcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdG9uZXLigJNXb2hsZmFydGhfbW9kZWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU29saWQtU3RhdGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgODYgPT4gMjgwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjg2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjgwXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTYzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZOKAk011bGxpbl9zZXF1ZW5jZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNCA9PiA0MTVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MTVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzAsXG4gICAgICAgIFwiZmllbGRcIjogXCJDaGVtaXN0cnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiZXF1YXRpb25cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkVyZGV5LUdyw7p6XCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJFbGVjdHJvY2hlbWlzdHJ5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMDMgPT4gMTQwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIwM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE0MFwiLFxuICAgICAgICBcInllYXJcIjogMTkyNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTMzID0+IDEzOFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMzNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMzhcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5ODMsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXJ0bGXigJNIYXdraW5nX3N0YXRlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkNvc21vbG9neVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMyA9PiAyM1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjNcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDksXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVmZmVjdFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FoYXJvbm924oCTQm9obV9lZmZlY3RcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiV2VybmVyIEVocmVuYmVyZyBhbmQgUmF5bW9uZCBTaWRheVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4NCA9PiAxMTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjg0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTE0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTYwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJmZXJtaW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR29sZHN0b25lX2Jvc29uI05hbWJ14oCTR29sZHN0b25lX2Zlcm1pb25zXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlBhcnRpY2xlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDk4ID0+IDE4XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjk4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMThcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvdXJpZXLigJNCZXNzZWxfc2VyaWVzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM0OSA9PiA0MDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzQ5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDA1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTEyLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhY2t1cuKAk1RldHJvZGVfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiVGhlcm1vZHluYW1pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI5MiA9PiAxNTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjkyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTU0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTg1LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTaW11bGF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMCA9PiA0N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQ3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTQ2LFxuICAgICAgICBcImZpZWxkXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JhdGNoZWxvcuKAk0NoYW5kcmFzZWtoYXJfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjI4ID0+IDI5OVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMjhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyOTlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5ODEsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM5MiA9PiA0MjdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzkyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDI3XCIsXG4gICAgICAgIFwieWVhclwiOiAxODg1LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0b25l4oCTV2VpZXJzdHJhc3NfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbmFseXNpc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNjUgPT4gMjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNjVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyM1wiLFxuICAgICAgICBcInllYXJcIjogMTk1MixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3J5XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvZGVfQnJvZ2xpZeKAk0JvaG1fdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNjEgPT4gMzg3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE2MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM4N1wiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJhbGxlbF9heGlzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4OSA9PiA0MDBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiODlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmVrZXRl4oCTU3plZ8WRX2luZXF1YWxpdHlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQW5hbHlzaXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE5MCA9PiAyMThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTkwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjE4XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVydHrigJNLbnVkc2VuX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIxNiA9PiAzODJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjE2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzgyXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTQ0LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmRhdeKAk1NxdWlyZV9qZXRcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwiTi4gQS4gU2xlemtpblwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRmx1aWQgTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNTYgPT4gMjVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjU2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NjAsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXh3ZWxs4oCTQm9sdHptYW5uX2Rpc3RyaWJ1dGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTdGF0aXN0aWNhbCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDQ1ID0+IDE4OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0NVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE4OFwiLFxuICAgICAgICBcInllYXJcIjogMTg1OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1ldHJpY1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NheWxleeKAk0tsZWluX21ldHJpY1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTU2ID0+IDI4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyODJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzMsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9ycm9ja3PigJNNdW1mb3JkX2J1bmRsZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzE2ID0+IDIxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIxXCIsXG4gICAgICAgIFwieWVhclwiOiAxODk4LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlbHZpbiUyN3NfY2lyY3VsYXRpb25fdGhlb3JlbSNQb2luY2Fyw6nigJNCamVya25lc19jaXJjdWxhdGlvbl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzEgPT4gMTY3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTY3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTcwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWV0aG9kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQm944oCTSmVua2luc19tZXRob2RcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUHJvYmFiaWxpdHkvU3RhdGlzdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzYgPT4gMTI5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTI5XCIsXG4gICAgICAgIFwieWVhclwiOiAxODIxLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhdWNoeeKAk0hhZGFtYXJkX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQW5hbHlzaXNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEwMyA9PiAxOTdcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTAzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTk3XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTM4LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnJlbmtlbOKAk0tvbnRvcm92YV9tb2RlbFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzMgPT4gMzE1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMzM1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMxNVwiLFxuICAgICAgICBcInllYXJcIjogMTkxNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uIG9mIHN0YXRlXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmF5bGVpZ2jigJNQbGVzc2V0X2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlcuIEguIEJlc2FudFwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRmx1aWQgTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxODcgPT4gMjc1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI3NVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Bcml0aG1ldGljYWxfaGllcmFyY2h5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIxNiA9PiAyMjlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjE2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjI5XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmRhdeKAk0xpZnNoaXR6X21vZGVsXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlNvbGlkLVN0YXRlIFBoeXNpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4NSA9PiAzOTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjg1XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzkxXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmF2aWVy4oCTU3Rva2VzX2VxdWF0aW9uc1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDI4OCA9PiAzMzFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjg4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzMxXCIsXG4gICAgICAgIFwieWVhclwiOiAxNjkwLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWV0aG9kXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTmV3dG9uJTI3c19tZXRob2RcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiTnVtZXJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM2ID0+IDIzNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIzNVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGljYXJk4oCTTGluZGVsw7ZmX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRGlmZmVyZW50aWFsIEVxdWF0aW9uc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzM4ID0+IDM0MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNDFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4NjUsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmllbWFubuKAk1JvY2hfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbmFseXNpc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE2ID0+IDMzMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMzJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmF5Y2hhdWRodXJpX2VxdWF0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlJlbGF0aXZpdHlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDEzMiA9PiAyMzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTMyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjM2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTIzLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NlY29uZF9IYXJkeeKAk0xpdHRsZXdvb2RfY29uamVjdHVyZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDIgPT4gOTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTQyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiOTFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxsbWFubuKAk0ZleW5tYW5fdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJHw7x0dGluZ2VyLCBQYXVsaVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMzMyA9PiA0MDNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzMzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDAzXCIsXG4gICAgICAgIFwieWVhclwiOiAxODgzLFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiaW5zdGFiaWxpdHlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYXlsZWlnaOKAk1RheWxvcl9pbnN0YWJpbGl0eVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM5MiA9PiA0MTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzkyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDE5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMxLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RvbmXigJN2b25fTmV1bWFubl90aGVvcmVtI0NJVEVSRUZ2b25fTmV1bWFubjE5MzFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDgzID0+IDQ3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjgzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDcsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWRlbuKAk0NoYW5kcmFzZWtoYXJfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQXN0cm9waHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMTIgPT4gMjcyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIxMlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjI3MlwiLFxuICAgICAgICBcInllYXJcIjogMTk1OSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbWLigJNNw7Zzc2JhdWVyX2ZhY3RvclwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQYXJ0aWNsZSBQaHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNiA9PiAzNjFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNjFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4MjEsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJpbmVxdWFsaXR5XCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F1Y2h54oCTU2Nod2Fyel9pbmVxdWFsaXR5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIlZpa3RvciBCdW55YWtvdnNreVwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE2ID0+IDIyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMjVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDIsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFuZGF14oCTTGV2aWNoX3Byb2JsZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRmx1aWQgTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4NyA9PiAyNDFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiODdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTEsXG4gICAgICAgIFwiZmllbGRcIjogXCJTb2NpYWwgU2NpZW5jZXNcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVy4oCTTG90a2FfZXF1YXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRGVtb2dyYXBoaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNzEgPT4gMzAxXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI3MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMwMVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJsZW1tYVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vcnNl4oCTUGFsYWlzX2xlbW1hXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3OSA9PiA3M1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNzlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI3M1wiLFxuICAgICAgICBcInllYXJcIjogOTg0LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJsYXdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmVsbCUyN3NfbGF3XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIklibiBTYWhsXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJPcHRpY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM5NyA9PiAyMzNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzk3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjMzXCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yeVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0dXJt4oCTTGlvdXZpbGxlX3RoZW9yeVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMzggPT4gMTQ3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMzOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE0N1wiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJwcm9ibGVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmllbWFubuKAk0hpbGJlcnRfcHJvYmxlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyOTMgPT4gMzcwXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI5M1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM3MFwiLFxuICAgICAgICBcInllYXJcIjogMTkxNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OeXF1aXN04oCTU2hhbm5vbl9zYW1wbGluZ190aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIkUuIFQuIFdoaXR0YWtlciwgVmxhZGltaXIgS290ZWxuaWtvdlwiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiSW5mb3JtYXRpb24gVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNDcgPT4gMzU1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE0N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM1NVwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlsYmVydOKAk1NjaG1pZHRfb3BlcmF0b3JcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDE5ID0+IDI3MFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0MTlcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNzBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDcsXG4gICAgICAgIFwiZmllbGRcIjogXCJFY29ub21pY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL3Zvbl9OZXVtYW5u4oCTTW9yZ2Vuc3Rlcm5fdXRpbGl0eV90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM3OSA9PiAzMjNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzc5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzIzXCIsXG4gICAgICAgIFwieWVhclwiOiAxNjE1LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwicHJvYmxlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuZWxsaXVz4oCTUG90aGVub3RfcHJvYmxlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjc0ID0+IDMwMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyNzRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMDFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9zdG934oCTUGFsYWlzX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR3JvdXAgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA4NyA9PiAzNlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4N1wiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM2XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYXVjaHlfc3RyZXNzX3RlbnNvciNFdWxlcuKAk0NhdWNoeV9zdHJlc3NfcHJpbmNpcGxlX+KAk19zdHJlc3NfdmVjdG9yXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzExID0+IDIyMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMTFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMjFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4OTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcnlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QaWNhcmTigJNMZWZzY2hldHpfdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlRvcG9sb2d5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMjAgPT4gNDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTIwXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWxnZWJyYVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXNzbWFubuKAk0NheWxleV9hbGdlYnJhXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkFsZ2VicmFcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMzMCA9PiAyMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMlwiLFxuICAgICAgICBcInllYXJcIjogMTk0NyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW/igJNCbGFja3dlbGxfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJQcm9iYWJpbGl0eS9TdGF0aXN0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMjAgPT4gMzg3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMyMFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM4N1wiLFxuICAgICAgICBcInllYXJcIjogMTgzMyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb25jZWxldOKAk1N0ZWluZXJfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJHZW9tZXRyeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjg3ID0+IDQwMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyODdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0MDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NjUsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJoZWlnaHRcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ow6lyb27igJNUYXRlX2hlaWdodFwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNzAgPT4gMTM0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjM3MFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEzNFwiLFxuICAgICAgICBcInllYXJcIjogMTk0OCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaGFubm9u4oCTSGFydGxleV90aGVvcmVtI0hpc3RvcmljYWxfZGV2ZWxvcG1lbnRcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiSW5mb3JtYXRpb24gVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzOTIgPT4gNDZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzkyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDZcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzcsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjb21wYWN0aWZpY2F0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3RvbmXigJPEjGVjaF9jb21wYWN0aWZpY2F0aW9uXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlRvcG9sb2d5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzNiA9PiAxMjJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxMjJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4MzksXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0ZW5zb3JcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaW5pdGVfc3RyYWluX3RoZW9yeSNUaGVfcmlnaHRfQ2F1Y2h54oCTR3JlZW5fZGVmb3JtYXRpb25fdGVuc29yXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTk0ID0+IDE0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxOTRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDhcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvdy1kaXNjcmVwYW5jeV9zZXF1ZW5jZSNUaGVfS29rc21h4oCTSGxhd2thX2luZXF1YWxpdHlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNzIgPT4gMzM5XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjcyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzM5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTA2LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbmpveeKAk1JpZXN6X3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiVG9wb2xvZ3lcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDExOCA9PiA0OFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMThcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0OFwiLFxuICAgICAgICBcInllYXJcIjogMTkxMCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkNoZW1pc3RyeVwiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91YmxlX2xheWVyXyhzdXJmYWNlX3NjaWVuY2UpI0dvdXnigJNDaGFwbWFuXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9uaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNzYgPT4gMTI1XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI3NlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEyNVwiLFxuICAgICAgICBcInllYXJcIjogMTk0MCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImxhd1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYWNlX2NoYXJnZSNEcmlmdF9yZWdpbWVfKE1vdHTigJNHdXJuZXlfbGF3KVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJNYXRlcmlhbHNcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE2OSA9PiAyOTNcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTY5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjkzXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiRW5naW5lZXJpbmdcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pvaG5zb27igJNOeXF1aXN0X25vaXNlI0hpc3RvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiRWxlY3Ryb25pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwNyA9PiA0MzJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzA3XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDMyXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI3LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BldGVy4oCTV2V5bF90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkhhcm1vbmljIEFuYWx5c2lzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMTggPT4gMjI3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjMxOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIyN1wiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJncm91cFwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaXNzb27igJNMaWVfZ3JvdXBcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR3JvdXAgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxMDQgPT4gNFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZyZXNuZWzigJNBcmFnb19sYXdzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk9wdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTQ0ID0+IDIzMVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxNDRcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMzFcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4ODIsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZGVtYW5u4oCTV2VpZXJzdHJhc3NfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJLYXJsIFdlaWVyc3RyYXNzXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJOdW1iZXIgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMDggPT4gMjI0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIwOFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjIyNFwiLFxuICAgICAgICBcInllYXJcIjogMTk1MSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LdWxsYmFja+KAk0xlaWJsZXJfZGl2ZXJnZW5jZVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJJbmZvcm1hdGlvbiBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE5OCA9PiA0MTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTk4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDE5XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMxLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS29vcG1hbuKAk3Zvbl9OZXVtYW5uX2NsYXNzaWNhbF9tZWNoYW5pY3NcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiQ2xhc3NpY2FsIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDE3ID0+IDE1N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0MTdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIxNTdcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzgsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJlcXVhdGlvblwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0vDoXJtw6Fu4oCTSG93YXJ0aF9lcXVhdGlvblwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDIwMyA9PiAyMDVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjAzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjA1XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI2LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS3JhbWVyc+KAk0tyb25pZ19yZWxhdGlvbnNcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiT3B0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSA3MSA9PiAyNDJcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiNzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyNDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NzYsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcnlcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWxpZ25l4oCTTHVzenRpZ190aGVvcnlcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiR3JvdXAgVGhlb3J5XCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNDEgPT4gNDE2XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjI0MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxNlwiLFxuICAgICAgICBcInllYXJcIjogMTkxMCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkJpb2xvZ3lcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwibWlzc2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzM4ID0+IDIyMFwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzMzhcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIyMjBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcImZpZWxkXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJsZW1tYVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JpZW1hbm7igJNMZWJlc2d1ZV9sZW1tYVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMzYgPT4gMzAyXCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjIzNlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMwMlwiLFxuICAgICAgICBcInllYXJcIjogMTkzMSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXR0bGV3b29k4oCTUGFsZXlfdGhlb3J5XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkFuYWx5c2lzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAzMjQgPT4gMTBcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzI0XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTBcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MDQsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJhbmR0bOKAk0JhdGNoZWxvcl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkZsdWlkIE1lY2hhbmljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzEgPT4gNThcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI1OFwiLFxuICAgICAgICBcInllYXJcIjogMTk2NCxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Bvd2VyX3RyYW5zZm9ybSNCb3jigJNDb3hfdHJhbnNmb3JtYXRpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUHJvYmFiaWxpdHkvU3RhdGlzdGljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTMyID0+IDMyOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIxMzJcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMjlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTgsXG4gICAgICAgIFwiZmllbGRcIjogXCJNYXRoZW1hdGljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGl0aW9uX2Z1bmN0aW9uXyhudW1iZXJfdGhlb3J5KSNBcHByb3hpbWF0aW9uX2Zvcm11bGFzXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk51bWJlciBUaGVvcnlcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDM5MSA9PiA4MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzOTFcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI4MlwiLFxuICAgICAgICBcInllYXJcIjogMTkwNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIkVuZ2luZWVyaW5nXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImVxdWF0aW9uXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly90aGVybW9wZWRpYS5jb20vY29udGVudC8xMTU2L1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJTdXRoZXJsYW5kXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDgwID0+IDM4MVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4MFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjM4MVwiLFxuICAgICAgICBcInllYXJcIjogMTkyNyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZyZWVfZWxlY3Ryb25fbW9kZWxcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiU29saWQtU3RhdGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgOSA9PiAzMjhcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiOVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjMyOFwiLFxuICAgICAgICBcInllYXJcIjogMTk3NixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImNvbmplY3R1cmVcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNz4oCTUXVpbGxlbl9jb25qZWN0dXJlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDc4ID0+IDQxMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI3OFwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjQxMlwiLFxuICAgICAgICBcInllYXJcIjogMTk4MyxcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzM2NDA0NTAvcmVjb25jaWxpbmctZG9uc2tlci12YXJhZGhhbi1kZWZpbml0aW9uLW9mLWtsLWRpdmVyZ2VuY2Utd2l0aC10aGUtdXN1YWwtZGVmaW5pXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkluZm9ybWF0aW9uIFRoZW9yeVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjE2ID0+IDQ0MlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyMTZcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCI0NDJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NDgsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYW5kYXXigJNZYW5nX3RoZW9yZW1cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUGFydGljbGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMjk3ID0+IDMwOVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIyOTdcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMDlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzUsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInByb2Nlc3NcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcHBlbmhlaW1lcuKAk1BoaWxsaXBzX3Byb2Nlc3NcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUGFydGljbGUgUGh5c2ljc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDMgPT4gNDI3XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjQzXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDI3XCIsXG4gICAgICAgIFwieWVhclwiOiAxODU5LFxuICAgICAgICBcImZpZWxkXCI6IFwiTWF0aGVtYXRpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidGhlb3JlbVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nhc29yYXRp4oCTV2VpZXJzdHJhc3NfdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJTb2tob3Rza2ksIEJyaW90LCBCb3VxdWV0XCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJBbmFseXNpc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgNDAzID0+IDMyNVwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI0MDNcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMjVcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MTYsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJ0aGVvcmVtXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGF5bG9y4oCTUHJvdWRtYW5fdGhlb3JlbVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJGbHVpZCBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE4OSA9PiAyOTFcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTg5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMjkxXCIsXG4gICAgICAgIFwieWVhclwiOiAxOTI4LFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2xlaW7igJNOaXNoaW5hX2Zvcm11bGFcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUXVhbnR1bSBNZWNoYW5pY3NcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDE1OCA9PiAzMzZcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMTU4XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzM2XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTUwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwicmVmZXJlbmNlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJTb2xpZC1TdGF0ZSBQaHlzaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyMCA9PiAzNTRcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjBcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzNTRcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE4MjAsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImxhd1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jpb3TigJNTYXZhcnRfbGF3XCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIkVsZWN0cm9tYWduZXRpc21cIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDMwMiA9PiA0MzVcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMzAyXCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiNDM1XCIsXG4gICAgICAgIFwieWVhclwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJmaWVsZFwiOiBcIk1hdGhlbWF0aWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInRoZW9yZW1cIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYWxleeKAk1dpZW5lcl90aGVvcmVtXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIm1pc3NpbmdcIlxuICAgICAgfSxcbiAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2VcbiAgICB9LFxuICAgIHtcbiAgICAgIFwiZGF0YVwiOlxuICAgICB7XG4gICAgICAgIFwiaWRcIjogXCJFZGdlIDgyID0+IDE0N1wiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCI4MlwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjE0N1wiLFxuICAgICAgICBcInllYXJcIjogMTkxNSxcbiAgICAgICAgXCJmaWVsZFwiOiBcIlBoeXNpY3NcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VpbnN0ZWlu4oCTSGlsYmVydF9hY3Rpb25cIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiUmVsYXRpdml0eVwiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMzQ1ID0+IDMyMlwiLFxuICAgICAgICBcInNlbGVjdGVkXCI6IGZhbHNlLFxuICAgICAgICBcImludGVyYWN0aW9uXCI6IFwiY2NcIixcbiAgICAgICAgXCJzb3VyY2VcIjogXCIzNDVcIixcbiAgICAgICAgXCJ0YXJnZXRcIjogXCIzMjJcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5NTcsXG4gICAgICAgIFwiZmllbGRcIjogXCJFbmdpbmVlcmluZ1wiLFxuICAgICAgICBcInR5cGVcIjogXCJwaGFzZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1J1ZGRsZXNkZW4tUG9wcGVyX3BoYXNlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIk1hdGVyaWFsc1wiXG4gICAgICB9LFxuICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZVxuICAgIH0sXG4gICAge1xuICAgICAgXCJkYXRhXCI6XG4gICAgIHtcbiAgICAgICAgXCJpZFwiOiBcIkVkZ2UgMTkgPT4gMzc0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE5XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMzc0XCIsXG4gICAgICAgIFwieWVhclwiOiAxOTMwLFxuICAgICAgICBcImZpZWxkXCI6IFwiUGh5c2ljc1wiLFxuICAgICAgICBcInR5cGVcIjogXCJjdXJ2ZVwiLFxuICAgICAgICBcInJlZmVyZW5jZVwiOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JldGhl4oCTU2xhdGVyX2N1cnZlXCIsXG4gICAgICAgIFwidW5yZWNvZ25pemVkP1wiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJzdWJmaWVsZFwiOiBcIlF1YW50dW0gTWVjaGFuaWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAyNzYgPT4gMTlcIixcbiAgICAgICAgXCJzZWxlY3RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpbnRlcmFjdGlvblwiOiBcImNjXCIsXG4gICAgICAgIFwic291cmNlXCI6IFwiMjc2XCIsXG4gICAgICAgIFwidGFyZ2V0XCI6IFwiMTlcIixcbiAgICAgICAgXCJ5ZWFyXCI6IDE5MzAsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImZvcm11bGFcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb3R04oCTQmV0aGVfZm9ybXVsYVwiLFxuICAgICAgICBcInVucmVjb2duaXplZD9cIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwic3ViZmllbGRcIjogXCJtaXNzaW5nXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcbiAgICB7XG4gICAgICBcImRhdGFcIjpcbiAgICAge1xuICAgICAgICBcImlkXCI6IFwiRWRnZSAxNjEgPT4gMTA0XCIsXG4gICAgICAgIFwic2VsZWN0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW50ZXJhY3Rpb25cIjogXCJjY1wiLFxuICAgICAgICBcInNvdXJjZVwiOiBcIjE2MVwiLFxuICAgICAgICBcInRhcmdldFwiOiBcIjEwNFwiLFxuICAgICAgICBcInllYXJcIjogXCJtaXNzaW5nXCIsXG4gICAgICAgIFwiZmllbGRcIjogXCJQaHlzaWNzXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm1pc3NpbmdcIixcbiAgICAgICAgXCJyZWZlcmVuY2VcIjogXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IdXlnZW5z4oCTRnJlc25lbF9wcmluY2lwbGVcIixcbiAgICAgICAgXCJ1bnJlY29nbml6ZWQ/XCI6IFwibWlzc2luZ1wiLFxuICAgICAgICBcInN1YmZpZWxkXCI6IFwiT3B0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcInNlbGVjdGVkXCI6IGZhbHNlXG4gICAgfSxcblxuICBdLFxufTtcblxuZWxlbWVudHMubm9kZXMuZm9yRWFjaCgobikgPT4ge1xuICAgIFxubi5kYXRhLm9yZ1BvcyA9IHtcbiAgeDogbi5wb3NpdGlvbi54LFxuICB5OiBuLnBvc2l0aW9uLnlcbiAgfTtcbn0pO1xuICAgIFxuZXhwb3J0IGRlZmF1bHQgZWxlbWVudHM7IiwiaW1wb3J0IHN0eWxlIGZyb20gJy4vc3R5bGUnO1xuaW1wb3J0IGVsZW1lbnRzIGZyb20gJy4vZWxlbWVudHMnO1xuXG5leHBvcnQgeyBzdHlsZSwgZWxlbWVudHMgfTtcbmV4cG9ydCBkZWZhdWx0IHsgc3R5bGUsIGVsZW1lbnRzIH07XG4iLCJleHBvcnQgZGVmYXVsdCBgXG5jb3JlIHtcblx0YWN0aXZlLWJnLWNvbG9yOiAjZmZmO1xuXHRhY3RpdmUtYmctb3BhY2l0eTogMC4zMzM7XG59XG5cbmVkZ2Uge1xuXHRjdXJ2ZS1zdHlsZTogaGF5c3RhY2s7XG5cdGhheXN0YWNrLXJhZGl1czogMDtcblx0b3BhY2l0eTogMC4zMzM7XG5cdHdpZHRoOiAyO1xuXHR6LWluZGV4OiAwO1xuXHRvdmVybGF5LW9wYWNpdHk6IDA7XG5cdG1pZC10YXJnZXQtYXJyb3ctc2hhcGU6IHRyaWFuZ2xlO1xuXHRtaWQtdGFyZ2V0LWFycm93LWNvbG9yOiAjRkFDRDM3O1xuXG4gIGV2ZW50czogbm87XG59XG5cbm5vZGUge1xuXHR3aWR0aDogNDA7XG5cdGhlaWdodDogNDA7XG5cdGZvbnQtc2l6ZTogOTtcblx0Zm9udC13ZWlnaHQ6IGJvbGQ7XG5cdG1pbi16b29tZWQtZm9udC1zaXplOiA0O1xuXHRsYWJlbDogZGF0YShmYW1pbHlfbmFtZSk7XG5cdHRleHQtd3JhcDogd3JhcDtcblx0dGV4dC1tYXgtd2lkdGg6IDUwO1xuXHR0ZXh0LXZhbGlnbjogY2VudGVyO1xuXHR0ZXh0LWhhbGlnbjogY2VudGVyO1xuXHR0ZXh0LWV2ZW50czogeWVzO1xuXHRjb2xvcjogIzAwMDtcblx0dGV4dC1vdXRsaW5lLXdpZHRoOiAxO1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6ICNmZmY7XG5cdHRleHQtb3V0bGluZS1vcGFjaXR5OiAxO1xuXHRvdmVybGF5LWNvbG9yOiAjZmZmO1xufVxuXG5lZGdlW2ludGVyYWN0aW9uID0gXCJjY1wiXSB7XG5cdGxpbmUtY29sb3I6ICNGQUNEMzc7XG5cdG1pZC10YXJnZXQtYXJyb3ctY29sb3I6ICNERTMxMjg7XG5cdG9wYWNpdHk6IDAuNjY2O1xuXHR6LWluZGV4OiA5O1xuXHR3aWR0aDogNDtcblx0bWlkLXRhcmdldC1hcnJvdy1zaGFwZTogdHJpYW5nbGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIkNoZWVzZVwiXSxcbm5vZGVbTm9kZVR5cGUgPSBcIkNoZWVzZVR5cGVcIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRkFDRDM3O1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6ICNGQUNEMzc7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIkNoZWVzZVwiXVtRdWFsaXR5XSxcbm5vZGVbTm9kZVR5cGUgPSBcIkNoZWVzZVR5cGVcIl1bUXVhbGl0eV0ge1xuXHR3aWR0aDogbWFwRGF0YShRdWFsaXR5LCA3MCwgMTAwLCAyMCwgNTApO1xuXHRoZWlnaHQ6IG1hcERhdGEoUXVhbGl0eSwgNzAsIDEwMCwgMjAsIDUwKTtcbn1cblxubm9kZVtOb2RlVHlwZSA9IFwiV2hpdGVXaW5lXCJdIHtcblx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbmVkZ2VbaW50ZXJhY3Rpb24gPSBcImN3XCJdIHtcblx0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIlJlZFdpbmVcIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjREUzMTI4O1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6ICNERTMxMjg7XG59XG5cbmVkZ2VbaW50ZXJhY3Rpb24gPSBcImNyXCJdIHtcblx0bGluZS1jb2xvcjogI0RFMzEyODtcbn1cblxubm9kZVtOb2RlVHlwZSA9IFwiQ2lkZXJcIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjQTRFQjM0O1xuXHR0ZXh0LW91dGxpbmUtY29sb3I6ICNBNEVCMzQ7XG59XG5cbm5vZGUuaGlnaGxpZ2h0ZWQge1xuXHRtaW4tem9vbWVkLWZvbnQtc2l6ZTogMDtcbiAgei1pbmRleDogOTk5OTtcbn1cblxuZWRnZS5oaWdobGlnaHRlZCB7XG5cdG9wYWNpdHk6IDAuODtcblx0d2lkdGg6IDQ7XG5cdHotaW5kZXg6IDk5OTk7XG59XG5cbi5mYWRlZCB7XG4gIGV2ZW50czogbm87XG59XG5cbm5vZGUuZmFkZWQge1xuICBvcGFjaXR5OiAwLjA4O1xufVxuXG5lZGdlLmZhZGVkIHtcbiAgb3BhY2l0eTogMC4wNjtcbn1cblxuLmhpZGRlbiB7XG5cdGRpc3BsYXk6IG5vbmU7XG59XG5cbmA7XG4iLCJleHBvcnQgY29uc3QgTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbmV4cG9ydCBjb25zdCBpc1Byb2QgPSBOT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzRGV2ID0gIWlzUHJvZDsiLCJpbXBvcnQgeyBpc1Byb2QgfSBmcm9tICcuL2Vudic7XG5pbXBvcnQgeyBoLCByZW5kZXIgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2FwcCc7XG5cbmlmKCAhaXNQcm9kICl7IC8vIHNldCB1cCBsaXZlcmVsb2FkIGZvciBkZXZcbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgc2NyaXB0LnNyYyA9ICdodHRwOi8vJyArIGxvY2F0aW9uLmhvc3RuYW1lICsgJzozNTcyOS9saXZlcmVsb2FkLmpzP3NuaXB2ZXI9MSc7XG5cbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICk7XG59XG5cbmNvbnN0IHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxucm9vdC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Jvb3QnKTtcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XG5cbnJlbmRlcihoKEFwcENvbXBvbmVudCksIHJvb3QpO1xuXG5jb25zb2xlLmxvZyhgWW91IGNhbiB2aWV3IHRoZSBzb3VyY2UgY29kZSBvZiB0aGlzIEN5dG9zY2FwZS5qcy1wb3dlcmVkIGFwcCBhdCBodHRwczovL2dpdGh1Yi5jb20vY3l0b3NjYXBlL3dpbmVhbmRjaGVlc2VtYXBgKTsiXSwic291cmNlUm9vdCI6IiJ9